#include	"Diffract_INCs.h"#include	"a_LatticeObject.h"//Jim:Real Lattice:RL_LatticeInfo.c#include	"UT_VectorMacros.c"#include	"AtomData.h"PenState SetupPen(Crystal *theCrystal);void ClearPen(PenState thePenState);void DrawLineAtomToAtom(LatticeAtom atom1,LatticeAtom Atom2);void LatticeObject::GetAngleBetweenAtoms(Point thePoint){	double x1,y1,z1;	double x2,y2,z2;	double coSineA,length,theta;		if(!MaintainAtoms( thePoint,3))		return;	x1 = currentAtom[0]->x * currentAtom[0]->length - currentAtom[1]->x * currentAtom[1]->length;	y1 = currentAtom[0]->y * currentAtom[0]->length - currentAtom[1]->y * currentAtom[1]->length;	z1 = currentAtom[0]->z * currentAtom[0]->length - currentAtom[1]->z * currentAtom[1]->length;	length = sqrt(x1 * x1 + y1 * y1 + z1 * z1);	x1 /= length;	y1 /= length;	z1 /= length;	x2 = currentAtom[2]->x * currentAtom[2]->length - currentAtom[1]->x * currentAtom[1]->length;	y2 = currentAtom[2]->y * currentAtom[2]->length - currentAtom[1]->y * currentAtom[1]->length;	z2 = currentAtom[2]->z * currentAtom[2]->length - currentAtom[1]->z * currentAtom[1]->length;	length = sqrt(x2 * x2 + y2 * y2 + z2 * z2);	x2 /= length;	y2 /= length;	z2 /= length;	coSineA = x1 * x2 + y1 * y2 + z1 * z2;	theta = 180. * acos(coSineA) / PI;		sprintf(gTheText,"  %6.2f ¡",theta);	theRuler->SetInfo(gTheText);	}Boolean  LatticeObject::MaintainAtoms(Point thePoint,short number){	short i;	PenState thePenState;	if(gMyOffG){		if(gShifted)numAtomsToHold = 0;		else{			if(numAtomsToHold == number){				numAtomsToHold--;			}		}	}else{		if(gShifted){						sprintf(gTheText," ");			theRuler->SetInfo(gTheText);			thePenState = SetupPen(theCrystal[baseCrystal]);			 			for(i = 0; i <= numAtomsToHold - 2;i++){				DrawLineAtomToAtom(*(currentAtom[i]),*(currentAtom[i + 1]));			}			ClearPen(thePenState);			for(i = 0; i < numAtomsToHold;i++)				HilightAtom(*(currentAtom[i]));			numAtomsToHold = 0;		}else{			if(numAtomsToHold == number){				thePenState = SetupPen(theCrystal[baseCrystal]);				if(number >= 2)DrawLineAtomToAtom(*(currentAtom[number - 2]),*(currentAtom[number - 1]));				ClearPen(thePenState);				numAtomsToHold--;				HilightAtom(*(currentAtom[numAtomsToHold]));			}		}	}		if(!FindAtom(thePoint))		return false;	//newPictEnable = true;	if(gMyOffG){		refreshFlag = true;		DoRefresh();		thePenState = SetupPen(theCrystal[baseCrystal]);		for(i = 0; i <= numAtomsToHold - 2;i++){			DrawLineAtomToAtom(*(currentAtom[i]),*(currentAtom[i + 1]));		}		ClearPen(thePenState);		for(i = 0; i < numAtomsToHold;i++)HilightAtom(*(currentAtom[i]));		if(numAtomsToHold < number)return false;		return true;	}	if(numAtomsToHold >= 2){		thePenState = SetupPen(theCrystal[baseCrystal]);		DrawLineAtomToAtom(*(currentAtom[(numAtomsToHold - 2)]),*(currentAtom[(numAtomsToHold - 1)]));		ClearPen(thePenState);	}	HilightAtom(*(currentAtom[numAtomsToHold - 1]));	if(numAtomsToHold < number)		return false;	return true;}void ClearPen(PenState thePenState){	SetPenState(&thePenState);	PenSize(1,1);	PenNormal();	PenMode(gCurrentObj->gMode);}PenState SetupPen(Crystal *theCrystal){	PenState thePenState;	GetPenState(&thePenState);	if(!gCurrentObj->gMyOffG){PenMode(patXor);}	else PenMode(0);	PenSize(2,2);	if(g_Monitor){		theCrystal->SetColor();	}	//ForeColor (blackColor);	return thePenState;}void LatticeObject::DrawLineAtomToAtom(LatticeAtom atom1,LatticeAtom Atom2){	Point thePoint;	thePoint.h = atom1.h;	thePoint.v = atom1.v;	ObjToLocal(&thePoint);	MoveTo(thePoint.h ,thePoint.v);	thePoint.h = Atom2.h;	thePoint.v = Atom2.v;	ObjToLocal(&thePoint);	LineTo(thePoint.h,thePoint.v);}void LatticeObject::GetDistanceBetweenAtoms(Point thePoint){	double x1,y1,z1;	double length;		if(!MaintainAtoms( thePoint,2))		return;			x1 = currentAtom[0]->length * currentAtom[0]->x - currentAtom[1]->length * currentAtom[1]->x;	y1 = currentAtom[0]->length * currentAtom[0]->y - currentAtom[1]->length * currentAtom[1]->y;	z1 = currentAtom[0]->length * currentAtom[0]->z - currentAtom[1]->length * currentAtom[1]->z;	length = sqrt(x1 * x1 + y1 * y1 + z1 * z1);	sprintf(gTheText,"  %6.2f ",length);	theRuler->SetInfo(gTheText);}void LatticeObject::HilightAtom(LatticeAtom theAtom){	Rect theRect;	theRect = theAtom.spotRect;	ObjRectToLocal(&theRect);	InvertOval(&theRect);}PicHandle		LatticeObject::SetInfoPict(void){	short		n,vSpace,h,v;	double		value;	Rect		theRect;	PicHandle	thePicture;	RgnHandle	clipRgn;	Crystal*	setCrystal;	char		theText[10];		SetRect(&theRect,0,0,182,85);		clipRgn = D_NewRgn();	GetClip(gTheRgn);	RectRgn(clipRgn,&theRect);	D_SetClip(clipRgn);	ForeColor (blackColor);	BackColor (whiteColor);	setCrystal = theCrystal[baseCrystal];	thePicture = OpenPicture(&theRect);		h = 10;	v = 18;	vSpace = 15;	TextFont(newYork);	TextSize(9);		n = sprintf(gTheText,"Atom Info for Crystal %d",baseCrystal + 1);	MoveTo(h,v);	DrawText(gTheText,0,n);		sprintf(gTheText,"Atom Symbol =");	setCrystal->GetAtomicSymbol(currentAtom[0]->atNum,theText);	strcat(gTheText,theText);	v += vSpace;				MoveTo(h,v);	n = strlen(gTheText);	DrawText(gTheText,0,n);	v += vSpace;		value = 0.0;		n = sprintf(gTheText,"Atomic Radius : %6.4f ",(double)currentAtom[0]->atomicRadius * 2 /displayType);	MoveTo(h,v);	DrawText(gTheText,0,n);	v += vSpace;		n = sprintf(gTheText,"coordinates ():");	MoveTo(h,v);	DrawText(gTheText,0,n);			n = sprintf(gTheText,"x = %5.3f,y =  %5.3f,z = %5.3f",(double)currentAtom[0]->x *  currentAtom[0]->length,		 currentAtom[0]->length * currentAtom[0]->y, currentAtom[0]->length * currentAtom[0]->z);	v += vSpace;	MoveTo(h,v);	DrawText(gTheText,0,n);		InsetRect(&theRect,2,2);	PenSize(2,2);	dm_FrameRect(&theRect);	PenNormal();	TextFont(0);	TextSize(12);	ClosePicture();	D_DisposeRgn(&clipRgn);	DMBackColor(BACKGROUND_COLOR);	return(thePicture);}void			LatticeObject::ShowInfo(void){	Point			thePoint;	GetMouse(&thePoint);		if(!MaintainAtoms( thePoint, 1))return;	PenNormal();			theRuler->SetHelp("Shift-Click to search at same location.");				//newPictEnable = true;			thePopUpPict->SetPopUpPict(SetInfoPict());	thePopUpPict->DrawPopUpPict(10,16,true);	thePopUpPict->ClearPopUpPict();	PenNormal();	HilightAtom(*(currentAtom[0]));	theRuler->SetHelp("Hold mouse down over spot.");		return;}Boolean	LatticeObject::FindAtom(Point thePoint){	short 			i,n;	unsigned long			time;	LatticeAtomPtr	theSpot;	static	Point	lastPoint;	static	short	lastLoc;	static	long	thelastClick;	static	Boolean	wasFound;	RgnHandle		tempRgn;		time = gTheEvent.when;	if(thelastClick == time){	/* if NO elapsed time, then same event, data is OK */		return wasFound;	}	thelastClick = time;	LocalToObj(&thePoint);		/*MFTemp*/D_HLock(theDataHandle);	if(gShifted){		double	x,y;		x = thePoint.h - lastPoint.h;		y = thePoint.v - lastPoint.v;		if(sqrt(x * x + y * y) < 4.2){			n = lastLoc;		} else {			n = 1;		}	} else {		n = 1;	}			tempRgn = D_NewRgn();		 	for(i = n , theSpot = &(((LatticeAtomPtr)*theDataHandle)[n - 1])  ; i <= data_Count ; i++,theSpot++){		if(theSpot->hidden)			continue;		OpenRgn();		dm_FrameOval(&theSpot->spotRect);		CloseRgn(tempRgn);				if(PtInRgn(thePoint,tempRgn)) {			currentAtom[numAtomsToHold] = theSpot;			numAtomsToHold++;			/*MFTemp*/D_HUnlock(theDataHandle);						lastLoc = i + 1;			thelastClick = time;			lastPoint = thePoint;			wasFound = true;			spotLoc = i - 1;			D_DisposeRgn(&tempRgn);			return wasFound;		}			}	D_DisposeRgn(&tempRgn);	SystemTask();	/*MFTemp*/D_HUnlock(theDataHandle);	thelastClick = time;	lastPoint = thePoint;	if(n != 1){		SysBeep(30);	} else {		FlashMenuBar(0);		Delay(6L,&time);		FlashMenuBar(0);	}	lastLoc = 1;					/* in case the spot was close but missed */	wasFound = false;	return wasFound;}void	LatticeObject::GetAtomPlane(Point thePoint){	double	radConvert,			xForm[3][3],			x3[3],y3[3],z3[3];	Crystal *setCrystal;	Index	*theIndex;	short	i;	char	theText[255];	if(!MaintainAtoms( thePoint,3))		return;	radConvert = PI / 180.0;				setCrystal = theCrystal[baseCrystal];			theIndex = (Index*)D_new(Index);	theIndex->DoInit(true,setCrystal);	theIndex->h  = 0;	theIndex->k  = 0;	theIndex->l  = 1;			for(i = 0; i <= 2; i++){		x3[i] = currentAtom[i]->x * currentAtom[i]->length;		y3[i] = currentAtom[i]->y * currentAtom[i]->length;		z3[i] = currentAtom[i]->z * currentAtom[i]->length;	}	theIndex->x = y3[0] * (z3[1] - z3[2]) + y3[1] * (z3[2] - z3[0]) + y3[2] * (z3[0] - z3[1]);	theIndex->y = z3[0] * (x3[1] - x3[2]) + z3[1] * (x3[2] - x3[0]) + z3[2] * (x3[0] - x3[1]);	theIndex->z = x3[0] * (y3[1] - y3[2]) + x3[1] * (y3[2] - y3[0]) + x3[2] * (y3[0] - y3[1]);		CopyAxesIntoMatrix(xForm);	InvertMatrix(xForm);	theIndex->direction = false;	theIndex->GetTheUVWFromXYZ(xForm);	theIndex->ConvertXYZToHKLReduce();	if(theIndex->direction == false) theIndex->reduceFlag = false;			theIndex->IndexToIndecies(gTheText);	p2cstr(pTheText);	sprintf(theText,"(%6.5f , %6.5f , %6.5f )",theIndex->x,theIndex->y,theIndex->z);	strcat(gTheText,theText);	theRuler->SetInfo(gTheText);	theIndex->DoClose();	return;}void	LatticeObject::GetAtomDirection(Point thePoint){	double 	x,y,z,			radConvert;	Crystal *setCrystal;	Index	*theIndex;	double  theXForm[3][3];	char	theText[255];		if(!MaintainAtoms( thePoint,2))		return;	radConvert = PI / 180.0;	baseCrystal = baseCrystal;	setCrystal = theCrystal[baseCrystal];		theIndex = (Index*)D_new(Index);	theIndex->DoInit(true,setCrystal);	theIndex->h  = 0;	theIndex->k  = 0;	theIndex->l  = 1;		x = currentAtom[1]->x * currentAtom[1]->length - currentAtom[0]->x * currentAtom[0]->length;	y = currentAtom[1]->y * currentAtom[1]->length  - currentAtom[0]->y * currentAtom[0]->length;	z = currentAtom[1]->z * currentAtom[1]->length  - currentAtom[0]->z * currentAtom[0]->length;		CopyAxesIntoMatrix(theXForm);	InvertMatrix(theXForm);	theIndex->direction = true;	NormalizeVector(&x,&y,&z);	theIndex->x = x;	theIndex->y = y;	theIndex->z = z;		theIndex->direction = true;	theIndex->GetTheUVWFromXYZ(theXForm);	theIndex->ConvertXYZToHKLReduce();	if(theIndex->direction == false) theIndex->reduceFlag = false;		theIndex->IndexToIndecies(gTheText);	p2cstr(pTheText);	sprintf(theText,"[%6.5f , %6.5f , %6.5f ]",theIndex->x,theIndex->y,theIndex->z);	strcat(gTheText,theText);	theRuler->SetInfo(gTheText);	theIndex->DoClose();	return;}void	LatticeObject::HiliteAtomPlane(void){	DialogPtr 		theDialog;	short			theSelect;	Boolean			quit;	GrafPtr			theOldPort;	short			resID = 7100;	double			theXForm[3][3];	Index			*newIndex;	Boolean			hilite;	Boolean			multiplePlanes;		GetPort(&theOldPort);	theDialog	= DM_GetNewDialog(7003,NUL,IN_FRONT);		GetDItem(theDialog,4,&gType,&gTheHandle,&gTheRect);	SetCtlValue((ControlHandle)gTheHandle,0);	newIndex = (Index*)D_new(Index);	newIndex->DoInit(false,theCrystal[baseCrystal]);	quit = false;	newIndex->x = 0;	newIndex->y = 0;	newIndex->z = 1;	theXForm[0][0] = theAtoms->cellX.x;	theXForm[1][0] = theAtoms->cellX.y;	theXForm[2][0] = theAtoms->cellX.z;	theXForm[0][1] = theAtoms->cellY.x;	theXForm[1][1] = theAtoms->cellY.y;	theXForm[2][1] = theAtoms->cellY.z;	theXForm[0][2] = theAtoms->cellZ.x;	theXForm[1][2] = theAtoms->cellZ.y;	theXForm[2][2] = theAtoms->cellZ.z;		InvertMatrix(theXForm);	newIndex->SetIndex(theDialog,3);		hilite = false;	multiplePlanes = false;	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case DLOG_ENTER_OR_CR:			case 1:				SetPort(theOldPort);				if(hilite)					MaintainHilitedPlanes(newIndex,theXForm,multiplePlanes);	 			SetPort(theDialog);	 			newIndex->GetIndex(theDialog,3);	 			SetPort(theOldPort);	 			GetDItem(theDialog,4,&gType,&gTheHandle,&gTheRect);				if(GetCtlValue((ControlHandle)gTheHandle)){					multiplePlanes = true;				}else{					multiplePlanes = false;				}	 			MaintainHilitedPlanes(newIndex,theXForm,multiplePlanes);	 			SetPort(theDialog);	 			hilite = true;				break;			case -1:			case 2:				DM_DisposDialog(&theDialog);								newIndex->DoClose();				return;			case 4:				GetDItem(theDialog,4,&gType,&gTheHandle,&gTheRect);				if(GetCtlValue((ControlHandle)gTheHandle)){					SetCtlValue((ControlHandle)gTheHandle,0);				}else{					SetCtlValue((ControlHandle)gTheHandle,1);				}				break;			default:				break;			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;					}	}		}void 	LatticeObject::MaintainHilitedPlanes(Index* newIndex,double theXForm[3][3],Boolean multiplePlanes){	double			A[3][3],theYForm[3][3];	double			x,y,z;	double			xC,yC,zC;	double			length;	LatticeAtomPtr  theSpot;	short			i;	short			n;	double			absLength;	double			dspacing;				dspacing = length = newIndex->DirCosOfPlaneNormal(&x,&y,&z);		theCrystal[baseCrystal]->Get001XForm(A);	TRANSFORM_VECTOR(x,y,z,A);	FIND_CENTER_XFORM(x,y,z,A);	MatrixMultiply(theXForm,A,theYForm);		xC = theAtoms->centeringValues[0];	yC = theAtoms->centeringValues[1];	zC = theAtoms->centeringValues[2];		TRANSFORM_VECTOR(xC,yC,zC,A);	/*MFTemp*/D_HLock((Handle)theDataHandle);	length -=  zC;	if(multiplePlanes){		absLength = fabs(length);		length = absLength;	}	for(i = 1 , theSpot = &(((LatticeAtomPtr)*theDataHandle)[i - 1])  ; i <= data_Count ; i++,theSpot++){		double testLength;		x = theSpot->x;		y = theSpot->y;		z = theSpot->z;		TRANSFORM_VECTOR(x,y,z,theYForm);		testLength = z * theSpot->length;		absLength = fabs(testLength);		if(multiplePlanes){						n = 0;			while(absLength + .2 >= (length  + (dspacing * n))){				if(fabs( absLength - (length  + (dspacing * n)) ) <= .1){					HilightAtom(*theSpot);					goto CONTINUEIT;				}				n++;			}		}else{			if(fabs( testLength - length) <= .1){				HilightAtom(*theSpot);			}		}		CONTINUEIT:;	}	/*MFTemp*/D_HUnlock((Handle)theDataHandle);	}void	LatticeObject::ShowNearestNeighbors(Point thePoint){		short number;	double bondLength = 0.0;	static Boolean wasShifted = false;	if(numAtomsToHold){		if(wasShifted){			bondLength = 5.0;		}		if(!gMyOffG) MaintainNearestNeighbors(&bondLength);		sprintf(gTheText," ");		theRuler->SetInfo(gTheText);		wasShifted = false;	}	numAtomsToHold = 0;		if(!FindAtom(thePoint))		return;	if(gShifted){		wasShifted = true;	}	number = MaintainNearestNeighbors(&bondLength);	sprintf(gTheText,"%d , min. B. L. = %5.3f ",number, bondLength);	theRuler->SetInfo(gTheText);}short    LatticeObject::MaintainNearestNeighbors(double *bondLength){	double 			*atomicDistances;	double			x,y,z;	double  		delX,delY,delZ;	double			minDistance;	double			nextDistance;	short			i;	LatticeAtomPtr 	theSpot;	short			number;	PenState thePenState;	number = 0;	minDistance = 1000;	nextDistance = 1000;	x = currentAtom[0]->x * currentAtom[0]->length;	y = currentAtom[0]->y * currentAtom[0]->length;	z = currentAtom[0]->z * currentAtom[0]->length;	atomicDistances = (double*)D_NewPtr(sizeof(double) * (data_Count + 1));	if(gMyOffG){		refreshFlag = true;		DoRefresh();	}	thePenState = SetupPen(theCrystal[baseCrystal]);	for(i = 1 , theSpot = &(((LatticeAtomPtr)*theDataHandle)[i - 1])  ; i <= data_Count ; i++,theSpot++){		if(i - 1 == spotLoc)			continue;		delX = x - (theSpot->x * theSpot->length);		delY = y - (theSpot->y * theSpot->length);		delZ = z - (theSpot->z * theSpot->length);		atomicDistances[i - 1] = sqrt(delX * delX + delY * delY + delZ * delZ);		if(atomicDistances[i - 1] < minDistance){			 minDistance = atomicDistances[i - 1];		}else{			if(atomicDistances[i - 1] < nextDistance + .1  && atomicDistances[i - 1] > minDistance + .1) 				nextDistance = atomicDistances[i - 1];		}	}		ClearPen(thePenState);	number = 0;		if(g_Monitor){		theCrystal[baseCrystal]->SetColor();	}	if(gShifted  || *bondLength == 5){		for(i = 1  ; i <= data_Count ; i++,theSpot++){			if(i - 1 == spotLoc)				continue;			if(atomicDistances[i - 1]  > minDistance + .1 && atomicDistances[i - 1]  <= nextDistance + .1) {				number++;				theSpot = &(((LatticeAtomPtr)*theDataHandle)[i - 1]);				thePenState = SetupPen(theCrystal[baseCrystal]);				DrawLineAtomToAtom(*(currentAtom[0]),*theSpot);				ClearPen(thePenState);				HilightAtom(*theSpot);			}		} 		*bondLength = nextDistance;		KillPtr(atomicDistances);		return number;	}	if(g_Monitor){		theCrystal[baseCrystal]->SetColor();	}		for(i = 1  ; i <= data_Count ; i++,theSpot++){		if(i - 1 == spotLoc)			continue;		if(atomicDistances[i - 1]  <= minDistance + .1) {			number++;			theSpot = &(((LatticeAtomPtr)*theDataHandle)[i - 1]);			thePenState = SetupPen(theCrystal[baseCrystal]);			DrawLineAtomToAtom(*(currentAtom[0]),*theSpot);			ClearPen(thePenState);			HilightAtom(*theSpot);		}	} 	*bondLength = minDistance;	KillPtr(atomicDistances);	return number;}void	LatticeObject::LabelAtom(Point thePoint){		numAtomsToHold = 0;	if(!FindAtom(thePoint))		return;	newPictEnable = true;	if((((LatticeAtomPtr)*theDataHandle)[spotLoc]).labeled)		(((LatticeAtomPtr)*theDataHandle)[spotLoc]).labeled = false;	else		(((LatticeAtomPtr)*theDataHandle)[spotLoc]).labeled = true;	ObjRectToLocal(&(((LatticeAtomPtr)*theDataHandle)[spotLoc]).spotRect);	DrawAtomLabel(&(((LatticeAtomPtr)*theDataHandle)[spotLoc]));	LocalRectToObj(&(((LatticeAtomPtr)*theDataHandle)[spotLoc]).spotRect);}void  LatticeObject::DrawAtomLabel(LatticeAtomPtr theAtom){	Crystal 	*setCrystal;	short 		theH,theV;	short		width,height;	Rect 		theRect;	FontInfo	theFontInfo;	theH = (double)(theAtom[0].spotRect.left + theAtom[0].spotRect.right) / 2;	theV = (double)(theAtom[0].spotRect.top + theAtom[0].spotRect.bottom) / 2;				setCrystal = theCrystal[baseCrystal]; 	setCrystal->GetAtomicSymbol(theAtom[0].atNum,gTheText);		c2pstr(gTheText);	TextFont(geneva);	TextSize(9);	PenNormal();	PenPat(&qd.black);		width = (StringWidth(pTheText) / 2) + 1;	GetFontInfo(&theFontInfo);	height = ((theFontInfo.leading + theFontInfo.ascent + theFontInfo.descent) / 2) + 1;		SetRect(&theRect,-width,- height  + (theFontInfo.descent),width,height);	OffsetRect(&theRect,theH,theV);		theH -= (width - 1);	theV += (height - 1);		MoveTo(theH,theV);	SetDrawEnviron();	dm_EraseRect(&theRect);	if(!theAtom[0].labeled)		return;	DrawDiffractString(pTheText);	TextFont(0);	TextSize(0);	}