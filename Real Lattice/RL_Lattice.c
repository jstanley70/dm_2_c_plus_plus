#include	"Diffract_INCs.h"#include	"a_LatticeObject.h"#include "ML_Real_Lattice.h"#include "ML_Crystal.h"#include "ML_PPT_Info.h"#include "ML_BeamOrientation.h"#include "ML_CrystalFace.h"//m:Real Lattice:RL_Lattice.c#include	"UT_VectorMacros.c"#include	"AtomData.h"void		AddLatticeVectors(latticeVectorPtr result,latticeVectorPtr,latticeVectorPtr);Boolean 	InitToHexFaces(Crystal *theC);void 		GetMaxUVW(Crystal *theC,short *uMax,short *vMax,short *wMax,latticeVector *theOffset);#define LATTICE_OBJ_PALETTE 7001void	LatticeObject::SetObjectMenu(void){	theMenuBar	= GetNewMBar(LATTICE_OBJ_MB);	ClearMenuBar();/* July 1992 */	SetMenuBar(theMenuBar);}void GetMaxUVW(Crystal *theC,short *uMax,short *vMax,short *wMax,latticeVector *theOffset){	short i;	CrystalEdge 	*theEdgesPtr;	CrystalVertice	theVert;	CrystalVertice 	*theVerticesPtr;	double			theAtom[3];	double			xMin = 0,yMin = 0,zMin = 0,xMax = 0,yMax = 0,zMax = 0;		theEdgesPtr = 	*(theC->theEdges);	theVerticesPtr = *(theC->theVertices);	for(i = 0; i <= theC->last_Edge;i++){		theVert = theVerticesPtr[theEdgesPtr[i].vert1];		if(xMin > theVert.x) xMin = theVert.x;		if(yMin > theVert.y) yMin = theVert.y;		if(zMin > theVert.z) zMin = theVert.z;				if(xMax < theVert.x) xMax = theVert.x;		if(yMax < theVert.y) yMax = theVert.y;		if(zMax < theVert.z) zMax = theVert.z;				theVert = theVerticesPtr[theEdgesPtr[i].vert2];		if(xMin > theVert.x) xMin = theVert.x;		if(yMin > theVert.y) yMin = theVert.y;		if(zMin > theVert.z) zMin = theVert.z;				if(xMax < theVert.x) xMax = theVert.x;		if(yMax < theVert.y) yMax = theVert.y;		if(zMax < theVert.z) zMax = theVert.z;			}	theAtom[0] = theOffset[0].x * theOffset[0].length + theOffset[1].x * theOffset[1].length + theOffset[2].x * theOffset[2].length;	theAtom[1] = theOffset[0].y * theOffset[0].length + theOffset[1].y * theOffset[1].length + theOffset[2].y * theOffset[2].length;	theAtom[2] = theOffset[0].z * theOffset[0].length + theOffset[1].z * theOffset[1].length + theOffset[2].z * theOffset[2].length;		if(fabs(xMin) > fabs(xMax))		*uMax = fabs(xMin) / theAtom[0];	else		*uMax = fabs(xMax) / theAtom[0];			if(fabs(yMin) > fabs(yMax))		*vMax = fabs(yMin) / theAtom[1];	else		*vMax = fabs(yMax) / theAtom[1];			if(fabs(zMin) > fabs(zMax))		*wMax = fabs(zMin) / theAtom[2];	else		*wMax = fabs(zMax) / theAtom[2];	*uMax += 1;	*vMax += 1;	*wMax += 1;}void		LatticeObject::DoInit(void)				/*  Default Object Init method		*/{//	CTabHandle		theCTab;	short					i;	variSize 		= true;	rulerHeight		= 50;	scaling 		= 30;	heightOfRuler	=  rulerHeight;	data_Size					=	sizeof(SpotInfo);	inherited::DoInit();		theRuler->EnableButtons(3);	if(gTheFile->file_is_Open){		SetWTitle(theWindow,fileInfo.sfFile.name);	}else{		sprintf(gTheText,"Real Lattice %d",g_Window_Number);		SetWTitle(theWindow,c2pstr(gTheText));		g_Window_Number++;	}	fileInfo.sfType = DIF_OBJ;	data_Size		= sizeof(LatticeAtom);	resizeOK		=	false;	data_Count		= 0;	data_Length		= 0;	data_Expand		= 25;	for(i = 0; i < 3; i++)currentAtom[i] = 0L;	theAtoms		= (lattice*)NUL;	baseCrystal		= 0;	imageType		= 2;	displayType		= 1;	radiusType		= 1;	geometryFlag	= false;	pictTransferMode = 0; 	toggleDraw = true;	gMode = 0;	forceOverlay = false;	sliceFlag		= false;	resizeOK		= true;/*august 1993*/	renderFlag	=	false;	theImageVectors = (ImageVector*)NUL;	theDefects		=	0L;	/*	theCTab			= (CTabHandle)GetResource('clut',LATTICE_OBJ_PALETTE);	CTab2Palette(theCTab,GetPalette(theWindow),pmTolerant,pmTolerant);	SetEntryColor(GetPalette(theWindow),14,&backgroundColor);	if(thePallette){			DisposePalette(thePalette);	}	thePallette = GetPalette(theWindow);	ActivatePalette(theWindow);	ReleaseResource((Handle)theCTab);	*/	SetWindowColors(LATTICE_OBJ_PALETTE);	DMBackColor(BACKGROUND_COLOR);	dm_EraseRect(&thePictRect);	imageCenter.v 		 = (theWindow->portRect.top + theWindow->portRect.bottom + heightOfRuler - 15) / 2;	imageCenter.h 		 = (theWindow->portRect.left + theWindow->portRect.right - 15) / 2;	theAtoms 			 = (lattice*)D_new(lattice);	theAtoms->DoInit((Ptr)this);	theAtoms->ownerObj	 = (Ptr)this;	numAtomsToHold 		=	0;	theImageVectors 	 = (ImageVector*)D_new(ImageVector);	theImageVectors->InitAll(0,12); 		thePopUpPict = (PopUpPicture*)D_new(PopUpPicture);/*dec 1992 added by Jim  -- Ack*/	thePopUpPict->DoInit((Ptr)this);		/*KillMBHandle*/DisposeHandle(theMenuBar);	theMenuBar = GetMenuBar();	DrawMenuBar();		if(gTheFile->file_is_Open){		DoZoom(1.0);		theAtoms->SortByZ();		theAtoms->SetIntensity();		theAtoms->SetSurface();				return;	}		GetColors();	DoDefine();	return;}void	LatticeObject::AdjustPlot(){	theImageVectors->SetScaling(scaling);	theAtoms->AdjustAtomicRadii(0,0);		DoZoom(1.0);}void		LatticeObject::DoPrint(void)				/*  Object Print method				*/{	heightOfRuler = 10;	inherited::DoPrint();	heightOfRuler = rulerHeight;	if(reSizeFlag)		theAtoms->ZoomAll();	DoZoom(1.0);	theAtoms->SetSurface();	return;}void		LatticeObject::DoAuxWrite(void)			/*	Stub for offspring writes		*/{	theImageVectors->DoFileWrite();	theAtoms->DoFileWrite();	gTheFile->WriteShort(baseCrystal);	gTheFile->WriteShort(imageType);	gTheFile->WriteShort(displayType);	gTheFile->WriteShort(radiusType);	gTheFile->WriteDataBlock(colors,110 * sizeof(short));	gTheFile->WriteDataBlock(&imageCenter,sizeof(Point));	gTheFile->WriteDataBlock(&centerOffset,sizeof(Point));	gTheFile->WriteFloat((float)scaling);	gTheFile->WriteBoolean(geometryFlag);	gTheFile->WriteBoolean(sliceFlag);	gTheFile->WriteDataBlock(&cellCenter,sizeof(latticeVector));	gTheFile->WriteDataBlock(cellVectors,8 * sizeof(latticeVector));	return;}void		LatticeObject::DoAuxRead(void)			/*	Stub for offspring reads		*/{	theImageVectors->DoFileRead();	theAtoms->DoFileRead();	baseCrystal 		= gTheFile->ReadShort();	imageType 		= gTheFile->ReadShort();	displayType 	= gTheFile->ReadShort();	radiusType 		= gTheFile->ReadShort();	gTheFile->ReadDataBlock(colors,110 * sizeof(short));	gTheFile->ReadDataBlock(&imageCenter,sizeof(Point));	gTheFile->ReadDataBlock(&centerOffset,sizeof(Point));	scaling			= gTheFile->ReadFloat();	geometryFlag 	= gTheFile->ReadBoolean();	sliceFlag		= gTheFile->ReadBoolean();	gTheFile->ReadDataBlock(&cellCenter,sizeof(latticeVector));	gTheFile->ReadDataBlock(cellVectors,8 * sizeof(latticeVector));	return;}void		LatticeObject::DoClose(void)			/*	Object Close method				*/{	if(theImageVectors != (ImageVector*)NUL)		theImageVectors->DoClose();	if(theAtoms != (lattice*)NUL)		theAtoms->DoClose();	thePopUpPict->DoClose(); /*dec 1992 added by Jim  -- Ack*/	if(theDefects != 0L)		theDefects->Kill();	inherited::DoClose();	return;}void		LatticeObject::DoMenu(long theResult)	/*	Menu Method						*/{	short	theItem,theMenu;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);	functionID = 0;		switch(theMenu){		case LATTICE_MENU:			switch(theItem){				case DO_DEFINE:					 DoSetUp();					break;				case DO_REDRAW:					EraseRgn(drawRgn);					InvalRgn(drawRgn);					break;				case HIDE_ATOMS:					theRuler->SetPrompt("Hide Atoms.");					theRuler->SetHelp("To hide atoms, Click on them.");					functionID = HIDE_ATOMS_FUNC;					break;				case HIDE_ELEMENT:					theRuler->SetPrompt("Hide an Element");					theRuler->SetHelp("To hide all atoms of a given Element type, Click on an atom of desired element.");					functionID = HIDE_ELEMENT_FUNC;					break;				case SLICE_LATTICE:/*					if(sliceFlag){						sliceFlag = false;						theAtoms->UnSliceLattice();						theAtoms->SetSurface();						SetPict(true);						  					} else {						sliceFlag = true;						theAtoms->SliceLattice();						theAtoms->SetSurface();						SetPict(true);						  					}					CheckItem(GetMHandle(LATTICE_MENU),SLICE_LATTICE,sliceFlag);*/					theAtoms->SliceLattice();					theAtoms->SetSurface();					//SetPict(true);					newPictReq = true;					break;				case SHOW_ALL:					theAtoms->ShowAll();					theAtoms->SetSurface();					//SetPict(true);					 newPictReq = true;					break;				case LAT_ZOOM_IN:					DoZoom(1.5);					theRuler->SetHelp("This will increase magnification by 1.5x. Please be patient...");					theAtoms->SetSurface();					SetPict(true);					newPictReq = true;					break;				case LAT_ZOOM_OUT:					DoZoom(.6667);					theRuler->SetHelp("This will decrease magnification by .6667x. Please be patient...");					theAtoms->SetSurface();					SetPict(true);					newPictReq = true;										break;				case LAT_ZOOM_ALL:					hScroll->ReInit();					vScroll->ReInit();					theAtoms->ZoomAll();					DoZoom(1.0);					theAtoms->SetSurface();					SetPict(true);					newPictReq = true;					break;				case LAT_SHADE_ATOMS:					renderFlag = !renderFlag;					CheckItem(GetMHandle(LATTICE_MENU),LAT_SHADE_ATOMS,renderFlag);					SetPict(true);					newPictReq = true;					break;				case	ADD_DEFECTS:				if(theDefects == 0L){					theDefects = (DefectObj*)D_new(DefectObj);					theDefects->Init(theCrystal[0]);				}				theDefects->DoDefine();				/*ConvertToUnitCell(baseCrystal);*/				break;				default:					break;			}			HiliteMenu(0);			return;			break;		case ROTATION_MENU:			switch(theItem){				case ROTATE_X:					theRuler->SetPrompt("Rotate about X (Horiz axis in screen).  Angle:");					theRuler->SetHelp("Click mouse and Hold to set rotation angle about the horizonatal axis in screen plane or use arrow keys.");					functionID = ROTATE_AROUND_X;				/*	CenterPicture();  */					break;				case ROTATE_Y:					theRuler->SetPrompt("Rotate about Y (Vert axis in screen).  Angle:");					theRuler->SetHelp("Click mouse and Hold to set rotation angle about the vertical axis in screen plane or use arrow keys.");					functionID = ROTATE_AROUND_Y;					CenterPicture();					break;				case ROTATE_Z:					theRuler->SetPrompt("Rotate about Z (center axis).  Angle:");					theRuler->SetHelp("Click mouse and Hold to set rotation angle about center axis perpendicular to screen or use arrow keys.");					functionID = ROTATE_AROUND;					CenterPicture();					break;				case ROTATE_ANY:					theRuler->SetPrompt("Free Rotate. Plane N:");					theRuler->SetHelp("Click mouse and Move to set rotation angle. Up moves around Y - axis. Down Around X, Around rotates about Z");					functionID = ROTATE_ANY_FUNC;					CenterPicture();					break;				case VIEW_001:					View001();					break;				case ROTATE_TO_PLANE_DIR:					RotateToSpecifiedDir();					break;				default:					break;			}			HiliteMenu(0);			return;			break;		case INFO_MENU_LATTICE:			switch(theItem){				case ATOM_LABELS:					theRuler->SetPrompt("Label Atom with Atomic Symbol:");					theRuler->SetHelp("Click mouse on atom to label with atomic symbol.");					functionID = LABEL_ATOM_FUNC;					numAtomsToHold = 0;					break;					break;				case ATOM_INFO:					functionID		= SHOW_ATOM_INFO_FUNC;					theRuler->SetHelp("Click on spot & hold to view info. Shift-click to view information on hidden atoms");/*dec 1992*/					theRuler->SetPrompt("Show Info:");					SetTheCursor(TARGET_CURSOR);					break;						case ATOM_SEPARATION:					theRuler->SetPrompt("Distance Between 2 Atoms:");					theRuler->SetHelp("Click mouse on 2 atoms to show distance bet. Atoms.  Shift-click clears first two");					functionID = DISTANCE_BETWEEN_ATOMS_FUNC;					numAtomsToHold = 0;					break;									case ANGLE_BETWEEN_ATOMS:					theRuler->SetPrompt("Angle Between 3 Atoms:");					theRuler->SetHelp("Click mouse on three atoms to calculate angle.  Shift-click clears first two");					functionID = ANGLE_BETWEEN_ATOMS_FUNC;					numAtomsToHold = 0;					break;								case ATOM_DIRECTION:					theRuler->SetPrompt("Direction of 2 Atoms:");					theRuler->SetHelp("Click mouse on three atoms to show direction.  Shift-click clears first two");					functionID = ATOM_DIRECTION_FUNC;					numAtomsToHold = 0;					break;										case ATOM_PLANE:					theRuler->SetPrompt("Plane of 3 Atoms:");					theRuler->SetHelp("Click mouse on 3 atoms to determine plane.  Shift-click clears first two");					functionID = ATOM_PLANE_FUNC;					numAtomsToHold = 0;					break;											case NEAREST_ATOM:					theRuler->SetPrompt("No. of Nearest Neighbors:");					theRuler->SetHelp("Click mouse on atom to hilite nearest neighbors.  Shift-click next nearest. Click anywhere to clear.");					functionID = NEAREST_NEIGHBOR_FUNC;					numAtomsToHold = 0;					break;				case ATOMS_ON_PLANE:					theRuler->SetPrompt("Hilite Atomic Plane:");					theRuler->SetHelp(" ");					numAtomsToHold = 0;					HiliteAtomPlane();					newPictReq = true;					break;				default:					break;			}			break;		default:			inherited::DoMenu(theResult);			break;	}}Boolean		LatticeObject::DoContent(Point thePoint)	/*	Content Method					*/{	if(PtInRect(thePoint,&rulerRect)){		return(inherited::DoContent(thePoint));	}		if(theRuler->functionFlag){		switch(functionID){			case ROTATE_AROUND_X:				if(RotateAroundX()){					DoZoom(1.0);					theAtoms->SortByZ();					theAtoms->SetIntensity();					theAtoms->SetSurface();					newPictReq = true;									}				return(true);				break;			case ROTATE_AROUND_Y:				if(RotateAroundY()){					DoZoom(1.0);					theAtoms->SortByZ();					theAtoms->SetIntensity();					theAtoms->SetSurface();					newPictReq = true;									}				return(true);				break;			case ROTATE_AROUND:				if(RotateAroundZ()){					DoZoom(1.0);					theAtoms->SortByZ();					theAtoms->SetIntensity();					theAtoms->SetSurface();					newPictReq = true;									}				return(true);				break;			case ROTATE_ANY_FUNC:				if(RotateAroundAny()){					StartWatch();					DoZoom(1.0);										theAtoms->SortByZ();										theAtoms->SetIntensity();										theAtoms->SetSurface();					StopWatch();					newPictReq = true;					return(true);				}				return(false);				break;			case HIDE_ATOMS_FUNC:				DoSetOrigin();				HideCursor();				theAtoms->HideAtom(thePoint);				ShowCursor();				DoResetOrigin(); 								return(true);				break;			case HIDE_ELEMENT_FUNC:				theAtoms->HideTypeAtom(thePoint);												theAtoms->SetIntensity();				theAtoms->SetSurface();				//SetPict(true);				newPictReq = true;				return(true);				break;			case ANGLE_BETWEEN_ATOMS_FUNC:				GetAngleBetweenAtoms(thePoint);				return true;			case SHOW_ATOM_INFO_FUNC:				ShowInfo();				return true;			case DISTANCE_BETWEEN_ATOMS_FUNC:				GetDistanceBetweenAtoms(thePoint);				return true;			case  ATOM_DIRECTION_FUNC:				GetAtomDirection(thePoint);					return true;			case ATOM_PLANE_FUNC:				GetAtomPlane(thePoint);				return true;						case LABEL_ATOM_FUNC:				LabelAtom(thePoint);				return true;							case NEAREST_NEIGHBOR_FUNC:				ShowNearestNeighbors(thePoint);				return true;												default:				return(inherited::DoContent(thePoint));				break;		}		return(false);	}	return(inherited::DoContent(thePoint));}void		LatticeObject::DoIdle(void)				/*	Idle Routine					*/{		if(linking && !CheckAxes(gDefault)){		gDefault->CopyObjTo(this,false);		DoCalculate();		newPictReq = true;	}		inherited::DoIdle();	return;}void		LatticeObject::DoRefresh(void)			/*	Screen	Refresh					*/{	short i;	if(!functionID)for(i = 0; i < 3; i++){		currentAtom[i] = 0L;		numAtomsToHold = 0;	}	inherited::DoRefresh();		return;}void		LatticeObject::DoCalculate(void)			/*  for compatibility				*/{	short				i,j;	latticeVectorPtr 	xVect,yVect,zVect;	Crystal*			thisCrystal;	latticeVector		temp;	Vector 				end,start;	double				xForm[3][3];	if(isCalculating) return;	thisCrystal = theCrystal[baseCrystal];	end.x = end.y = end.z = 0.0;			cellVectors[0].x		= 0.0;	cellVectors[0].y		= 0.0;	cellVectors[0].z		= 0.0;	cellVectors[0].length	= 0.0;	//thisCrystal->Get001XForm(xForm); 	StartWatch();	isCalculating = true;	GetPPTXFormMatrixBase		(xForm,thisCrystal,0);		/*for(i = 0,j = 1; i <= 2;i++,j++){		start.x = xForm[i][0];		start.y = xForm[i][1];		start.z = xForm[i][2];		cellVectors[j].length	= VectorsLength( start, end);	}				for(i = 0,j = 1; i <= 2;i++,j++){		cellVectors[j].x		= xForm[i][0];		cellVectors[j].y		= xForm[i][1];		cellVectors[j].z		= xForm[i][2];			}*/	InvertMatrix(xForm);	for(i = 0,j = 1; i <= 2;i++,j++){		start.x = xForm[i][0];		start.y = xForm[i][1];		start.z = xForm[i][2];		cellVectors[j].length	= VectorsLength( start, end);	}		NormalizeMatrixRows(xForm);	for(i = 0,j = 1; i <= 2;i++,j++){		cellVectors[j].x		= xForm[i][0];		cellVectors[j].y		= xForm[i][1];		cellVectors[j].z		= xForm[i][2];			}		xVect = &cellVectors[1];	yVect = &cellVectors[2];	zVect = &cellVectors[3];		//cellCenter.x	= .5 * (xVect->length * xVect->length + yVect->length * yVect->x);		cellCenter.x 		= .5 * (	xVect->length * xVect->x + 									yVect->length * yVect->x + 									zVect->length * zVect->x);								cellCenter.y	 	= .5 * (	xVect->length * xVect->y +									yVect->length * yVect->y +									zVect->length * zVect->y);								cellCenter.z 		= .5 * (	xVect->length * xVect->z +									yVect->length * yVect->z +									zVect->length * zVect->z);			cellCenter.length 	=	sqrt(	cellCenter.x * cellCenter.x +									cellCenter.y * cellCenter.y + 									cellCenter.z * cellCenter.z);										cellCenter.x		/= cellCenter.length;	cellCenter.y		/= cellCenter.length;	cellCenter.z		/= cellCenter.length;								AddLatticeVectors(&cellVectors[4],xVect,yVect);	AddLatticeVectors(&cellVectors[5],&cellVectors[4],zVect);	AddLatticeVectors(&cellVectors[6],xVect,zVect);	AddLatticeVectors(&cellVectors[7],yVect,zVect);		if(theImageVectors != (ImageVector*)NUL)		theImageVectors->DoClose();	theImageVectors = (ImageVector*)D_new(ImageVector);			theImageVectors->DoInit(&cellVectors[0],&cellVectors[1],"\pa");		theImageVectors->InitNext(&cellVectors[0],&cellVectors[2],"\pb");	theImageVectors->InitNext(&cellVectors[0],&cellVectors[3],"\pc");	theImageVectors->InitNext(&cellVectors[4],&cellVectors[1],"\p");		theImageVectors->InitNext(&cellVectors[4],&cellVectors[2],"\p");		theImageVectors->InitNext(&cellVectors[4],&cellVectors[5],"\p");		theImageVectors->InitNext(&cellVectors[6],&cellVectors[1],"\p");	theImageVectors->InitNext(&cellVectors[6],&cellVectors[3],"\p");		theImageVectors->InitNext(&cellVectors[6],&cellVectors[5],"\p");		theImageVectors->InitNext(&cellVectors[7],&cellVectors[2],"\p");		theImageVectors->InitNext(&cellVectors[7],&cellVectors[3],"\p");		theImageVectors->InitNext(&cellVectors[7],&cellVectors[5],"\p");				theImageVectors->SetCenter(imageCenter);	theImageVectors->SetScaling(scaling);	theImageVectors->OffsetPoints(&cellCenter);				theAtoms->DoInit((Ptr)this);		for(i = 0 ; i <= thisCrystal->atom_Count ; i++){		theAtoms->DoAtomInit(&((*(thisCrystal->theAtoms))[i]));	}	switch(imageType){		case UNIT_CELL:			geometryFlag = false;			DisableItem(GetMHandle(LATTICE_MENU),SLICE_LATTICE);			break;		case UNIT_LATTICE:			if(theCrystal[baseCrystal]->lattice_Type != HEXAGONAL && theCrystal[baseCrystal]->lattice_Type != TRIGONAL)			{				theAtoms->UnitLattice();			}else{				DrawHexUnitCell();				geometryFlag = true;				DisableItem(GetMHandle(LATTICE_MENU),SLICE_LATTICE);				GetOrientation(xForm);				theImageVectors->DoRotate(xForm);				theAtoms->DoRotate(xForm);				theAtoms->SortByZ();				theAtoms->SetIntensity();				theAtoms->SetSurface();				StopWatch();				changedFlag = false;				newPictReq = true;				isCalculating = false;				return;			}						geometryFlag = true;			DisableItem(GetMHandle(LATTICE_MENU),SLICE_LATTICE);			break;		case LATTICE_8_CELL:			theAtoms->DupAndOffset(&cellVectors[1]);			theAtoms->DupAndOffset(&cellVectors[2]);			theAtoms->DupAndOffset(&cellVectors[3]);			EnableItem(GetMHandle(LATTICE_MENU),SLICE_LATTICE);			geometryFlag = false;			break;		case LATTICE_64_CELL:			theAtoms->DupAndOffset(&cellVectors[1]);			theAtoms->DupAndOffset(&cellVectors[2]);			theAtoms->DupAndOffset(&cellVectors[3]);			temp = cellVectors[1];			temp.length += cellVectors[1].length;			theAtoms->DupAndOffset(&temp);			temp = cellVectors[2];			temp.length += cellVectors[2].length;			theAtoms->DupAndOffset(&temp);			temp = cellVectors[3];			temp.length += cellVectors[3].length;			theAtoms->DupAndOffset(&temp); 			EnableItem(GetMHandle(LATTICE_MENU),SLICE_LATTICE);			geometryFlag = false;			break;		case GEOMETRIC_SHAPE:			DrawLatticeToCrystalMorphology();			{				double x = 0,y = 0,z = 0.0;				short count = 0;			theImageVectors->SetCenter(imageCenter);			theImageVectors->SetScaling(scaling);			theImageVectors->GetAverageLength(&x,&y,&z,count);			cellCenter.length 	=	sqrt(	x * x +									y * y + 									z * z);			if(	cellCenter.length > .00000001){									cellCenter.x		= x/ cellCenter.length;				cellCenter.y		= y/ cellCenter.length;				cellCenter.z		= z/ cellCenter.length;			}else{								cellCenter.x		= 0;				cellCenter.y		= 0;				cellCenter.z		= 0;				cellCenter.length 	= 0;			}			theAtoms->CenterAtoms();  			theImageVectors->ShiftImageVectors(theAtoms->centeringValues[0],theAtoms->centeringValues[1],theAtoms->centeringValues[2]);			/*theImageVectors->OffsetPoints(&cellCenter);*/			}			geometryFlag = true;						EnableItem(GetMHandle(LATTICE_MENU),SLICE_LATTICE);/*dec 1992*/			if(theDefects != 0L)				theAtoms->CalculateDisplacements();			GetOrientation(xForm);			theImageVectors->DoRotate(xForm);			theAtoms->DoRotate(xForm);			theAtoms->SortByZ();			theAtoms->SetIntensity();			theAtoms->SetSurface();			StopWatch();			changedFlag = false;				newPictReq = true;				isCalculating = false;			return;			break;		default:			break;	}	theAtoms->CenterAtoms();  		if(theDefects != 0L)				theAtoms->CalculateDisplacements();	GetOrientation(xForm);	theImageVectors->DoRotate(xForm);	theAtoms->DoRotate(xForm);	theAtoms->SortByZ();	theAtoms->SetIntensity();	theAtoms->SetSurface();		StopWatch();	changedFlag = false;	newPictReq = true;	isCalculating = false;	return;}void	LatticeObject::DrawHexUnitCell(void){	Crystal *theC,*theCN;		theCN = theCrystal[baseCrystal];	theC = (Crystal*)AllocCrystal(baseCrystal);	theCN->CopyCrystal(theC);	if(!InitToHexFaces(theCN))		return;	theCN->DetermineCrystalFaces();	theCN->DetermineVertices();	theCN->DetermineEdges();		DrawLatticeToCrystalMorphology();	{		double x = 0,y = 0,z = 0.0;		short count = 0;	theImageVectors->SetCenter(imageCenter);	theImageVectors->SetScaling(scaling);	theImageVectors->GetAverageLength(&x,&y,&z,count);	cellCenter.length 	=	sqrt(	x * x +							y * y + 							z * z);	if(	cellCenter.length > .00000001){							cellCenter.x		= x/ cellCenter.length;		cellCenter.y		= y/ cellCenter.length;		cellCenter.z		= z/ cellCenter.length;	}else{				cellCenter.x		= 0;		cellCenter.y		= 0;		cellCenter.z		= 0;		cellCenter.length 	= 0;	}	theAtoms->CenterAtoms();  	theImageVectors->ShiftImageVectors(theAtoms->centeringValues[0],theAtoms->centeringValues[1],theAtoms->centeringValues[2]);	/*theImageVectors->OffsetPoints(&cellCenter);*/	}	theC->CopyCrystal(theCN);	theC->DoClose();	return;}Boolean InitToHexFaces(Crystal *theC){	CrystalFace *theFace,*theFacesPtr;	short i;	KillHandle((Handle*)&(theC->theFaces));	theC->face_Count = 7;	theC->theFaces		= (CrystalFaceHnd)D_NewHandle((long)(theC->face_Count + 1) * sizeof(CrystalFace)); 					if(!HandleIsOK((Handle)theC->theFaces)){						theC->face_Count = -1;						return false;					}	KillHandle((Handle*)&(theC->theEdges));	theC->theEdges 		= 	(CrystalEdgeHnd)D_NewHandle(19 * sizeof(CrystalEdge));					if(!HandleIsOK((Handle)theC->theEdges)){						theC->face_Count = -1;						return false;					}	KillHandle((Handle*)&(theC->theVertices));					theC->theVertices 	= (CrystalVerticeHnd)D_NewHandle(14 * sizeof(CrystalVertice));					if(!HandleIsOK((Handle)theC->theVertices)){						theC->face_Count = -1;						return false;					}	D_HLock((Handle)theC->theFaces);	theFace = theFacesPtr = *(theC->theFaces);	for(i = 0;i <= theC->face_Count; i++,theFace++){		theFace->h = 	theFace->k = 	theFace->l = 	0;		theFace->area = 1;		theFace->theCrystal = (Handle)theC;		theFace->direction = false;		theFace->x = 0;		theFace->y = 0;		theFace->z = 0;		theFace->length = 0.0;		theFace->flags = 0;	}	theFacesPtr[0].h =  1;	theFacesPtr[1].h = -1;	theFacesPtr[2].k =  1;	theFacesPtr[3].k = -1;		theFacesPtr[4].h = -1;	theFacesPtr[4].k = 1;		theFacesPtr[5].h = 1;	theFacesPtr[5].k = -1;		theFacesPtr[6].l =  1;	theFacesPtr[7].l = -1;	theFacesPtr[6].area =  1;	theFacesPtr[7].area = 0;	D_HUnlock((Handle)theC->theFaces);	return true;}void	LatticeObject::DrawLatticeToCrystalMorphology(void){	Crystal 		*theC;	CrystalVertice 	*theVert;	CrystalEdge		*theEdge;	Boolean			flag[3];	short			noVects[3];	short			uMax,vMax,wMax,u,v,w;		theC 		= 	theCrystal[baseCrystal];	HLock			((Handle)theC->theVertices);	HLock			((Handle)theC->theEdges);	theVert 	= 	*theC->theVertices;	theEdge 	= 	*theC->theEdges;	theImageVectors->	DoClose();	theImageVectors 	 = (ImageVector*)D_new(ImageVector);	theImageVectors->		InitAll(0,theC->last_Edge + 1); 	theImageVectors->		InsertCrystalMorphology(theVert,theEdge,0);	HUnlock			((Handle)theC->theVertices);	HUnlock			((Handle)theC->theEdges);		GetMaxUVW(theC,&uMax,&vMax,&wMax,&cellVectors[1]);	for(u = -uMax; u <= uMax;u += 1){		for(v = -vMax; v <= vMax;v += 1){			for(w = -wMax; w <= wMax;w += 1){				if(u == 0 && v == 0 && w == 0)					continue;				noVects[0] = u;				noVects[1] = v;				noVects[2] = w;				flag[2] = theAtoms->DupAndOffsetToMorph(&cellVectors[1], noVects);			}		}	}	theAtoms->CheckUnitCell();	}	void		LatticeObject::DoPictDraw(void)			/*  Picture Drawing Routine			*/{	short			h,v;	Boolean			alreadyDrawn;	PenMode(gMode);	PenPat(&qd.black);	if(printing){/*august 1993 Jim.. what a kludge!!!*/		D_HUnlock((Handle)theDataHandle);		if(reSizeFlag){/* august 1993*/			theAtoms->ZoomAll();		}		DoZoom(1.0);		theAtoms->SetSurface();		D_HLock((Handle)theDataHandle);	}	alreadyDrawn = false;	D_HUnlock((Handle)theDataHandle);	centerOffset.h = (short)(.5 + (double)imageCenter.h + (cellCenter.y * cellCenter.length * scaling));	centerOffset.v = (short)(.5 + (double)imageCenter.v + (cellCenter.x * cellCenter.length * scaling));	if(imageType != GEOMETRIC_SHAPE){		theAtoms->DoDraw();		alreadyDrawn= true;	}		if(imageType == GEOMETRIC_SHAPE || geometryFlag){			while(theImageVectors->SortByZ(&theImageVectors))			;				theImageVectors->SetCenter(imageCenter);				centerOffset.h = (short)(.5 + (double)imageCenter.h - (cellCenter.y * cellCenter.length * scaling));		centerOffset.v = (short)(.5 + (double)imageCenter.v - (cellCenter.x * cellCenter.length * scaling));				theImageVectors->DoDraw(theAtoms);						if(!alreadyDrawn)			theAtoms->DoDraw();			}			 h = v = 0;	if(thePictRect.top < heightOfRuler){		v = heightOfRuler - thePictRect.top;	}	if(thePictRect.left < 0){		h = -thePictRect.left;	}	 OffsetRect(&thePictRect,h,v);	D_HLock((Handle)theDataHandle);	return;}WindowPtr	LatticeObject::OpenObjectWindow(void){	return(GetNewCWindow(7000,NUL,IN_FRONT));}void	LatticeObject::DoZoom(double magnification){	Rect	tempRect;	short	height;		height = heightOfRuler + 15;		if(magnification > 0){		scaling *= magnification;		theImageVectors->SetScaling(scaling);	}	theAtoms->GetPicSize(&tempRect);	if((tempRect.bottom - tempRect.top) > objectSize.v && !printing){		objectSize.v = tempRect.bottom - tempRect.top;	} else if((tempRect.bottom - tempRect.top) < (theWindow->portRect.bottom - height) || printing){		objectSize.v = theWindow->portRect.bottom - height;	}			if((tempRect.right - tempRect.left) > objectSize.h  && !printing){		objectSize.h = tempRect.right - tempRect.left;	} else if((tempRect.right - tempRect.left) < (theWindow->portRect.right - 15)  || printing){		objectSize.h = theWindow->portRect.right - 15;	}	hScroll->DoResize();	vScroll->DoResize();/********************* Find Center of centered pictRect ***********************/		imageCenter.v 		= height + objectSize.v / 2;	imageCenter.h 		= objectSize.h / 2;	}void	LatticeObject::CenterPicture(void){	short	h,v;		h = GetCtlMax(hScroll->theControl) / 2;	v = GetCtlMax(vScroll->theControl) / 2;	hScroll->DoScrollSetValue(h);	vScroll->DoScrollSetValue(v);	InvalRect(&thePictRect);	refreshFlag = true;	DoRefresh();}Boolean	LatticeObject::RotateAroundX(void){	short				h,v;	double 				theXForm[3][3],rotAngle;		if(StillDown()){		short				height,lastAngle,angle;		Point				thePoint,lastPoint;		Rect				theRect;				gTheRect = theWindow->portRect;		height = (gTheRect.bottom - gTheRect.top) / 3;		v = (gTheRect.bottom - 16 + gTheRect.top + heightOfRuler) / 2;		h = (gTheRect.right - 16 + gTheRect.left) / 2;		theRect.left	= h - 20;		theRect.right	= h + 20;		theRect.bottom	= v + height;		theRect.top		= v - height;		PenMode(patXor);		dm_FrameOval(&theRect);		PenNormal();				GetMouse(&thePoint);		lastAngle = 0;		InvertArc(&theRect,90,lastAngle);				while(StillDown()){			GetMouse(&thePoint);			if(!EqualPt(thePoint,lastPoint)){				lastPoint = thePoint;				if(thePoint.h < h)					thePoint.h += (2 * (h - thePoint.h));				PtToAngle(&theRect,thePoint,&angle);				angle -= 90;				InvertArc(&theRect,90,lastAngle);				InvertArc(&theRect,90,angle);				lastAngle = angle;				sprintf(gTheText,"%3d¡",lastAngle);				theRuler->SetInfo(gTheText);			}		}		InvertArc(&theRect,90,lastAngle);		PenMode(patXor);		dm_FrameOval(&theRect);		PenNormal();		if(lastAngle == 0)			return false;		rotAngle = ((double)lastAngle) * PI / 180.0;	} else {		return false;	}					RotatateMatrixAxis(theXForm,rotAngle,1);	SetAndRotate(theXForm);	return true;}Boolean	LatticeObject::RotateAroundY(void){	short				h,v;	double 				theXForm[3][3],rotAngle;		if(StillDown()){		short				width,lastAngle,angle;		Point				thePoint,lastPoint;		Rect				theRect;						gTheRect = theWindow->portRect;		v = (gTheRect.bottom - 16 + gTheRect.top + heightOfRuler) / 2;		h = (gTheRect.right - 16 + gTheRect.left) / 2;				width = (theWindow->portRect.right - theWindow->portRect.left) / 3;		theRect.left	= h - width;		theRect.right	= h + width;		theRect.bottom	= v + 20;		theRect.top	= v - 20;		PenMode(patXor);		dm_FrameOval(&theRect);		PenNormal();				GetMouse(&thePoint);		lastAngle = 0;		InvertArc(&theRect,180,lastAngle);				while(StillDown()){			GetMouse(&thePoint);			if(!EqualPt(thePoint,lastPoint)){				lastPoint = thePoint;				if(thePoint.v < v)					thePoint.v += (2 * (v - thePoint.v));				PtToAngle(&theRect,thePoint,&angle);				angle -= 180;				InvertArc(&theRect,180,lastAngle);				InvertArc(&theRect,180,angle);				lastAngle = angle;				sprintf(gTheText,"%3d¡",-lastAngle);				theRuler->SetInfo(gTheText);  			}		}		InvertArc(&theRect,180,lastAngle);		PenMode(patXor);		dm_FrameOval(&theRect);		PenNormal();		if(lastAngle == 0)			return false;		rotAngle = ((double)lastAngle) * PI / 180.0;	} else {		return false;	}			RotatateMatrixAxis(theXForm,rotAngle,0);	SetAndRotate(theXForm);	return true;}Boolean	LatticeObject::RotateAroundZ(void){	short				h,v;	double 				theXForm[3][3],rotAngle;		if(StillDown()){		short				width,height,lastAngle,angle;		Point				thePoint,lastPoint;		Rect				theRect;				width = (theWindow->portRect.right - theWindow->portRect.left) / 3;		height = (theWindow->portRect.bottom - theWindow->portRect.top - heightOfRuler) / 3;				gTheRect = theWindow->portRect;		v = (gTheRect.bottom - 16 + gTheRect.top + heightOfRuler) / 2;		h = (gTheRect.right - 16 + gTheRect.left) / 2;				if(height < width)			width = height;		theRect.left	= h - width;		theRect.right	= h + width;		theRect.bottom	= v + width;		theRect.top		= v - width;		PenMode(patXor);		dm_FrameOval(&theRect);		PenNormal();				GetMouse(&thePoint);		lastAngle = 0;		InvertArc(&theRect,0,lastAngle);				while(StillDown()){			GetMouse(&thePoint);			if(!EqualPt(thePoint,lastPoint)){				lastPoint = thePoint;				PtToAngle(&theRect,thePoint,&angle);				if(angle > 180)					angle -= 360;				InvertArc(&theRect,0,lastAngle);				InvertArc(&theRect,0,angle);				lastAngle = angle;				sprintf(gTheText,"%3d¡",-lastAngle);				theRuler->SetInfo(gTheText);  			}		}		InvertArc(&theRect,0,lastAngle);		PenMode(patXor);		dm_FrameOval(&theRect);		PenNormal();		if(lastAngle == 0)			return false;		rotAngle = ((double)lastAngle) * PI / 180.0;	} else {		return false;	}			RotatateMatrixAxis(theXForm,rotAngle,2);	SetAndRotate(theXForm);	return true;}Boolean	LatticeObject::RotateAroundAny(void){	short				i,h,v;	double 				theXForm[3][3];	double 				yForm[3][3],zForm[3][3],yMirrorForm[3][3];	double				theta[3];	PenState			thePenState;	Boolean 			flag = false;	char				theText[256];	Index				*theIndex,*newIndex;	RgnHandle			theRgn;		GetPenState(&thePenState);	theIndex = (Index*)D_new(Index);	newIndex = (Index*)D_new(Index);	theIndex->DoInit(true,theCrystal[baseCrystal]);	newIndex->DoInit(false,theCrystal[baseCrystal]);	Identity_Matrix(yMirrorForm);	yMirrorForm[1][1] = -1;	theRgn = D_NewRgn();	RectRgn(theRgn,&theWindow->portRect);	D_SetClip(theRgn);	D_DisposeRgn(&theRgn);		if(StillDown()){		Point				thePoint,lastPoint;		Rect				theRect;				double 				rotX,rotY,							setLengthOrg,setNewLength,zThetaNew;									double 				zTheta,oldXYTheta;									PicHandle			thePict;		Crystal 			*thisCrystal;		short				centerX,centerY;						theIndex->x = 0;		theIndex->y = 0;		theIndex->z = 1;		newIndex->x = 0;		newIndex->y = 0;		newIndex->z = 1;				theRect = theWindow->portRect;		centerY = (theRect.top + theRect.bottom)/2;		centerX = (theRect.left + theRect.right)/2;		v = (theRect.top  + heightOfRuler + 80);		h = (theRect.left + 80);						SetRect(&(theRect),h - 75,v - 75,h + 75,v + 75);				flag = false;		GetMouse(&thePoint);				thisCrystal = theCrystal[baseCrystal];		thisCrystal->SetColor();				PenNormal();		GetOrientation(theXForm);		thePict = thisCrystal->DrawMorphology(theXForm,theRect);		dm_EraseRect(&theRect);		DrawPicture(thePict,&theRect);		KillPicture(thePict);		MoveTo(theRect.left,theRect.top);						oldXYTheta = 0;		GetMouse(&lastPoint);		rotX = thePoint.h - centerX;		rotY = thePoint.v - centerY;		setNewLength = setLengthOrg  = sqrt(rotX * rotX + rotY * rotY);		zTheta = atan2(rotY/setNewLength,rotX/setNewLength);		for(i = 0;i <= 2;i++) theta[i] = 0;				gTheText[0] = 	0;		while(StillDown()){			GetMouse(&thePoint);			if(!EqualPt(thePoint,lastPoint)){				rotX = (thePoint.h - lastPoint.h) * PI / 360;				rotY = (thePoint.v - lastPoint.v) * PI / 360;				setNewLength = sqrt(rotX * rotX + rotY * rotY);				if(setNewLength > 6){					zThetaNew = atan2(rotY/setNewLength,rotX / setNewLength);				}								theta[2] = (zThetaNew - zTheta);				zTheta = zThetaNew;								theta[0] = (thePoint.h - lastPoint.h) * PI / 360;				theta[1] = (thePoint.v - lastPoint.v) * PI / 360;																for(i = 0; i < 2;i++){					if(theta[i] == 0) continue;					Identity_Matrix		(yForm);					RotatateMatrixAxis	(yForm,-theta[i],i);					MatrixMultiply		(theXForm,yForm,theXForm);									}				thePict = thisCrystal->DrawMorphology(theXForm,theRect);				dm_EraseRect(&theRect);		 		DrawPicture(thePict,&theRect);		 		KillPicture(thePict);		 			 		theIndex->x = 0;				theIndex->y = 0;				theIndex->z = 1;				newIndex->x = 0;				newIndex->y = 0;				newIndex->z = 1;												InvertMatrix(theXForm);/*Takes the 001 and rotates to true direction*/				theIndex->GetTheUVWFromXYZ(theXForm);				theIndex->ConvertXYZToHKLReduce();				if(theIndex->direction == false) theIndex->reduceFlag = false;							newIndex->GetTheUVWFromXYZ(theXForm);				newIndex->ConvertXYZToHKLReduce();				if(newIndex->direction == false) newIndex->reduceFlag = false;							newIndex	->	IndexToIndecies(gTheText);				p2cstr			(pTheText);				sprintf			(theText," & Direction:");				strcat			(gTheText,theText);				theIndex	->	IndexToIndecies(theText);				p2cstr			((unsigned char*)theText);				strcat			(gTheText,theText);				theRuler	->	SetInfo(gTheText); 				gTheText[0] = 	0;				flag 		= 	true;				lastPoint 	= 	thePoint;		 		InvertMatrix(theXForm);/*Revert the 001 and rotates to true direction*/			}					}			} else {		theIndex->DoClose();		newIndex->DoClose();		return false;	}OUT_OF_LOOP:	SetPenState(&thePenState);		if(!flag){		theIndex->DoClose();		newIndex->DoClose();		return false;	}		SetMatrixAEqB			(zForm,theXForm);	GetOrientation		(theXForm);	InvertMatrix			(theXForm);	MatrixMultiply		(theXForm,zForm,yForm);	SetAndRotate(yForm); 	sprintf				(gTheText,"wait for plotting");	theRuler			->SetInfo(gTheText); 	theIndex			->DoClose();	newIndex			->DoClose(); 				return true;}void	LatticeObject::LMoveTo(latticeVectorPtr theVector){	short	h,v;		h = imageCenter.h + (short)(.5 + theVector->x * theVector->length * scaling);	v = imageCenter.v + (short)(.5 - theVector->y * theVector->length * scaling);		MoveTo(h,v);}		void	LatticeObject::LLineTo(latticeVectorPtr theVector){	short	h,v;		h = imageCenter.h + (short)(.5 + theVector->x * theVector->length * scaling);	v = imageCenter.v + (short)(.5 - theVector->y * theVector->length * scaling);	if(theVector->z < 0.){		DMForeColor(12);	} else {		DMForeColor(0);	}	LineTo(h,v);}	void			LatticeObject::DoDblClick(Point where){	if(where.v > heightOfRuler){		theAtoms->SetColor(where);	} else {		inherited::DoDblClick(where);	}}											void			LatticeObject::GetColors(void)	{	Handle	theHandle;		theHandle = GetResource('Colr',7000);	BlockMove((Ptr)(*theHandle),(Ptr)colors,210);	ReleaseResource(theHandle);	}				void			LatticeObject::View001(void){	double rotation[3][3];	changedFlag = false;	GetOrientation(rotation);	InvertMatrix(rotation);	theImageVectors->DoRotate(rotation);	theAtoms->DoRotate(rotation);	DoZoom(1.0);	theAtoms->SortByZ();	theAtoms->SetIntensity();	theAtoms->SetSurface();	newPictReq = true;	{		double zForm[3][3];		Identity_Matrix(zForm);		ZoneAxisFromMatrix(false,zForm,&calcIrrational,theZoneAxis,theRotationAxis,g_Vector,&rotationAngle,&offLaueDistance,&totalRot,&beamAzimuth);		SetOrientation(zForm);	}}		void		AddLatticeVectors(latticeVectorPtr c,latticeVectorPtr a,latticeVectorPtr b){		c->x 		= a->x * a->length + b->x * b->length;	c->y 		= a->y * a->length + b->y * b->length;	c->z 		= a->z * a->length + b->z * b->length;		c->length	= sqrt(c->x * c->x + c->y * c->y + c->z * c->z);	c->x		/= c->length;	c->y		/= c->length;	c->z		/= c->length;} void	LatticeObject::RotateToSpecifiedDir(void){	double matrix[3][3],theXForm[3][3];	GetOrientation(theXForm);	InvertMatrix(theXForm);	{double x = 0,y = 0,z = 1;		if(DefineOrientation(true,&x,&y,&z)){			GetOrientation(matrix);			MatrixMultiply(theXForm,matrix,theXForm);			theImageVectors->DoRotate(theXForm);			theAtoms->DoRotate(theXForm);			DoZoom(1.0);			theAtoms->SortByZ();			theAtoms->SetIntensity();			theAtoms->SetSurface();			newPictReq = true;		}	}}short  LatticeObject::SetPictMode(short theItem)//bloch{	short i;	for(i = 1;i < 7;i++)	{		CheckItem(g_Hier_Pict_Mode,i,false);	}	CheckItem(g_Hier_Pict_Mode,theItem,true);		switch(theItem)	{		case 1:			pictTransferMode = 0; 			if(picObjList)picObjList->ConvertPictToNewTransferMode();			toggleDraw = true;			gMode = 0;			forceOverlay = false;			break;			default:				inherited::SetPictMode( theItem);			break;	}	return 0;}	void  LatticeObject::CheckMode(void)//bloch{	short i;	for(i = 1;i < 7;i++)	{		CheckItem(g_Hier_Pict_Mode,i,false);	}		if(pictTransferMode == 0 && toggleDraw == true		&& gMode == 0 && forceOverlay == false){			CheckItem(g_Hier_Pict_Mode,1,true);			return;	}	inherited::CheckMode();			return;}