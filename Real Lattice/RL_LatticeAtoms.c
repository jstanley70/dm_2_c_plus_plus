#include	"Diffract_INCs.h"#include	"AtomData.h"//m:Real Lattice:RL_LatticeAtoms.c#include	"a_LatticeObject.h"#include	"UT_VectorMacros.c"short	AtomCompare(LatticeAtomPtr,LatticeAtomPtr);#define	OWNER_LAT_A		((LatticeObject*)ownerObj)->cellVectors[1]#define	OWNER_LAT_B		((LatticeObject*)ownerObj)->cellVectors[2]#define	OWNER_LAT_C		((LatticeObject*)ownerObj)->cellVectors[3]#define	OWNER_CENTER	((LatticeObject*)ownerObj)->cellCenter#define	CX				((LatticeObject*)ownerObj)->imageCenter.h#define	CY				((LatticeObject*)ownerObj)->imageCenter.v#define	SCALE			((LatticeObject*)ownerObj)->scaling#define	BASE_OBJ		((LatticeObject*)ownerObj)void	lattice::DoInit(Ptr theOwner){	ownerObj 				= theOwner;	BASE_OBJ->data_Count 	= 0;	theLattice 				= (LatticeAtomHandle)BASE_OBJ->theDataHandle;	cellX.length 	= cellY.length 	= cellZ.length 	= 1.0;	cellX.x 		= cellY.y 		= cellZ.z 		= 1.0;	cellX.y 		= cellY.x 		= cellZ.x 		= 0.0;	cellX.z 		= cellY.z 		= cellZ.y 		= 0.0;}		void	lattice::DoAtomInit(AtomPtr thisAtom){	AtomData *theAtomData;		if(BASE_OBJ->data_Count >= BASE_OBJ->data_Length){		BASE_OBJ->ExpandMemory();		if(BASE_OBJ->data_Count >= BASE_OBJ->data_Length){			return;		}	}		D_HLock((Handle)theLattice);	theAtoms = &((*theLattice)[BASE_OBJ->data_Count++]);		theAtoms->a = 	thisAtom->x;	theAtoms->b = 	thisAtom->y;	theAtoms->c = 	thisAtom->z;	theAtoms->labeled = false;	theAtoms->x = 	thisAtom->x * OWNER_LAT_A.x * OWNER_LAT_A.length +					thisAtom->y * OWNER_LAT_B.x * OWNER_LAT_B.length +					thisAtom->z * OWNER_LAT_C.x * OWNER_LAT_C.length;		theAtoms->y = 	thisAtom->x * OWNER_LAT_A.y * OWNER_LAT_A.length +					thisAtom->y * OWNER_LAT_B.y * OWNER_LAT_B.length +					thisAtom->z * OWNER_LAT_C.y * OWNER_LAT_C.length;		theAtoms->z = 	thisAtom->x * OWNER_LAT_A.z * OWNER_LAT_A.length +					thisAtom->y * OWNER_LAT_B.z * OWNER_LAT_B.length +					thisAtom->z * OWNER_LAT_C.z * OWNER_LAT_C.length;			theAtoms->length = sqrt(theAtoms->x * theAtoms->x + 							theAtoms->y * theAtoms->y + 							theAtoms->z * theAtoms->z);	if(fabs(theAtoms->length) > .0000001){		theAtoms->x /= theAtoms->length;		theAtoms->y /= theAtoms->length;		theAtoms->z /= theAtoms->length;	} else {		theAtoms->x 		= 0.0;		theAtoms->y 		= 0.0;		theAtoms->z 		= 0.0;		theAtoms->length	= 0.0;	}		theAtoms->hidden		= false;	theAtoms->atNum			= thisAtom->atomicNum;	theAtomData = (AtomData*)D_new(AtomData);	theAtomData->DoInit(theAtoms->atNum - 1);  /* Changed May 28 1992 */	theAtoms->atomicRadius	= BASE_OBJ->displayType * .5 * theAtomData->GetRadius(BASE_OBJ->radiusType,BASE_OBJ->theCrystal[BASE_OBJ->baseCrystal]);	theAtoms->color 		= BASE_OBJ->colors[theAtoms->atNum];	theAtomData->DoClose();	if(theAtoms->color < 1 )		theAtoms->color = 1;	if(theAtoms->color > 7 )		theAtoms->color = 7;	D_HUnlock((Handle)theLattice);		return;}void	lattice::CenterAtoms(void){	register double			x,y,z;		D_HLock((Handle)theLattice);		x = y = z = 0.0;		theAtoms = *theLattice;	for(i = 1 ; i <= BASE_OBJ->data_Count ; i++,theAtoms++){		x += theAtoms->x * theAtoms->length;		y += theAtoms->y * theAtoms->length;		z += theAtoms->z * theAtoms->length;	}		x /= (double)(BASE_OBJ->data_Count);	y /= (double)(BASE_OBJ->data_Count);	z /= (double)(BASE_OBJ->data_Count);		theAtoms = *theLattice;	for(i = 1 ; i <= BASE_OBJ->data_Count ; i++,theAtoms++){		theAtoms->x 		= theAtoms->x * theAtoms->length - x;		theAtoms->y 		= theAtoms->y * theAtoms->length - y;		theAtoms->z 		= theAtoms->z * theAtoms->length - z;		theAtoms->length 	= sqrt(	theAtoms->x * theAtoms->x +									theAtoms->y * theAtoms->y +									theAtoms->z * theAtoms->z);		if(theAtoms->length > .0000001){			theAtoms->x			/= theAtoms->length;			theAtoms->y			/= theAtoms->length;			theAtoms->z			/= theAtoms->length;		} else {			theAtoms->x			= 0.0;			theAtoms->y			= 0.0;			theAtoms->z			= 0.0;			theAtoms->length	= 0.0;		}	}	 centeringValues[0] = x;	 centeringValues[1] = y;	 centeringValues[2] = z;	D_HUnlock((Handle)theLattice);}void	lattice::DoClose(void){	D_delete(this);}void	lattice::AdjustAtomicRadii(short atomicNo,float radius){	AtomData *theAtomData;	theAtoms = *theLattice;			if(atomicNo == 0 && radius == 0.0){		theAtomData = (AtomData*)D_new(AtomData);		for(i = 1 ; i <= BASE_OBJ->data_Count ; i++,theAtoms++){			theAtomData->DoInit(theAtoms->atNum - 1);  /* Changed May 28 1992 */			theAtoms->atomicRadius	= BASE_OBJ->displayType * .5 * theAtomData->GetRadius(BASE_OBJ->radiusType,BASE_OBJ->theCrystal[BASE_OBJ->baseCrystal]);		}		theAtomData->DoClose();	}else{		for(i = 1 ; i <= BASE_OBJ->data_Count ; i++,theAtoms++){			if(theAtoms->atNum == atomicNo){				theAtoms->atomicRadius	= radius;				theAtoms->radius	=	theAtoms->atomicRadius * SCALE;			}		}	}	}void	lattice::DoRotate(double theXForm[][3]){	double xForm00,xForm01,xForm02,xForm10,xForm11,xForm12,xForm20,xForm21,xForm22;	double	x,y,z;	D_HLock((Handle)theLattice);	xForm00	=	theXForm[0][0];	xForm01	=	theXForm[0][1];	xForm02	=	theXForm[0][2];		xForm10	=	theXForm[1][0];	xForm11	=	theXForm[1][1];	xForm12	=	theXForm[1][2];		xForm20	=	theXForm[2][0];	xForm21	=	theXForm[2][1];	xForm22	=	theXForm[2][2];	theAtoms = *theLattice;	//NormalizeMatrixRows(theXForm);	//g_ThreadObj->YieldToThreads(0L);	for(i = 1 ; i <= BASE_OBJ->data_Count ; i++,theAtoms++){		//TRANSFORM_VECTOR(theAtoms->x,theAtoms->y,theAtoms->z,theXForm);		x = theAtoms->x * xForm00 + theAtoms->y * xForm01 + theAtoms->z * xForm02;		y = theAtoms->x * xForm10 + theAtoms->y * xForm11 + theAtoms->z * xForm12;		z = theAtoms->x * xForm20 + theAtoms->y * xForm21 + theAtoms->z * xForm22;		theAtoms->x = x;		theAtoms->y = y;		theAtoms->z = z;	//	NORMALIZE_VECTOR(theAtoms->x,theAtoms->y,theAtoms->z);	}	//g_ThreadObj->YieldToThreads(0L);	TRANSFORM_VECTOR(cellX.x,cellX.y,cellX.z,theXForm);	NORMALIZE_VECTOR(cellX.x,cellX.y,cellX.z);	TRANSFORM_VECTOR(cellY.x,cellY.y,cellY.z,theXForm);	NORMALIZE_VECTOR(cellY.x,cellY.y,cellY.z);	TRANSFORM_VECTOR(cellZ.x,cellZ.y,cellZ.z,theXForm);	NORMALIZE_VECTOR(cellZ.x,cellZ.y,cellZ.z);	D_HUnlock((Handle)theLattice);	return;}void	lattice::SetSurface(void){	Rect				*theRect;	//RgnHandle			thePicRgn,theSpotRgn,resultRgn;	register double	 	scale,length;	double				rad;	register short		h;	short				cx,cy;	cx 		= CX;	cy 		= CY;	scale	= SCALE;		//thePicRgn	= D_NewRgn();	//theSpotRgn	= D_NewRgn();//	resultRgn	= D_NewRgn();//	SetEmptyRgn(thePicRgn);	D_HLock((Handle)theLattice);	theAtoms = *theLattice;	for(i = 1 ; i <= BASE_OBJ->data_Count ; i++,theAtoms++){		/* CheckWatch(); */		if(theAtoms->hidden)			continue;		theRect						= &theAtoms->spotRect;		length						= scale * theAtoms->length;		h 								= cx + (short)(.5 + theAtoms->y * length);		theAtoms->h				= h;		theAtoms->v 			= cy + (short)(.5 + theAtoms->x * length);		theAtoms->radius 	= theAtoms->atomicRadius * scale;		rad								= theAtoms->radius;		theRect->top 			= theRect->left 	= (short)-rad;		theRect->right 		= theRect->bottom 	= (short)rad;		OffsetRect(theRect,h,theAtoms->v);		theAtoms->covered = false;/*eliminate if you need to go back to the old way of doing it*/	}	D_HUnlock((Handle)theLattice);	/*	rad *= .70710678;		val = (short)rad;		step = (short)(rad - (double)val);		OpenRgn();			MoveTo(h,theRect->top);		Line(val,step);		Line(step,val);		Line(-step,val);		Line(-val,step);		Line(-val,-step);		Line(-step,-val);		Line(step,-val);		LineTo(h,theRect->top);				CloseRgn(theSpotRgn);		DiffRgn(theSpotRgn,thePicRgn,resultRgn);		if(EmptyRgn(resultRgn)){			theAtoms->covered = true;		} else {			theAtoms->covered = false;			UnionRgn(resultRgn,thePicRgn,thePicRgn);		}	}	D_HUnlock((Handle)theLattice);	D_DisposeRgn(&resultRgn);	D_DisposeRgn(&thePicRgn);	D_DisposeRgn(&theSpotRgn);	*/}void	lattice::DoDraw(void){	short		n,j;	double		posInc,radInc,pos,rad;	Rect		theRect;		D_HLock((Handle)theLattice);	theAtoms = &((*theLattice)[BASE_OBJ->data_Count - 1]);	for(i = 1 ; i <= BASE_OBJ->data_Count ; i++,theAtoms--){		if(theAtoms->hidden || theAtoms->covered){			continue;		}		posInc 				= (double)theAtoms->radius * .02;		radInc 				= (double)theAtoms->radius * .055;		pos					= 0.0;		rad					= theAtoms->radius;		n 					= theAtoms->color * 32 + theAtoms->intensity + theAtoms->intensity;		if(g_Monitor){			if(BASE_OBJ->renderFlag){				for(j = 1 ; j <= 16 ; j++){					short iPos,iRad,dx,dy;										iPos			= (short)(.5 + pos);					iRad 			= (short)(.5 + rad);										theRect.top 	= theRect.left 		= -iRad;					theRect.right 	= theRect.bottom 	= iRad;					dx 				= theAtoms->h + iPos;					dy 				= theAtoms->v - iPos;					OffsetRect(&theRect,dx,dy);					BASE_OBJ->DMForeColor(n++);					dm_PaintOval(&theRect);					pos += posInc;					rad -= radInc;				}			}else{				j = 1;				{					short iPos,iRad,dx,dy;										iPos			= (short)(.5 + pos);					iRad 			= (short)(.5 + rad);										theRect.top 	= theRect.left 		= -iRad;					theRect.right 	= theRect.bottom 	= iRad;					dx 				= theAtoms->h + iPos;					dy 				= theAtoms->v - iPos;					OffsetRect(&theRect,dx,dy);					BASE_OBJ->DMForeColor(n);					dm_PaintOval(&theRect);					pos += posInc;					rad -= radInc;				}			}		}else{			/* Added by Jim */			PatHandle thePatHandle;			PatPtr thePatPtr;			long penPatNo;									{				short iPos,iRad,dx,dy;								iPos			= (short)(.5 + pos);				iRad 			= (short)(.5 + rad);								theRect.top 	= theRect.left 		= -iRad;				theRect.right 	= theRect.bottom 	= iRad;				dx 				= theAtoms->h + iPos;				dy 				= theAtoms->v - iPos;				OffsetRect(&theRect,dx,dy);							}			PenNormal();			if(!BASE_OBJ->renderFlag){			penPatNo = (200 + (long)theAtoms->atNum);			if(penPatNo > 237){				if(penPatNo < 274){					penPatNo = penPatNo - 37;					PenMode(notPatCopy);				}else{					penPatNo = penPatNo - 74;					PenMode(notPatOr);				}			}			thePatHandle = GetPattern(penPatNo);			thePatPtr = *thePatHandle;			PenPat(thePatPtr);			ReleaseResource((Handle)thePatHandle);			}else{				short patID;				PatHandle hPat;				patID = 300 + Round((double)theAtoms->intensity);				hPat =  GetPattern(patID);				PenPat(*hPat); 				ReleaseResource((Handle)hPat);			}			dm_PaintOval(&theRect);			PenNormal();			dm_FrameOval(&theRect);		}		if(theAtoms->labeled){			BASE_OBJ->DrawAtomLabel(theAtoms);		}	}	D_HUnlock((Handle)theLattice);	}void	lattice::DoRgnDraw(RgnHandle theUpdateRgn,short top,short left,short bottom,short right){	short		n,j;	double		posInc,radInc,pos,rad;	Rect		theRect;	RgnHandle	atomRgn,resultRgn,oldClip;	Boolean		end;		oldClip		= D_NewRgn();	atomRgn 	= D_NewRgn();	resultRgn	= D_NewRgn();	GetClip(oldClip);	theRect = BASE_OBJ->theVisRect;	BASE_OBJ->LocalRectToObj(&theRect);	RectRgn(resultRgn,&theRect);	SectRgn(theUpdateRgn,resultRgn,theUpdateRgn);	D_SetClip(theUpdateRgn);		D_HLock((Handle)theLattice);	end = false;	theAtoms = *theLattice;	for(i = 1 ; i <= BASE_OBJ->data_Count && !end ; i++,theAtoms++){		if(theAtoms->hidden){			continue;		}		theRect = theAtoms->spotRect;				if(	theRect.top > bottom 	|| 			theRect.bottom < top	||			theRect.right < left 	||			theRect.left > right){				continue;		}				OpenRgn();		dm_FrameOval(&theRect);		CloseRgn(atomRgn);						SectRgn(theUpdateRgn,atomRgn,resultRgn);				if(EmptyRgn(resultRgn))			continue;		D_SetClip(resultRgn);		DiffRgn(theUpdateRgn,resultRgn,theUpdateRgn);		if(EmptyRgn(theUpdateRgn))			end = true;				theAtoms->covered = false;						posInc 				= (double)theAtoms->radius * .02;		radInc 				= (double)theAtoms->radius * .055;		pos					= 0.0;		rad					= theAtoms->radius;		n 					= theAtoms->color * 32 + theAtoms->intensity + theAtoms->intensity;			for(j = 1 ; j <= 16 ; j++){			short iPos,iRad;						iPos			= (short)(.5 + pos);			iRad 			= (short)(.5 + rad);						theRect.top 	= theRect.left 		= -rad;			theRect.right 	= theRect.bottom 	= rad;			OffsetRect(&theRect,(short)(theAtoms->h + iPos),(short)(theAtoms->v - iPos));			BASE_OBJ->DMForeColor(n++);			dm_PaintOval(&theRect);			pos += posInc;			rad -= radInc;		}		}	if(!end){		D_SetClip(theUpdateRgn);		EraseRgn(theUpdateRgn);	}	D_HUnlock((Handle)theLattice);	D_DisposeRgn(&atomRgn);	D_DisposeRgn(&resultRgn);	D_SetClip(oldClip);	D_DisposeRgn(&oldClip);}void	lattice::SortByZ(void){	D_HLock((Handle)theLattice);	qsort(*theLattice,(long)BASE_OBJ->data_Count,sizeof(LatticeAtom),(_compare_function/*__cmp_func_Cmpfun**/)AtomCompare);	D_HUnlock((Handle)theLattice);}void	lattice::SetIntensity(void){	double	span,value,max;		D_HLock((Handle)theLattice);	theAtoms = *theLattice;		max		= theAtoms->z * theAtoms->length;	span 	= max - theAtoms[BASE_OBJ->data_Count-1].z * theAtoms[BASE_OBJ->data_Count-1].length;	if(span < .001)			span = 1000000;	span = 7.0 / span;				for(i = 1 ; i <= BASE_OBJ->data_Count ; i++,theAtoms++){		value 					= max - theAtoms->z * theAtoms->length; 		theAtoms->intensity 	= (short)(7.5 - value * span);	}	D_HUnlock((Handle)theLattice);}			Boolean 		lattice::DupAndOffsetToMorph(latticeVector* theOff,short noVects[3]){	short			last;	LatticeAtomPtr	newAtom;	Crystal			*theCrys;	Boolean			flag = true;	double			theAtom1,theAtom2,theAtom3,theAtom[3];	short			k = 0,l = 0,m = 0,n;	double 			kd,ld,md;		kd = (double)noVects[0];	ld = (double)noVects[1];	md = (double)noVects[2];	k = kd / fabs(kd);	l = ld / fabs(ld);	m = md / fabs(md);	theCrys		= BASE_OBJ->theCrystal[BASE_OBJ->baseCrystal];	theAtom1 = theOff[0].x *  kd * theOff[0].length + theOff[1].x *  ld  * theOff[1].length + theOff[2].x *  md * theOff[2].length;	theAtom2 = theOff[0].y *  kd * theOff[0].length + theOff[1].y *  ld  * theOff[1].length + theOff[2].y *  md * theOff[2].length;	theAtom3 = theOff[0].z *  kd * theOff[0].length + theOff[1].z *  ld  * theOff[1].length + theOff[2].z *  md * theOff[2].length;	theAtom[0] = theAtom1 + (theOff[0].x *  k * theOff[0].length + theOff[1].x *  l  * theOff[1].length + theOff[2].x *  m * theOff[2].length);	theAtom[1] = theAtom2 + (theOff[0].y *  k * theOff[0].length + theOff[1].y *  l  * theOff[1].length + theOff[2].y *  m * theOff[2].length);	theAtom[2] = theAtom3 + (theOff[0].z *  k * theOff[0].length + theOff[1].z *  l  * theOff[1].length + theOff[2].z *  m * theOff[2].length);	flag = true;	if(!theCrys->CornerInsideVolume(theAtom))		flag = false;	last 		= theCrys->atom_Count + 1;	D_HLock((Handle)theLattice);	theAtoms 	= *(theLattice);	n = BASE_OBJ->data_Count;	for(i = 1 ; i <= last ; i++,theAtoms++){		if(BASE_OBJ->data_Count >= BASE_OBJ->data_Length){			BASE_OBJ->ExpandMemory();			if(BASE_OBJ->data_Count >= BASE_OBJ->data_Length){				D_HUnlock((Handle)theLattice);				return false;			}		}				theAtom[0]		= theAtoms->x * theAtoms->length + theAtom1;		theAtom[1]		= theAtoms->y * theAtoms->length + theAtom2;		theAtom[2]		= theAtoms->z * theAtoms->length + theAtom3;				if(!flag && !theCrys->CornerInsideVolume(theAtom)) continue;				newAtom = &((*theLattice)[BASE_OBJ->data_Count++]);		n = BASE_OBJ->data_Count;				newAtom->a				= theAtoms->a;		newAtom->b				= theAtoms->b;		newAtom->c				= theAtoms->c;		newAtom->atNum 			= theAtoms->atNum;		newAtom->atomicRadius 	= theAtoms->atomicRadius;		newAtom->color 			= theAtoms->color;		newAtom->hidden			= false;		newAtom->covered		= false;		newAtom->labeled		= false;		newAtom->x = theAtom[0];		newAtom->y = theAtom[1];		newAtom->z = theAtom[2];		newAtom->length	= sqrt(	newAtom->x * newAtom->x +								newAtom->y * newAtom->y +								newAtom->z * newAtom->z);						if(fabs(newAtom->length) > .0000001){			newAtom->x /= newAtom->length;			newAtom->y /= newAtom->length;			newAtom->z /= newAtom->length;		} else {			newAtom->x 		= 0.0;			newAtom->y 		= 0.0;			newAtom->z 		= 0.0;			newAtom->length	= 0.0;		}	}	D_HUnlock((Handle)theLattice);	return flag;}	void		lattice::CheckUnitCell(void){	short			last;	LatticeAtomPtr	theAtomsPlus,oldAtom;	Crystal			*theCrys;	double			theAtom[3];	short			j = 0,i = 0;	theCrys		= BASE_OBJ->theCrystal[BASE_OBJ->baseCrystal];	last 		= theCrys->atom_Count + 1;	D_HLock((Handle)theLattice);	theAtoms 	= *(theLattice);	for(i = 1 ; i <= last ; i++,theAtoms++){		theAtom[0]		= theAtoms->x * theAtoms->length;		theAtom[1]		= theAtoms->y * theAtoms->length;		theAtom[2]		= theAtoms->z * theAtoms->length;				if(!theCrys->CornerInsideVolume(theAtom)){			theAtomsPlus = &theAtoms[1];			oldAtom = theAtoms;			for(j = i; j <  BASE_OBJ->data_Count;j++,theAtoms++,theAtomsPlus++)*theAtoms = *theAtomsPlus;							i--;			last--;			theAtoms = &oldAtom[-1];			 BASE_OBJ->data_Count--;		}	}	D_HUnlock((Handle)theLattice);	return;}	void 		lattice::DupAndOffset(latticeVector* theOffset){	short			last;	LatticeAtomPtr	newAtom;		D_HLock((Handle)theLattice);	theAtoms 	= *theLattice;	last		= BASE_OBJ->data_Count;	//g_ThreadObj->YieldToThreads(0L);	for(i = 1 ; i <= last ; i++,theAtoms++){		if(BASE_OBJ->data_Count >= BASE_OBJ->data_Length){			BASE_OBJ->ExpandMemory();			if(BASE_OBJ->data_Count >= BASE_OBJ->data_Length){				D_HUnlock((Handle)theLattice);				return;			}		}		newAtom = &((*theLattice)[BASE_OBJ->data_Count++]);						newAtom->a				= theAtoms->a;		newAtom->b				= theAtoms->b;		newAtom->c				= theAtoms->c;		newAtom->atNum 			= theAtoms->atNum;		newAtom->atomicRadius 	= theAtoms->atomicRadius;		newAtom->color 			= theAtoms->color;		newAtom->hidden			= false;		newAtom->covered		= false;		newAtom->labeled		= false;		newAtom->x		= theAtoms->x * theAtoms->length;		newAtom->x		+= (theOffset->x * theOffset->length);		newAtom->y		= theAtoms->y * theAtoms->length;		newAtom->y		+= (theOffset->y * theOffset->length);		newAtom->z		= theAtoms->z * theAtoms->length;		newAtom->z		+= (theOffset->z * theOffset->length);						newAtom->length	= sqrt(	newAtom->x * newAtom->x +								newAtom->y * newAtom->y +								newAtom->z * newAtom->z);						if(fabs(newAtom->length) > .0000001){			newAtom->x /= newAtom->length;			newAtom->y /= newAtom->length;			newAtom->z /= newAtom->length;		} else {			newAtom->x 		= 0.0;			newAtom->y 		= 0.0;			newAtom->z 		= 0.0;			newAtom->length	= 0.0;		}	}	D_HUnlock((Handle)theLattice);	//g_ThreadObj->YieldToThreads(0L);	return;}void 		lattice::HideAtom(Point	thePoint){	Rect		*theRect;	RgnHandle	theUpdateRgn;			BASE_OBJ->LocalToObj(&thePoint);	D_HLock((Handle)theLattice);	theAtoms 	= *theLattice;		for(i = 1 ; i <= BASE_OBJ->data_Count ; i++,theAtoms++){		theRect = &(theAtoms->spotRect);		if(!theAtoms->hidden && PtInRect(thePoint,theRect)){			double	x,y,rad,dist;						rad 	= (theRect->right - theRect->left) / 2;			x		= (double)thePoint.h - ((double)theRect->right + (double)theRect->left) / 2.0;			y		= (double)thePoint.v - ((double)theRect->top + (double)theRect->bottom) / 2.0;			dist 	= sqrt(x * x + y * y);			if(dist <= rad){				short j,left,right,top,bottom;				RgnHandle	tempRgn;				theAtoms->hidden	= true;				theUpdateRgn		= D_NewRgn();				tempRgn				= D_NewRgn();												InsetRect(theRect,-1,-1);				OpenRgn();				dm_FrameOval(theRect);				CloseRgn(theUpdateRgn);				left 		= theRect->left;				right 		= theRect->right;				top 		= theRect->top;				bottom 		= theRect->bottom;								theAtoms--;				for(j = i - 1 ; j >= 1 ; j--,theAtoms--){					if(!theAtoms->hidden){						theRect = &(theAtoms->spotRect);						if(	left 	> theRect->right || 							right 	< theRect->left ||							top 	> theRect->bottom ||							bottom	< theRect->top)						continue;						OpenRgn();						dm_FrameOval(theRect);						CloseRgn(tempRgn);						DiffRgn(theUpdateRgn,tempRgn,theUpdateRgn);					}				}				D_HUnlock((Handle)theLattice);				DoRgnDraw(theUpdateRgn,top,left,bottom,right);  				D_DisposeRgn(&theUpdateRgn);				D_DisposeRgn(&tempRgn);				//BASE_OBJ->newPictEnable = true;  				return;			}		}	}	D_HUnlock((Handle)theLattice);}void 		lattice::HideTypeAtom(Point	thePoint){	Rect		*theRect;	double		theZ;	Boolean		found = false;		BASE_OBJ->LocalToObj(&thePoint);	D_HLock((Handle)theLattice);	theAtoms 	= *theLattice;		for(i = 1 ; i <= BASE_OBJ->data_Count; i++,theAtoms++){		theRect = &(theAtoms->spotRect);		if(!theAtoms->hidden && PtInRect(thePoint,theRect)){			double	x,y,rad,dist;						rad 	= (theRect->right - theRect->left) / 2;			x		= (double)thePoint.h - ((double)theRect->right + (double)theRect->left) / 2.0;			y		= (double)thePoint.v - ((double)theRect->top + (double)theRect->bottom) / 2.0;			dist 	= sqrt(x * x + y * y);			if(dist <= rad){				theZ 	= theAtoms->atNum;				found 	= true;				break;			}					}	}		theAtoms 	= *theLattice;	for(i = 1 ; i <= BASE_OBJ->data_Count; i++,theAtoms++){		if(theAtoms->atNum == theZ){			theAtoms->hidden = true;		}	}	D_HUnlock((Handle)theLattice);}void 		lattice::ShowAll(void){	D_HLock((Handle)theLattice);	theAtoms 	= *theLattice;		for(i = 1 ; i <= BASE_OBJ->data_Count ; i++,theAtoms++){		theAtoms->hidden = false;	}	D_HUnlock((Handle)theLattice);}void 		lattice::UnitLattice(void){	LatticeAtomPtr 	thisAtom;	short			last;		D_HLock((Handle)theLattice);	thisAtom = *theLattice;	last = BASE_OBJ->data_Count;		for(i = 1 ; i <= last ; i++,thisAtom++){		thisAtom = &((*theLattice)[i - 1]);		if(thisAtom->a <= .000001){			OffsetThisAtom(thisAtom,1);			if(thisAtom->b <= .000001){				OffsetThisAtom(thisAtom,3);				if(thisAtom->c <= .000001){					OffsetThisAtom(thisAtom,7);				}			}			if(thisAtom->c <= .000001){				OffsetThisAtom(thisAtom,5);			}		}		if(thisAtom->b <= .000001){			OffsetThisAtom(thisAtom,2);			if(thisAtom->c <= .000001){				OffsetThisAtom(thisAtom,6);			}		}		if(thisAtom->c <= .000001){			OffsetThisAtom(thisAtom,4);		}	}	D_HUnlock((Handle)theLattice);}	