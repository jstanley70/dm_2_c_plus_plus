//rces.Jim:Desktop.2.0:Tables 2:TA2_TextTableObj.c#include	"Diffract_INCs.h"#include 	"AtomData.h"#include	"a_D_Space.h"#include	"TextTableObj.h"short	TestMultiplicity(Index *index1,Index *index2,double *x,double *y);short	ZCompare(SpotInfo* spot1,SpotInfo* spot2);short	TestMultiplicity3D(Index *index1,Index *index2,Index *index3,double *x,double *y,double *z);#include 	"JimsLib.h"Ptr AllocTextTableObj(void){	TextTableObj	*textTable;		textTable =  (TextTableObj*)D_new(TextTableObj);	if(HandleIsOK((Handle)textTable)){		textTable->objectType  =		TEXT_TABLE;		textTable->DoInit();		return((Ptr)textTable);	} else {		return(NUL_PTR);	}}void		TextTableObj::DoInit(void){	initFlag = true;		inherited::DoInit();	sprintf(gTheText,"Text Table %d",g_Window_Number++);	SetObjectWindowTitle(gTheText,400,380);	 	displayDspace = 1;	crystalNum2 = 5;		theListRect = ((GrafPtr)theWindow)->portRect;	theListRect.top += 50;	theListRect.left = 5;	theListRect.right -= 18;	theListRect.bottom -= 5;	numColumns = 7;	initFlag = false;				/*KillMBHandle*/DisposeHandle(theMenuBar);	theMenuBar = GetMenuBar();	DrawMenuBar();	objectType = TEXT_TABLE; 			}void	TextTableObj::DoKey(char theKey){	inherited::DoKey(theKey);}void TextTableObj::SetOwner(DiffractObject* theOwner){	owner = theOwner;	theBeamFlag = ((DiffractObject*)owner)->theBeamFlag;	energy =   ((DiffractObject*)owner)->energy;	wavelength =  ((DiffractObject*)owner)->wavelength;	maxEnergy =  ((DiffractObject*)owner)->energy;	HideGraph();}void	TextTableObj::DoDefineSetUp(void){	DoDefine();}void	TextTableObj::DoDefine(void){		TextTableObj3D 	*theTable;	Boolean			*flags;	short			j;	if(initFlag) return ;	DisplayList();	j = CountMItems(gTheWindowMenu);	flags = (Boolean*)D_NewPtr(sizeof(Boolean) * j);	if(MarkSpotSet(flags)){		theTable = (TextTableObj3D*)AllocTextTable3DObj();		theTable->FillValuesFromTables(flags);		theTable->CalculateReducedUnitCell();		KillPtr((Ptr)flags);		theTable->ShowGraph();		theTable->SetPict(true);		theTable->D_DrawPict();		theTable->DoRefresh();			}	return ;}void	TextTableObj::CalculateReducedUnitCell(void){	SpotInfoPtr theSpots;	SpotInfoPtr theSpotsPtr;	short		i,j,p;	Boolean		flag = false;	Index		*index1,*index2,*index3,*index4;	double		x1,y1,z1,x2,y2,z2,oldAngle,length,oldLength = 100;	double 		x,y,z;	double 		theAngle,angle1;		index1 = (Index*)D_new(Index);	index2 = (Index*)D_new(Index);	index3 = (Index*)D_new(Index);	index4 = (Index*)D_new(Index);	/*MFTemp*/D_HLock(theDataHandle);	qsort(*theDataHandle,(long)(data_Count),sizeof(SpotInfo),(_compare_function/*__cmp_func_Cmpfun**/)JimsStructFactCompare);	theSpots 						= (SpotInfoPtr)(*theDataHandle);	theSpots[0].h 			= 1;	theSpots[0].k	 			= 0;	theSpots[0].l 			= 0;	theSpots[0].angle 	= 0;	index1->CopyPtrToIndex((Ptr)&theSpots[0]);	theSpotsPtr 		= (SpotInfoPtr)*theDataHandle;	theSpots 			= (SpotInfoPtr)&(theSpotsPtr[1]);	i = 1;	while(i < data_Count && !flag)	{				index2->CopyPtrToIndex((Ptr)theSpots);		theSpots->angle = theAngle = index1->GetTheXYZAngle(index2);		if(!flag && fabs(theAngle) > .1 && fabs(PI - theAngle) > .1 && fabs((2 * PI) - theAngle) > .1){			p = j = i;			flag = true;		}		i++;		theSpots++;	}	if(!flag){		index1->DoClose();		index2->DoClose();		index3->DoClose();		index4->DoClose();	 	return;	}	/*MFTemp*/D_HUnlock(theDataHandle);	theSpots = (SpotInfoPtr)(*theDataHandle);	theSpots[j].h = 0;	theSpots[j].k = 1;	theSpots[j].l = 0;	angle1					=	theSpots[j].angle;	theSpots[j].angle 	= 0;		index2->CopyPtrToIndex((Ptr)&theSpots[j]);	index2->EliminateIndexComponent(index1);	index1->EliminateIndexComponent(index2);	theSpots[j].angle 	= angle1;	flag = false;	x1 = index1->x;	y1 = index1->y;	z1 = index1->z;	x2 = index2->x;	y2 = index2->y;	z2 = index2->z;	CrossProduct(&x,&y,&z,x1,y1,z1,x2,y2,z2);	index4->x = x;	index4->y = y;	index4->z = z;	oldAngle = .92;TRYAGAIN:	theSpotsPtr = (SpotInfoPtr)*theDataHandle;	theSpots = (SpotInfoPtr)theSpotsPtr;	i = 0;	j = -1;	length	=	20;/*Work In Here!!!*/	while(i < data_Count && !flag)	{		double angle;		index3->CopyPtrToIndex((Ptr)theSpots);		angle = index4->GetTheXYZAngle(index3);		theAngle = sqrt(1 - (cos(angle) *  cos(angle)));				if(fabs(theAngle)  <= oldAngle){			j = i;			flag = true;		}		i++;		theSpots++;	}	if(!flag && oldAngle < 1){		oldAngle += .01;		goto TRYAGAIN;	}	if(!flag){		index1->DoClose();		index2->DoClose();		index3->DoClose();		index4->DoClose();	 	return;	}	theSpots = (SpotInfoPtr)(*theDataHandle);	theSpots[j].h = 0;	theSpots[j].k = 0;	theSpots[j].l = 1;		index3->CopyPtrToIndex((Ptr)&theSpots[j]);	if(fabs(index3->z) < .01 && fabs(index1->z) < .01 && fabs(index2->z) < .01){Message(NO_REDUCED_CELL); goto ENDIT;}STARTOVER: index3->EliminateIndexComponent(index1);	if(index3->EliminateIndexComponent(index2))goto STARTOVER;	if(index1->EliminateIndexComponent(index3))goto STARTOVER;	if(index2->EliminateIndexComponent(index3))goto STARTOVER;	if(index1->EliminateIndexComponent(index2))goto STARTOVER;	if(index2->EliminateIndexComponent(index1))goto STARTOVER;	if(index1->EliminateIndexComponent(index3))goto STARTOVER;	if(index2->EliminateIndexComponent(index3))goto STARTOVER;	for(i = 0; i < data_Count;i++,theSpots++){		double x,y,z;		x = theSpots->x;		y = theSpots->y;		z = theSpots->z;		TestMultiplicity3D(index1,index2,index3,&x,&y,&z);		theSpots->h = x;		theSpots->k = y;		theSpots->l = z;	}	theCrystal[0]->SetCrystalFromBasisSet(index1,index2,index3,false);ENDIT:	index1->DoClose();	index2->DoClose();	index3->DoClose();	index4->DoClose();	}short	TestMultiplicity3D(Index *index1,Index *index2,Index *index3,double *x,double *y,double *z){	short p = 0,maxH,maxK,maxL,i,k,j;	double x1,x2,x3,length,minG;		length = sqrt(*x * *x + *y * *y + *z * *z);	if(length < .1){		*x = 0;		*y = 0;		*z = 0;		return p;	}			maxH	=	fabs(length / index1->GetLength()) + 1;	maxK	=	fabs(length / index2->GetLength()) + 1;	maxL	=	fabs(length / index3->GetLength()) + 1;		minG = index1->GetLength() / 2;	for(i = -maxH;i <= maxH;i++){		for(k = -maxK;k <= maxK;k++){			for(j = -maxL;j<= maxL;j++){			x1 = (index1->x * i) - *x + (index2->x * k) + (index3->x * j);			x2 = (index1->y * i) - *y + (index2->y * k) + (index3->y * j);			x3 = (index1->z * i) - *z + (index2->z * k) + (index3->z * j);				if(sqrt(x1 * x1 + x2 * x2 + x3 * x3) < minG){					 *x = i;					 *y = k;					 *z = j;					 return p;				}			}		}			}	return 0;}void TextTableObj::SetObjectMenu(void){	theMenuBar = GetNewMBar(TABLE_MB);	ClearMenuBar();/* July 1992 */	SetMenuBar(theMenuBar);}void		TextTableObj::DoClose(void){			inherited::DoClose();	return;}Boolean		TextTableObj::DoContent(Point thePoint){	PenState theState;	GetPenState(&theState);	PenNormal();	if((theCrystalButton)->DoContent(thePoint)){		return true;		}	SetPenState(&theState);		gCurrentObj->DMForeColor/*PMForeColor*/(10 + crystalNum);	PmBackColor(BACKGROUND_COLOR);	return(inherited::DoContent(thePoint));	}void			TextTableObj::DoIdle(void){		inherited::DoIdle();	return;}#define DEFINE_TABLE 500void		TextTableObj::DoMenu(long	theResult){	short	theMenu,theItem;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);		switch(theMenu){		case EDIT_MENU:			switch(theItem){				case CUT:				case COPY:				case PASTE:				case DO_CLEAR:					return;					break;				default:					break;			}			break;		case DEFINE_TABLE:			switch(theItem){								case 3:					qsort(*theDataHandle,(long)(data_Count),sizeof(SpotInfo),(_compare_function/*__cmp_func_Cmpfun**/)DspaceCompare);					sortMethod = 1;					DisplayList();					break;				case 4:					qsort(*theDataHandle,(long)(data_Count),sizeof(SpotInfo),(_compare_function/*__cmp_func_Cmpfun**/)JimsStructFactCompare);					sortMethod = 2;					DisplayList();					break;				case 5:					/*MFTemp*/D_HLock(theDataHandle);					qsort(*theDataHandle,(long)(data_Count),sizeof(SpotInfo),(_compare_function/*__cmp_func_Cmpfun**/)JimsStructFactCompare);					/*MFTemp*/D_HUnlock(theDataHandle);					sortMethod = 3;					DisplayList();					break;				case 7:					displayDspace = 1;					DisplayList();					break;				case 8:					displayDspace = 2;					DisplayList();					break;				case 9:					displayDspace = 3;					DisplayList();					break;				case 10:					displayDspace = 4;					DisplayList();					break;				default:					break;			}								break;		default:			break;	}	inherited::DoMenu(theResult);	return;}void TextTableObj::DrawTheText(void){	short top,bottom;		bottom 	= theCrystalButton->theButtonRect.bottom;	top		= theCrystalButton->theButtonRect.top + 1;		theCrystalButton->DrawButtonRect(crystalNum + 10);	MoveTo(theListRect.left +12 ,theListRect.top - 10);		switch(displayDspace){		case 1:			sprintf(gTheText,"HKL X  (-1) Y (-1) Z (-1) D-Space ()  g1 ^ gn ¡");			break;		case 2:			sprintf(gTheText,"HKL X  (-1) Y (-1) Z (-1) D-Space -1  g1 ^ gn ¡");			break;		case 3:			sprintf(gTheText," HKL X  (-1) Y (-1) Z (-1)  g-vec (mm)  g1 ^ gn ¡");		break;		case 4:			sprintf(gTheText," HKL X  (-1) Y (-1) Z (-1) 2Theta (¡)  E.D ()");		break;	}	gCurrentObj->DMForeColor/*PMForeColor*/(BLACK);	DrawString(c2pstr(gTheText));}void		TextTableObj::ConvertPointsToSpots(PointObj* thePoints){	SpotInfoPtr theSpots;	short		n = 1;	PointObj	*centerPoint;	centerPoint = 	0L;	centerPoint = 	thePoints->CountObjects(&n,centerPoint,REG_POINT);	data_Count 	= 	n - 1;	KillHandle(&theDataHandle);		theDataHandle 	= D_NewHandle(sizeof(SpotInfo) * (data_Count + 1));	data_Length 	= data_Count;	D_HLock			(theDataHandle);	theSpots 		= 	(SpotInfoPtr)*theDataHandle;	theSpots		->	theCrystal = thePoints->theCrystal;	thePoints		->	InsertData(theSpots,centerPoint,REG_POINT);	D_HUnlock			(theDataHandle);	DetermineHKLValues();}short	ZCompare(SpotInfo* spot1,SpotInfo* spot2){	double z1,z2;		z2 = fabs((double)spot1->z);	z1 = fabs((double)spot2->z);		return((short)((z1 < z2) ? -1 : ((z1 == z2) ? 0 : 1)));}void 		TextTableObj::DetermineHKLValues(void){	SpotInfoPtr dspace;	Index		*index1,*index2;	short		i,j;	Boolean		flag = false,try3D = false;	double		z;	D_HLock(theDataHandle);	dspace = (SpotInfoPtr)(*theDataHandle);	for(i = 0; i < data_Count;i++){		z = sqrt(dspace[i].y * dspace[i].y + dspace[i].x * dspace[i].x  + dspace[i].z * dspace[i].z);		if(z > .001) dspace[i].intensity = 1 / z;		else dspace[i].intensity = 0;		if(dspace[i].z > 0.1){			try3D = true;		}		 dspace[i].direction = false;		 dspace[i].theCrystal = theCrystal[0];	}	if(try3D){		D_HUnlock(theDataHandle);		CalculateReducedUnitCell();		return;	}	D_HUnlock(theDataHandle);	qsort(*theDataHandle,(long)(data_Count),sizeof(SpotInfo),(_compare_function/*__cmp_func_Cmpfun**/)JimsStructFactCompare);		index1 = (Index*)D_new(Index);	index2 = (Index*)D_new(Index);	D_HLock((Handle)theDataHandle);	dspace = (SpotInfoPtr)(*theDataHandle);		flag = false;	i = 1;	dspace[0].h = 1;	dspace[0].k = 0;	dspace[0].l = 0;	dspace[0].angle = 0;	index1->CopyPtrToIndex((Ptr)&dspace[0]);		j = 0;	while(i < data_Count)	{		double theAngle;		index2->CopyPtrToIndex((Ptr)&dspace[i]);		dspace[i].angle = theAngle = index1->GetTheXYZAngle(index2);		if(!flag && fabs(theAngle) > .3 && fabs(PI - theAngle) > .3 && fabs((2 * PI) - theAngle) > .3){			j = i;			flag = true;		}		i++;	}	dspace[j].h = 0;	dspace[j].k = 1;	dspace[j].l = 0;		index2->CopyPtrToIndex((Ptr)&dspace[j]);		if(flag == true){		double x,y;		for(i = 1; i < data_Count;i++){			if(i == j)continue;			x = dspace[i].x;			y = dspace[i].y;						TestMultiplicity(index1,index2,&x,&y);			dspace[i].h = (short)x;			dspace[i].k = (short)y;			dspace[i].l = 0;		}	}	index1->DoClose();	index2->DoClose();	D_HUnlock((Handle)theDataHandle);	}short	TestMultiplicity(Index *index1,Index *index2,double *x,double *y){	short p = 0,maxH,maxK,i,k;	double x1,x2,length,minG,test;		length = sqrt(*x * *x + *y * *y);	if(length < .1){		*x = 0;		*y = 0;		return 0;	}	minG = sqrt(index1->x * index1->x + index1->y * index1->y);	test = sqrt(index2->x * index2->x + index2->y * index2->y);	maxH	=	fabs(length / minG) + 1;	maxK	=	fabs(length / test) + 1;	if(minG > test) minG = test;	minG *= .5;	for(i = -maxH;i <= maxH;i++){		for(k = -maxK;k <= maxK;k++){			x1 = (index1->x * i) - *x + (index2->x * k);			x2 = (index1->y * i) - *y + (index2->y * k);			if(sqrt(x1 * x1 + x2 * x2) < minG){				 *x = i;				 *y = k;				 return 0;			}		}			}	return p;}void		TextTableObj::ShowGraph(){	ShowWindow(theWindow);	SelectWindow(theWindow);	SetPort(theWindow);}void	TextTableObj::MyCalculate(void){}void	TextTableObj::HideGraph(void){	HideWindow(theWindow);	SetPort( ((DiffractObject*)owner)->theWindow);}void	TextTableObj::ConvertXYtoXYZ_List(double *x,double *y,double *z){	ConvertXYtoXYZ(x,y,z);}void		TextTableObj::ConvertXYtoXYZ(double *x,double *y,double *z){	stage		->		 CancelMatrixRotation(x,y,z,false);}void		TextTableObj::DisplayList(void){	SpotInfoPtr dspace;	short 		length,i;	Cell		theCell;	double		x,y,z;			LDoDraw(false,theList);	TextFont(geneva);	TextSize(10); 	gCurrentObj->DMForeColor/*PMForeColor*/(10 + crystalNum);	PmBackColor(BACKGROUND_COLOR);	theCell.v = -1;	theCell.h = 0;	/*MFTemp*/D_HLock(theDataHandle);	dspace = (SpotInfoPtr)(*theDataHandle);	PenNormal();		firstPlane->Init(false,theCrystal[0]);		for(i = 0; i < data_Count && gNoBreak;i++)	{		short j;		AllowBackground();		theCell.v = i;		theCell.h = 0;		firstPlane->CopyPtrToIndex((Ptr)&(dspace[i]));		firstPlane->direction = false;		firstPlane->SetListIndecies(theList,theCell);		x	=	dspace[i].x;		y	=	dspace[i].y;		z	=	dspace[i].z;		ConvertXYtoXYZ_List(&x,&y,&z);		for(j = 1;j <= 5;j++)		{			switch(j){			case 1:				length = sprintf(gTheText,"%6.4f",x);				break;			case 2:				length = sprintf(gTheText,"%6.4f",y);				break;			case 3:				length = sprintf(gTheText,"%6.2f",z);				break;			case 4:				length = sprintf(gTheText,"%6.4f",dspace[i].intensity);				break;			case 5:					length = sprintf(gTheText,"%6.2f",dspace[i].angle * 180 / PI);				break;			}				++theCell.h;				LSetCell(gTheText,length,theCell,theList);						}			}	LDoDraw			(true,theList);	/*MFTemp*/D_HUnlock	(theDataHandle);	gCurrentObj->DMForeColor/*PMForeColor*/		(10 + crystalNum);	PmBackColor		(BACKGROUND_COLOR);	LUpdate			(theWindow->visRgn,theList); 	TextFont		(0);	TextSize		(0);	newPictReq = true;/*needs to be added so we get a redraw of the header*/	return;}Boolean	TextTableObj::MarkSpotSet(Boolean *flags){	PopUpMenu 	*theMenu;	DialogPtr 	theDialog;	Boolean 		calculateFlag , quit;	short 			i,theSelect;	Boolean			onFlag;	short				j;			theDialog	= 	DM_GetNewDialog(206,NUL,IN_FRONT);		calculateFlag = quit = false;		theMenu = (PopUpMenu*)D_new(PopUpMenu);	theMenu->Init(theDialog,3,135,1);	j = CountMItems(gTheWindowMenu);	for(i = 1; i <= j;i++){		GetItem(gTheWindowMenu,i,pTheText);		theMenu->P_AppendMenu(gTheText);	}	while(!quit){		WindowPeek	theWindow;		TextTableObj	*theObj;		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;			case -1:			case 2:				quit = true;				calculateFlag = false;				break;			case 1:				calculateFlag = true;				quit = true;				break;			case	3:				theMenu->DoPopUp();				i = 0;				theWindow = (WindowPeek)FrontWindow();				while(i < theMenu->lastResult){theWindow = theWindow->nextWindow;i++;}					theObj = (TextTableObj*)((WindowPeek)theWindow)->refCon;		 						if(theObj->objectType == TEXT_TABLE ) {					onFlag = (Boolean)theMenu->P_GetCItemMark();					theMenu->P_CheckCItem(!onFlag);				}				break;			default:				break;		}	}	j = theMenu->P_CountMItems();	for(i = 1; i <= j;i++){		if(theMenu->P_GetItemMark(i))			flags[i - 1] = true;		else{			flags[i - 1] = false;		}	}	theMenu->DoClose();	DM_DisposDialog(&theDialog);		return calculateFlag;}