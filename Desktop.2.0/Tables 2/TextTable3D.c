//ects:D.M. v2.0:Sources.Jim:Desktop.2.0:Tables 2:TextTable3D.c#include	"Diffract_INCs.h"#include 	"AtomData.h"#include	"a_D_Space.h"#include	"TextTableObj.h"#include 	"nrutil.h"#include 	"mathRecipies.h"Ptr AllocTextTable3DObj(void){	TextTableObj3D	*textTable;		textTable =  (TextTableObj3D*)D_new(TextTableObj3D);	if(HandleIsOK((Handle)textTable)){		textTable->objectType  =		TEXT_TABLE_3D;		textTable->DoInit();		return((Ptr)textTable);	} else {		return(NUL_PTR);	}}void	TextTableObj3D::FitUnitCellToData(void){	float latticeParam[7];	float *y;	float	**p;	float	e = -.15;	int		nfunk,i,k;		y = vector(1,7);	p = matrix(1,7,1,6);	SetTheCursor(WATCH_CURSOR);	StartWatch();	latticeParam[0] = 0;	latticeParam[1] = theCrystal[0]->theUnitCell.a ;	latticeParam[2] = theCrystal[0]->theUnitCell.b;	latticeParam[3] = theCrystal[0]->theUnitCell.c;	latticeParam[4] = theCrystal[0]->theUnitCell.alpha;	latticeParam[5] = theCrystal[0]->theUnitCell.beta;	latticeParam[6] = theCrystal[0]->theUnitCell.gamma;	for(i = 1; i < 8;e += .05,i++){		for(k = 1; k < 7;k++)p[i][k] = latticeParam[k] + e;	}	for(i = 1; i < 8;e += .05,i++){		for(k = 1; k < 7;k++)latticeParam[k] = p[i][k];		y[i] = LeastSquareAnalysis(latticeParam);	}	if(amoeba(p, y, 6, .0001, LeastSquareAnalysis,&nfunk)){		if(p[1][1] > .5 &&			p[1][2] > .5 && 			p[1][3] > .5){			theCrystal[0]->theUnitCell.a 		= p[1][1];			theCrystal[0]->theUnitCell.b 		= p[1][2];			theCrystal[0]->theUnitCell.c 		= p[1][3];			theCrystal[0]->theUnitCell.alpha 	= p[1][4];			theCrystal[0]->theUnitCell.beta 	= p[1][5];			theCrystal[0]->theUnitCell.gamma 	= p[1][6];						theCrystal[0]->GetSvals();			theCrystal[0]->CellVolume();			y[1] *= 10;			y[1] +=  .002;			theCrystal[0]->DetermineReducedCell(&y[1]);		}	}else{		y[1] = .005;/* proportion of value for fudging*/		theCrystal[0]->GetSvals();		theCrystal[0]->CellVolume();		theCrystal[0]->DetermineReducedCell(&y[1]);	}		theCrystal[0]->GetSvals();	theCrystal[0]->CellVolume();	free_matrix(p,1,8,1,7);	free_vector(y,1,6);	StopWatch();}float	LeastSquareAnalysis(float latticeParam[]){	short i;	double dspace,value,total = 0;	Index *theIndex;	SpotInfoPtr theSpots;	theIndex = (Index*)D_new(Index);	theIndex->DoInit(false,gCurrentObj->theCrystal[0]);	theIndex->theCrystal->theUnitCell.a = latticeParam[1];	theIndex->theCrystal->theUnitCell.b = latticeParam[2];	theIndex->theCrystal->theUnitCell.c = latticeParam[3];	theIndex->theCrystal->theUnitCell.alpha = latticeParam[4];	theIndex->theCrystal->theUnitCell.beta = latticeParam[5];	theIndex->theCrystal->theUnitCell.gamma = latticeParam[6];	theIndex->theCrystal->GetSvals();	theIndex->theCrystal->CellVolume();	theSpots = (SpotInfoPtr)*(gCurrentObj->theDataHandle);	for(i = 0; i < gCurrentObj->data_Count;i++,theSpots++){		theIndex->CopyPtrToIndex((Ptr)theSpots);		dspace = 1 / theIndex->TheDSpacing();		value = (dspace - theIndex->GetLength());		value *= value;		total += value;	}	theIndex->DoClose();	return total;}void	TextTableObj3D::CalculateReducedUnitCell(void){	inherited::CalculateReducedUnitCell();	FitUnitCellToData();}void	TextTableObj3D::FillValuesFromTables(Boolean *flags){	WindowPeek	theWindow;	SpotInfoPtr theSpots,theSpotsNew;	short		i,j;	TextTableObj	*theObj;	Boolean		flag = false;	double 		x,y,z;		theWindow = (WindowPeek)FrontWindow();	i = 0;	data_Count = 0;	theWindow = theWindow->nextWindow;	while(theWindow != NULL){		theObj = (TextTableObj*)((WindowPeek)theWindow)->refCon;		 		if(theObj->objectType == TEXT_TABLE && flags[i] ) {			short k;			SpotInfoPtr theSpotsPtr;			j = data_Count;			if(data_Count <= 0){				KillHandle(&theDataHandle);				theDataHandle = D_NewHandle((theObj->data_Count + 1) * sizeof(SpotInfo));				data_Length = theObj->data_Count + 1;			}			data_Count += theObj->data_Count;			/*MFTemp*/D_HLock(theDataHandle);			ExpandMemory();						/*MFTemp*/D_HLock(theObj->theDataHandle);						theSpotsNew =  (SpotInfoPtr)(*theObj->theDataHandle);			theSpotsPtr = (SpotInfoPtr)*theDataHandle;			theSpots = (SpotInfoPtr)&(theSpotsPtr[j]);			for(k = 0 ; k < theObj->data_Count;k++,theSpots++,theSpotsNew++){				 *theSpots = *theSpotsNew;			}			theSpots = (SpotInfoPtr)&(theSpotsPtr[j]);			for(k = 0; k < theObj->data_Count;k++,theSpots++)			{								x = theSpots->x;				y = theSpots->y;				z = theSpots->z;				theObj->ConvertXYtoXYZ(&x,&y,&z);				theSpots->x = x;				theSpots->y = y;				theSpots->z = z;				theSpots->theCrystal = theCrystal[0];			}			/*MFTemp*/D_HUnlock(theDataHandle);			/*MFTemp*/D_HUnlock(theObj->theDataHandle);		}		i++;		theWindow = theWindow->nextWindow;	}}