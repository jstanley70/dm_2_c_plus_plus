//s.Jim:Desktop.2.0:E_Diffract 2:EL2_Kikuchi_Line.c#include	"Diffract_INCs.h"#include	"UT_VectorMacros.c"#include 	"Kikuchi_Line.h"#include	"KosselObj.h"void KikuchiLine::Draw(Boolean erase){	inherited::Draw( erase);	DrawLine( erase);}void KikuchiLine::Move(void){	inherited::Move();}void KikuchiLine::SetScaleFactor(double value1,double value2,short value3,short value4){	short h,v;	ScreenRes(&h,&v);	cameraConstant = value1;	wavelength = 	value2;	scaleFactor = 	cameraConstant * h;	centerX		=	value3;	centerY		=	value4;	projLengthScreen = cameraLength * (double)h/ 25.4;}void KikuchiLine::SetAngle(Point thePoint){	Point center;	Draw(true);	ReturnCenter(&center);	x = (thePoint.h - center.h) / scaleFactor;	y = (thePoint.h - center.h) / scaleFactor;	Draw(false);}void KikuchiLine::ReturnCenter(Point *thePoint){	thePoint->h = (theSpotRect.left + theSpotRect.right) / 2;	thePoint->v = (theSpotRect.top + theSpotRect.bottom) / 2;}void	KikuchiLine::DrawLine(Boolean erase){	double		alpha,phi,angle,cameraLength;	double		x2,y2,z2,P,J,C,B;	double		Bx,By,Bz;	short		hRes,vRes;	double		theXForm[3][3];	double		length;	double		x1,y1,z1,factor;	short		theX,theY,theXOld,theYOld;	double		theXForm00,value,				theXForm10,				theXForm20,				theXForm01,				theXForm11,				theXForm21;	double		theta;				if(erase){		//	DMForeColor(BACKGROUND_COLOR);	} else {		/*if(g_Monitor)			theCrystal->SetColor();		else{*/			//DMForeColor(BLACK);	}	PenNormal();	PenPat(&qd.black);	cameraLength	=	 cameraConstant/wavelength;	alpha		= 0;	length = sqrt(x * x + y * y + z * z);	x2 = x/length;/*thisPole->x*/	y2 = y/length;	z2 = z/length;	phi = acos(z2);	/*phi = 2.0 * atan2(x2,y2);*/	P = phi - alpha;	if(fabs(cos(P)) < .003) return;	J = cameraLength / cos(P);	C = fabs(J * sin(alpha));	B = fabs(J * cos(alpha));		Bx = B * x;	By = B * y;	Bz = B * z;		FIND_CENTER_XFORM(x2,y2,z2,theXForm);	InvertMatrix(theXForm);				theXForm00 = theXForm[0][0];	theXForm10 = theXForm[1][0];	theXForm20 = theXForm[2][0];	theXForm01 = theXForm[0][1];	theXForm11 = theXForm[1][1];	theXForm21 = theXForm[2][1];	x2 = C;		x1			= x2 * theXForm00  + Bx;	y1			= x2 * theXForm10  + By;	z1			= x2 * theXForm20  + Bz;		length 		= sqrt(x1 * x1 + y1 * y1 + z1 * z1);	if(length <= .000001) return;	angle		= acos(z1 / length);	length		=	sqrt(x1 * x1 + y1 * y1);	x1 /= length;	y1 /= length;	if((fabs(angle) - PI/2) < .001 && fabs(2 * PI - fabs(angle) - PI/2) < .001) return;	ScreenRes(&hRes,&vRes);	factor	= projLengthScreen * tan(angle);		value = Round((double)factor * y1);	if(value > 32000) value = 32000;	else if(value < -32000) value = -32000;	theXOld	= centerX + value;/*change this from theYOld to theXOld*/		value = Round((double)factor * x1);	if(value > 32000) value = 32000;	else if(value < -32000) value = -32000;	theYOld	= centerY + value;	MoveTo(theXOld,theYOld);		P = PI/90;	theta = 0;	for(theta = 0; theta <= PI_2;theta += P){		x2 = C * cos(theta);		y2 = C * sin(theta);		x1			= x2 * theXForm00 + y2 * theXForm01 + Bx;		y1			= x2 * theXForm10 + y2 * theXForm11 + By;		z1			= x2 * theXForm20 + y2 * theXForm21 + Bz;		length 		= sqrt(x1 * x1 + y1 * y1 + z1 * z1);		if(length <= .000001) continue;		angle		= acos(z1 / length);		length		=	sqrt(x1 * x1 + y1 * y1);		x1 /= length;		y1 /= length;		if((fabs(angle) - PI/2) < .001 && fabs(2 * PI - fabs(angle) - PI/2) < .001) continue;				factor	= projLengthScreen * tan(angle);		value = Round((double)factor * y1);		if(value > 32000) value = 32000;		else if(value < -32000) value = -32000;		theX	= centerX + value;		value = Round((double)factor * x1);		if(value > 32000) value = 32000;		else if(value < -32000) value = -32000;		theY	= centerY + value;				if(fabs((double)theX) > 1000 || fabs((double)theY) > 1000 || z1 < .2){			theXOld = theX;			theYOld = theY;			MoveTo(theXOld,theYOld);			continue;		}		LineTo(theX,theY);		theXOld = theX;		theYOld = theY;	}	}/*TextRoundObj* KikuchiLine::Add(short spotLoc,SpotInfoPtr theCurrentSpot,Point thePoint){	TextRoundObj theObj;	 theObj = inherited::Add( spotLoc, theCurrentSpot, thePoint);	theObj->x = theCurrentSpot->x;	theObj->y = theCurrentSpot->y;	theObj->z = theCurrentSpot->z;}*/