//s.Jim:Desktop.2.0:E_Diffract 2:EL2_SADObj.c#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"PCVNumerical.h"#include	"RulerButton.h"#include	"AtomicScatter.h"#include	"SF_MathLib.h"#include 	"TextTableObj.h"  #include 	"mathRecipies.h"#include 	"nrutil.h"#include "UextBoxFree.h"#include "PoleBox.h"#include "SADObj.h"#include 	"JimsLib.h"#include 	"FixMath.h"Boolean	notDone;//pascal	voidPtr	SADObjThreadEntry( void *there);#define INT2FIX(i) ((long) i << 16 )	float	SADObj::RotateSpotsAroundZ(Point thePoint){	short 			i;	double 		theta = 0;	double 		x,y,X,Y;	SpotInfoPtr theSpot;	short 			maxLines = 1;	short 			value;	double			theXForm[3][3];	float				rotation;	Point			aPoint;	if(!theDataHandle)return 0;	aPoint.h = centerX;	aPoint.v = centerY;	if(!Button() && theLine) {		value = -1;		value = 	theLine->NumberOfLines(value);		if(value == maxLines) goto NEWHIT;	}	if(!MaintainLines(maxLines,true,thePoint,aPoint))return 0.0;		theta = -180 * theLine->next->AngleBetween(theLine) / PI;	sprintf				(gTheText,"%6.2f¡",theta);	theRuler	->	SetInfo(gTheText);	 	 return theta; NEWHIT:	theta = -180 * theLine->next->AngleBetween(theLine) / PI;	totalRot += theta;	if(totalRot >= 360)		totalRot -= 360;	if(totalRot <= -360)		totalRot -= 360;	y = sin(theta * PI / 180);	x = cos(theta * PI / 180);	/*MFTemp*/D_HLock(theDataHandle);	theSpot = *((SpotInfoHandle)theDataHandle);	theSpot++;	for(i = 1 ; i < data_Count ; i++){		X = theSpot->x * x - theSpot->y * y;		Y =  theSpot->x * y + theSpot->y * x;		theSpot->x = X;		theSpot->y = Y;		theSpot++;	}		/*MFTemp*/D_HUnlock(theDataHandle);	RotateStreaks(theta);	RotatateMatrixAxis(theXForm,theta * PI/180,2);	TransformAxes(theXForm);	CopyAxesIntoMatrix(theXForm);	ZoneAxisFromMatrix(false,theXForm,&calcIrrational,theZoneAxis,theRotationAxis,g_Vector,&rotationAngle,&offLaueDistance,&rotation,&beamAzimuth);	//SetPict(true);	newPictReq = true;	theLine->KillAll();	theLine = 0L;	return (theta * PI / 180);}	void		SADObj::NormalizeIntensity(short baseCrystal,double maxIntensity[4]){	short i;	SpotInfoPtr thisSpot;		if(!theDataHandle)return;	if(data_Count < 1) return;	/*MFTemp*/D_HLock			((Handle)theDataHandle);	thisSpot		= 	(SpotInfoPtr)*theDataHandle;	thisSpot->intensity = 1;	for(i = baseCrystal; i < 4;i++){		maxIntensity[i] = fabs(maxIntensity[i]);		if(maxIntensity[i] < .000001)maxIntensity[i] = .001;		maxIntensity[i] = 1/ maxIntensity[i];		if(i != baseCrystal) maxIntensity[i] *= the_PPT_Info[i - 1]->intensity;	}	thisSpot++;	for(i = 1;i <  data_Count;thisSpot++,i++){		if(startCount[thisSpot->flags] == i)continue;			thisSpot->intensity *= maxIntensity[thisSpot->flags];	}	/*MFTemp*/D_HUnlock			((Handle)theDataHandle);}void SADObj::MoveReconfigureSpot(Point thePoint){	Point 			theCenter;	static Boolean spotHit = 0;	static Point 	oldPoint;	double 		radius;	short 			theSize;			if(!Button()){		oldPoint.h = 0;		oldPoint.v = 0;		PenMode(gMode);		spotHit = false;		return;	}		if(spotHit || FindSpot(thePoint)){		spotHit = true;		StdOvalMarquee(&THE_CURRENT_SPOT.spotRect);		if(!gShifted){			if(thePoint.h != oldPoint.h || thePoint.v != oldPoint.v){								gTheRect = THE_CURRENT_SPOT.spotRect;				theCenter 		= thePoint;				THE_CURRENT_SPOT.y = (theCenter.h - centerX) / scaleFactor;				THE_CURRENT_SPOT.x = (theCenter.v - centerY) / scaleFactor;				theSize =  (THE_CURRENT_SPOT.spotRect.bottom - THE_CURRENT_SPOT.spotRect.top)/2;								theCenter.h 			= centerX + THE_CURRENT_SPOT.y *  scaleFactor;				theCenter.v 			= centerY + THE_CURRENT_SPOT.x *  scaleFactor;				SetRect				(&(THE_CURRENT_SPOT.spotRect),-theSize,-theSize,theSize,theSize);				OffsetRect		(&(THE_CURRENT_SPOT.spotRect),theCenter.h,theCenter.v);				gTheRect 	= 	THE_CURRENT_SPOT.spotRect;				StdOvalMarquee(&gTheRect);				oldPoint = thePoint;				newPictReq = true;			}			return;		}else{						if(thePoint.h != oldPoint.h || thePoint.v != oldPoint.v){				double compareIntensity , compareRadius;				short theSize;				gTheRect 		= THE_CURRENT_SPOT.spotRect;								theCenter.h = centerX + THE_CURRENT_SPOT.y *  scaleFactor;				theCenter.v = centerY + THE_CURRENT_SPOT.x *  scaleFactor;				compareIntensity 	= (double)THE_CURRENT_SPOT.intensity;				compareRadius 		= (double)(THE_CURRENT_SPOT.spotRect.right - THE_CURRENT_SPOT.spotRect.left);				radius = sqrt((double)((theCenter.h  - thePoint.h) * (theCenter.h  - thePoint.h)					+ (theCenter.v  - thePoint.v) * (theCenter.v  - thePoint.v)));				THE_CURRENT_SPOT.intensity = compareIntensity * 2 * radius /  compareRadius;				theSize =  (expoTime + 2) * pow((double)THE_CURRENT_SPOT.intensity,(1. / (double)dyRange));				SetRect		(&gTheRect,theCenter.h - theSize,theCenter.v - theSize,theCenter.h + theSize,theCenter.v + theSize);				THE_CURRENT_SPOT.spotRect = gTheRect;				oldPoint = thePoint;				StdOvalMarquee(&gTheRect);				newPictReq = true;			}		}		return;	}}void	SADObj::MyCalculate(void){	short 	k;	dcomplex sF;	SpotInfoPtr thisSpot;	data_Length			=	100;	data_Expand			=	50;	data_Count			=	0;	data_Size				=	sizeof(SpotInfo);	ResetCurvedLabels();	if(calcIntensities){//Bloch		KillHandle((Handle*)&calcIntensities);//Bloch		calcIntensities = 0;//Bloch	}	for(k = 0; k < 3;k++){		streakSize[k] = 0;		if(streaks[k] != 0L)KillHandle((Handle*)&(streaks[k]));		streaks[k] = 0L;	}	if(theDataHandle != 0L)		/*Temp*/KillHandle				(&theDataHandle);	sF.r = 0;	sF.i = 0;	theDataHandle		= 	/*Temp*/D_NewHandle(data_Length * data_Size);//,&gTheOSError	thisSpot	=	(SpotInfoPtr)*theDataHandle;	/*MFTemp*/D_HLock(theDataHandle);	thisSpot = InsertData( (double)theZoneAxis->h,  (double)theZoneAxis->k,   (double)theZoneAxis->l,  1, 0, 0, 0,0,theCrystal[baseCrystal],baseCrystal,Complex(1, 0),thisSpot);	((SpotInfoPtr)*theDataHandle)->direction = true;	CalcPoleIntensities();	//g_ThreadObj->DeleteLastThread();	CalculateKLines();//				if(!fullCalcPPt) return;		for(k = 1; k < 3;k++){		long numberOfPoints;		if(!plotFlags[k])continue;		streakSize[k - 1] = -1;		if(streaks[k - 1] != 0L)KillHandle((Handle*)&(streaks[k - 1]));		if(!pptSimple)			streakSize[k - 1] = numberOfPoints = (streakRes + 1) * (streakRes + 1) * (streakRes + 2);		else			streakSize[k - 1] = numberOfPoints = 2 * (streakRes + 2) * (theCrystal[k]->face_Count + 1);		streaks[k - 1] = (PointInfoHdn)D_NewHandle(numberOfPoints * sizeof(PointInfo));		if(streaks[k - 1] == NUL){			streakSize[k - 1] = 0;			return;		}		D_HLock((Handle)streaks[k - 1]);		if(!pptSimple)			PrecipitateStreaking(k,(PointInfoPtr)*(streaks[k - 1]),&streakSize[k - 1]);		else			SimplePrecipiStreak(k,(PointInfoPtr)*(streaks[k - 1]),&streakSize[k - 1]);		D_HUnlock((Handle)streaks[k - 1]);	}}/*pascal	voidPtr	SADObjThreadEntry( void *there){	SADObj		*t = (SADObj *)there;	t->MyCalculate();		return nil;}*/void	SADObj::CalcPoleIntensities(void){		double	thehMax,thekMax,thelMax,hmax,kmax,lmax;				double 	chx,ckx,clx,				chy,cky,cly,				chz,ckz,clz,				chxD,ckxD,clxD,				chyD,ckyD,clyD,				chzD,ckzD,clzD,				x,y,z,				x1,x2,				y1,y2,				z1,z2,				theDist,reciprocalLatticeSize,intens,intensity,				zLimit,zLow,				theD,				xLimit,yLimit,				electronMassRation,				spikingFactor,spikingFactorSqr,				RofEwaldSph,				H,K,L,delH,delK,delL;		double 	xForm[3][3],					xFormMatrix[3][3],					maxIntensity[4];		PPT_Info 		*pptOR;		short		k = 0,i;		short		orNumber,orNum;		short		plotCrystal;		Crystal 	*thisCrystal;			double 	*theUs,*theVs,*theWs,*theZs,*theBs;		Ptr*		theHandle;		SpotInfoPtr	thisSpot,spots;		dcomplex	sF;		dcomplex cAb;		double cutOff;	notDone = true;		for(i = 0; i <= 3; i++) calculateFlags[i] = false;	RofEwaldSph = 1 / wavelength;		electronMassRation = 1. + ( (double)energy / 511.);	xLimit = (double)negHeight * .5 / (double)cameraConstant;	yLimit = (double)negWidth * .5 / (double)cameraConstant;	zLimit = RofEwaldSph * (1 - cos(atan(yLimit / RofEwaldSph))) + .3;	zLimit -= RofEwaldSph;		thisCrystal = theCrystal[baseCrystal];	spots				=	(SpotInfoPtr)(*theDataHandle);	thisSpot		=	(SpotInfoPtr)&(spots[data_Count]);		if(theBeamFlag == 2 && theXRay->polarizedFlag) return;			GetOrientation(xFormMatrix);//	 InvertMatrix(xFormMatrix);		obj_Index->DoInit(false,theCrystal[baseCrystal]);			reciprocalLatticeSize = ((double)(negWidth + negHeight) * 0.25)/												(double)cameraConstant;		for(i = 0; i < 5;i++)startCount[i] = -1;																							for(plotCrystal  = baseCrystal; plotCrystal <= 3 && gNoBreak ; plotCrystal++){			short atom_Count;		double centralDistance;		SpotInfo thisPole;			if(!plotFlags[plotCrystal] || (plotCrystal > baseCrystal && baseCrystal > 0))			continue;		if(plotCrystal  == baseCrystal)			orNumber = 0;		else{			thisCrystal = theCrystal[plotCrystal];			pptOR = the_PPT_Info[plotCrystal- 1];			orNumber = pptOR->lastOR;		}		calculateFlags[plotCrystal] = true;		obj_Index->theCrystal = thisCrystal;		electronMassRation = 1. + ( (double)energy / 511.);		theHandle = thisCrystal->AtomicScatteringSet(electronMassRation,theBeamFlag);		maxIntensity[plotCrystal] = 0.0001;								hmax = SizeofReciprocalLattice(1.,0.,0.,reciprocalLatticeSize,thisCrystal);		kmax = SizeofReciprocalLattice(0.,1.,0.,reciprocalLatticeSize,thisCrystal);		lmax = SizeofReciprocalLattice(0.,0.,1.,reciprocalLatticeSize,thisCrystal);		if(!SetScatteringPosAIntensity(thisCrystal,&theUs,&theVs,&theWs,&theZs,&theBs,&atom_Count))goto FINISHOFF;//Timebomb!!//*atom_Count cannot be the same address as *crystal->Atom_Couynt  or you will continually increase the number		AtomicScatterForDFromSet(0,theHandle,theZs,atom_Count);		if(plotCrystal  == baseCrystal){			startCount[plotCrystal] = 0;			sF = ((SpotInfoPtr)(*theDataHandle))->sF	= TotalStructureFactor(0,0,0,theUs,theVs,theWs,atom_Count,theZs,theBs,thisCrystal->volume,10000,thisCrystal,&cAb);			cutOff = ((SpotInfoPtr)(*theDataHandle))->sF.r * .0005;		}else{				sF	= TotalStructureFactor(0,0,0,theUs,theVs,theWs,atom_Count,theZs,theBs,thisCrystal->volume,10000,thisCrystal,&cAb);				intens = 1;				cutOff = sF.r * .0005;				startCount[plotCrystal] = data_Count;				thisSpot = InsertData((double)theZoneAxis->h,  (double)theZoneAxis->k,   (double)theZoneAxis->l,  intens, 0, 0, 0,0,thisCrystal, plotCrystal, sF,thisSpot);				}		thisPole.x = 0;		thisPole.y = 0;		thisPole.z = 0;		thisPole.sF = sF;		thisPole.theCrystal = thisCrystal;		centralDistance   = CalcExtinctionDistance(&thisPole,RofEwaldSph);		for(orNum = 0 ; orNum <= orNumber && gNoBreak ; orNum++){						GetPPTXFormMatrixBase		(xForm,thisCrystal,orNum);			MatrixMultiply			(xForm,xFormMatrix,xForm); 			ConverttoReciprocal		(xForm,(double)thisCrystal->volume,true);						SetDeltas(&delH,&delK,&delL,hmax,kmax,lmax);					chx = xForm[0][0] ;			chy = xForm[1][0];			chz = xForm[2][0] ;			ckx = xForm[0][1];			cky = xForm[1][1] ;			ckz = xForm[2][1];			clx = xForm[0][2];			cly = xForm[1][2] ;			clz = xForm[2][2] ;								chxD = xForm[0][0] *  delH;			chyD =   xForm[1][0] * delH;			chzD =  xForm[2][0] * delH;			ckxD =  xForm[0][1] * delK;			ckyD =   xForm[1][1] * delK;			ckzD =   xForm[2][1] * delK;			clxD =   xForm[0][2] * delL;			clyD =  xForm[1][2] * delL;			clzD =  xForm[2][2] * delL;					if(calcPPtSize)						spikingFactor =  GetSpikingFactor(theFoilNormal,theFNRotationAxis,theFoilBragg,theFNRotationAngle,theFNOffLaueDistance,theFoilThickness,calcFoil,thisCrystal);			else{				spikingFactor =  GetSpikingFactor(theFoilNormal,theFNRotationAxis,theFoilBragg,theFNRotationAngle,theFNOffLaueDistance,theFoilThickness,calcFoil,theCrystal[baseCrystal]);			}			if(spikingFactor < .006 || spikingFactor == 0x7FF8000000000000)				spikingFactor =  .006;			spikingFactorSqr = spikingFactor * spikingFactor /* 100. * z1 * z1 / ((double)theFoilThickness * theFoilThickness)*/;									zLow = - spikingFactor - RofEwaldSph;		//	zLow = -spikingFactor * .3;						thehMax = -hmax;			thekMax = -kmax;			thelMax = -lmax;			x = thehMax * chx;			y = thehMax * chy;			z = thehMax * chz;			for(H = thehMax ; H <= hmax && gNoBreak ; H += delH)			{				x1 = x + thekMax * ckx;				y1 = y + thekMax * cky;				z1 = z + thekMax * ckz;				for(K = thekMax; K<= kmax && gNoBreak ; K += delK)				{					x2 = x1 + thelMax * clx ;					y2 = y1 + thelMax * cly;					z2 = z1 + (thelMax * clz)  - RofEwaldSph;//					for(L =  thelMax; L <= lmax && gNoBreak ; L += delL)					{												if(TestDimension(&theD,&theDist, H, K, L, x2, y2, z2, xLimit, yLimit, zLimit,zLow, RofEwaldSph, spikingFactor))							goto NEWSTART;						AtomicScatterForDFromSet(theD,theHandle,theZs,atom_Count);						sF	= TotalStructureFactor(H,K,L,theUs,theVs,theWs,atom_Count,theZs,theBs,thisCrystal->volume,1/theD,thisCrystal,&cAb);						intensity = (double)Cabs(sF);												if(spikingFactorSqr - theDist * theDist <= 0){							goto NEWSTART;						}else{							intens = (double)(intensity * sqrt(fabs((spikingFactorSqr - theDist * theDist)) / spikingFactorSqr));						}						if(intens < cutOff)// && objectType != CBED_OBJ)							goto NEWSTART;						//						{//more sophisticated spikingdistance														double distance,testD;							thisPole.x = x2;							thisPole.y = y2;							thisPole.z = (z2 + RofEwaldSph);							thisPole.sF = sF;							thisPole.theCrystal = thisCrystal;							distance   = CalcExtinctionDistance(&thisPole,RofEwaldSph);							testD =  spikingFactor * (1.23 - exp(-1.5 * centralDistance / distance));							if(theDist > testD)goto NEWSTART;						}						thisSpot = InsertData( H, K,  L,  intens, x2, y2,thisPole.z,0,thisCrystal, plotCrystal, sF,thisSpot);						if(intens > maxIntensity[plotCrystal])maxIntensity[plotCrystal] = intens;																NEWSTART:		x2 += clxD;						y2 += clyD;						z2 += clzD;						AllowBackground();											}										x1 += ckxD;					y1 += ckyD;					z1 += ckzD;								}				x += chxD;				y += chyD;				z += chzD;					//g_ThreadObj->YieldToThreads(0L);			}					}		startCount[plotCrystal + 1] = data_Count;					thisCrystal->ClearAtomicScatSet(theHandle);		KillPtr((Ptr)theUs);		if(dynamic_Calc){				dcomplex *sFp,*sFt;				SpotInfoPtr startSpot,aSpot;				short total,nout;				double *mInten;				aSpot = (SpotInfoPtr)*theDataHandle;				total = startCount[plotCrystal];				startSpot = &(aSpot[total]);				nout = total = (startCount[plotCrystal + 1] - startCount[plotCrystal]);				sFp = (dcomplex*)D_NewPtr(sizeof(dcomplex) * (total + 1));				SingleBlochWaveDynamic(&nout,sFp,startSpot);				if(nout == 0){KillPtr((Ptr)sFp);continue;}				sFt = sFp;				mInten = &maxIntensity[plotCrystal];				*mInten = 0;				startSpot->sF = *sFt;				sFt++;				startSpot++;				for(i = 1; i < nout;startSpot++,sFt++,i++){						startSpot->sF = *sFt;						startSpot->intensity = Cabs(startSpot->sF);						startSpot->intensity *= startSpot->intensity;						if(startSpot->intensity > *mInten)*mInten = startSpot->intensity;				}				KillPtr((Ptr)sFp);			}	}		FINISHOFF:	/*MFTemp*/D_HUnlock			((Handle)theDataHandle);		if(data_Length >  data_Count){		D_RecoverMemory		(theDataHandle,data_Size,(long)data_Count);	}	data_Length 	= 	data_Count;	numSpots			= 	data_Count;	NormalizeIntensity(baseCrystal,maxIntensity);	notDone = false;	return;}void SADObj::CalcDySinglePoint(void){		dcomplex *sFp,*sFt;		SpotInfoPtr startSpot,aSpot;		short total,nout;		double *mInten,maxIntensity[4];		short		i,k;		D_HLock(theDataHandle);		aSpot = (SpotInfoPtr)*theDataHandle;		for(k = baseCrystal;k < 4;k++){ 			if(!plotFlags[k] || (k > baseCrystal && baseCrystal > 0))				continue;			total = startCount[k];						startSpot = &(aSpot[total]);			nout = total = (startCount[k + 1] - startCount[k]);						sFp = (dcomplex*)D_NewPtr(sizeof(dcomplex) * (total + 1));			SingleBlochWaveDynamic(&nout,sFp,startSpot);			if(nout == 0){KillPtr((Ptr)sFp);return;}			sFt = sFp;			mInten = &maxIntensity[k];			*mInten = 0;			startSpot->sF = *sFt;			sFt++;			startSpot++;			for(i = 1; i < nout;startSpot++,sFt++,i++){					startSpot->sF = *sFt;					startSpot->intensity = Cabs(startSpot->sF);					startSpot->intensity *= startSpot->intensity;					if(startSpot->intensity > *mInten)*mInten = startSpot->intensity;			}			KillPtr((Ptr)sFp);		}		D_HUnlock(theDataHandle);		NormalizeIntensity(baseCrystal,maxIntensity);				newPictReq = true;}Boolean	SADObj::TestIntensity(double intensity){	double cutOff = .0001;	if(intensity < cutOff)		return true;	return false;	}void		SADObj::SetDeltas(double *delH,double *delK,double *delL,double hmax,double kmax,double lmax){	double dummy;	dummy = hmax = kmax = lmax;	*delH = *delK = *delL = 1;}Boolean SADObj::TestDimension(double *theD,double *theDist,double h,double k,double l,double x2,double y2,double z2,double xLimit,				double yLimit,double zLimit,double zLow,double RofEwaldSph,double spikingFactor){	if( h == 0 && k == 0 && l == 0)		return true;	if(z2 <  zLow || z2 > zLimit || fabs(x2) > xLimit || fabs(y2) > yLimit ) 		return true;	*theD = x2 * x2 + y2 * y2;	*theDist = fabs((RofEwaldSph - sqrt(*theD + (z2 * z2)))); 	//*theDist = z2; 	if(*theDist > spikingFactor)		return true;	*theD = sqrt(*theD);	return false;}SpotInfoPtr		SADObj::InsertData(double H,double K, double L, double intens,double x2,double y2,double z2,double angle,Crystal *thisCrystal,short plotCrystal,dcomplex sF,SpotInfoPtr thisSpot){	SpotInfoPtr spots;	if(data_Count >= data_Length){		ExpandMemory();		spots					=		(SpotInfoPtr)*theDataHandle;		thisSpot 			= 	&(spots[data_Count]);	}		thisSpot->intensity 	= 	(float)/*(short double)*/intens;	thisSpot->angle 	= 	angle;	thisSpot->x 		=  	(float)/*(short double)*/x2;	thisSpot->y 		= 	(float)/*(short double)*/y2;	thisSpot->z		=  	(float)/*(short double)*/(z2);	thisSpot->h 		= 	(short)H;	thisSpot->k 		= 	(short)K;	thisSpot->l 		= 	(short)L;	thisSpot->direction 	=	false;	thisSpot->theCrystal = 	thisCrystal;	thisSpot->flags 	= 	(long)plotCrystal;	thisSpot->sF		=	sF;	data_Count++;	thisSpot++;	return thisSpot;}	short	SortByZ(PointInfoPtr spot1,PointInfoPtr spot2);void SADObj::PrecipitateStreaking(short crystalNum,PointInfoPtr Io,long *totalPoints/*,double devParam*/){	double 	chx,chy,chz,ckx,cky,ckz,clx,cly,clz;	double 	crystal_Face;	short 	i,j,k;	long		l,pointNo;	double 	crystalvector[3][3],orForm[3][3],			xForm[3][3];	Crystal *thisCrystal;	double pie2;	PointInfoPtr startIo;	double hXmax,hYmax,hZmax,hX,hY,hZ;	double kXmax,kYmax,kZmax,kX,kY,kZ;	double lXmax,lYmax,lZmax;	short	maxI,minI;	Vector *unitFace,*edgeDir,*midPoint;	double *faceArea,*length,*faceDist,iMax = 0;	short	*edge_Count;	long	tPts;	double value;	Vector p;		thisCrystal 	= 	theCrystal[crystalNum];	thisCrystal		->	Get001XForm(xForm);	crystal_Face 	= 	thisCrystal->face_Count + 1;	unitFace 		= 	(Vector*)D_NewPtr(crystal_Face * sizeof(Vector));	edgeDir 		= 	(Vector*)D_NewPtr(crystal_Face * 12 * sizeof(Vector));	midPoint 		= 	(Vector*)D_NewPtr(crystal_Face * 12 * sizeof(Vector));	length 			= 	(double*)D_NewPtr(crystal_Face * 12 * sizeof(double));	faceDist 		= 	(double*)D_NewPtr(crystal_Face * 12 * sizeof(double));	faceArea 		= 	(double*)D_NewPtr(crystal_Face * 12 * sizeof(double));	edge_Count 		= 	(short*)D_NewPtr(crystal_Face  * 12 * sizeof(short));	ConverttoReciprocal			(xForm,(double)thisCrystal->volume,true);	thisCrystal		->	CrystalShapeParameters(xForm,unitFace,edgeDir,midPoint,faceDist,faceArea,length,edge_Count);	thisCrystal		->	Get001XForm(xForm);	pie2 = PI * 2;	if(fabs(numGVectors) < .01)numGVectors = 1;	value = fabs(numGVectors);	value /= (double)streakRes;	chx = value * xForm[0][0];	chy = value * xForm[1][0];	chz = value * xForm[2][0];	ckx = value * xForm[0][1];	cky = value * xForm[1][1];	ckz = value * xForm[2][1];	clx = value * xForm[0][2];	cly = value * xForm[1][2];	clz = value * xForm[2][2];			l = -1;	startIo = Io;	maxI = streakRes/2;	minI = -streakRes/2;	hXmax = minI * chx;	hYmax = minI * chy;	hZmax = minI * chz;	kXmax = minI * ckx;	kYmax = minI * cky;	kZmax = minI * ckz;	lXmax = minI * clx;	lYmax = minI * cly;	lZmax = minI * clz;	hX = hXmax;	hY = hYmax;	hZ = hZmax;	for(i = minI;i <= maxI;i++){		kX = hX + kXmax;		kY = hY + kYmax;		kZ = hZ + kZmax;		for(j = minI;j <= maxI;j++){			p.x = kX + lXmax;			p.y = kY + lYmax;			p.z = kZ + lZmax;						for(k = minI;k <= maxI;k++){ 				if(Quit())goto DONE_STREAK;				{					Vector theVector,*aFace;					double value,pMagSqr,pMag,faceSumSin,faceSumCos,faceSumSinI,faceSumCosI;					double dotProdpF,faceMag,edgeSum,edgeValue,edgeSumSin,edgeSumCos;					double sinTotal;					double cosTotal;					short m,n,vectorLoc;										pMag = VectorMag(p);					if(pMag < .000001){						 goto MOVEITON;					}					pMagSqr = pMag * pMag;					value = 1. / (pie2 * pMagSqr);										faceSumSin = 0;					faceSumCos = 0;					faceSumSinI = 0;					faceSumCosI = 0;									aFace = unitFace;					for( m = 0; m < crystal_Face;m++,aFace++){						dotProdpF = VectorDot(p,*aFace);						if(fabs(fabs(dotProdpF) - pMag) > .001 * pMag){ 							double divisor;							divisor = (pMagSqr - (dotProdpF * dotProdpF));							if(fabs(divisor) < .000001) continue;							faceMag = dotProdpF / divisor;							edgeSum = 0;							edgeSumSin = 0;							edgeSumCos = 0;							for(n = 0; n <= edge_Count[m];n++){								double	term2,theta;								vectorLoc 	= 		(m * 12) + n;								VectorCrossProd		(edgeDir[vectorLoc],*aFace,&theVector);								term2 		= 		VectorDot(p,theVector);								theta 		= 		VectorDot(p,edgeDir[vectorLoc]);								edgeValue 	= 		PI * theta;								if(fabs(edgeValue) < .000001)continue;								edgeSum 	= 		term2 * sin( edgeValue ) / edgeValue;								theta 		= 		pie2 * VectorDot(p,midPoint[vectorLoc]);								edgeSumSin += 		fabs(edgeSum * sin(theta));								edgeSumCos += 		fabs(edgeSum * cos(theta));								}							faceSumSin += fabs(faceMag * edgeSumSin);							faceSumCos += fabs(faceMag * edgeSumCos);						}else{							double yy;							yy = pie2 * dotProdpF * faceDist[m];							faceSumSinI += faceArea[m] * sin(yy) / dotProdpF;							faceSumCosI += faceArea[m] * cos(yy) / dotProdpF;						}											}					sinTotal = faceSumSin * faceSumSin - faceSumSinI * faceSumSinI;					cosTotal = faceSumCos * faceSumCos - faceSumCosI * faceSumCosI;					Io->intensity = sqrt(value * fabs(cosTotal - sinTotal));					Io->x = (float)p.x;					Io->y = (float)p.y;					Io->z = (float)p.z;					if(iMax < fabs(Io->intensity)) iMax = fabs(Io->intensity);					l++;					Io++;				}				MOVEITON:				p.x += clx;				p.y += cly;				p.z += clz;			}			kX += ckx;			kY += cky;			kZ += ckz;		}		hX += chx;		hY += chy;		hZ += chz;	}	DONE_STREAK:	Io = startIo;	iMax = 1/ iMax;	for(pointNo = 0; pointNo < l;pointNo++,Io++) Io->intensity *= iMax;	KillPtr((Ptr)unitFace);	KillPtr((Ptr)edgeDir);	KillPtr((Ptr)midPoint);	KillPtr((Ptr)faceArea);	KillPtr((Ptr)faceDist);	KillPtr((Ptr)length);	KillPtr((Ptr)edge_Count);	*totalPoints = l - 1;	tPts = *totalPoints;	Io = startIo;	GetOrientation					(crystalvector);	GetPPTXFormMatrixBase		(orForm,thisCrystal,0);	MatrixMultiply					(orForm,crystalvector,orForm); 			ConverttoReciprocal			(orForm,(double)thisCrystal->volume,true);	ConverttoReciprocal			(xForm,(double)thisCrystal->volume,true);	for(pointNo = 0; pointNo < tPts;pointNo++,Io++){			double x,y,z;			x = Io->x;			y = Io->y;			z = Io->z;			TransFormVector(&x,&y,&z,xForm);			TransFormVector(&x,&y,&z,orForm);			Io->x = x;			Io->y = y;			Io->z = z;	}	Io = startIo;		return;}short	SortByZ(PointInfoPtr spot1,PointInfoPtr spot2){	double z1,z2;		z1 = (double)spot1->z;	z2 = (double)spot2->z;	return((short)((z1 < z2) ? -1 : ((z1 == z2) ? 0 : 1)));// 	return((short)((z1 > z2) ? -1 : ((z1 == z2) ? 0 : 1)));}void SADObj::RotateStreaks(double theta){	double x1,y1,x,y;	PointInfoPtr theIo;	long		totalPoints;	long		pointNo;	short		i;	PointInfoPtr	baseIo;		if(!fullCalcPPt)return;	theta *= PI/180;	for(i = 0; i < 3;i++){		totalPoints = streakSize[i ];		if(totalPoints < 10) return;		D_HLock(streaks[i]);		baseIo = theIo = *(streaks[i]);					y	=	sin(theta);		x	=	cos(theta);		for(pointNo = 0; pointNo < totalPoints;pointNo++,theIo++){			x1 = theIo->x  * x - theIo->y * y;			y1 = theIo->x  * y + theIo->y * x;			theIo->x = x1;			theIo->y = y1;		}		D_HUnlock(streaks[i]);	}	}void DiffractObject::CalculateSpotLocation(long *theX,long *theY,SpotInfoPtr thisSpot){	double 		radius,length,factor;	radius = 1 / wavelength;	length = sqrt(thisSpot->y * thisSpot->y + thisSpot->x * thisSpot->x);	if(length < .0001){		*theX	= centerX;		*theY	= centerY;	}else{		factor	= (radius -   thisSpot->z) / (length * radius);		*theX	= centerX + Round((double) scaleFactor * thisSpot->y / (length * factor));		*theY	= centerY + Round((double) scaleFactor * thisSpot->x / (length * factor));								}	}void DiffractObject::CalcSpotLocAngsToPixels(double x,double y,double z,long *theX,long *theY){	double 		radius,length,factor;	radius = 1 / wavelength;	length = sqrt(y * y + x * x);	if(length < .0001){		*theX	= centerX;		*theY	= centerY;	}else{		factor	= (radius -   z) / (length * radius);		*theX	= centerX + Round((double) scaleFactor * y / (length * factor));		*theY	= centerY + Round((double) scaleFactor * x / (length * factor));								}	}void	SADObj::DoPictDraw(void){		Rect 				theOval,oldOval;	double			thePeriod;	double 		diameter;	double			grayGain,delZ,eW,eW2;	double 			intensityRange;	long 				theX,theY,count=0;	SpotInfoPtr thisSpot;	short				maxOrder[200];	short				j,k;	short 			theIdent,i,theSize,oldCrystal = 0,theValue;	double			aMaxSize;	Boolean 		flagNew = true, 							morePloting = false;	Boolean 		done = false;	Boolean			flag;	if(notDone)return;	thisSpot = (SpotInfoPtr)*theDataHandle;	if(!kikuchiLines)ResetCurvedLabels();	if(calcIntensities){		FullPlot(nOut,thisSpot);		FullPlot_MS(nOut,thisSpot);		return;	}//Bloch	SetDrawEnviron();	thePeriod = (1/theZoneAxis->Periodicity( 1,cameraLength,wavelength,&diameter)) - (double)convergenceAngle;	aMaxSize = (short)expoTime + 2;	intensityRange = 1. / (double)dyRange;	oldCrystal = 0;	j = -1;	if(g_Monitor){		grayGain = 220. ;	}else{		grayGain = 10;	}	eW = 1/wavelength;	eW2 =eW * eW;	//if(greyFlag)PenMode(addPin);	if(fullCalcPPt){		thisSpot = ((SpotInfoPtr)*theDataHandle);		thisSpot++;		theX = 39;		theY = 100;		delZ = 0;		if(multiSlice){			for(i = 0; i < numOfVoxSlice;i++)			{				short maxX;				maxX = 	PlotStreaks						(theX,theY,delZ,0,1,grayGain);				theX += (2 * maxX) + 8;				delZ += sliceDistance;			}		}		for(i = 0 ; i < numSpots; i++,thisSpot++){			if(thisSpot->angle > 0.0){				morePloting = true;				 continue;			}			theIdent 		= thisSpot->flags & CRYSTAL_MASK;						if(!plotFlags[theIdent] && theIdent <= 3 && i != 0) continue;			CalculateSpotLocation		(&theX,&theY,thisSpot);			if(theIdent != baseCrystal){				delZ = eW - sqrt(eW2 - (thisSpot->x * thisSpot->x  + thisSpot->y * thisSpot->y)) - thisSpot->z;				PlotStreaks						(theX,theY,delZ,theIdent - 1,thisSpot->intensity,grayGain);			}		}	}	thisSpot			= 				((SpotInfoPtr)*theDataHandle);	PenMode			(gMode);	PlotKLines(thisSpot);		for(i = 0 ; i < numSpots; i++,thisSpot++){				if(showPeriods)PlotPeriods(0);		if(thisSpot->z > thePeriod && j < 200 && showPeriods){			short zoneOrder;			zoneOrder = thisSpot->h * theZoneAxis->h + thisSpot->k * theZoneAxis->k + thisSpot->l * theZoneAxis->l;			flag = false;			k = 0;			while(k <= j){				if(zoneOrder == maxOrder[k])					flag = true;					k++;			}			j++;		 	maxOrder[j] = zoneOrder;		 	if(!flag)PlotPeriods(zoneOrder);		}		if(thisSpot->angle > 0.0){			morePloting = true;			 continue;		}		theIdent = thisSpot->flags & CRYSTAL_MASK;		if(!plotFlags[theIdent] && theIdent <= 3 && i != 0) continue;						CalculateSpotLocation(&theX,&theY,thisSpot);				theSize = Round(aMaxSize * pow((double)thisSpot->intensity,intensityRange));		SetRect(&oldOval,-theSize,-theSize,theSize,theSize);			theOval = oldOval;		OffsetRect(&theOval,(short)theX,(short)theY);		if(greyFlag){			theValue = Round(grayGain *  pow((double)thisSpot->intensity,intensityRange));		}				DM_DrawRect(theOval,theIdent,theValue,thisSpot->direction);		thisSpot->spotRect = theOval;								 						 	}	theSearchObj->PlotRings(scaleFactor,scaleFactor,centerX,centerY,0,500);				ClearDrawEnviron();}/*void SADObj::PlotStreaks(long thePtX,long thePtY,float devParam,short crystal,float intensity,double grayGain){	double minimum,delZ;	PointInfoPtr theIo;	long		totalPoints;	long		pointNo;	Rect		oldOval;	Rect		theOval;	double	intensityRange;	PointInfoPtr	baseIo;	short		theIdent;	double	delZ_devParam;	if(!calcPPtSize)return;		SetRect(&oldOval,-2,-2,2,2);	PenNormal();		totalPoints = streakSize[crystal];	if(totalPoints < 10) return;	D_HLock(streaks[crystal]);	baseIo = theIo = *(streaks[crystal]);	theIdent = 	crystal + 1;	theIo = baseIo;	intensityRange = 1. / (double)dyRange;	minimum =  .005;	delZ = 3 / scaleFactor;	delZ_devParam = delZ + devParam;//new//	for(pointNo = 0; pointNo < totalPoints;pointNo++,theIo++){		pointNo = 0;	while(theIo->z < delZ_devParam  && pointNo < totalPoints){			double aintens;		if(fabs(theIo->z - devParam) > delZ){pointNo++;theIo++; continue;}		 aintens = theIo->intensity * intensity;		// if(theIo->z - devParam > delZ) {pointNo++;theIo++; continue;}		if(fabs(aintens) >= minimum || greyFlag) {			short	theX2,theY2;			double	theValue;						theOval = oldOval;			theX2	=  (short)Round(scaleFactor  *  theIo->x);			theY2	=  - (short)Round(scaleFactor  *  theIo->y);			theX2 += (short)thePtX ;			theY2 += (short)thePtY;			theValue = 1;			OffsetRect(&theOval,(short)theX2,(short)theY2);			if(greyFlag){				theValue = Round(grayGain * (pow((double) theIo->intensity,intensityRange)));				if(theValue > 219)theValue = 219;				if(theValue <= 0){pointNo++;theIo++; continue;}			}				DM_DrawRect(theOval,theIdent,theValue, false);		}		pointNo++;theIo++;	}	D_HUnlock(streaks[crystal]);}*/Boolean SADObj::StageControl(void)//Override{	Boolean flag;	projLengthScreen *= 2;	flag = inherited::StageControl();	projLengthScreen /= 2;	return flag;}void SADObj::GetZoneAxisFromBox(Point thePoint){	if(thePoleBox)thePoleBox->DoContent(thePoint);	else{		thePoleBox = (PoleBox*)D_new(PoleBox);		thePoleBox->DoInit(this);	}	return;}void SADObj::CalculateKLines(void){	double	thehMax,thekMax,thelMax,hmax,kmax,lmax;			double 	chx,ckx,clx,			chy,cky,cly,			chz,ckz,clz,			chxD,ckxD,clxD,			chyD,ckyD,clyD,			chzD,ckzD,clzD,			x,y,z,			x1,x2,			y1,y2,			z1,z2,			theD,			H,K,L,delH,delK,delL;	double 	xForm[3][3],				xFormMatrix[3][3],				maxIntensity;	short				k = 0,i;	Crystal 		*thisCrystal;	long				dataFlag;	double 	*theUs,*theVs,*theWs,*theZs,*theBs;	Ptr		*theHandle;	Boolean		errFlag;	double		SFValue;	Boolean		hexFlag;	SpotInfoPtr theSpots;	SpotInfoPtr	thisSpot;	short				num;	double			PI_Over2,electronMassRation;	double			cutOff = .02,value;	dcomplex sF,cAb;	numSpots	= 	data_Count;		if(!kikuchiLines) return;	ExpandMemory();							if(MemError() != 0 || FreeMem() < 32000L) return;							errFlag = true;	STARTOVER:		electronMassRation = 1. + ( (double)energy / 511.);		SFValue = 1.0;	thisCrystal = theCrystal[baseCrystal];	if(thisCrystal->lattice_Type == HEXAGONAL || thisCrystal->lattice_Type == TRIGONAL){		hexFlag = true;	} else {		hexFlag = false;	}	dataFlag = baseCrystal;		dataFlag |= K_MAP_MASK | SMALL_CIRCLE;	theHandle = thisCrystal->AtomicScatteringSet(electronMassRation,theBeamFlag);	if(!SetScatteringPosAIntensity(thisCrystal,&theUs,&theVs,&theWs,&theZs,&theBs,&num))return;//Timebomb!!//*atom_Count cannot be the same address as *crystal->Atom_Couynt  or you will continually increase the number	AtomicScatterForDFromSet(0,theHandle,theZs,num);	sF	= TotalStructureFactor(0,0,0,theUs,theVs,theWs,num,theZs,theBs,thisCrystal->volume,10000,thisCrystal,&cAb);	cutOff *= sF.r;	/*MFTemp*/D_HLock((Handle)theDataHandle);	theSpots 	= 	(SpotInfoPtr)*theDataHandle;		thisSpot	=		&(theSpots[data_Count]);			GetOrientation(xFormMatrix);//	InvertMatrix(xFormMatrix);	GetPPTXFormMatrixBase		(xForm,thisCrystal,0);	MatrixMultiply					(xForm,xFormMatrix,xForm); 	ConverttoReciprocal			(xForm,(double)thisCrystal->volume,false);	hmax = kmax = lmax = kLimit;	SetDeltas(&delH,&delK,&delL,hmax,kmax,lmax);	chx = xForm[0][0] ;	chy = xForm[1][0];	chz = xForm[2][0] ;	ckx = xForm[0][1];	cky = xForm[1][1] ;	ckz = xForm[2][1];	clx = xForm[0][2];	cly = xForm[1][2] ;	clz = xForm[2][2] ;				chxD = xForm[0][0] *  delH;	chyD =   xForm[1][0] * delH;	chzD =  xForm[2][0] * delH;	ckxD =  xForm[0][1] * delK;	ckyD =   xForm[1][1] * delK;	ckzD =   xForm[2][1] * delK;	clxD =   xForm[0][2] * delL;	clyD =  xForm[1][2] * delL;	clzD =  xForm[2][2] * delL;			thehMax = -hmax;	thekMax = -kmax;	thelMax = -lmax;	x = thehMax * chx;	y = thehMax * chy;	z = thehMax * chz;		for(H = thehMax ; H <= hmax && gNoBreak ; H += delH)	{		x1 = x + thekMax * ckx;		y1 = y + thekMax * cky;		z1 = z + thekMax * ckz;		for(K = thekMax; K<= kmax && gNoBreak ; K += delK)		{			x2 = x1 + thelMax * clx;			y2 = y1 + thelMax * cly;			z2 = z1 + thelMax * clz;			for(L =  thelMax; L <= lmax && gNoBreak ; L += delL)			{								AllowBackground();				if( fabs(H) < 0.0001 && fabs(K) < 0.0001 && fabs(L) < .0001)						goto NEWSTART;				if(!(hexFlag && (abs(H + K) > kLimit))){																		SFValue = 0;					theD = VectorLengthXYZ(x2,y2,z2);					AtomicScatterForDFromSet(theD,theHandle,theZs,num);					sF	= TotalStructureFactor(H,K,L,theUs,theVs,theWs,num,theZs,theBs,thisCrystal->volume,theD,thisCrystal,&cAb);					SFValue = (double)Cabs(sF);										if(SFValue < cutOff) goto NEWSTART;														thisSpot->theCrystal	= thisCrystal;					thisSpot->h 			= H;					thisSpot->k 			= K;					thisSpot->l 			= L;					thisSpot->direction		= false;					thisSpot->x 			= x2;					thisSpot->y 			= y2;					thisSpot->z 			= z2;					thisSpot->flags 		= dataFlag;					thisSpot->intensity		= SFValue;					thisSpot->sF			= sF;					thisSpot->angle			= 0.0;					data_Count++;					thisSpot++;					if(data_Count >= data_Length){							ExpandMemory();														if(MemError() != 0 || FreeMem() < 32000L)							{								kLimit -= 1;								H = K = L = i = 32000;								if(errFlag){									StopAlert(OUT_OF_MEM,NUL);									{										KeyMap		keyArray;										GetKeys(keyArray);										if(keyArray[1] == 5){											SysBreak();										}									}									errFlag = false;								}								{									KillPtr((Ptr)theUs);									theUs = 0L;								}								goto	STARTOVER;															}							theSpots = (SpotInfoPtr)*theDataHandle;							thisSpot = &(theSpots[data_Count]);					}										}NEWSTART:		x2 += clxD;				y2 += clyD;				z2 += clzD;				AllowBackground();			}			x1 += ckxD;			y1 += ckyD;			z1 += ckzD;		}		x += chxD;		y += chyD;		z += chzD;		//g_ThreadObj->YieldToThreads(0L);	}	thisCrystal->ClearAtomicScatSet(theHandle);	KillPtr((Ptr)theUs);			PI_Over2 = PI / 2.0;	theSpots	=	((SpotInfoPtr)*theDataHandle);	thisSpot = &(theSpots[numSpots]);	maxIntensity = -10;	value = wavelength / 2;	for(i = numSpots ; i < data_Count ; i++,thisSpot++){				double	dummy;			theD = 	sqrt((thisSpot->x * thisSpot->x) + (thisSpot->z * thisSpot->z) + (thisSpot->y * thisSpot->y));		if(1/theD <  .000001){			thisSpot->angle = 0;			 continue;		}		dummy = value * theD;		if(fabs(dummy) > 1){			dummy = 1;		}		thisSpot->angle = asin(dummy);		if(thisSpot->intensity > maxIntensity)maxIntensity = thisSpot->intensity;	}	theSpots	=	((SpotInfoPtr)*theDataHandle);	thisSpot = &(theSpots[numSpots]);	for(i = numSpots ; i < data_Count ; i++,thisSpot++)thisSpot->intensity /= maxIntensity;				/*MFTemp*/D_HUnlock(theDataHandle);	if(data_Length >  data_Count){		D_RecoverMemory		(theDataHandle,data_Size,(long)data_Count);	}	data_Length 	= 	data_Count;	return;}void DiffractObject::PlotKLines(SpotInfoPtr thisSpot){	thisSpot = thisSpot;}void SADObj::PlotKLines(SpotInfoPtr thisSpot){	long i;	double	intensityRange;	intensityRange = 1. / (double)dyRange;	thisSpot = &thisSpot[numSpots];	if(kikuchiLines){		for(i = numSpots ; i < data_Count; i++,thisSpot++){			DrawSmallCircle(thisSpot,false,32000.,32000.);		}	}}void	SADObj::DrawSmallCircle(SpotInfo *thisPole,Boolean erase,double xMax,double yMax){	double		alpha,P;	double		x,y,z;	short		hRes,vRes;	double		theXForm[3][3];	double		length,zz;	double		factor,L;	short		theX,theY,theXOld,theYOld;	double	theXForm00,value,					theXForm10,					theXForm20,					theXForm01,					theXForm11,					theXForm21,					theXForm02,					theXForm12,					theXForm22;	double		theta,distance,inelasticCal;	double  dummy;	double x1,y1,z1,xp,yp,zp;	dummy = xMax = yMax;	alpha		= thisPole->angle;	if(fabs(alpha) < .000001)return;//the pole has no angle the cone radius is therefore infinite	distance   = CalcExtinctionDistance(thisPole,1/wavelength);	SetScaleFactor();	//this sets camera length and camera length in pixels.	inelasticCal = kLineMult * (1.23 -  exp(-1.5 * trueThickness / distance));	inelasticCal *= pow((double)(thisPole->intensity),1/dyRange);	if(inelasticCal < .1)return;	if(erase){		DMForeColor(BACKGROUND_COLOR);	} else {		RGBColor	aColor;		if(g_Monitor)			if(greyFlag){				long theValue;				theValue = 210 * inelasticCal;				DMForeColor(theValue + 15);			}else{				thisPole->theCrystal->SetColor();				GetForeColor(&aColor);				InvertColor	(&aColor);				RGBForeColor(&aColor);			}		else{			DMForeColor(BLACK);		}				}	PenNormal();	PenPat(&qd.black);	SetRect			(&thisPole->spotRect,-2,-2,2,2);	//	newClip 	= 	D_NewRgn();//	RectRgn			(newClip,&thePictRect);//	D_SetClip			(newClip);//	DisposeRgn		(newClip);				length = sqrt(thisPole->x * thisPole->x + thisPole->y * thisPole->y + thisPole->z * thisPole->z);	x = thisPole->x/length;	y = thisPole->y/length;	z = thisPole->z/length;		FIND_CENTER_XFORM(x,y,z,theXForm);	InvertMatrix(theXForm);//this is the rotation for all new points		ScreenRes(&hRes,&vRes);	theXForm00 = theXForm[0][0];	theXForm10 = theXForm[1][0];	theXForm20 = theXForm[2][0];	theXForm01 = theXForm[0][1];	theXForm11 = theXForm[1][1];	theXForm21 = theXForm[2][1];	theXForm02 = theXForm[0][2];	theXForm12 = theXForm[1][2];	theXForm22 = theXForm[2][2];	L = cos(alpha);	zz = z = sin(alpha);	theta = 0;	x = L;	y = 0;	TransFormVector(&x,&y,&z,theXForm);	NormalizeVector(&x,&y,&z);	//angle = acos(z);	length		= sqrt(x * x + y * y);	factor = projLengthScreen * length / z;		value = Round((double)factor * y/length);	if(value > 32000) value = 31000;	else if(value < -32000) value = -31000;	theXOld	= centerX + value;			value = Round((double)factor * x/length);	if(value > 31000) value = 32000;	else if(value < -31000) value = -32000;	theYOld	= centerY + value;	MoveTo(theXOld,theYOld);	x1 = zz * theXForm02;	y1 = zz * theXForm12;	z1 = zz * theXForm22;	P = PI/90;	for(theta =  0; theta <= PI_2;theta += P){		x = L * cos(theta);		y = L * sin(theta);		//z = zz;		xp = x * theXForm00 + y * theXForm01 + x1;		yp = x * theXForm10 + y * theXForm11 + y1;		zp = x * theXForm20 + y * theXForm21 + z1;		//TransFormVector(&x,&y,&z,theXForm);		//NormalizeVector(&x,&y,&z);				length		= sqrt(xp * xp + yp * yp);		factor	= projLengthScreen * length / zp;		value = Round((double)factor * yp/length);				if(value > 32000) value = 32000;		else if(value < -32000) value = -32000;		theX	= centerX + value;								value = Round((double)factor * xp/length);		if(value > 32000) value = 32000;		else if(value < -32000) value = -32000;		theY	= centerY + value;		if(zp < 0){			theXOld = theX;			theYOld = theY;			continue;		}		if(fabs((double)theX) > 3000 || fabs((double)theY) > 3000){			theXOld = theX;			theYOld = theY;			MoveTo(theXOld,theYOld);			continue;		}		LineTo(theX,theY);		theXOld = theX;		theYOld = theY;	}	}void	SADObj::SetTableObject(TextTableObj* aTextTable){	theTable = aTextTable;}void	SADObj::CorrectImageDistortions(void){	PointObj	*centerPt;	short		flag = 0;	if(!picObjList || !picObjList->GetSelected()){		Message(NO_PICT_SELECTED);		return;	}		if(!theImagePixels){		CreateExpPointObj();		flag = 1;	}	centerPt	=	0L;	centerPt	=	(PointObj*)theImagePixels->GetPointOfType(ORIGIN);	if(centerPt == 0L){		Point	thePoint;		RGBColor *theColor = 0L;		centerPt 				= 	(PointObj*)D_new(PointObj);		thePoint.h	=	centerX;		thePoint.v	=	centerY;		centerPt->InitText(thePoint,this,ORIGIN,false,theCrystal[0]);		centerPt->SetColor(1,theColor);		flag = 2;	}	picObjList->ImageAntiDistortion(xDis,yDis, centerPt->objPoint);	if(flag == 1){		theImagePixels->KillAll();		theImagePixels = 0L;	}	if(flag == 2){		centerPt->KillAll();		centerPt = 0L;	}}void SADObj::DefineAspectRatioSquare(Point thePoint){	Boolean textOn = true;	//if(!theImagePixels) return;	if(!theImagePixels)CreateExpPointObj();	theImagePixels->DeactivateAll();	theImagePixels->DoContent(thePoint,&textOn,ASPECT_RATIO);}void SADObj::SetCenter(Point thePoint){	PointObj	*theObj;	if(!theImagePixels)CreateExpPointObj();	theImagePixels->DeactivateAll();	thePoint = theImagePixels->objPoint;	thePoint.h -= centerX;	thePoint.v -= centerY;	thePoint.h *= -1;	thePoint.v *= -1;	theObj = (PointObj*)theImagePixels->GetPointOfType(ORIGIN);	theObj->RelocateText(thePoint);}void SADObj::SetManualSpots(Point thePoint){	Boolean 	textOn = true;	if(!theImagePixels)CreateExpPointObj();	theImagePixels->DeactivateAll();	theImagePixels->DoContent(thePoint,&textOn,REG_POINT);}void SADObj::AutomatedRadialIntensity(void){	PointObj	*centerPt;	Handle		theValue;	short		noChannels;	if(!theImagePixels) CreateExpPointObj();	centerPt	=	0L;	centerPt	=	(PointObj*)theImagePixels->GetPointOfType(ORIGIN);	theValue 	= 	picObjList->RadialIntensity(centerPt->objPoint,&noChannels);	if(graph == (GraphFunction*)NUL)ShowGraph();	if(graph != (GraphFunction*)NUL){		graph->SetValues(0L,theValue);		graph->AddGraph(graph,graph->GetDerivative(),graph->frame);		graph->PlotGraph();	}	KillHandle((Handle*)&theValue);	return;	}void SADObj::CenterPoints(){	if(!theImagePixels)return;	theImagePixels->CenterPeaks();}void SADObj::SetPointTable(void){	PointObj 		*centerPt;	SpotInfoPtr 	theSpot;	short			i,num,k,j;	if(!theImagePixels)return;	centerPt 		= 	(PointObj*)theImagePixels->GetPointOfType(ORIGIN);	SetScaleFactor		();	theImagePixels	->	CalcXYValues((double)1/scaleFactor,centerPt);/*set x,y to */	theTable 		= 	(TextTableObj*)AllocTextTableObj();	this			->	CopyObjTo			(theTable,true);	theTable		->	ConvertPointsToSpots(theImagePixels);	theSpot 		= 	(SpotInfoPtr)(*theTable->theDataHandle);	num				=	theTable->data_Count;	for(k = 0; k < num;k++,theSpot++){		i = 0;		while(dspacings[i] >= theSpot->intensity && i < MAXEXPDSPACE){			if(dspacings[i] > 0 && fabs(dspacings[i] - theSpot->intensity) / dspacings[i] < .05) goto NEXT_IT;			 i++;		}		if(dspacings[i] > 0 && fabs(dspacings[i] - theSpot->intensity) / dspacings[i] < .05) goto NEXT_IT;		if(i == MAXEXPDSPACE - 1)			dspacings[i] = theSpot->intensity;		else{			for(j = MAXEXPDSPACE - 1;j >= i; j--)dspacings[j ] = dspacings[j - 1] ;			dspacings[i] = theSpot->intensity;		}		NEXT_IT:;	}	qsort(dspacings,MAXEXPDSPACE,sizeof(float),(_compare_function/*__cmp_func_Cmpfun**/)FloatCompare);	if(theTable)theTable->ShowGraph();	if(theTable)theTable->SetPict(true);	if(theTable)theTable->D_DrawPict();//change	if(theTable)theTable->DoRefresh();	return;}void SADObj::ShowGraph(void){	Rect graphBox;	SetRect(&graphBox,80,80,320,240);	if(graph)graph->DoClose(graph);	graph	= (GraphFunction*)D_new(GraphFunction);	if(!graph)return;	graph->DoInit(graphBox,gCurrentObj->theCrystal[0]->crystalColor,true,true);		sprintf(gTheText,"In Pixels");	graph->SetTitleX(gTheText);	sprintf(gTheText,"g-vector");	graph->SetTitleY(gTheText);	sprintf(gTheText,"Image Analysis");	graph->SetTitleGraph(gTheText);	c2pstr(gTheText);	graph->titleMenu->P_AppendMenu	(gTheText);	graph->titleMenu->P_CheckItem		(2,true);	graph->SetValues(0L,(Handle)0L);}void SADObj::SetImageAspectRatio(void){	float 		**a;	short		n,startValue;	short 		noParameters,max;	PointObj	*centerPt;	short		totalPoints = 0;	double		x,y;	if(!theImagePixels)return;	n = 0;	noParameters = 3;	a = matrix(1,3,1,3);		startValue 	= 0;	noParameters = 3;	max 		= 	noParameters + startValue;		centerPt	=	0L;	centerPt 	= theImagePixels->CountObjects(&totalPoints,centerPt,ASPECT_RATIO);	centerPt 	= (PointObj*)theImagePixels->GetPointOfType(ORIGIN);	/*theImagePixels->SetOrigin(centerPt->x,centerPt->y,centerPt->hor,centerPt->ver);*/	theImagePixels->GetAllValues(centerPt);	if(max <= totalPoints){		n = 0;		n = theImagePixels->SetMatrixValues(startValue,max,n,a,xDis,true,ASPECT_RATIO,centerPt);		gaussj(a,noParameters,xDis,1);		n = 0;				n = theImagePixels->SetMatrixValues(startValue,max,n,a,yDis,false,ASPECT_RATIO,centerPt);		gaussj(a,noParameters,yDis,1);		startValue++;		max = noParameters + startValue;	}	free_matrix(a, 1, 3, 1, 3);	x = sqrt(xDis[1][1] * xDis[1][1] +  xDis[2][1] * xDis[2][1]);	y = sqrt(yDis[1][1] * yDis[1][1] +  yDis[2][1] * yDis[2][1]);	if(y > x)x = y;	xDis[1][1] /= x;	xDis[2][1] /= x;		yDis[1][1] /= x;	yDis[2][1] /= x;}void SADObj::DetermineCameraConstantsFromStandard(void){	float 		**a;	short		n,startValue;	short 		noParameters,max;	short		totalPoints = 0;	PointObj*	centerPt = 0L;		if(theImagePixels == 0L)return;	SetScaleFactor();	centerPt 		= theImagePixels->CountObjects(&totalPoints,centerPt,ASPECT_RATIO);	if(totalPoints < 2) return;	centerPt 		= (PointObj*)theImagePixels->GetPointOfType(ORIGIN);	theImagePixels->GetAllValues(centerPt);	n = 0;	noParameters = 3;	a = matrix(1,4,1,4);			startValue 		= 0;	if(totalPoints >= 3) 		noParameters = 3;	else		noParameters 	= 2;			max 					= 	noParameters;		theImagePixels	->	SetXYToRecipA();	theImagePixels	->	SetXToHKLConvertToXY(0L,data_Count,ASPECT_RATIO);	if(max <= totalPoints){		n = 0;		n = theImagePixels->SetMatrixValues(startValue,max,n,a,yDis,true,ASPECT_RATIO,centerPt);		gaussj(a,noParameters,yDis,1);			n = 0;		n = theImagePixels->SetMatrixValues(startValue,max,n,a,xDis,false,ASPECT_RATIO,centerPt);		gaussj(a,noParameters,xDis,1);				startValue++;		max = noParameters + startValue;	}	free_matrix(a, 1, 4, 1, 4);	if(totalPoints < 3){xDis[3][1] = 0;yDis[3][1] = 0;}	return;}void  SADObj::ConvertToTextTable(void)//Override{	inherited::ConvertToTextTable();}void  SADObj::SetExpLattice(void){	short 				maxLines = 1;	Vector				g1,g2,value,value2;	Point					start;	short 				n1,n2,i,k,p1,p2,m,j;	Point					loc;	RgnHandle			theRgn;	Handle				theHandle;	theHandle	= (Handle)this;	if(!theLine)return;	if(!theLine->next) return;	if(!theImagePixels)CreateExpPointObj();	g1 = theLine->GetVector();	g2 = theLine->next->GetVector();	n1 = theLine->segments;	n2 = theLine->next->segments;	p1	=	n1 / 2;	p2	=	n2 / 2;	loc.h = theLine->hor1;	loc.v = theLine->ver1;		start = theLine->CrossOver(0L);	for(i = -1; i <= 1;i += 2){			loc = start;		value.x = loc.h;		value.y = loc.v;		for(m = 0; m <= p1;m++){			for(k = -1; k <= 1;k += 2){				value2.x = value.x;				value2.y = value.y;				for(j = 0; j <= p2;j++){					loc.h  	= value2.x;					loc.v		=	value2.y;					theImagePixels->Add(loc,&theHandle,REG_POINT);					//theImagePixels->DeactivateAll();					value2.x += k * g2.x;					value2.y += k * g2.y;				}			}			value.x += i * g1.x;			value.y += i * g1.y;		}	}	//theRuler->SetInfo(gTheText);	theRgn = D_NewRgn();	RectRgn(theRgn,&thePictRect);	D_SetClip(theRgn);	theImagePixels->DeactivateAll();	D_DisposeRgn(&theRgn);	newPictReq = true;}void SADObj::SetLatticeDblClick(Point thePoint){	thePoint = theLine->CrossOver(0L);	if(!theImagePixels)return;	theImagePixels->MovePointTo(thePoint);}Boolean SADObj::MaintainLines(short maxLines,Boolean pinned,Point thePoint,Point lastPoint){	static Rect		theRect;	short					hitLine,value;	if(!theLine && Button()){		long options = 0L;		short theSize;		theLine = (LineObj*)D_new(LineObj);		options  |= 0L;		theLine->DoInit(true,theCrystal[referenceCrystal],pinned,options,thePoint,lastPoint);		theSize = (double)scaleFactor * (double)theEBeam->convergenceAngle;		SetRect			(&theRect,thePoint.h - theSize,thePoint.v - theSize,thePoint.h + theSize,thePoint.v + theSize);		PenNormal();		PenMode						(patXor);		theLine->DrawAllLines(false);		return false;	}	if(!Button() && theLine){		theLine->DeSelectAll();		PenNormal();		PenMode						(patXor);				theLine->DrawAllLines(true);		if(functionID != SETUP_LATTICE_F)dm_FrameOval		(&theRect);	}	if(!theLine || !Button())return false;		hitLine = -1;//	FastPictDraw();	theLine->TakeCareOfLines(thePoint,lastPoint,maxLines,&hitLine);	PenMode						(patXor);	theLine->DrawAllLines(false);	if(Button()){		short theSize;		if(IsPressed( (unsigned short )56)/*shiftkey*/)theLine->SetSegments();		theSize = (double)scaleFactor * (double)theEBeam->convergenceAngle;		SetRect			(&theRect,thePoint.h - theSize,thePoint.v - theSize,thePoint.h + theSize,thePoint.v + theSize);		//FrameOval		(&theRect);		//StdOvalMarquee(&theRect);	}	value = -1;	value = 	theLine->NumberOfLines(value);	if(value < maxLines) {		return false;	}else{		value = 	theLine->NumberOfLines(value);		return true;	}}void SADObj::SetMagLine(Point thePoint){	double 			dspace;	double 			theValue;	Crystal 			*aCrystal;	char 					theText[255];	short 				maxLines = 0;	static short hitLine;	short					hRes,vRes;		//newPictEnable = true;		if(!MaintainLines(maxLines,false,thePoint,thePoint))return;	dspace 		=  (double)scaleFactor * theLine->segments/ theLine->GetLength();	sprintf				(gTheText,"%8.2f ",(double)dspace);	aCrystal 	= 	this->theCrystal[referenceCrystal];	obj_Index	->	DoInit(false,aCrystal);	theText[0] = 0;	ScreenRes			(&hRes,&vRes);	theValue 	= theLine->GetLength() * 25.4/(hRes * magnification);	sprintf(gTheText,"%8.2f  S.L. Length = %d mm",dspace,(short)theValue);	theRuler->SetInfo(gTheText);	D_SetClip(drawRgn);}void SADObj::SetupExpLattice(Point thePoint){	double 			dspace,dspace2;	double 			theValue,theValue2;	short 				maxLines = 1;	short					hRes,vRes;	Point					aPoint;	 PointObj			*centerPt = 0L;//	RgnHandle			theNewClip;	Handle				theHandle;	theHandle	= (Handle)this;	aPoint = thePoint;//	newPictEnable = true;		if(Button()){		if(!theImagePixels)CreateExpPointObj();		centerPt = (PointObj*)theImagePixels->GetPointOfType(REG_POINT);		if(!centerPt){			theImagePixels->Add(thePoint,&theHandle,REG_POINT);			centerPt = (PointObj*)theImagePixels->GetPointOfType(REG_POINT);		}		centerPt->MovePointTo(thePoint);	}	if(theImagePixels){		centerPt = (PointObj*)theImagePixels->GetPointOfType(ORIGIN);		if(centerPt){			centerPt->active = false;		}	}	if(!MaintainLines(maxLines,false,thePoint,thePoint))return;		if(aPoint.h == 0 && aPoint.v == 0)return;//	GetClip			(gTheRgn);//	theNewClip = D_NewRgn();//	RectRgn			(theNewClip,&theVisRect);//	D_SetClip			(theNewClip);	aPoint = theLine->CrossOver(0L);	centerPt = (PointObj*)theImagePixels->GetPointOfType(ORIGIN);	if(!centerPt){		theImagePixels->Add(aPoint,&theHandle,ORIGIN);		centerPt = (PointObj*)theImagePixels->GetPointOfType(ORIGIN);	}	centerPt->active = false;		centerPt->MovePointTo(aPoint);	centerX	=	aPoint.h;	centerY = aPoint.v;	dspace 		=  (double)scaleFactor * theLine->segments  / theLine->GetLength();	dspace2 		=  (double)scaleFactor * theLine->next->segments / theLine->next->GetLength();	ScreenRes			(&hRes,&vRes);	theValue 	= theLine->GetLength() * 25.4/(hRes * magnification);	theValue2 	= theLine->next->GetLength() * 25.4/(hRes * magnification);	sprintf(gTheText,"%8.2f  S.L. Length = %d mm, second line %8.2f  S.L. Length = %d mm",dspace,(short)theValue,dspace2,(short)theValue2);	theRuler->SetInfo(gTheText);//	D_SetClip(gTheRgn);//	D_DisposeRgn(&theNewClip);}void SADObj::CreateExpPointObj(void){		Point	thePoint;		Handle	theHandle;		RGBColor *theColor = 0L;		theImagePixels 				= 	(PointObj*)D_new(PointObj);		theHandle	= (Handle)this;		thePoint.h	=	centerX;		thePoint.v	=	centerY;		theImagePixels->InitText(thePoint,this,ORIGIN,false,theCrystal[0]);		theImagePixels->SetColor(1,theColor);}void SADObj::DoARotation(double angle,short axis){	double matrix[3][3],theXForm[3][3];	RotatateMatrixAxis(theXForm,angle,axis);		TransformAxes(theXForm);	CopyAxesIntoMatrix(theXForm);	SetMatrixAEqB(matrix,theXForm);	ZoneAxisFromMatrix(false,matrix,&calcIrrational,theZoneAxis,theRotationAxis,g_Vector,&rotationAngle,&offLaueDistance,&totalRot,&beamAzimuth);	SetOrientation(theXForm);	totalTilts[axis] += angle;	DoCalculate();}void	SADObj::CalculateScreenThetas(double *x,double *y,double *z,Point thePoint){	double temp,length,x1,y1;	SetScaleFactor();		onScreen = true;	LocalToObj(&thePoint);	y1 = thePoint.h - centerX;	x1 = thePoint.v - centerY;	length = sqrt(x1 * x1 + y1 * y1);	if(length < .01){			*x = 0;			*y = 0;			*z = 1;			return;	}	temp = atan(length/projLengthScreen);	*z = cos(temp);	temp = sin(temp) / length;	x1 *= temp;	y1 *= temp;	*x = x1;	*y = y1;	}void	SADObj::SetAspectRatioDBox(void){	short 			i,item;	pascal Boolean 	TheFilter();	DialogPtr 		theDialog;	theDialog 		= 		DM_GetNewDialog(365, 0L,(WindowPtr)-1L);		for(i = 3; i < 6;i++)	SetItemValue(theDialog,i,xDis[i - 2][1],4);	for(i = 6; i < 9;i++)	SetItemValue(theDialog,i,yDis[i - 5][1],4);		while(1 != 2){		SystemTask();		ModalDialog(TheFilterUPP,&item);		switch(item){			case DLOG_ENTER_OR_CR:			case 	1:			for(i = 3; i < 6;i++)				xDis[i - 2][1] = GetItemValue(theDialog,i);			for(i = 6; i < 9;i++)				yDis[i - 5][1] = GetItemValue(theDialog,i);			case 2:			case CANCELCLICK: 				DM_DisposDialog(&theDialog);				return ;			default:				break;			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			}	}}Boolean	SADObj::FindTrace(Point thePoint,short n){	short 			i;	SpotInfo		*theSpot;	double			minError = 100.9;	LineObj			*line;	//Index				*aIndex;	unsigned long				time=0;	//double			alpha;	if(!kikuchiLines)return false;	SetScaleFactor();	//radius = scaleFactor / wavelength;	line = (LineObj*)D_new(LineObj);	line->DoInit(false,theCrystal[0],false,0L,thePoint,thePoint);		n = numSpots;	GetMouse(&thePoint);	//	aIndex = (Index*)D_new(Index);	/*MFTemp*/D_HLock			(theDataHandle);	theSpot 	= 	(SpotInfoPtr)*theDataHandle;	obj_Index->DoInit(false,theSpot->theCrystal);	LocalToObj(&thePoint);		for(i = numSpots , theSpot = &(((SpotInfoPtr)*theDataHandle)[numSpots])  ; i < data_Count ; i++,theSpot++){		if(	FindIndividualTrace( theSpot,line, thePoint)) goto END;		/*double	P;		double	x,y,z;		double	theXForm[3][3];		double	length,zz;		double	factor,L;		short		theX,theY;		double	theXForm00,value,						theXForm10,						theXForm20,						theXForm01,						theXForm11,						theXForm21,						theXForm02,						theXForm12,						theXForm22;		double	theta;		double	x1,y1,z1,xp,yp,zp,inelasticCal,distance;		Point		aPoint;		if(theSpot->direction)continue;		distance   = 1/ (theSpot->sF.r * wavelength);// /CalcExtinctionDistance(thisPole,1/wavelength);		SetScaleFactor();	//this sets camera length and camera length in pixels.		//inelasticCal = exp(-PI * distance/trueThickness);		//inelasticCal *= pow((double)(theSpot->intensity),1/dyRange);		inelasticCal = kLineMult * (1.23 -  exp(-1.5 * trueThickness / distance));		inelasticCal *= pow((double)(theSpot->intensity),1/dyRange);		if(inelasticCal < .1)continue;		alpha		= theSpot->angle;		length = sqrt(theSpot->x * theSpot->x + theSpot->y * theSpot->y + theSpot->z * theSpot->z);		x = theSpot->x/length;		y = theSpot->y/length;		z = theSpot->z/length;					FIND_CENTER_XFORM(x,y,z,theXForm);		InvertMatrix(theXForm);		theXForm00 = theXForm[0][0];		theXForm10 = theXForm[1][0];		theXForm20 = theXForm[2][0];		theXForm01 = theXForm[0][1];		theXForm11 = theXForm[1][1];		theXForm21 = theXForm[2][1];		theXForm02 = theXForm[0][2];		theXForm12 = theXForm[1][2];		theXForm22 = theXForm[2][2];			L = sin(alpha);		zz = z = cos(alpha);		theta = 0;		x = L;		y = 0;		TransFormVector(&x,&y,&z,theXForm);		NormalizeVector(&x,&y,&z);		length		= sqrt(x * x + y * y);		factor = projLengthScreen * length / z;				value = Round((double)factor * y / length);		if(value > 32000) value = 31000;		else if(value < -32000) value = -31000;				line->hor1	= centerX + value;					value = Round((double)factor * x / length);		if(value > 31000) value = 32000;		else if(value < -31000) value = -32000;				line->ver1	= centerY + value;				x1 = zz * theXForm02;		y1 = zz * theXForm12;		z1 = zz * theXForm22;						P = PI/90;		for(theta =  0; theta <= PI_2;theta += P){			x = L * cos(theta);			y = L * sin(theta);			xp = x * theXForm00 + y * theXForm01 + x1;			yp = x * theXForm10 + y * theXForm11 + y1;			zp = x * theXForm20 + y * theXForm21 + z1;						length		= sqrt(xp * xp + yp * yp);			factor	= projLengthScreen * length / zp;			value = Round((double)factor * yp/length);						if(fabs(value) > 4000){				line->hor2 = line->hor1 = 4000 * value/(fabs(value));				continue;			}			theX	= centerX + value;									value = Round((double)factor * xp/length);			if(fabs(value) > 4000){				line->ver2 = line->ver1 = 4000 * value/(fabs(value));				 continue;			}			theY	= centerY + value;			if(zp < 0){				line->hor2 = line->hor1 = theX;				line->ver2 = line->ver1 = theY;				continue;			}			aPoint.h = line->hor2	= theX;			aPoint.v = line->ver2	= theY;			if(line->PointOnLine(thePoint)){					line->DoClose();					aIndex->DoClose();					spotLoc = i - 1;					D_HUnlock(theDataHandle);//MFTemp					goto END;			}						SubPt(thePoint,&aPoint);			x = aPoint.h;			y = aPoint.v;			error = sqrt((double)(x * x) + (double)(y * y));			if(error < 8){				line->DoClose();				aIndex->DoClose();				D_HUnlock(theDataHandle);//MFTemp				spotLoc = i - 1;				goto END;			}					line->hor1	= line->hor2;			line->ver1	= line->ver2;		}			*/			}	line->DoClose();	//aIndex->DoClose();	spotLoc = -1;		/*MFTemp*/D_HUnlock(theDataHandle);	if(n != 1){		SysBeep(30);	} else {		FlashMenuBar(0);		Delay(6L,&time);		FlashMenuBar(0);	}	return false;END:	/*MFTemp*/D_HUnlock(theDataHandle);	line->DoClose();	spotLoc = i;	obj_Index->theCrystal	= 	THE_CURRENT_SPOT.theCrystal;	obj_Index->h 			= 	THE_CURRENT_SPOT.h;	obj_Index->k 			= 	THE_CURRENT_SPOT.k;	obj_Index->l 			= 	THE_CURRENT_SPOT.l;	obj_Index->direction 	= 	THE_CURRENT_SPOT.direction;	if(THE_CURRENT_SPOT.flags){		THE_CURRENT_SPOT.spotRect.right = THE_CURRENT_SPOT.spotRect.left = thePoint.h;		THE_CURRENT_SPOT.spotRect.top = THE_CURRENT_SPOT.spotRect.bottom = thePoint.v;	}	return 						true;			}Boolean	SADObj::FindSpot(Point thePoint){	short 			n;	static	Point	lastPoint;	static	short	lastLoc;	static	long	thelastClick;	static	Boolean	wasFound = false;	double				minError = 100.9;	Point 				aPoint;	long					time;			theRoundObj		=	NULL;	if(!theDataHandle)return false;	time = gTheEvent.when;	if(time == thelastClick && spotLoc >= 0){	/* if NO elapsed time, then same event, data is OK */		return wasFound;	}	thelastClick = time;	if(thePoint.h == 0 && thePoint.v == 0){		lastPoint = thePoint;		lastLoc = -1;		return false;	}	StartWatch();	aPoint = thePoint;	if(inherited::FindSpot(thePoint)){		wasFound = true;		StopWatch();		FlushEvents(everyEvent,0);		lastLoc = spotLoc;		return wasFound;	}				LocalToObj(&aPoint);	lastPoint = aPoint;	//LocalToObj(&lastPoint);		if(theCurvedLabels){		theRoundObj = (TextRoundObj*)theCurvedLabels->DoFind(aPoint);	}	if(theRoundObj){		wasFound				= 	true;		StopWatch();		FlushEvents(everyEvent,0);		return true;	}		n = 1;	wasFound = FindTrace(aPoint, n);	if(!wasFound) spotLoc = -1;	StopWatch();	FlushEvents(everyEvent,0);	return wasFound;}Boolean SADObj::FindIndividualTrace(SpotInfoPtr thisPole,LineObj *line,Point thePoint){		double		alpha,P;	double		x,y,z;	short		hRes,vRes;	double		theXForm[3][3];	double		length,zz;	double		factor,L;	short		theX,theY,theXOld,theYOld;	double	theXForm00,value,					theXForm10,					theXForm20,					theXForm01,					theXForm11,					theXForm21,					theXForm02,					theXForm12,					theXForm22;	double		theta,distance,inelasticCal;	//double  dummy;	double x1,y1,z1,xp,yp,zp;	//dummy = xMax = yMax;	alpha		= thisPole->angle;	if(fabs(alpha) < .000001)return false;//the pole has no angle the cone radius is therefore infinite	distance   = CalcExtinctionDistance(thisPole,1/wavelength);	SetScaleFactor();	//this sets camera length and camera length in pixels.	inelasticCal = kLineMult * (1.23 -  exp(-1.5 * trueThickness / distance));	inelasticCal *= pow((double)(thisPole->intensity),1/dyRange);	if(inelasticCal < .1)return false;				length = sqrt(thisPole->x * thisPole->x + thisPole->y * thisPole->y + thisPole->z * thisPole->z);	x = thisPole->x/length;	y = thisPole->y/length;	z = thisPole->z/length;		FIND_CENTER_XFORM(x,y,z,theXForm);	InvertMatrix(theXForm);//this is the rotation for all new points		ScreenRes(&hRes,&vRes);	theXForm00 = theXForm[0][0];	theXForm10 = theXForm[1][0];	theXForm20 = theXForm[2][0];	theXForm01 = theXForm[0][1];	theXForm11 = theXForm[1][1];	theXForm21 = theXForm[2][1];	theXForm02 = theXForm[0][2];	theXForm12 = theXForm[1][2];	theXForm22 = theXForm[2][2];	L = cos(alpha);	zz = z = sin(alpha);	theta = 0;	x = L;	y = 0;	TransFormVector(&x,&y,&z,theXForm);	NormalizeVector(&x,&y,&z);	//angle = acos(z);	length		= sqrt(x * x + y * y);	factor = projLengthScreen * length / z;		value = Round((double)factor * y/length);	if(value > 32000) value = 31000;	else if(value < -32000) value = -31000;	line->hor2 = line->hor1 = theXOld	= centerX + value;			value = Round((double)factor * x/length);	if(value > 31000) value = 32000;	else if(value < -31000) value = -32000;	line->ver2 = line->ver1 = theYOld	= centerY + value;	MoveTo(theXOld,theYOld);	x1 = zz * theXForm02;	y1 = zz * theXForm12;	z1 = zz * theXForm22;	P = PI/90;	for(theta =  0; theta <= PI_2;theta += P){		x = L * cos(theta);		y = L * sin(theta);		//z = zz;		xp = x * theXForm00 + y * theXForm01 + x1;		yp = x * theXForm10 + y * theXForm11 + y1;		zp = x * theXForm20 + y * theXForm21 + z1;		//TransFormVector(&x,&y,&z,theXForm);		//NormalizeVector(&x,&y,&z);				length		= sqrt(xp * xp + yp * yp);		factor	= projLengthScreen * length / zp;		value = Round((double)factor * yp/length);				if(value > 32000) value = 32000;		else if(value < -32000) value = -32000;		theX	= centerX + value;								value = Round((double)factor * xp/length);		if(value > 32000) value = 32000;		else if(value < -32000) value = -32000;		theY	= centerY + value;		if(zp < 0){			theXOld = theX;			theYOld = theY;			continue;		}		if(fabs((double)theX) > 3000 || fabs((double)theY) > 3000){			theXOld = theX;			theYOld = theY;			continue;		}		line->hor1 = theXOld;		line->hor2 =  theX;		line->ver1 = theYOld;		line->ver2 =  theY;		theXOld = theX;		theYOld = theY;		if(line->PointOnLine(thePoint))return true;	}	return false;}void SADObj::LabelSpot(void){	Point thePoint;	DoSetOrigin();	ClipRect(&theWindow->portRect);	DoResetOrigin();	if((long)theRoundObj){		PenState thePenState;		GetPenState(&thePenState);		DMForeColor(BACKGROUND_COLOR);				if(IsPressed(56)){						if(theRoundObj == theCurvedLabels  && theRoundObj != NULL){				theCurvedLabels = theCurvedLabels->next;				((SpotInfoPtr)(*theDataHandle))[theRoundObj->spotLoc].flags -= TEXT_MASK;				DoSetOrigin();				theRoundObj->Kill();				DoResetOrigin();				D_delete(theRoundObj);			}else{				if(theCurvedLabels != 0L){					DoSetOrigin();					theCurvedLabels->EraseObject(theRoundObj);					DoResetOrigin();				}			}		}else{			DoSetOrigin();			ClipRect(&theWindow->portRect);			theRoundObj->Move();			DoResetOrigin();		}		SetPenState(&thePenState);		thePoint.h = thePoint.v = 0;		theRoundObj = 0L;		newPictEnable = true;		spotLoc = -1;	}	theRoundObj = 0L;	if(spotLoc >= 0){		if(spotLoc < numSpots){			ClipRect(&theWindow->portRect);			inherited::LabelSpot();			return;		}		newPictEnable = true;		if(THE_CURRENT_SPOT.flags & TEXT_MASK){			//if(LabelAllLines(false))return;			if(!theCurvedLabels)THE_CURRENT_SPOT.flags -= TEXT_MASK;				DoSetOrigin();				ClipRect(&theWindow->portRect);				if(theCurvedLabels)theCurvedLabels = (TextRoundObj*)theCurvedLabels->Erase(spotLoc,theCurvedLabels);			DoResetOrigin();		} else {			//if(LabelAllLines(true))return;			THE_CURRENT_SPOT.flags |= (TEXT_MASK);						THE_CURRENT_SPOT.theCrystal->SetColor();			GetMouse(&thePoint);			DoSetOrigin();			ClipRect(&theWindow->portRect);						if(theCurvedLabels){				TextRoundObj* line;				line = theCurvedLabels->Add(spotLoc,(&THE_CURRENT_SPOT),thePoint);				CleanLabel((TextObj*)line);				line -> Move();			}else{				theCurvedLabels = (TextRoundObj*)D_new(TextRoundObj);				theCurvedLabels->DoInit(false,theCrystal[0]);				theCurvedLabels->InsertNewLoc(spotLoc,(&THE_CURRENT_SPOT),thePoint);				CleanLabel(theCurvedLabels);				theCurvedLabels->Move();			}			DoResetOrigin();		}		spotLoc = -1;	}		theRoundObj = 0L;}void	SADObj::DeleteSpot(void){	short		i;	SpotInfo	*sourceSpot,*destSpot;		if(spotLoc < 0)		return;		/*MFTemp*/D_HLock(theDataHandle);		sourceSpot = destSpot = &(((SpotInfoPtr)*theDataHandle)[spotLoc]);	DoSetOrigin();	if(theCurvedLabels)theCurvedLabels = (TextRoundObj*)theCurvedLabels->Erase(spotLoc,(TextObj*)theCurvedLabels);	DoResetOrigin();	sourceSpot++;		if(spotLoc < numSpots){		HilightDataPoint(destSpot);			}else{		DrawSmallCircle(&THE_CURRENT_SPOT,true,32000.,32000.);	}	if(spotLoc < numSpots){		numSpots--;		i = (destSpot->flags & CRYSTAL_MASK);		while(i < 4){startCount[i + 1] -= 1;i++;}	}	data_Count--;	for(i = spotLoc ; i < data_Count; i++,sourceSpot++,destSpot++){		*destSpot = *sourceSpot;	}		D_HUnlock(theDataHandle);	newPictEnable = true;	return;}void SADObj::CleanLabel(TextObj* line){	short hor,ver;	if(((SpotInfoPtr)*theDataHandle)[line->spotLoc].flags & TOO_BIG){		hor = (line->lineRect.left + line->lineRect.right) / 2;		ver = (line->lineRect.top + line->lineRect.bottom) / 2;		line->lineRect.left = line->lineRect.right = hor;		line->lineRect.top = line->lineRect.bottom = ver;	}else{		line->lineRect = ((SpotInfoPtr)*theDataHandle)[line->spotLoc].spotRect;	}}Boolean	SADObj::LabelAllLines(Boolean label){	Point thePoint,aPoint;	short i,h1,h2,v1,v2;	SpotInfoPtr thisLine;	Rect	centerRect;	TextRoundObj* newLine;	LineObj	*line1,*line2;	Point rectP[8];	short		j = 0,k,hor;	double x, y;	double dangle;	Rect oldRect;	short maxHKL = -1,theIdent = -2,theCrys;		maxHKL = 3;	if(!IsPressed((unsigned short )58))/*optionkey*/return false;	if(IsPressed( (unsigned short )56))/*shiftkey*/maxHKL = 0;	if(IsPressed( (unsigned short )17)){		theIdent 		= THE_CURRENT_SPOT.flags & CRYSTAL_MASK;	}else if(IsPressed( (unsigned short )0)){		theIdent = -1;	}		D_HLock(theDataHandle);	thisLine 		= 	((SpotInfoPtr)*theDataHandle);	h1 = centerX - projLengthScreen;	h2 = centerX + projLengthScreen;	v1 = centerY - projLengthScreen;	v2 = centerY + projLengthScreen;		centerRect = theWindow->portRect;				LocalRectToObj(&centerRect); 	InsetRect(&centerRect,50,50);	oldRect = centerRect;	hor = (centerRect.bottom - centerRect.top) / 2;	hor /= 5;	InsetRect(&oldRect,4 * hor,4 * hor);	thisLine++;	ResetCurvedLabels();	newPictReq = true;	if(!label){		for(i = numSpots ; i < data_Count; i++,thisLine++){			if(thisLine->direction)continue;			thisLine->flags -= TEXT_MASK;		} 		D_HUnlock(theDataHandle);		return true;	}		line1 = (LineObj*)D_new(LineObj);	line1->next = 0L;	line1->previous = 0L;	line2 = (LineObj*)D_new(LineObj);	line2->next = 0L;	line2->previous = 0L;	for(i = numSpots ; i < data_Count; i++,thisLine++){		thePoint.h = 0;		thePoint.v = 0;		centerRect = oldRect;		k = 0;		if(thisLine->direction)continue;		if(maxHKL){				if(fabs((double)thisLine->h) > 3 || fabs((double)thisLine->k) > 3					|| fabs((double)thisLine->l) > 3)continue;		}		theCrys = thisLine->flags & CRYSTAL_MASK;		if(theIdent > -1 && (theCrys != theIdent)) continue;				while(thePoint.h == 0 && thePoint.v == 0 && k <= 10){						if(thisLine->flags){				Boolean flag = false;				rectP[0].h = centerRect.left;				rectP[0].v = centerRect.top;				rectP[1].h = centerRect.left;				rectP[1].v = centerRect.bottom;								rectP[2].h = centerRect.left;				rectP[2].v = centerRect.top;				rectP[3].h = centerRect.right;				rectP[3].v = centerRect.top;								rectP[4].h = centerRect.right;				rectP[4].v = centerRect.top;				rectP[5].h = centerRect.right;				rectP[5].v = centerRect.bottom;								rectP[6].h = centerRect.right;				rectP[6].v = centerRect.bottom;				rectP[7].h = centerRect.left;				rectP[7].v = centerRect.bottom;				j = 0;				while(flag == false && j < 7){					line1 -> SetLine(rectP[j],rectP[j + 1]);					aPoint.h = thisLine->spotRect.left;					aPoint.v = thisLine->spotRect.top;					thePoint.h = thisLine->spotRect.right;					thePoint.v = thisLine->spotRect.bottom;					line2 -> SetLine(thePoint,aPoint);					thePoint = line1->CrossOver(line2);					if(PtInRect(thePoint,&centerRect)){						flag = true;					}else{						thePoint.h = 0;						thePoint.v = 0;					}					j++;				}							}else{				thePoint	= FindCrossOver(thisLine,centerRect);			}			InsetRect(&centerRect,-hor,-hor);			k++;		}		if(thePoint.h == 0 && thePoint.v == 0) continue;				aPoint = thePoint;		//the following offsets the label from the line ~ perpendicular to the line		j = 0;		if(thisLine->h != 0) j = thisLine->h / fabs((double)thisLine->h);		if(j == 0){			if(thisLine->k != 0) j = thisLine->k / fabs((double)thisLine->k);		}		if(j == 0){			 if(thisLine->l != 0) j = thisLine->l / fabs((double)thisLine->l);		}		if(j == 0) j = 1;		if(j < 0)continue;				if(thisLine->flags & TOO_BIG){			Fixed	theSlope;			short	theAngle, dh, dv;				dh = line2->hor1 - line2->hor2;					/* calculate the deltas */				dv = line2->ver1 -  line2->ver2;				theSlope = FixRatio( INT2FIX(dh), INT2FIX(dv) );	/* slope=dh/dv */				theAngle = AngleFromSlope( theSlope );				dangle = theAngle;				y = 20 * cos(dangle);				x = 20 * sin(dangle);		}else{			short angle;			PtToAngle(&thisLine->spotRect,aPoint,&angle);			dangle = angle;			dangle *= PI / 180;			x =  20 * sin(dangle);			y =  20 * cos(dangle);		}		thePoint.h += x;		thePoint.v += y;		ObjToLocal(&thePoint);//necessary because labels are expecting local coordinates for point		if(!theCurvedLabels){			theCurvedLabels = (TextRoundObj*)D_new(TextRoundObj);			theCurvedLabels->DoInit(false,theCrystal[0]);			theCurvedLabels->InsertNewLoc(i,thisLine,thePoint);			newLine = theCurvedLabels;		}else{			newLine = theCurvedLabels->Add(i,thisLine,thePoint);		}		thisLine->flags |= TEXT_MASK;		newLine->lineRect.left = newLine->lineRect.left = aPoint.h;		newLine->lineRect.top = newLine->lineRect.bottom = aPoint.v;		CleanLabel(newLine);		newLine->Draw(true);	}	line1->DoClose();	line2->DoClose();	D_HUnlock(theDataHandle);	return true;}Point	SADObj::FindCrossOver(SpotInfoPtr theSpot,Rect testRect){	double			minError = 100.9;	long				time=0;	double			alpha;	double	P;	double	x,y,z;	double	theXForm[3][3];	double	length,zz;	double	factor,L;	short		theX,theY;	double	theXForm00,value,					theXForm10,					theXForm20,					theXForm01,					theXForm11,					theXForm21,					theXForm02,					theXForm12,					theXForm22;	double	theta;	double	x1,y1,z1,xp,yp,zp,distance;	Point		thePoint;	SetScaleFactor();	//radius = scaleFactor / wavelength;	thePoint.h = thePoint.v = 0;		if(theSpot->direction)return thePoint;	distance   = 1/ (theSpot->sF.r * wavelength);// /CalcExtinctionDistance(thisPole,1/wavelength);	SetScaleFactor();	//this sets camera length and camera length in pixels.		alpha		= theSpot->angle;	length = sqrt(theSpot->x * theSpot->x + theSpot->y * theSpot->y + theSpot->z * theSpot->z);	x = theSpot->x/length;	y = theSpot->y/length;	z = theSpot->z/length;		FIND_CENTER_XFORM(x,y,z,theXForm);	InvertMatrix(theXForm);	theXForm00 = theXForm[0][0];	theXForm10 = theXForm[1][0];	theXForm20 = theXForm[2][0];	theXForm01 = theXForm[0][1];	theXForm11 = theXForm[1][1];	theXForm21 = theXForm[2][1];	theXForm02 = theXForm[0][2];	theXForm12 = theXForm[1][2];	theXForm22 = theXForm[2][2];	L = sin(alpha);	zz = z = cos(alpha);	theta = 0;	x = L;	y = 0;	TransFormVector(&x,&y,&z,theXForm);	NormalizeVector(&x,&y,&z);	length		= sqrt(x * x + y * y);	factor = projLengthScreen * length / z;		x1 = zz * theXForm02;	y1 = zz * theXForm12;	z1 = zz * theXForm22;			P = PI/90;	for(theta =  0; theta <= PI_2;theta += P){		x = L * cos(theta);		y = L * sin(theta);		xp = x * theXForm00 + y * theXForm01 + x1;		yp = x * theXForm10 + y * theXForm11 + y1;		zp = x * theXForm20 + y * theXForm21 + z1;				length		= sqrt(xp * xp + yp * yp);		factor	= projLengthScreen * length / zp;		value = Round((double)factor * yp/length);				if(fabs(value) > 4000){			continue;		}		theX	= centerX + value;		value = Round((double)factor * xp/length);		if(fabs(value) > 4000){			 continue;		}		theY	= centerY + value;		if(zp < 0){			continue;		}		thePoint.h = theX;		thePoint.v = theY ;		if(PtInRect(thePoint,&testRect)){			thePoint.h = theX;			thePoint.v = theY;			return 	thePoint;		}	}	thePoint.h = 0;	thePoint.v = 0;	return thePoint;}void SADObj::SetFoilPtrs(Boolean thePtr1,short thePtr2,short thePtr3)//Override{     delugeFlag = thePtr1;     numberOfSteps = thePtr2;     interval = thePtr3; }#undef INT2FIX