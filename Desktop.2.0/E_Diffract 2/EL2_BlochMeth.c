#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"PCVNumerical.h"#include	"RulerButton.h"#include	"AtomicScatter.h"#include	"SF_MathLib.h"#include 	"TextTableObj.h"  #include 	"mathRecipies.h"#include 	"SADObj.h"#include 	"nrutil.h"#include "UextBoxFree.h"#include "FortranProtos.h"#include "atomicAbsorp.h"#include "f2c.h"#include	"CBEDObj.h"/*#define		KJ  k + j * nBeams#define		JK  j + k * nBeams#define		IJ  i + j * nBeams#define		JI  j + i * nBeams#define		II	i + i * nBeams#define		IK	i + k  * nBeams#define		KK  k + k * nBeams*//*#define		KJ  k][j#define		JK  j][k#define		IJ  i][j#define		JI  j][i#define		II	i][i#define		IK	i][k#define		KK  k][k*/#define		FREE_MATRIX free_matrix#define		MATRIX		matrix#define		KJ  j][k#define		JK  k][j#define		IJ  j][i#define		JI  i][j#define		II	i][i#define		IK	k][i#define		KK  k][klong		numPoints = 101;/*#define		KJ  k * nBeams + j#define		JK  j * nBeams + k#define		IJ  i * nBeams + j#define		JI  j * nBeams + i#define		II	i * nBeams + i#define		IK	i * nBeams + k#define		KK  k * nBeams + k*/void MatrixMMMultiply(rreal **matrix1,rreal **matrix2,rreal **final,short m);void NormalizeRotationMMMatrix(rreal **matrix,short m);void DiffractObject::ThruTilt(SpotInfoPtr theSpotsSt)//bloch{	SpotInfoPtr theSpots,theSpot;	double		matrixX[3][3],matrixY[3][3];	double		rotX,rotY,ratio,x,y;	double		delT,thetaTotal;	double		*val,**value,bigK;	double		*intensities;	double		normal;	long		k,i,ii,kk;	Rect		theRect;	char		theText[125];	rreal		**theUgReal,**theUgIm;	short		nBeams,pBeams;	short		num;	long		start,totalBeams,maxBeams;	rreal		*oldB,*b,*oldC,*c;	if(theSpotsSt[spotLoc].flags & BETH_PERTURB)return;	if(!GetStartStop(theSpotsSt,&start,&totalBeams))return;	if(totalBeams > 100){		if(TooManyBeams(totalBeams)){			return;		}	}	StartWatch();	theSpots = theSpotsSt;	for(i = 0; i < numSpots;i++,theSpots++){		if(theSpots->flags &= PRIME_MASK)		theSpots->flags ^= PRIME_MASK;	}	if(!SetUpUgh((Handle*)&theUgReal,(Handle*)&theUgIm,&nBeams,&pBeams,theSpotsSt,totalBeams)){StopWatch(); return;}	if(calcIntensities)KillHandle((Handle*)&calcIntensities);	calcIntensities = 0L;	k = 0;	if(spotLoc > 0)k = spotLoc - start;	ratio = (.006648352)*(1 + (1.9569341e-3 * energy));// this converts Vg to Ug, Vg is the fourier components of the 	//crystal potential given in eV, Ug is the Dynamical Structure factor	theSpots = theSpotsSt;	theSpot = &theSpots[k];	bigK  = sqrt((1/ (wavelength * wavelength)) + (ratio * theSpots->sF.r));	if(k == 0){		if(this->objectType == CBED_OBJ){		if(((CBEDObj*)this)->acrossCenter == 0){x = 1;y = 0;((CBEDObj*)this)->acrossCenter = 1;}		else {x = 0;y = 1;((CBEDObj*)this)->acrossCenter = 0;}		}	}else{		y = theSpot->x / sqrt(theSpot->x * theSpot->x + theSpot->y * theSpot->y);		x = theSpot->y / sqrt(theSpot->x * theSpot->x + theSpot->y * theSpot->y);	}	thetaTotal = -(double)theEBeam->convergenceAngle / bigK;// the standard sinz theta == theta at small angles assumption	num = (numPoints - 1) * .5;	delT = -thetaTotal / num;	delugeFlag = false;	maxBeams = nBeams + pBeams;// + 10;	value = (double**)D_NewHandle(numPoints * sizeof(double));	D_HLock(value);	val = *value;	for(i = 0; i < numPoints;i++,val++)*val = 0;	val = *value;	b = (rreal*)D_NewPtr(sizeof(rreal) * maxBeams * maxBeams);	c = (rreal*)D_NewPtr(sizeof(rreal) * maxBeams * maxBeams);	intensities = 0L;	oldB = b;	oldC = c;	for(ii = 1;ii <= maxBeams;ii++){		for(kk = 1; kk <= maxBeams;kk++,oldB++,oldC++){			*oldB = theUgReal[ii][kk];			*oldC = theUgIm[ii][kk];		}	}	normal = 1 / (double)(2 * num);	for(i = -num; i <= num;i++,thetaTotal += delT,val++){		rotX = thetaTotal * x;		rotY = thetaTotal * y;		RotatateMatrixAxis( matrixX,rotX,0);		RotatateMatrixAxis( matrixY,rotY,1);		MatrixMultiply(matrixX,matrixY,matrixX);		//NormalizeRotationMatrix(matrixX);		oldB = b;		oldC = c;		for(ii = 1;ii <= maxBeams;ii++){			for(kk = 1; kk <= maxBeams;kk++,oldB++,oldC++){				theUgReal[ii][kk] = *oldB;				theUgIm[ii][kk] = *oldC;			}		}		intensities = BlochMethod(theUgReal,theUgIm,matrixX,1,nBeams,pBeams,0L,theSpotsSt);				if(intensities == 0L || Quit()){ 			*val = 0;			goto THE_END2;		}		*val = *intensities;		if(fabs(*val) > 3){			*val = 0;		}		KillPtr(intensities);				sprintf(gTheText,"Percentage Complete %5.1f.",(double)(i + num) * normal * 100 );		theRuler->SetInfo(gTheText);		AllowBackground();	}THE_END2:		SetRect(&theRect,thePictRect.right - 250,thePictRect.bottom - 250,		thePictRect.right - 40,thePictRect.bottom - 100);	if(graph == 0L){		graph	= (GraphFunction*)D_new(GraphFunction);		graph	->	DoInit(theRect,theCrystal[(theSpotsSt->flags & CRYSTAL_MASK)]->crystalColor,true,true);	}		graph	->	SetValues			(0L,(Handle)value);		theSpots = theSpotsSt;	theSpots[spotLoc].flags |= PRIME_MASK;	obj_Index->CopyPtrToIndex((Ptr)&(theSpots[spotLoc]));	sprintf			(gTheText,"g-vector ");	obj_Index->IndexToText	(theText);	p2cstr			((unsigned char*)theText);	strcat			(gTheText,theText);	graph	->SetTitleY(gTheText);	sprintf			(gTheText,"Tilt in Recp.Angstroms");	graph	->SetTitleX(gTheText);	sprintf			(gTheText,"Beam Intensity vs Tilt");	graph	->SetTitleGraph(gTheText);	graph	->	minX 	= -theEBeam->convergenceAngle;	graph	->	maxX 	= theEBeam->convergenceAngle;	graph	->ResetPlotMinMax	();	//graph	->PlotGraph();	sprintf			(gTheText,"Thru Tilt");	c2pstr(gTheText);	graph->titleMenu->P_DelMenuItem		(2);	graph->titleMenu->P_AppendMenu	(gTheText);	graph->titleMenu->P_CheckItem		(2,true);		D_HUnlock(value);	KillHandle((Handle*)&value);	FREE_MATRIX(theUgReal,1,maxBeams,1,maxBeams);	FREE_MATRIX(theUgIm,1,maxBeams,1,maxBeams);	KillPtr(b);	KillPtr(c);	newPictReq = true;	StopWatch();	return;	}void DiffractObject::SingleBlochWaveDynamic(short *nout,dcomplex *sF,SpotInfoPtr theSpotsSt){	double		matrixX[3][3];	double		*intensities;	static short j = 0;	rreal		**theUgReal,**theUgIm;	short		nBeams,pBeams;	long		start,totalBeams,maxBeams;		if(!GetStartStop(theSpotsSt,&start,&totalBeams)){*nout = 0;return;}	if(totalBeams > 100){		if(TooManyBeams(totalBeams)){			*nout = 0;			return;		}	}	StartWatch();	if(!SetUpUgh((Handle*)&theUgReal,(Handle*)&theUgIm,&nBeams,&pBeams,theSpotsSt,totalBeams)) {*nout = 0; StopWatch();return;}	if(*nout > 1)*nout =  nBeams;	maxBeams = nBeams + pBeams;// + 10;	delugeFlag 		= false;	if(calcIntensities)KillHandle((Handle*)&calcIntensities);	calcIntensities = 0L;	Identity_Matrix(matrixX);	intensities =  BlochMethod(theUgReal,theUgIm,matrixX,*nout,nBeams,pBeams,sF,theSpotsSt);	if(intensities != 0L){		KillPtr(intensities);	}else{		*nout = 0;	}		FREE_MATRIX(theUgReal,1,maxBeams,1,maxBeams);	FREE_MATRIX(theUgIm,1,maxBeams,1,maxBeams);	newPictReq = true;	StopWatch();	return;}void DiffractObject::FullTilt(short *nout,SpotInfoPtr theSpotsSt){	SpotInfoPtr theSpots;	double		matrixX[3][3],matrixY[3][3];	double		rotX,rotY,ratio;	double		delT,thetaY,thetaX;	double		*val,bigK,maxInten;	double		*intensities,*inten,startTheta;	static short j = 0;	long		k,i,ii,kk,theSize;	long		totalPoints;	rreal		**theUgReal,**theUgIm;	double		value,theValue;	short		nBeams,pBeams;	long		start,totalBeams;	long		maxBeams;	rreal		*b,*c,*oldB,*oldC;	if(*nout == 1 && theSpotsSt[spotLoc].flags & BETH_PERTURB)return;	if(!GetStartStop(theSpotsSt,&start,&totalBeams)){*nout = 0;return;}	if(totalBeams > 100){		if(TooManyBeams(totalBeams)){			*nout = 0;return;		}	}	StartWatch();	if(!SetUpUgh((Handle*)&theUgReal,(Handle*)&theUgIm,&nBeams,&pBeams,theSpotsSt,totalBeams)){*nout = 0; StopWatch();return;}	if(*nout > 1)*nout =  nBeams;	maxBeams = nBeams + pBeams;// + 10;	ratio = (.006648352)*(1 + (1.9569341e-3 * energy));// this converts Vg to Ug, Vg is the fourier components of the 	//crystal potential given in eV, Ug is the Dynamical Structure factor	theSpots		=	theSpotsSt;	bigK  			= 	sqrt((1/ (wavelength * wavelength)) + (ratio * theSpots->sF.r));	theSize 		= 	(double)scaleFactor * (double)theEBeam->convergenceAngle;	theValue		=	*nout;	theValue /= 10;	value = (double)(theSize * theSize) * PI * (1 + theValue);	value /=  101;	sprintf(gTheText,"Calculation  will take ~ %5.1f longer than a thru tilt.",value);	theRuler->SetInfo(gTheText);		totalPoints		=	((theSize * 2) + 1) *  ((theSize * 2) + 1) * *nout;	startTheta 		= thetaX = -(double)theEBeam->convergenceAngle / bigK;// the standard sin theta == theta at small angles assumption	delT 			= -thetaX / theSize;	delugeFlag 		= false;	if(calcIntensities != 0){KillHandle((Handle*)&calcIntensities);calcIntensities = 0L;}		calcIntensities = (double**)D_NewHandle((totalPoints + 2) * sizeof(double));	if(calcIntensities == 0L){StopWatch(); return;}	val = *calcIntensities;	for(i = 0; i <= totalPoints;i++,val++)*val = 0.0;	D_HLock(calcIntensities);	val = *calcIntensities;	*val = theSize ;	val++;	*val = *nout;	val++;	maxInten = 0.0000001;	intensities = 0L;	b = (rreal*)D_NewPtr(sizeof(rreal) * maxBeams * maxBeams);	c = (rreal*)D_NewPtr(sizeof(rreal) * maxBeams * maxBeams);	oldB = b;	oldC = c;	for(ii = 1;ii <= maxBeams;ii++){		for(kk = 1; kk <= maxBeams;kk++,oldB++,oldC++){			*oldB = theUgReal[ii][kk];			*oldC = theUgIm[ii][kk];		}	}	for(i = -theSize; i <= theSize;i++,thetaX += delT){		thetaY = startTheta;		for(j = -theSize; j <= theSize;j++,thetaY += delT){			double jx,ix;						rotX = thetaX;			rotY = thetaY;			ix = i; jx = j;			if(Round(sqrt(ix * ix + jx * jx)) > theSize)continue;			RotatateMatrixAxis( matrixX,rotX,0);			RotatateMatrixAxis( matrixY,rotY,1);			MatrixMultiply(matrixX,matrixY,matrixX);			oldB = b;			oldC = c;			for(ii = 1;ii <= maxBeams;ii++){				for(kk = 1; kk <= maxBeams;kk++,oldB++,oldC++){					theUgReal[ii][kk] = *oldB;					theUgIm[ii][kk] = *oldC;				}			}			inten = intensities =  BlochMethod(theUgReal,theUgIm,matrixX,*nout,nBeams,pBeams,0L,theSpotsSt);			if(intensities == 0L || Quit()){				if(intensities != 0L)KillPtr(intensities);			 goto THE_END;			}			for(k = 0; k < *nout;k++,val++,inten++){				*val = *inten;				if(*val > 3){					*val = 0;				}				if(*val > maxInten)maxInten = *val;			}			KillPtr(intensities);						//g_ThreadObj->YieldToThreads(0L);			AllowBackground();		}		sprintf(gTheText,"Percentage Complete %5.1f .",-50 * (thetaX - startTheta) / startTheta);		theRuler->SetInfo(gTheText);		//g_ThreadObj->YieldToThreads(0L);	}THE_END:		val = *calcIntensities;	val += 2;	for(i = 0; i < totalPoints;i++,val++){		*val /= maxInten;	}	D_HUnlock(calcIntensities);	FREE_MATRIX(theUgReal,1,maxBeams,1,maxBeams);	FREE_MATRIX(theUgIm,1,maxBeams,1,maxBeams);	KillPtr(b);	KillPtr(c);	newPictReq = true;	plotType = BETHE_CBED;	//g_ThreadObj->DeleteLastThread();	StopWatch();	return;}enum{	THRU_THICK = 1,	THRU_TILT,	PLOT_CRITICAL_VOLTAGE,	FULL_TILT = 5,	FULL_TILT_All,	SET_BETHE_PERTURB = 8,	INCREASE_RES,	DECREASE_RES};void DiffractObject::BetheMenu(short item){	switch(item)	{		case THRU_THICK://Bloch			functionID = THRU_THICKNESS_DY;			theRuler->SetPrompt("Calculate Thru Thickness Dynamic Plots for selected spot");			theRuler->SetHelp("Labels toggle on/off with succesive clicks. Plot Generated when spot selected.");/*dec 1992*/			SetTheCursor(TARGET_CURSOR);			break;		case THRU_TILT://Bloch			 functionID = THRU_TILT_DY;			 theRuler->SetPrompt("Calculate Thru Tilt Dynamic Plots for selected spot. Line thru center of spot,along line  from spot to center.");			theRuler->SetHelp("Labels toggle on/off with succesive clicks. Plot generated when spot selected.");/*dec 1992*/			SetTheCursor(TARGET_CURSOR);			 break;		case FULL_TILT://Bloch			functionID = FULL_TILT_DY;			nOut = 1;			 theRuler->SetPrompt("Calculate Full Tilt Dynamic Plots for selected spot. This plot will be for both x and y direction.");			theRuler->SetHelp("Labels toggle on/off with succesive clicks. Plot generated when spot selected.");/*dec 1992*/			SetTheCursor(TARGET_CURSOR);			break;		case FULL_TILT_All://Bloch			nOut = startCount[baseCrystal + 1] - startCount[baseCrystal];			theRuler->SetPrompt("Calculate Full Tilt Dynamic Plots for the full pattern.");			//g_ThreadObj->CreateCoopThread((ThreadEntryProcPtr)FullTiltThreadEntry,(void*)this);//MyCalculate();			FullTilt(&nOut,(SpotInfoPtr)*theDataHandle);			break;		case SET_BETHE_PERTURB://bloch			functionID = SET_BETHE_PERTURB_F;			theRuler->SetPrompt("Set Spots to be used as perturbations");			SetTheCursor(306);			theRuler->SetHelp("Click to select. Click again to deselect.");			break;		case PLOT_CRITICAL_VOLTAGE:			functionID = CRITICAL_VOLTAGE_F;			theRuler->SetPrompt("Calculate Intensity vs Voltage for selected spot.");			theRuler->SetHelp("Labels toggle on/off with succesive clicks. Plot generated when spot selected.");/*dec 1992*/			SetTheCursor(TARGET_CURSOR);			break;		case INCREASE_RES:			numPoints += numPoints * .33;			sprintf(gTheText,"Bloch Plots will now have a total of %d calculated points",numPoints);			theRuler->SetPrompt(gTheText);			break;		case DECREASE_RES:			numPoints -= numPoints * .33;			sprintf(gTheText,"Bloch Plots will now have a total of %d calculated points",numPoints);			theRuler->SetPrompt(gTheText);			break;				}}void DiffractObject::FullPlot(short nout,SpotInfoPtr theSpotsSt){	SpotInfoPtr theSpots;	double		*val;	static short j = 0;	short		k,i,theSize;	Rect		oldOval,theOval;	double		grayGain;	short		theIdent;	double		intensityRange;	long		start,totalBeams;	if(!GetStartStop(theSpotsSt,&start,&totalBeams)){return;}	if(calcIntensities == 0 || plotType != BETHE_CBED)return;		SetDrawEnviron();	if(g_Monitor){		grayGain = 220. ;	}else{		grayGain = 10;	}		greyFlag = true;			SetRect(&oldOval,0,0,0,0);		D_HLock(calcIntensities);	val 	= *calcIntensities;	theSize = Round(*val);	val++;	nout = Round(*val);	val++;	intensityRange = 1. / (double)dyRange;	theSpots = theSpotsSt;	theIdent = theSpots->flags & CRYSTAL_MASK;						for(i = -theSize; i <= theSize;i++){		for(j = -theSize; j <= theSize;j++){			double ix,jx;			long	theX,theY;			short	theValue;			ix = i; jx = j;			if(Round(sqrt(ix * ix + jx * jx)) > theSize)continue;			theSpots = theSpotsSt;			if(nout == 1){				theSpots = &(theSpotsSt[spotLoc - start]);			}			for(k = 0; k < nout;k++,val++,theSpots++){				if(k >= numSpots)continue;				if(theSpots->flags & BETH_PERTURB)continue;				CalculateSpotLocation(&theX,&theY,theSpots);				theX += i;				theY += j;				theOval = oldOval;				OffsetRect(&theOval,(short)theX,(short)theY);				theValue = Round(grayGain * (pow((double)*val,intensityRange)));				if(theValue > 219)theValue = 219;				if(theValue <= 0)continue;				//DM_DrawRect(theOval,theIdent,theValue,theSpots->direction);				DMForeColor(theValue + 15);				dm_PaintRect(&theOval);			}		}	}	D_HUnlock(calcIntensities);	theSpots			= 				((SpotInfoPtr)*theDataHandle);	PlotKLines(theSpots);	theSearchObj->PlotRings(scaleFactor,scaleFactor,centerX,centerY,0,500);	//if(graph)graph	->PlotGraph();	ClearDrawEnviron();}Boolean DiffractObject::SortAndFindPerturbedBeams(short *nBeams,short *pBeams,SpotInfoPtr baseSpots,short totBeam){	SpotInfoPtr 	theSpots;	SpotInfoPtr 	nSpots,pSpots;	SpotInfoPtr		newSpots;	long			i;	//This functions puts the perturbing beams at the end and rrealigns the spots	newSpots = (SpotInfoPtr)D_NewPtr(sizeof(SpotInfo) * totBeam);	if(!newSpots)return false;	nSpots = newSpots;	pSpots = &nSpots[totBeam - 1];//setting address for Beth Perturbs	theSpots = baseSpots;	*nSpots   = *baseSpots;//setting 000 to nSpots	theSpots++;	nSpots++;	*pBeams = 0;	*nBeams = 1;	for(i = 1; i < totBeam;i++,theSpots++){		if(theSpots->flags & BETH_PERTURB){			*pSpots = *theSpots;			pSpots--;			*pBeams += 1;		}else{			*nSpots = *theSpots;			nSpots++;			if(i == spotLoc){				spotLoc = *nBeams;			}			*nBeams += 1;		}	}	nSpots = newSpots;	theSpots = baseSpots;	for(i = 0; i < totBeam;i++,theSpots++,nSpots++){		*theSpots = *nSpots;	}	KillPtr(newSpots);	return true;}void	DiffractObject::SetBethPerturb(Point thePoint){	short oldVal;	short	theIdent;	if(!FindSpot(thePoint)) return;	if(spotLoc < 0) return;/*dec 1992*/	theIdent = THE_CURRENT_SPOT.flags & CRYSTAL_MASK;		newPictEnable = true;	dm_EraseRect(&THE_CURRENT_SPOT.spotRect);	if(THE_CURRENT_SPOT.flags & BETH_PERTURB){		THE_CURRENT_SPOT.flags -= BETH_PERTURB;		DM_DrawRect(THE_CURRENT_SPOT.spotRect,theIdent,theIdent,THE_CURRENT_SPOT.direction);	} else {		THE_CURRENT_SPOT.flags |= (BETH_PERTURB);		oldVal = theCrysSymbols_P[theIdent];		theCrysSymbols_P[theIdent] = 1;		DM_DrawRect(THE_CURRENT_SPOT.spotRect,theIdent,theIdent,THE_CURRENT_SPOT.direction);//Bloch			theCrysSymbols_P[theIdent] = oldVal;	}	return;}Boolean DiffractObject::SetUpUgh(Handle* theUgReal,Handle* theUgIm,short *nbeams,short *pBeams,SpotInfoPtr theSpotsSt,short totalBeams){	Crystal 	*thisCrystal;	double		electronMassRation;	double 			*theUs,*theVs,*theWs,*theZs,*theBs;	double			H,K,L,X,Y,Z;	double			theD;	dcomplex		sF,abC;	short			atom_Count;		Ptr*			theHandle;	long			maxBeams;	SpotInfoPtr		theSpots;	SpotInfoPtr		theSpots2;	rreal			**theHR,**theHI;		long			i,j,k;	long			nBeams;	double			ratio;		if(!SortAndFindPerturbedBeams(nbeams,pBeams,theSpotsSt,totalBeams)){return 0;}	nBeams			=	*nbeams + *pBeams;	maxBeams 	= nBeams;// + 10;		theSpotsSt->h = theSpotsSt->k = theSpotsSt->l = 0;//sets beam to 0,0,0	theSpotsSt->direction = 0;//converts it to a plane to allow Structure factor calc			*theUgReal 	= (Handle)MATRIX(1,maxBeams,1,maxBeams);	theHR = (rreal**)*theUgReal;	if(*theUgReal == 0L) return false;			*theUgIm	= (Handle)MATRIX(1,maxBeams,1,maxBeams);	theHI = (rreal**)*theUgIm;	if(*theUgIm == 0L){FREE_MATRIX(theHR,1,maxBeams,1,maxBeams); return false;}		ratio 	= (.006648352) * (1 + (1.9569341e-3 * energy));// this converts Vg to Ug, Vg is the fourier components of the 	for(i = 1; i <= maxBeams;i++){		for(k = 1;k <= maxBeams;k++){			theHI[k][i] = 0;			theHR[k][i] = 0;		}	}		thisCrystal = theCrystal[(theSpotsSt->flags & CRYSTAL_MASK)];	electronMassRation = 1. + ( (double)energy / 511.);	theHandle 	= thisCrystal->AtomicScatteringSet(electronMassRation,theBeamFlag);	// D_HLock((Handle)  theHandle); 	if(!SetScatteringPosAIntensity(thisCrystal,&theUs,&theVs,&theWs,&theZs,&theBs,&atom_Count)){//Timebomb!!//*atom_Count cannot be the same address as *crystal->Atom_Couynt  or you will continually increase the number		FREE_MATRIX(theHR,1,maxBeams,1,maxBeams);		FREE_MATRIX(theHI,1,maxBeams,1,maxBeams);		return 0;	}	/* this calculates the off diagonal Ug-h terms required for the Bloch wave matrix*/	//is the additional beams which are treated as a perturvbation on the blach wave matrix.	theSpots = theSpotsSt;	theSpots++;//offsets base spots	abC.i = 0;	abC.r = 0;	for( i = 2;i <= nBeams;theSpots++,i++){//nBeams = nbeams + pbeams		theSpots2 = theSpotsSt;		for(j = 1; j < i;theSpots2++, j++)		{			H = theSpots->h - theSpots2->h;			K = theSpots->k - theSpots2->k;			L = theSpots->l - theSpots2->l;			X = theSpots->x - theSpots2->x;			Y = theSpots->y - theSpots2->y;			Z = theSpots->z - theSpots2->z;			theD = sqrt(X * X + Y * Y);			if(theD < .00001) theD = .00001;			AtomicScatterForDFromSet(theD,theHandle,theZs,atom_Count);						sF	= StructureFactor(H,K,L,theUs,theVs,theWs,atom_Count,theZs,theBs,thisCrystal->volume,1/theD);			if(g_absorpFlag){				abC = AbsorptionCoefficient(H,K,L,theUs,theVs,theWs,thisCrystal,theBs,energy,theD * .5);				abC.i *= ratio;				abC.r *= ratio;			}						theHR[IJ] 	= (sF.r - abC.i);// * ratio;// sF.r - absorpFIM, the absorptions needs to be calucualed,ratio converts Vg to Ug			theHI[IJ] 	= (sF.i + abC.r);// * ratio;// sF.i + absorpFRe			theHR[JI] 	= (sF.r + abC.i);// * ratio;//sF.r + absorpFIM			theHI[JI] = (-sF.i + abC.r);// * ratio;// -sF.i + absorpFRe			//g_ThreadObj->YieldToThreads(0L);		}			}	theSpots 	= theSpotsSt;	theSpots->h = theZoneAxis->h;theSpots->k = theZoneAxis->k;theSpots->l = theZoneAxis->l;	theSpots->direction = true;	thisCrystal->ClearAtomicScatSet(theHandle);	KillPtr((Ptr)theUs);	return true;}double* DiffractObject::BlochMethod(rreal **theUgReal,rreal **theUgIm,double matrixD[3][3],short nout,short nbeams,short pBeams,dcomplex *sF,SpotInfoPtr theSpotsSt)//matrix is the matrix required to tilt the reciprocal lattice to mimic the beam tilt{	double  		bigK;	SpotInfoPtr 	theSpots;			rreal			*eigenValR,*eigenValIm,**eigenVecR,**eigenVecIm;	rreal			*thePtr2,*thePtr3;	long			j,i,k;	double			*intensities,ratio;		double			Uo,x,y,z;	long			maxBeams;	long			nBeams;	dcomplex		*thePtr,**a,*b,*oldB;			double			matrix1[3][3],matrix2[3][3];	long			totalBeams,start;		if(!GetStartStop(theSpotsSt,&start,&totalBeams)){return 0L;}		maxBeams 	= nbeams + pBeams;// + 10;	nBeams		=	nbeams + pBeams;	theSpots 	= (SpotInfoPtr)theSpotsSt;	ratio 		= (.006648352) * (1 + (1.9569341e-3 * energy));// this converts Vg to Ug, Vg is the fourier components of the 	//crystal potential given in eV, Ug is the Dynamical Structure factor	Uo  		= ratio * theSpots->sF.r;	bigK  		= sqrt( (1/(wavelength * wavelength)) + Uo); // this calculates the momentum vector	//K inside the crystal.  sF.r is the mean inner potential Uo for this crystal	thePtr2 = eigenValR 	= (rreal*)D_NewPtr((maxBeams + 2) * sizeof(rreal));	if(MemError()){StopAlert(OUT_OF_MEM,NUL); return 0L;}	thePtr3 = eigenValIm 	= (rreal*)D_NewPtr((maxBeams + 2) * sizeof(rreal));	if(MemError()){ StopAlert(OUT_OF_MEM,NUL);KillPtr(thePtr2);return 0L;}	thePtr  = b 			= (dcomplex*)D_NewPtr((maxBeams + 2) * sizeof(dcomplex));	if(MemError()){StopAlert(OUT_OF_MEM,NUL); KillPtr(thePtr2);KillPtr(thePtr3);return 0L;}	a = dcommatrix(1,maxBeams,1,maxBeams);	eigenVecIm 	= MATRIX(1,maxBeams,1,maxBeams);	eigenVecR	= MATRIX(1,maxBeams,1,maxBeams);	for(i = 0; i < maxBeams + 2;i++,thePtr2++,thePtr3++,thePtr++){		*thePtr2 = *thePtr3 = 0;		thePtr->r = 0;		thePtr->i = 0;	}	for(i = 1; i <= maxBeams;i++){		for(k = 1; k <= maxBeams;k++){			a[i][k].r = 0;			a[i][k].i = 0;			eigenVecIm[i][k] = 0;			eigenVecR[i][k] = 0;		}	}				//reverts 000 beam to orginal notation		theSpots++;	IrrationalZoneAxis(theFoilNormal,theFNRotationAxis,theFoilBragg,theFNRotationAngle,theFNOffLaueDistance,totalRot,beamAzimuth,calcIrrational,&x,&y,&z,matrix1);	// matrix1 is the rotation matrix required to rotate the Foil normal to the z axis	CopyAxesIntoMatrix(matrix2);	//matrix2 is the rotation matrix for the zone axis	InvertMatrix(matrix1);	MatrixMultiply(matrix1,matrix2,matrix1);//this gives the orientation difference between zone axis and foil normal	/*this calculates the diagonal elements Ksg for the Bloch Matrix*/	NormalizeRotationMatrix(matrix1);	//NormalizeRotationMatrix(matrixD);	theUgReal[1][1] = 0.0;	theUgIm[1][1] 	= absorpMean * Uo;//(ratio * theSpots->sF.r) is Uo mean scattering potential	for( i = 2;i <= nBeams;theSpots++,i++){			double d,sg;		double xx,yy,zz;				xx = theSpots->x;		yy = theSpots->y;		zz = theSpots->z;		TransFormVector(&xx,&yy,&zz,matrixD);//this tilts the reciprocal lattice to match the tilt angle		d = xx * xx + yy * yy;		sg = bigK - sqrt((bigK * bigK) - d) - zz; // determine distance from Ewald Sphere for xy projection		// Beam is always along the z axis by convention s is given parallel to foil normal from end of g to ewald sphere, this is slightly wrong		//this needs to be calculated.		xx = 0;yy = 0; 		TransFormVector(&xx,&yy,&sg,matrix1);//this converts sg to sgn where sgn is the component of sg along the foil normal		theUgReal[II] = -2 * bigK * sg; //2KSg = 2Kg - g**2		theUgIm[II] = absorpMean * Uo;	}	//NormalizeRotationMMMatrix(theUgReal,nBeams);	//NormalizeRotationMMMatrix(theUgIm,nBeams);	//Calculates the bethe Perturbation potential	BethePerturbations	(theUgReal,theUgIm,nbeams,pBeams);//pbeams = difference between number of beams used in matrix for		//calculation and number of beams available but not used, normally this is 0,but will not be if the bethe perturbations		//are not zero.	EisPack				(nbeams,nbeams,theUgReal,theUgIm,eigenValR,eigenValIm,eigenVecR,eigenVecIm,&i);	if(Quit()){		KillPtr(eigenValR);		KillPtr(eigenValIm);		KillPtr(b);		FREE_MATRIX(eigenVecR,1,maxBeams,1,maxBeams);		FREE_MATRIX(eigenVecIm,1,maxBeams,1,maxBeams);		FREE_MATRIX((rreal**)a,1,maxBeams,1,maxBeams);		return 0L;	}	if(i == 0){		oldB = b;		for(j = 1; j <= nbeams;j++,oldB++){			oldB->r = 0;			oldB->i = 0;			for(i = 1; i <= nbeams;i++){				a[i][j].r = eigenVecR[i][j];				a[i][j].i = eigenVecIm[i][j];			}		}				C_InverseRow		( nbeams, nbeams,a,b, &i);		intensities	= 0L;		if(i == 100)intensities = (double*)GetBeamIntensities(bigK,eigenVecR,eigenVecIm,eigenValR,eigenValIm,b,nbeams,nout,sF,(short)spotLoc - start);			}		KillPtr(eigenValR);	KillPtr(eigenValIm);	KillPtr(b);	FREE_MATRIX(eigenVecR,1,maxBeams,1,maxBeams);	FREE_MATRIX(eigenVecIm,1,maxBeams,1,maxBeams);	FREE_MATRIX((rreal**)a,1,maxBeams,1,maxBeams);	return intensities;}void NormalizeRotationMMMatrix(rreal **matrix1,short m){	rreal **a,**v;	rreal *w;	short i,j;	rreal **matrix2;		//w = (float*)D_NewPtr(sizeof(float) * 4);	w = vector(1,m);	v = matrix(1,m,1,m);	a = matrix(1,m,1,m);	matrix2 = matrix(1,m,1,m);	for(i = 1; i <= m; i++){		for(j = 1; j <= m;j++){			a[i][j] = matrix1[i][j];		}	}		svdcmp(a,m,m,w,v);		MatrixMMMultiply(a,v,matrix1,m);	free_matrix(a,1,m,1,m);	free_matrix(v,1,m,1,m);	free_vector(w, 1,m);}void MatrixMMMultiply(rreal **matrix1,rreal **matrix2,rreal **final,short m){	rreal **a;	short i,k,j;	a = matrix(1,m,1,m);	for(i = 1; i <= m;i++){		for(k = 1; k <= m; k++){			a[i][k] = 0;			for(j = 1; j <= m;j++){				a[i][k] +=  matrix2[i][j] * matrix1[j][k];			}		}	}	for(i = 1; i <= m;i++){		for(k = 1; k <= m; k++){			final[i][k] = a[i][k];		}	}	free_matrix(a,1,m,1,m);}#pragma segment Mainvoid DiffractObject::BethePerturbations(rreal **theUgReal,rreal **theUgIm,short nbeams,short pbeams){	long i,k,j;	double val1,val2;	long	nBeams;	if(pbeams == 0)return;	nBeams = pbeams + nbeams;	for(i = 1;i <= nbeams;i++){				for(j = 1;j < i;j++){			val1 = 0;			val2 = 0;			for(k = nbeams + 1;k <= nBeams;k++){				val1 += (theUgReal[IK] * theUgReal[KJ] - theUgIm[IK] * theUgIm[KJ]) 								/ theUgReal[KK];				val2 += (theUgReal[IK] * theUgIm[KJ] + theUgIm[IK] * theUgReal[KJ]) 								/ theUgReal[KK];			}			theUgReal[IJ] -= val1;			theUgIm[IJ] -= val2;			theUgReal[JI] -= val1;			theUgIm[JI] += val2;		}	}		for(i = 1; i <= nbeams;i++)	{		val1 = 0;		for(k = nbeams + 1;k <= nBeams; k++)		{			val1 += (theUgReal[IK] * theUgReal[IK] + theUgIm[IK] * theUgIm[IK]) / theUgReal[KK];		}		theUgReal[II] = theUgReal[II] - val1;	}	}#pragma segment Maindouble* DiffractObject::GetBeamIntensities(double bigKZ,rreal **ccR,rreal **ccI,rreal *vR,rreal *vI,dcomplex *cinV,short nBeams,short nout,dcomplex *sF,short theSpotLoc){	double 	sFR,sFIm;	long 	m,j,ndepth = 1,k,numSteps,i;	double *intensity;	double *int1;	dcomplex c1,c2,ac;	double 	cn1,val,val1,decay,sn1;	double	thick,intervalT;	rreal	*vRk,*vIk;	dcomplex *cinVk;		if(delugeFlag )	{		if( numberOfSteps < 2){			numSteps = numPoints;			numberOfSteps = numSteps;		}else{			numSteps = numberOfSteps;		}		interval = trueThickness / (double)numSteps;		thick  = trueThickness - (numSteps * interval);	}else{		numSteps = 1;		thick  = trueThickness;	}	if(numSteps == 0)numSteps = 1;	intensity = (double*)D_NewPtr(sizeof(double) * nout * (numSteps));	if(intensity == 0L)return 0L;	int1 = intensity;		intervalT = interval;	for(i = 0; i < numSteps;i++){		for(m = 1;m <= nout;m++,int1++){			//j = iD[m];/* use this for output specific reflections, must be set up earlier*/			if(nout == 1)j = theSpotLoc + 1;			else j = m;			sFR = 0;			sFIm = 0;			vRk = &vR[1];			vIk = &vI[1];			cinVk = &cinV[1];			for(k = 1;k <= nBeams;k++,vRk++,vIk++,cinVk++){				c1 = Complex(ccR[JK],ccI[JK]);				val =  -PI * *vRk * thick / bigKZ;				cn1 = 	cos(val);				sn1 = 	sin(val);				c2 = 	Complex(cn1,sn1);				val1 = 	PI * *vIk * thick/bigKZ;				decay = exp(-val1);				ac  = 	RCmul(decay,*cinVk);				c1	=	Cmul(c2, c1);				c1  = 	Cmul(c1,ac);				sFR += c1.r;				sFIm += c1.i;			}			*int1 = sFR * sFR + sFIm * sFIm;			if(sF){				sF->r = sFR;				sF->i = sFIm;				sF++;			}		}		thick += intervalT;	}	return intensity;}#pragma segment Mainvoid DiffractObject::EisPack(long nm,long n,rreal **ar,rreal **ai,rreal *wr,rreal *wi,rreal **vr,rreal **vi,long *err){	rreal *fv1,*fv2,*fv3;/* 300 is the number of allowed beams, needs to be generalized*/	integer	 is1,is2;	integer nLong,nmLong,pLong;	integer	errLong;	fv1 = (rreal*)D_NewPtr(sizeof(rreal) * (nm + 2));	if(MemError()){StopAlert(OUT_OF_MEM,NUL); return;}	fv2 = (rreal*)D_NewPtr(sizeof(rreal) * (nm + 2));	if(MemError()){StopAlert(OUT_OF_MEM,NUL);KillPtr((Ptr)fv1); return;}	fv3 = (rreal*)D_NewPtr(sizeof(rreal) * (nm + 2));	if(MemError()){StopAlert(OUT_OF_MEM,NUL);KillPtr((Ptr)fv1);	KillPtr((Ptr)fv2); return;}	nLong = n;	nmLong = nm;		cbal_(&nmLong,&nLong,ar,ai,&is1,&is2,fv1);	if(Quit()){		KillPtr((Ptr)fv1);		KillPtr((Ptr)fv2);		KillPtr((Ptr)fv3);		return;	}	//g_ThreadObj->YieldToThreads(0L);	corth_(&nmLong,&nLong,&is1,&is2,ar,ai,fv2,fv3);	if(Quit()){		KillPtr((Ptr)fv1);		KillPtr((Ptr)fv2);		KillPtr((Ptr)fv3);		return;	}	//g_ThreadObj->YieldToThreads(0L);	comqr2_(&nmLong,&nLong,&is1,&is2,fv2,fv3,ar,ai,wr,wi,vr,vi,&errLong);	if(Quit()){		KillPtr((Ptr)fv1);		KillPtr((Ptr)fv2);		KillPtr((Ptr)fv3);		return;	}	//g_ThreadObj->YieldToThreads(0L);	*err = errLong;	pLong = nLong;	if(errLong == 0){		cbabk2_(&nmLong,&nLong,&is1,&is2,fv1,&pLong,vr,vi);	}	KillPtr((Ptr)fv1);	KillPtr((Ptr)fv2);	KillPtr((Ptr)fv3);}#pragma segment MainBoolean DiffractObject::GetStartStop(SpotInfoPtr theSpotsHit,long *start,long *total){	short theIdent;	theIdent = (theSpotsHit->flags & CRYSTAL_MASK);	if(theIdent == 4) return false;	*start = startCount[theIdent];	*total =  startCount[theIdent + 1] - *start;	return true;}void DiffractObject::ThruThicknessRockingCurve(SpotInfoPtr theSpotsSt)//bloch{	double 		*intensities,*inten;	double		**value,*val;	char		theText[200];	Rect		theRect;	short		k,i;	SpotInfoPtr theSpots;	double		matrix[3][3];	rreal		**theUgReal,**theUgIm;	short		nBeams, pBeams;	long		start,totalBeams,maxBeams;	Identity_Matrix(matrix);	if(theSpotsSt[spotLoc].flags & BETH_PERTURB)return;	if(!GetStartStop(theSpotsSt,&start,&totalBeams))return;	if(totalBeams > 100){		if(TooManyBeams(totalBeams)){			return;		}	}	StartWatch();	delugeFlag = true;	numberOfSteps = numPoints;	if(!SetUpUgh((Handle*)&theUgReal,(Handle*)&theUgIm,&nBeams,&pBeams,theSpotsSt,totalBeams)){ StopWatch();return;}	maxBeams 	= nBeams + pBeams;// + 10;	inten = intensities =  BlochMethod(theUgReal,theUgIm,matrix,1,nBeams, pBeams,0L,theSpotsSt);	FREE_MATRIX(theUgReal,1,maxBeams,1,maxBeams);	FREE_MATRIX(theUgIm,1,maxBeams,1,maxBeams);	if(intensities == 0L) goto END_THRU_THICK;	if(calcIntensities)KillHandle((Handle*)&calcIntensities);	calcIntensities = 0L;	value = (double**)D_NewHandle(numberOfSteps * sizeof(double));	D_HLock(value);	val = *value;	k = 0;	if(spotLoc > 0)k = spotLoc - start;	for(i = 0; i < numberOfSteps;i++,val++,inten++){		*val = *inten;	}		SetRect(&theRect,thePictRect.right - 250,thePictRect.bottom - 250,		thePictRect.right - 40,thePictRect.bottom - 100);	if(graph == 0L){		graph	= (GraphFunction*)D_new(GraphFunction);		graph	->	DoInit(theRect,theCrystal[(theSpotsSt->flags & CRYSTAL_MASK)]->crystalColor,true,true);	}	D_HUnlock(value);	graph	->	SetValues			(0L,(Handle)value);		theSpots = theSpotsSt;	obj_Index->CopyPtrToIndex((Ptr)&(theSpots[k]));	sprintf			(gTheText,"g-vector ");	obj_Index->IndexToText	(theText);	p2cstr			((unsigned char*)theText);	strcat			(gTheText,theText);	graph	->SetTitleY(gTheText);	sprintf			(gTheText,"Thickness in nm");	graph	->SetTitleX(gTheText);	sprintf			(gTheText,"Beam Intensity vs Thickness");	graph	->SetTitleGraph(gTheText);	graph	->	minX 	= trueThickness - (numberOfSteps * interval);	graph	->	maxX 	= trueThickness;	sprintf(gTheText,"Thickness Plot");	c2pstr(gTheText);	graph->titleMenu->P_DelMenuItem		(2);	graph->titleMenu->P_AppendMenu	(gTheText);	graph->titleMenu->P_CheckItem		(2,true);	graph	->ResetPlotMinMax	();	//graph	->PlotGraph();	newPictReq = true;		KillPtr(intensities);END_THRU_THICK:		KillHandle((Handle*)&value);		StopWatch();	}void DiffractObject::CriticalVoltagePlot(SpotInfoPtr theSpotsSt)//bloch{	double 		*intensities;	char		theText[200];	Rect		theRect;	short		i;	SpotInfoPtr theSpots;	double		matrix[3][3];	rreal		**theUgReal,**theUgIm;	short		nBeams, pBeams;	long		start,totalBeams,maxBeams;	double		delEnergy,oldEnergy;	double		**value,*val;	Identity_Matrix(matrix);	if(theSpotsSt[spotLoc].flags & BETH_PERTURB)return;	if(!GetStartStop(theSpotsSt,&start,&totalBeams))return;	if(totalBeams > 100){		if(TooManyBeams(totalBeams)){			return;		}	}		StartWatch();	delugeFlag = false;	delEnergy = energy / numPoints;	value = (double**)D_NewHandle(numPoints * sizeof(double));	D_HLock(value);	val = *value;	oldEnergy = energy;	energy = 0;	if(calcIntensities)KillHandle((Handle*)&calcIntensities);	calcIntensities = 0L;	for(i = 0; i < numPoints;i++,val++){		energy += delEnergy;		switch(theBeamFlag)		{			case 1:				theEBeam->		SetWaveAndEnergy(energy);				wavelength	=	theEBeam->wavelength;				break;			case 2:				wavelength 	= 	12.4 / energy;				break;			case 3:				break;		}		if(!SetUpUgh((Handle*)&theUgReal,(Handle*)&theUgIm,&nBeams,&pBeams,theSpotsSt,totalBeams)){ StopWatch();return;}		maxBeams = nBeams + pBeams;// + 10;		intensities =  BlochMethod(theUgReal,theUgIm,matrix,1,nBeams, pBeams,0L,theSpotsSt);		FREE_MATRIX(theUgReal,1,maxBeams,1,maxBeams);		FREE_MATRIX(theUgIm,1,maxBeams,1,maxBeams);		if(intensities == 0L) goto END_CRITICAL;		*val = *intensities;		if(fabs(*val) > 1){			*val = 0;		}		KillPtr(intensities);		sprintf(gTheText,"Percentage Complete %5.1f.",(double)((double)100 * i / (double)numPoints) );		theRuler->SetInfo(gTheText);		AllowBackground();	}	END_CRITICAL:	energy = oldEnergy;	switch(theBeamFlag)	{		case 1:			theEBeam->		SetWaveAndEnergy(energy);			wavelength	=	theEBeam->wavelength;			break;		case 2:			wavelength 	= 	12.4 / energy;			break;		case 3:			break;	}	SetRect(&theRect,thePictRect.right - 250,thePictRect.bottom - 250,		thePictRect.right - 40,thePictRect.bottom - 100);	if(graph == 0L){		graph	= (GraphFunction*)D_new(GraphFunction);		graph	->	DoInit(theRect,theCrystal[(theSpotsSt->flags & CRYSTAL_MASK)]->crystalColor,true,true);	}	D_HUnlock(value);	graph	->	SetValues			(0L,(Handle)value);	KillHandle((Handle*)&value);	theSpots = theSpotsSt;	obj_Index->CopyPtrToIndex((Ptr)&(theSpots[spotLoc - start]));	sprintf			(gTheText,"g-vector ");	obj_Index->IndexToText	(theText);	p2cstr			((unsigned char*)theText);	strcat			(gTheText,theText);	graph	->SetTitleY(gTheText);	sprintf			(gTheText,"Voltage in kV");	graph	->SetTitleX(gTheText);	sprintf			(gTheText,"Beam Intensity vs Energy");	graph	->SetTitleGraph(gTheText);	graph	->	minX 	= delEnergy;	graph	->	maxX 	= energy;	graph	->ResetPlotMinMax	();	//graph	->PlotGraph();	sprintf(gTheText,"Critical Voltage");	c2pstr(gTheText);	graph->titleMenu->P_DelMenuItem		(2);	graph->titleMenu->P_AppendMenu	(gTheText);	graph->titleMenu->P_CheckItem		(2,true);	newPictReq = true;		StopWatch();	}Boolean DiffractObject::SetUp2BeamUgh(Handle* theUgReal,Handle *theUgIm,short *nbeams,short *pBeams,SpotInfoDPtr theSpotsSt,short totalBeams){	Crystal 	*thisCrystal;	double		electronMassRation;	double 		*theUs,*theVs,*theWs,*theZs,*theBs;	double		H,K,L;	double		theD;	dcomplex	sF,abC;	short		atom_Count;		Ptr*		theHandle;	short			maxBeams;	SpotInfoDPtr		theSpots;	SpotInfoDPtr		theSpots2;	rreal			**theHR,**theHI;		long			i,j;	short			nBeams;	double			ratio;	*nbeams = *nbeams;	totalBeams = totalBeams;	nBeams			=	2;	pBeams			=	0;	maxBeams 	= nBeams;// + 10;		theSpotsSt->h = theSpotsSt->k = theSpotsSt->l = 0;//sets beam to 0,0,0			*theUgReal 	= (Handle)MATRIX(1,maxBeams,1,maxBeams);	theHR = (rreal**)*theUgReal;	if(*theUgReal == 0L) return false;			*theUgIm	= (Handle)MATRIX(1,maxBeams,1,maxBeams);	theHI = (rreal**)*theUgIm;	if(*theUgIm == 0L){FREE_MATRIX(theHI,1,maxBeams,1,maxBeams); return false;}		ratio 	= (.006648352) * (1 + (1.9569341e-3 * energy));// this converts Vg to Ug, Vg is the fourier components of the 	for(i = 1; i <= maxBeams;i++){		for(j = 0; j <= maxBeams;j++){		 theHI[i][j] = theHR[i][j] = 0; 		}	}		thisCrystal = theSpotsSt->theCrystal;	electronMassRation = 1. + ( (double)energy / 511.);	theHandle 	= thisCrystal->AtomicScatteringSet(electronMassRation,theBeamFlag);		if(!SetScatteringPosAIntensity(thisCrystal,&theUs,&theVs,&theWs,&theZs,&theBs,&atom_Count)){//Timebomb!!//*atom_Count cannot be the same address as *crystal->Atom_Couynt  or you will continually increase the number		FREE_MATRIX(theHR,1,maxBeams,1,maxBeams);		FREE_MATRIX(theHI,1,maxBeams,1,maxBeams);		thisCrystal->ClearAtomicScatSet(theHandle);		return 0;	}	/* this calculates the off diagonal Ug-h terms required for the Bloch wave matrix*/	//is the additional beams which are treated as a perturvbation on the blach wave matrix.	theSpots = theSpotsSt;	theSpots++;//offsets base spots	abC.i = 0;	abC.r = 0;	 D_HLock((Handle)  theHandle); 	for( i = 2;i <= nBeams;theSpots++,i++){//nBeams = nbeams + pbeams		theSpots2 = theSpotsSt;		for(j = 1; j <= i;theSpots2++, j++)		{			H = theSpots->h - theSpots2->h;			K = theSpots->k - theSpots2->k;			L = theSpots->l - theSpots2->l;			theD = theSpots->x;			if(theD < .00001) theD = .00001;			AtomicScatterForDFromSet(theD,theHandle,theZs,atom_Count);						sF	= StructureFactor(H,K,L,theUs,theVs,theWs,atom_Count,theZs,theBs,thisCrystal->volume,1/theD);			if(g_absorpFlag){				abC = AbsorptionCoefficient(H,K,L,theUs,theVs,theWs,thisCrystal,theBs,energy,theD * .5);				abC.i *= ratio;				abC.r *= ratio;			}						theHR[IJ] 	= (sF.r - abC.i);// * ratio;// sF.r - absorpFIM, the absorptions needs to be calucualed,ratio converts Vg to Ug			theHI[IJ] = (sF.i + abC.r);// * ratio;// sF.i + absorpFRe			theHR[JI] 	= (sF.r + abC.i);// * ratio;//sF.r + absorpFIM			theHI[JI] = (-sF.i + abC.r);// * ratio;// -sF.i + absorpFRe					}	}	D_HUnlock((Handle)  theHandle); 	thisCrystal->ClearAtomicScatSet(theHandle);	KillPtr((Ptr)theUs);	return true;}