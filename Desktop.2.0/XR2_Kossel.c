//ects:D.M. v2.0:Sources.Jim:Desktop.2.0:XR2_Kossel.c#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"StereoObject.h"#include	"KikuchiObject.h"#include 	"Kikuchi_Line.h"#include	"KosselObj.h"void	KosselObj::DoMenu(long	theResult){	short	theMenu,theItem;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);	switch(theMenu){		case	FUNCTION_MENU:			switch(theItem){				case	4:					((KikuchiLine*)theKLines)->SetScaleFactor(cameraConstant,wavelength,centerX,centerY);					break;				case 7:					theResult &= 0xFFFF0000;					theResult += 12;					break;				default:					break;			}			break;				default:			break;	}	inherited::DoMenu(theResult);}void	KosselObj::DoInit()			/* initialize object			*/{	theKLines = (KikuchiLine*)D_new(KikuchiLine);		inherited::DoInit();	theKLines->DoInit(false,theCrystal[0]);	return;}void	KosselObj::DoClose(void){	theKLines->DoClose();	inherited::DoClose();}Boolean		KosselObj::DoContent(Point thePoint){	SpotInfo theSpot;	double x,y,z,mu,lambda;	switch(functionID){		case ADD_SPOT_SIMPLE_F:			if(IsPressed((unsigned short )58) ){				((KikuchiLine*)theKLines)->SetAngle(thePoint);			}			GetMuLambda(thePoint,&mu,&lambda,false);			ConvertMuLambdaToXYZ(&x,&y,&z, mu, lambda);			theSpot.x = x;			theSpot.y = y;			theSpot.z = z;			((KikuchiLine*)theKLines)->Add( 0, &theSpot, thePoint);					return false;		default:		break;	}	inherited::DoContent( thePoint);	return false;}void 	KosselObj::CleanLabel(TextObj* line){	short hor,ver;	hor = (line->lineRect.left + line->lineRect.right) / 2;	ver = (line->lineRect.top + line->lineRect.bottom) / 2;	line->lineRect.left = line->lineRect.right = hor;	line->lineRect.top = line->lineRect.bottom = ver;}