//m:Desktop.2.0:Monte Carlo 2:MO2_MonteCarloObj.c#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include 	"MonteCarloObj.h"#include 	"GraphObject.h" #include	"GraphFunction.h"#include	"UA2_Text_Box.h"#include 	"UextBoxFree.h"#include 	"mathRecipies.h"#define		MONTE_CARLO_DEF   350#define		MONTE_CARLO_DEFINE_MENU  400;void		MonteCarloObj::DoInit(void)	{	short i;	for(i = 0; i < NUM_OF_STAT_PLOTS;i++){		statHandle[i] 		= D_NewHandle(101 * sizeof(double));		D_HLock(statHandle[i] );	}		statPlot		=	0;	noEVChannels	= 1024;	gridFlag = true;	i = 0;	IRP 	= (double*)*(statHandle[i++]);	IPL 	= (double*)*(statHandle[i++]);		depth_Ex 		= (double*)*(statHandle[i++]);	ELE 	= (double*)*(statHandle[i++]);	ELN 	= (double*)*(statHandle[i++]);	e_Total = (double*)*(statHandle[i++]);	DMG 	= (double*)*(statHandle[i++]);	radial_Dis 		= (double*)*(statHandle[i++]);	radial_EL_Loss	= (double*)*(statHandle[i++]);	radial_Nuc_Loss	= (double*)*(statHandle[i++]);	radial_Total_Loss	= (double*)*(statHandle[i++]);	radial_Dam_Loss	= (double*)*(statHandle[i++]);	backEVDis 		= (double*)*(statHandle[i++]);	forwardEVDis	= (double*)*(statHandle[i]);		numberOfIons 		= 20;	channelWidth 		= 10;	channel1Start 		= 1;	ionFinalCutoffEnergy = 50;	stoppingCorrection 	= 1;	graph			=	0L;	inherited::DoInit();	}		void	MonteCarloObj::	DoAuxWrite(void){	inherited::DoAuxWrite();}void	MonteCarloObj::DoAuxRead(void){	inherited::DoAuxRead();}void	MonteCarloObj::MyCalculate(void){	double 	atWtRatio,atomicDensity,pwr,cosinAlpha,sinAlpha;	double 	randNum1,randNum2,positionSum,positionSumSqrd;	double 	lowEPath,phi,impactParm,pathIntervalConst,screeningLength,reducedEFactor;	double 	sinScatAngle,cosScatAngle,labScatAngle,initFreeFlightDist;	double	KL,K,FD,IO,EPSBK,SBK,KD,PL,EPS,EPSB,SL,SB,LS=0.0,SE;	double 	QE,DEE,ASIG,B,EC,S2,C2,DEN,EPD,G,PathLengthSum;	double 	PathLengthSumSqrd,numberImplanted,thisPL;	double 	theX,theY,theZ,sinLabScatCosPhi,sinLabScatSinPhi,cosLabScat,newZ,newY;	double 	xPos,yPos,zPos,twoPi,shift=1.0;	short	offset;	double	energyEV;	short 	IH,IC,I,IP,j;	Vector	*theSpots,*thisSpot;	long	idum = -1;	RandomNumber(&idum);	energyBackScat=0.0;	numberBackScat=0;	numberXmited=0;	energyXmited=0.0;	if(theDataHandle != 0L) /*Temp*/KillHandle(&theDataHandle);	if(data_Length <= 99) data_Length = 100;	theDataHandle		= 	/*Temp*/D_NewHandle(data_Length * data_Size);//,&gTheOSError	/*MFTemp*/D_HLock(theDataHandle);	theSpots			= 	(Vector*)*theDataHandle;		positionSum = positionSumSqrd = PathLengthSum = PathLengthSumSqrd = 0.0;	switch(theBeamFlag)	{		case 1:			incidentIonZ = 1;			incidentIonAtWt = ELECTRON_MASS * AVOGADROS_NUMBER  * 1000;			break;		case 2:			incidentIonZ = 1;			incidentIonAtWt = energy * 1000 * EV_TO_JOULES / (SPEED_OF_LIGHT * SPEED_OF_LIGHT);			break;		case 3:			incidentIonZ = theIon->element;			incidentIonAtWt = theIon->mass;			break;	}			CalculateTargetValues();				for(j = 0; j <= noOfChannels ; j++){		IRP[j] 		= 0;		IPL[j] 	= 0;			depth_Ex[j] 		= 0;		ELE[j] 	= 0;		ELN[j] 	= 0;		e_Total[j] = 0;		DMG[j] 	= 0;		radial_Dis[j] 		= 0;		radial_EL_Loss[j]	= 0;		radial_Nuc_Loss[j]	= 0;		radial_Total_Loss[j]	= 0;		radial_Dam_Loss[j]	= 0;	}	for(j = 0; j <= noEVChannels;j++){			backEVDis[j] = forwardEVDis[j] = 0;	}	twoPi = 2.0 * PI;		atWtRatio 			= incidentIonAtWt / targetAtWt;	atomicDensity		= .6022 * targetDensity / targetAtWt;		pwr 					= 	2.0 / 3.0;	screeningLength 		= 	.529 * .8853 / pow((sqrt(incidentIonZ) + sqrt(targetZ)),pwr);	reducedEFactor 			= 	screeningLength * 								targetAtWt / 	(incidentIonZ * targetZ * 14.4 *													(incidentIonAtWt + targetAtWt));		reducedE 			= reducedEFactor * energy * 1000.;	pathIntervalConst 	= .02 * pow((1.0 + atWtRatio),2.0) / (4.0 * PI * screeningLength * screeningLength * atomicDensity);	initFreeFlightDist	= pathIntervalConst * (pow(reducedE,2.0) + .052 * pow(reducedE,1.32)) / log(1.0 + reducedE);	lowEPath 			= pow(atomicDensity,(-1.0 / 3.0));	{		double justHold,justHold1;		KL = 1.212 * pow(incidentIonZ,(7./6.)) * targetZ;		justHold = pow((pow(incidentIonZ,(2./3.)) + pow(targetZ,(2./3.))),1.5);		justHold1 =	sqrt(incidentIonAtWt);		KL /=	justHold * justHold1; 	}	K = stoppingCorrection * KL;	KD = .1334 * pow(targetZ,(2./3.)) / sqrt(targetAtWt);	FD = .01024 / pow(targetZ,(7./3.)); 	if(targetZ < 13){		IO = 12.0 + 7.0 / targetZ;	} else {		IO = 9.76 + 58.5 * pow(targetZ,-1.19);	}	EPSBK = 1.0 / (456.0 * targetZ * incidentIonAtWt * IO);	SBK = 8.0 * PI * pow((incidentIonZ * 14.4),2.0) * atomicDensity / IO;	incidentIonInitPos	=	0;	offset = channel1Start;	IH = 0;	data_Count = 0;		while(IH < (short)numberOfIons && gNoBreak){		IH++;		theX = cos(incidentIonAngle);		theY = sin(incidentIonAngle);				yPos = xPos =  theZ = 0.0;		zPos = incidentIonInitPos;		if(plotFlags[4]){			if(data_Count >= data_Length){				ExpandMemory();				if(!gNoBreak) goto L170;				theSpots			= 	(Vector*)*theDataHandle;			}			thisSpot 			= 	&(theSpots[data_Count++]);			thisSpot->x = -12;			thisSpot->y = -12;			thisSpot->y = -12;								}				/*sprintf(gTheText,"Particles Left = %d",((short)numberOfIons - IH + 1));		MoveTo(40,80);		dm_EraseRect(&thePictRect);		DrawString(c2pstr(gTheText));*/				energyEV 		= energy * 1000.;		cosinAlpha		= cos(incidentIonAngle);		sinAlpha		= sin(incidentIonAngle);		PL = 0.0;		IC = 0;		randNum1 	= RandomNumber(&idum); 	while(energyEV > ionFinalCutoffEnergy && zPos >= 0.0 && 											zPos <= theFoilThickness){																															L40:		randNum2	= RandomNumber(&idum);			EPS = energyEV * reducedEFactor;			SL = K * atomicDensity * sqrt(energyEV);			if(EPS > 10.0){				EPSB = EPSBK * energyEV;				SB = SBK * (log(EPSB + 1.0 + (.5 / EPSB)) / EPSB);/*SB nust be Bethn relation*/				SE = 1.0 / ((1.0 / SL) + (1.0 / SB));			} else {L50:			SE = SL;			}L60:		IC++;			if(IC <= 2 || LS != lowEPath){L70:			LS = pathIntervalConst * (EPS * EPS + .052 * pow(EPS,1.32)) / (log(1.0 + EPS) * randNum1);				randNum1 = 1.0;				if(LS > lowEPath){					DEE = SE * LS;					QE = 20.0 * DEE / energyEV;					if(QE > 1.0)						LS /= QE;					if(LS < lowEPath)						LS = lowEPath;				} else {L80:				LS = lowEPath;				}L90:			ASIG = LS * atomicDensity;			}L100:		DEE = SE * LS;  /*SE = dE/dS  or loss in energy as a function of step size, LS = length of step*/			if(LS != lowEPath){L110:			impactParm = sqrt(-log(randNum2) / ASIG / PI);			} else {L120:			impactParm = sqrt(randNum2 / ASIG / PI);			}			B = impactParm / screeningLength;			EC = 4.0 * atWtRatio / pow((1.0 + atWtRatio),2.0) * energyEV;			if(EPS > 10){				S2 = 1.0 / (1.0 + pow((2.0 * EPS * B),2.0));				C2 = 1.0 - S2;			} else {L130:			C2 = Magic(EPS,B);				S2 = 1.0 - C2;			}L140:		DEN = EC * S2;			energyEV -= (DEN + DEE);/*DEE loss in Energy for step due to electron cloud, DEN loss in Energy due to nuclear*/			PL += (LS / channelWidth);			phi = twoPi * RandomNumber(&idum);			cosScatAngle = 1.0 - 2.0 * C2;/*2.0 * C2 - 1.0;*/			sinScatAngle = sqrt(1.0 - cosScatAngle * cosScatAngle);			labScatAngle = atan(sinScatAngle / (cosScatAngle + atWtRatio));						cosinAlpha = cosinAlpha * cos(labScatAngle) + sinAlpha * sin(labScatAngle) * cos(phi);			sinAlpha = sqrt(1.0 - cosinAlpha * cosinAlpha);						sinLabScatSinPhi = sin(labScatAngle) * sin(phi);			sinLabScatCosPhi = sin(labScatAngle) * cos(phi);			cosLabScat = cos(labScatAngle);			/*newX = theX * cosLabScat + theY * sinLabScatSinPhi + theZ * sinLabScatCosPhi;*/			newY = theX * sinLabScatCosPhi + theY * cosLabScat + theZ * sinLabScatSinPhi;			newZ = theX * sinLabScatSinPhi + theY * sinLabScatCosPhi + theZ * cosLabScat;			theY = newY;			theZ = newZ;			theX = cosinAlpha;			{				short num;				num = (sqrt((xPos * xPos) + (yPos * yPos)) / (channelWidth * 10));				if(num < 0) num = 0;				if(num > noOfChannels) num = noOfChannels;				radial_Dis[num]++; 				radial_EL_Loss[num]  += DEE;				radial_Nuc_Loss[num]  += DEN;				radial_Dam_Loss[num]  += (DEN / (1.0 + (KD * G)));				radial_Total_Loss[num] += DEE + DEN;			}			xPos += (theY * LS);			yPos += (theZ * LS);			zPos += (theX * LS);						if(plotFlags[4]){				if(data_Count >= data_Length){ 					ExpandMemory();					if(!gNoBreak) goto L170;					theSpots			= 	(Vector*)*theDataHandle;				}				thisSpot 			= 	&(theSpots[data_Count++]);				thisSpot->x = xPos;				thisSpot->y = yPos;				thisSpot->z = zPos;			} 						//position += (LS * cosinAlpha);			//position = zPos;			if(zPos >= 0.0 && zPos <= theFoilThickness){				I = (short)(1.0 + (zPos - offset) / channelWidth);				if(I < 0)					I = 0;				if(I > noOfChannels)					I = noOfChannels;				ELE[I] += DEE;				ELN[I] += DEN;				depth_Ex[I]++;				EPD = FD * DEN;				G = EPD + .40244 * pow(EPD,.75) + 3.4008 * pow(EPD,.1667);				DMG[I] += (DEN / (1.0 + (KD * G)));				e_Total[I] += DEE + DEN;			}		}				AllowBackground();		if(zPos >= 0.0 && zPos <= theFoilThickness){			IRP[I]++;			IP = (short)(PL + 1.0);			if(IP > noOfChannels)				IP = noOfChannels;			IPL[IP]++;			positionSum 		+= zPos;			thisPL 				= fabs(PL * channelWidth);			PathLengthSum 		+= thisPL;			positionSumSqrd 	+= (zPos * zPos);			PathLengthSumSqrd 	+= (thisPL * thisPL);		} else if(zPos < 0.0){			short n;L150:		numberBackScat++;			energyBackScat += energyEV;			n = 1 + ((energyEV - ionFinalCutoffEnergy) / channelEV);			if(n > noEVChannels)n = noEVChannels;			if(n < 0)n = 0;			backEVDis[n]++;		} else if(zPos > theFoilThickness){			short n;L160:		numberXmited++;			energyXmited += energyEV;			n = 1 + ((energyEV - ionFinalCutoffEnergy)  / channelEV);			if(n > noEVChannels)n = noEVChannels;			if(n < 0)n = 0;			forwardEVDis[n] ++;		}	}L170:	numberTotal = IH;	numberImplanted = (double)(numberTotal  - numberBackScat - numberXmited);	aveRange = positionSum / numberImplanted;	avePathLength = PathLengthSum / numberImplanted;	aveRangeSigma = sqrt((positionSumSqrd - numberImplanted * aveRange * aveRange) / 							numberImplanted);	avePathLengthSigma = sqrt((PathLengthSumSqrd -  numberImplanted * avePathLength * avePathLength) / 									numberImplanted);														   	x = 10;	y = 50;		if(data_Length >  data_Count){		D_RecoverMemory		(theDataHandle,data_Size,(long)data_Count);	}	data_Length 	= 	data_Count;	/*MFTemp*/D_HUnlock			((Handle)theDataHandle);	if(textBox == 0L){		Rect rDataBnds,theRect;		Point 		cellSize;		textBox				=	(TextBoxFree*)D_new(TextBoxFree);		SetRect(&rDataBnds,0,0,1,8);		SetRect(&theRect,300,100,540,300);		cellSize.h = 80;		cellSize.v = 15;		textBox		-> DoInit(&theRect,&rDataBnds,cellSize,0,theWindow,false,true,true,true,true,true,geneva,9,0);		textBox		-> ResetCell();		textBox		->selected = true;		textBox		-> SetColumnWidth(0,110);		textBox		->selected = false;		textBox->SetDrawFlag(true);			}	if(textBox)AddTextToBox();	return;}void	MonteCarloObj::DoPictDraw(void){	Vector *thisSpot;	long	i;	RgnHandle		theNewClip;		SetPort(gCurrentObj->theWindow);	reSizeFlag = true;	SetDrawEnviron();		if(plotFlags[4]){		double del;		short startY,startX;		PenNormal();		DMForeColor(COMPLEMENT_COLOR);		thisSpot = (Vector*)*theDataHandle;		scaleFactor = (double)(.5 * (double)(thePictRect.bottom - thePictRect.top - 40)) / theFoilThickness;		centerX = (thePictRect.right - thePictRect.left) * .125;		centerY = 90;		startY = centerY - 30 * cos(incidentIonAngle);		startX = centerX - 30 * sin(incidentIonAngle);		MoveTo(centerX,centerY);		LineTo(startX,startY);		gTheRect.left 	= 	thePictRect.left + 5;		gTheRect.top 	= 	centerY;		gTheRect.bottom =  	centerY + theFoilThickness * scaleFactor;		gTheRect.right 	= 	thePictRect.left + (centerX * 2) + 5;		dm_FrameRect(&gTheRect);				if(gridFlag){			double startHor,startVer;			SetMarqueePattern(NUL);			del = (double)(gTheRect.bottom - gTheRect.top) / 10;			startHor = gTheRect.left + del;			startVer = gTheRect.top + del;			for(i = 0; i < 9; i++){				if(startHor < gTheRect.right){					MoveTo((short)startHor,(short)gTheRect.top); LineTo((short)startHor,gTheRect.bottom - 1);				}				MoveTo(gTheRect.left,(short)startVer); LineTo(gTheRect.right - 1,(short)startVer);				startVer += del;				startHor += del;			}			PenNormal();		}		GetClip(gTheRgn);		theNewClip = D_NewRgn();		RectRgn(theNewClip,&gTheRect);		D_SetClip(theNewClip);				for(i = 0; i < data_Count;i++,thisSpot++){			if(thisSpot->x < -11 && thisSpot->y < -11){				StartIon();			}else{				DrawPath(thisSpot->x,/*thisSpot->y,*/thisSpot->z,baseCrystal);			}		}		D_SetClip(gTheRgn);		D_DisposeRgn(&theNewClip);			PenNormal();		DMForeColor(BLACK);		MoveTo(gTheRect.left + 3,gTheRect.bottom + 20);		sprintf(gTheText,"Grid Division = %5.2f nm",del / (scaleFactor * 10));		DrawString(c2pstr(gTheText));	}//	if(graph != 0L){//		graph	-> PlotGraph();//	}	ClearDrawEnviron();	}void MonteCarloObj::AddTextToBox(void){		{			int iTemp;		short theX,theY,theXNew;		//inherited::DrawTheText();		if(textBox== 0L) return;		theX = (thePictRect.right - thePictRect.left) * .5;		theY = centerY - 30;		textBox->SetDrawFlag(false);		textBox->ResetCell();				TextFont(3);		TextSize(8);		theXNew = theX;		theXNew = DrawData(theXNew,theY,incidentIonZ,"Incident Z",1);		theXNew = DrawData(theXNew,theY,incidentIonAtWt,"Incident  M",1);		theXNew = DrawData(theXNew,theY,targetZ,"Target  Z",1);			theXNew = DrawData(theXNew,theY,targetAtWt,"Target  M",1);		theXNew = DrawData(theXNew,theY,targetDensity,"Density",1);				theXNew = DrawData(theXNew,theY,theFoilThickness / 10,"Thick. (nm)",1);								theY += 30;		theXNew = theX;											theXNew = DrawData(theXNew,theY,energy,"Inc. Ion Energy kV",1);			theXNew = DrawData(theXNew,theY,ionFinalCutoffEnergy,"Cutoff Energy",1);			theXNew = DrawData(theXNew,theY,incidentIonInitPos,"Initial Position",1);		theXNew = DrawData(theXNew,theY,incidentIonAngle * 180 / PI,"Initial Angle",1);		theXNew = DrawData(theXNew,theY,stoppingCorrection,"Stopping Correction",1);		theXNew = DrawData(theXNew,theY,channelWidth,"Channel Width",1);																										theY += 45;		theXNew = theX;			iTemp = numberTotal ;		theXNew = DrawData(theXNew,theY,iTemp,"Number of Ions",3);			theXNew = DrawData(theXNew,theY,reducedE,"Reduced Energy",1);		theXNew = DrawData(theXNew,theY,initFreeFlightDist,"In Free Flight Distance",1);					theY += 30;		theXNew = theX;				theXNew = DrawData(theXNew,theY,(double)numberBackScat,"# Back Scattered",3);		theXNew = DrawData(theXNew,theY,energyBackScat,"Back Scattered Energy",1);		theXNew = DrawData(theXNew,theY,(double)numberXmited,"# Emitted",3);		theXNew = DrawData(theXNew,theY,energyXmited,"Emitted Energy",1);				theY += 30;		theXNew = theX;		theXNew = DrawData(theXNew,theY,aveRange / 10,"Avg Proj Range",2);			theXNew = DrawData(theXNew,theY,aveRangeSigma / 10,"Proj Range Std. Dev.",2);			theXNew = DrawData(theXNew,theY,avePathLength / 10,"Avg Path Length",2);		theXNew = DrawData(theXNew,theY,avePathLengthSigma / 10,"Path Length Std Dev",2);		textBox->SetDrawFlag(true);				TextFont(0);		TextSize(12);	}}void	MonteCarloObj::DrawTheText(void){	}short 	MonteCarloObj::DrawData(short theX,short theY,double theData,char *aText,short i){	short length = 0;	short	flag = 1,j = 1,start = 0,stop = 0;	char	theText[255];	char	text[255];	strcpy(text,aText);	if(theData > 1E40 || theData < -1E40)theData = 0.0;	if(text[0] == (char)0)return 0;	while(text[j] != (char)0){		if(text[j] == '\r'){			flag++;			stop = j;			if(stop - start > length){				length = stop - start;				start = j;			}					}		j++;	}		stop = j;	if(stop - start > length){		length = stop - start;	}			if(flag > 1){		strncpy(theText,&text[start],length);		theText[length + 1] = (char)0;		length = StringWidth((unsigned char*)c2pstr(theText));		start = 0;		j = 0;		while(text[j] != (char)0){			if(text[j] == '\r'){				strncpy(theText,&text[start],j - start);				theText[j - start] = (char)0;				DrawCenteredText(theX + (length / 2),theY,theText);				theY += 10;				start = j + 1;			}			j++;		}		strncpy(theText,&text[start],j - start);		theText[j - start] = (char)0;		DrawCenteredText(theX + (length / 2),theY,theText);			theY += 11;	}else{		length = StringWidth((unsigned char*)c2pstr(text));		DrawCenteredText(theX + (length / 2),theY,p2cstr((unsigned char*)text));		theY += 11;	}			switch(i){		case 1:			sprintf(gTheText,"%10.4f",theData);			break;		case 2:			sprintf(gTheText,"%10.2f",theData);			break;		case 3:			sprintf(gTheText,"%d",(short)theData);			break;		default:		break;	}			DrawCenteredText(theX + length / 2,theY,gTheText);	length += theX + 10;	return length;}short 	MonteCarloObj::DrawCenteredText(short theX,short theY,char *theText){	short length;		textBox->AddListText(theText);	return 0;	length = StringWidth((unsigned char*)c2pstr(theText));	theX -= length / 2;	MoveTo(theX,theY);	DrawString((unsigned char*)theText);	return length;}void	MonteCarloObj::SetObjectWindowTitle(void){															theBeamFlag = 3;	energy = theIon->energy;	theRuler->SetBeamButton(theBeamFlag);		data_Length			=	500;	data_Expand			=	500;	data_Count			=	0;	data_Size			=	sizeof(Vector);	theCurvedLabels 	= NULL;	theLabels			= NULL;		incidentIonZ = theIon->element;	incidentIonAtWt = theIon->mass;	targetDensity = theCrystal[0]->CrystalDensity(&targetAtWt,&targetZ);	plotFlags[4] = true;	incidentIonAngle 	= AngleBetFoilAndBeam(theFoilNormal,theFNRotationAxis,theFoilBragg,theFNRotationAngle,theFNOffLaueDistance,0,calcFoil);	if(gTheFile->file_is_Open){		SetWTitle(theWindow,fileInfo.sfFile.name);		return;	}	sprintf(gTheText,"Monte Carlo Calcs. %d",g_Window_Number);	SetWTitle(theWindow,c2pstr(gTheText));	g_Window_Number++;	if(theWindow != 0L)		ActivatePalette(theWindow);}void	MonteCarloObj::SetObjectMenu(void){	theMenuBar = GetNewMBar(MONTE_CARLO_MB);	ClearMenuBar();/* July 1992 */	SetMenuBar	(theMenuBar);}void	MonteCarloObj::DoMenu(long theResult){	short theMenu,theItem;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);	switch(theMenu){		case 400:			switch(theItem){				case 1:					//DoDefine();					DoSetUp();					break;				case 2:					changedFlag = true;					reSizeFlag = true;					break;				case 4:				case 5:					ShowGraph(theItem - 4);					break;				case 7:				case 8:				case 9:				case 10:				case 11:					ShowGraph(theItem - 5);					break;				case 13:				case 14:				case 15:				case 16:				case 17:					ShowGraph(theItem - 6);					break;				case 19:				case 20:					ShowGraph(theItem - 7);					break;				default:					break;							}			break;		default:			inherited::DoMenu(theResult); 		break;	}	HiliteMenu(0);	return;}void	MonteCarloObj::CalculateTargetValues(void){	short i;	targetDensity = CalcExpDenZA(baseCrystal,theCrystal,the_PPT_Info,plotFlags,&targetZ,&targetAtWt);	noOfChannels = 1 + (( theFoilThickness - channel1Start) / channelWidth);	channelEV		=	((energy * 1000) - ionFinalCutoffEnergy)/(double)noEVChannels;	for(i = 0; i < NUM_OF_STAT_PLOTS;i++){		D_HUnlock(statHandle[i]);		KillHandle(&(statHandle[i]));		if(i < 12)			statHandle[i] 		= D_NewHandle((noOfChannels + 1) * sizeof(double));		else				statHandle[i] 		= D_NewHandle((noEVChannels + 1) * sizeof(double));		D_HLock(statHandle[i]);	}		i = 0;	IRP 	= (double*)*(statHandle[i++]);	IPL 	= (double*)*(statHandle[i++]);	depth_Ex 		= (double*)*(statHandle[i++]);	ELE 	= (double*)*(statHandle[i++]);	ELN 	= (double*)*(statHandle[i++]);	e_Total = (double*)*(statHandle[i++]);	DMG 	= (double*)*(statHandle[i++]);	radial_Dis 		= (double*)*(statHandle[i++]);	radial_EL_Loss	= (double*)*(statHandle[i++]);	radial_Nuc_Loss	= (double*)*(statHandle[i++]);	radial_Total_Loss	= (double*)*(statHandle[i++]);	radial_Dam_Loss	= (double*)*(statHandle[i++]);	backEVDis 		= (double*)*(statHandle[i++]);	forwardEVDis	= (double*)*(statHandle[i]);	if(foilParallel)		incidentIonAngle 	= PI * stage		->tilt / 180;	else		incidentIonAngle 	= AngleBetFoilAndBeam(theFoilNormal,theFNRotationAxis,theFoilBragg,theFNRotationAngle,theFNOffLaueDistance,0,calcFoil);	}double MonteCarloObj::Magic(double EPS,double B){	double RR,EX1,EX2,EX3,V,FR,R,V1,FR1,Q,ROC,SQE,CC,AA,FF,DELTA,C,value;		R = B;										/* reduced interatomic seperation */ 	RR = log(.35 / (EPS * B)) / .3;	if(RR >= B){		RR = log(.35 / (EPS * RR)) / .3; 		if(RR >= B)			R = RR;	}		Q = R;	while(fabs(Q / R) > .001){L20:	EX1 	= exp(-.3 * R);		EX2 	= pow(EX1,4.0);		EX3 	= pow(EX2,5.0);		V 		= (.35 * EX1 + .55 * EX2 + .1 * EX3) / R; 		/* Molieres screening func */		FR 	= (B * B / R) + (V * R / EPS) - R;		V1 	= -(V + .105 * EX1 + .66 * EX2 + .6 * EX3) / R;		FR1 	= -B * B / (R * R) + (V + V1 * R) / EPS - 1.0;		Q 		= FR / FR1;		R -= Q;	}	ROC 		= -2.0 * (EPS - V) / V1;	SQE 		= sqrt(EPS);	CC 			= (.009611 + SQE) / (.005175 + SQE);	AA 			= 2.0 * EPS * (1.0 + (.6743 / SQE)) * pow(B,CC);	FF 			= (sqrt(1.0 + AA * AA) - AA) * ((6.314 + EPS) / (10.0 + EPS));	DELTA 		= (R - B) * AA * FF  / (FF + 1.0);	C 			= (B + DELTA + ROC) / (R + ROC);	value		= C * C;	return(value);}double MonteCarloObj::RandomNumber(long *idum){		/*theNum = ((long double)Random() + 32767.0) / 65534.0;	return theNum;*/	return (double)ran1(idum);}void MonteCarloObj::DoClose(void){	short i;	for(i = 0; i < NUM_OF_STAT_PLOTS;i++){		D_HUnlock(statHandle[i]);		KillHandle((Handle*)&statHandle[i]);	}		inherited::DoClose();}void MonteCarloObj::StartIon(void){	short x,y;		x = centerX;	y = centerY;	MoveTo(x,y);}double MonteCarloObj::RandomSign(void){	if(Random() < 0){		return(-1.0);	} else {		return(1.0);	}}void MonteCarloObj::DrawPath(double theX,/*double theY,*/double theZ,short theCrystal){	short x,y;	if(g_Monitor)	{		DMForeColor(theCrystal + 10);	}else{		PenNormal();		DMForeColor(BLACK);	}	y = (short)(theZ * scaleFactor) + centerY;	x = (short)(theX * scaleFactor) + centerX;	LineTo(x,y);}void MonteCarloObj::ShowGraph(short plotType){	Handle	theHandle;	Rect theRect;	GraphFunction *agraph = 0L,*activeGraph = 0L;	if(plotType > NUM_OF_STAT_PLOTS) return;	theHandle = statHandle[plotType];	SetRect(&theRect,thePictRect.right - 250,thePictRect.bottom - 250,		thePictRect.right - 40,thePictRect.bottom - 100);	statPlot = plotType;	if(graph == 0L){						graph	= (GraphFunction*)D_new(GraphFunction);		graph	->	DoInit(theRect,theCrystal[baseCrystal]->crystalColor,true,true);				graph	->	SetValues(0L,(Handle)theHandle);		SetPlotTitles( graph,plotType);	}else{		activeGraph = graph->GetSelected();		if(!activeGraph)activeGraph = graph;		if(activeGraph->shrunk){			agraph	= (GraphFunction*)D_new(GraphFunction);			agraph	->	DoInit(theRect,theCrystal[baseCrystal]->crystalColor,false,true);			agraph	->	SetValues(0L,(Handle)theHandle);			SetPlotTitles( agraph,plotType);			graph	->	AddGraph(activeGraph,agraph,graph->frame);		}else{			activeGraph	->	SetValues(0L,(Handle)theHandle);			SetPlotTitles( activeGraph,plotType);		}	}			graph	->ResetPlotMinMax();	refreshFlag = true;	graph	->PlotGraph();}void MonteCarloObj::SetPlotTitles(GraphFunction* theGraph,short plotType){	short n;	if(!theGraph)return;	switch(plotType){		case 0:		sprintf(gTheText,"Particles");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Distance in nm");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Projected Range");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= channel1Start / 10;		theGraph	->	maxX 	= theFoilThickness / 10;		break;		case 1:		sprintf(gTheText,"Particles");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Distance in nm");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Path Length");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= channel1Start / 10;		theGraph	->	maxX 	= theFoilThickness / 10;		break;		case 2:		sprintf(gTheText,"Excitations");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Distance in nm");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Depth Excitation Distr.");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= channel1Start / 10;		theGraph	->	maxX 	= theFoilThickness / 10;		break;		case 3:		sprintf(gTheText,"Energy Loss");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Distance in nm");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Electronic Energy Loss");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= channel1Start / 10;		theGraph	->	maxX 	= theFoilThickness / 10;		break;		case 4:		sprintf(gTheText,"Energy Loss");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Distance in nm");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Nuclear Energy Loss");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= channel1Start / 10;		theGraph	->	maxX 	= theFoilThickness / 10;		break;		case 5:			sprintf(gTheText,"Energy Loss");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Distance in nm");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Total Energy Distribution");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= channel1Start / 10;		theGraph	->	maxX 	= theFoilThickness / 10;		break;		case 6:		sprintf(gTheText,"Energy Loss");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Distance in nm");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Nuclear Damage Distribution");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= channel1Start / 10;		theGraph	->	maxX 	= theFoilThickness / 10;		break;		case 7:		sprintf(gTheText,"Excitations");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Distance in nm");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Radial Excitation Distr.");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= channel1Start / 10;		theGraph	->	maxX 	= theFoilThickness / 10;		break;		case 8:		sprintf(gTheText,"Energy Loss");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Radial Distance in nm");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Radial Electron Energy Distr.");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= channel1Start / 10;		theGraph	->	maxX 	= theFoilThickness / 10;		break;		case 9:		sprintf(gTheText,"Energy Loss");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Radial Distance in nm");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Radial Total Energy Distr.");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= channel1Start / 10;		theGraph	->	maxX 	= theFoilThickness / 10;		break;		case 10:		sprintf(gTheText,"Energy Loss");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Radial Distance in nm");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Radial Nuclear Damage");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= channel1Start / 10;		theGraph	->	maxX 	= theFoilThickness / 10;		break;		case 11:		sprintf(gTheText,"Energy Loss");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Radial Distance in nm");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Backscattered Energy Distr.");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= channel1Start / 10;		theGraph	->	maxX 	= theFoilThickness / 10;		break;		case 12:		sprintf(gTheText,"Particles");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Energy in eV");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Backscattered Energy Distr.");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= ionFinalCutoffEnergy;		theGraph	->	maxX 	= energy * 1000;		break;		case 13:		sprintf(gTheText,"Particles");		theGraph	->SetTitleY(gTheText);		sprintf(gTheText,"Energy in eV");		theGraph	->SetTitleX(gTheText);		sprintf(gTheText,"Forward Scattered Energy Distr.");		theGraph	->SetTitleGraph(gTheText);		theGraph	->	minX 	= ionFinalCutoffEnergy;		theGraph	->	maxX 	= energy * 1000;		break;		break;	}	n = graph->titleMenu->P_CountMItems();	if(n > 1)	graph->titleMenu->P_DelMenuItem(n);	c2pstr(gTheText);	if(graph->titleMenu)graph->titleMenu->P_AppendMenu(gTheText);}void MonteCarloObj::DoIdle(void)//Override{		inherited::DoIdle();	}Boolean MonteCarloObj::DoContent(Point thePoint){		return inherited::DoContent(thePoint);}void MonteCarloObj::DoRefresh(void)//Override{	inherited::DoRefresh();}void  MonteCarloObj::DoDblClick  (Point thePoint)//Override{		inherited::DoDblClick  ( thePoint);}void  MonteCarloObj::DoKey  (char theChar)//Override{		inherited::DoKey(theChar);}