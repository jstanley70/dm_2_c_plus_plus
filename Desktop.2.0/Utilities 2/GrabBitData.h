/********************************************************************************//*								Application Notes								*//*																				*//*	The routines contained herein will work for 8 bit grey scale images only.	*//*	In general the user need only call GetDataFromPICT to obtain the image 		*//*	data. The GetDataFromPICT function scans the picture and responds to those	*//*	opcodes typical for this type of picture...it may be necessary to add a 	*//*	few more depending on the image capture software. The 8 bit data is 		*//*	converted into 16 bit words and pointer to an array is returned to the user.*//*	In the event of insufficient memory, the routine returns a 0 for the Ptr.	*//*	The DrawPixels routine can be used to display the data if desired.			*//*																				*//*	NOTE:	GetDataFromPICT returns a Ptr which must be disposed of using the 	*//*			the DisposePtr Toolbox call. Failure to do so once you no longer 	*//*			need the data will result in a somewhat less than gracefull 		*//*			termination.... ie. a crash.										*//*																				*//********************************************************************************//********************************************************************************//*								PackedBitsInfo									*//*																				*//*		The PackedBitsInfo structure is used to decode PICT opcode 0x0098. 		*//*	It is used to obtain information about the image and to generate the 		*//*	offset into the picture data.												*//*																				*//********************************************************************************/typedef struct PackedBitsInfo{		PixMap		thePixMap;		/* NOTE: compiler struct alignment can cause problems here */		short		ctSeed;		short		ctFlags;		short		ctSize;		ColorSpec	theColors[256]; /* NOTE: compiler struct alignment can cause problems here */		Rect		srcRect;		/* NOTE: compiler struct alignment can cause problems here */		Rect		destRect;		/* NOTE: compiler struct alignment can cause problems here */		short		mode;		short		dataStart;}PackedBitsInfo,*PackedBitsInfoPtr;					/********************************************************************************//*								GetDataFromPICT									*//*																				*//*	theData = GetDataFromPICT(thePicture,&rows,&columns);						*//*																				*//*		This routine returns a pointer of type unsigned short*. Within this 	*//*	data block the routine will return the intensity data. The routine also		*//*	returns the number of rows and columns in the image. In the event of an 	*//*	error a Ptr address of '0' is returned.										*//*																				*//********************************************************************************/Ptr GetDataFromPICT(PicHandle thePicture,short *rows,short *columns,short *bitDepth);/********************************************************************************//*								GetTheData										*//*																				*//*	theHandle = GetTheData(opcodeInfo,&dataSize,&rows,&columns);				*//*																				*//*		This routine returns a Handle to a byte array which was extracted from 	*//*	the picture. GetDataFromPICT calls this routine and converts the byte array	*//*	into a unsigned short array. This routine returns the number of pixels, the	*//*	number of rows and the number of columns. In the event of an error the 		*//*	routine returns a Handle value of '0'.										*//*																				*//********************************************************************************/Handle 	GetTheData(PackedBitsInfoPtr opcodeInfo,long *dataSize,short *rows,short *columns);/********************************************************************************//*									DrawPixels									*//*																				*//*	DrawPixels(theData,rows,columns);											*//*																				*//*		The DrawPixels routine takes a Ptr to an array of unsigned shorts and	*//*	the number of rows and columns and draws the bit data to the screen. This	*//*	routine is good for verification. It calls SetGrayPixel to generate the 	*//*	colors for the pixels.														*//*																				*//********************************************************************************/void	DrawPixels(unsigned short *theData,short rows,short columns);/********************************************************************************//*								SetGrayPixel									*//*																				*//*	SetGrayPixel(h,v,value);													*//*																				*//*		The SetGrayPixel routine takes horizontal and vertical pixel 			*//*	coordinates and a short value in the range 0 <= value <= 255 and sets the	*//*	pixel at the coordinates to a gray value.								 	*//*																				*//********************************************************************************/void	SetGrayPixel(short h,short v,unsigned short value);/********************************************************************************//*								DoOtherOPCODE									*//*																				*//*	if(!DoOtherOPCODE &opcodeInfo){												*//*																				*//*		The DoOtherOPCODE routine is invoked whenever an unexpeted OPCODE is	*//*	encountered. If the OPCODE is recognized by the routine, the opcode Ptr		*//*	is incremented the proper amount to allow processing to continue and the 	*//*	function return TRUE. If the OPCODE is not recognized, the Ptr is not		*//*	altered and the function returns FALSE.										*//*																				*//*	NOTE: Not all picture opcodes are included									*//*																				*//********************************************************************************/Boolean	DoOtherOPCODE(short **opcodeInfo);