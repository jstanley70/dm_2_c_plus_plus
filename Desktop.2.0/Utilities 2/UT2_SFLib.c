//ects:D.M. v2.0:Sources.Jim:Desktop.2.0:UT2_SFLib.c#include	"Diffract_INCs.h"#include	"SF_MathLib.h"double 	GetSFRatio(void);dcomplex  TotalStructureFactor(double h,double k,double l,double *theUs,double *theVs,			double *theWs,long num,double *theZs,double *theBs,double volume,double dspace,Crystal *thisCrystal,dcomplex *abC){		dcomplex sF;		sF	= StructureFactor( h, k, l,theUs,theVs,theWs, num,theZs,theBs, volume, dspace);		if(g_absorpFlag){			double ratio;			ratio = GetSFRatio() * (1 + (1.9569341e-3 * gCurrentObj->energy));//1 + 1.959034 is the electron mass ratio//this is already calc. for SF as part of the scattering crossection			*abC = AbsorptionCoefficient(h,k,l,theUs,theVs,theWs,thisCrystal,theBs, gCurrentObj->energy,dspace * .5);			abC->i *= ratio;			abC->r *= ratio;			sF.r -= abC->i;// * ratio;// sF.r - absorpFIM, the absorptions needs to be calucualed,ratio converts Vg to Ug			sF.i += abC->r;		}else{			abC->r = abC->i = 0;		}		return sF;	}dcomplex	StructureFactor(double h,double k,double l,double *theUs,double *theVs,			double *theWs,long num,double *theZs,double *theBs,double volume,double dspace){	short 	i;	long double 	imagePart = 0;	long double 	realPart = 0;	long double	angle;	dcomplex complexV;	double    ratio;	if(g_DebyeWaller){		return StructureFactorDW( h, k, l,theUs,theVs,theWs, num,theZs,theBs, volume, dspace);	}		i = 0;	while( i < num)	{			angle 		= 6.28318530717958648 * fmod((*theUs * h + *theVs * k + *theWs * l),1.0);		realPart 	+= 	*theZs * cos(angle);		imagePart +=	*theZs * sin(angle);				i++;		theUs++;theVs++;theWs++;theZs++;	}	complexV.r 	= (double)realPart;	complexV.i  = (double)imagePart;	//We use Born approximation to get new values multipy by h2 * eo * pi * 8 / mo e2	ratio = GetSFRatio();	return RCmul( ratio/ volume,complexV);	}dcomplex	StructureFactorDW(double h,double k,double l,double *theUs,double *theVs,			double *theWs,long num,double *theZs,double *theBs,double volume,double dspace){	short 	i = 0;	double 	imagePart = 0;	double 	realPart = 0;	double	theValue,aValue;	double	s;	dcomplex	value;	double    ratio;	 s = 1/ (4 * dspace * dspace);	while(i < num)	{				aValue			=	*theZs * exp(-(*theBs) * s);		theValue 		= 6.28318530717958648 * fmod((*theUs * h + *theVs * k + *theWs * l),1.0);				imagePart  	+=	aValue * sin(theValue);		realPart 		+= 	aValue * cos(theValue);		i++;		theUs++;theVs++;theWs++;theZs++;theBs++;	}	value.r = realPart;	value.i  = imagePart;	ratio = GetSFRatio();	return RCmul( ratio/ volume,value);}double	StructureFactorOld(double h,double k,double l,double* theUs,double* theVs,double* theWs,long num,double* theZs,double volume){	long	i;	double	realPart,imagPart,total,angle;		realPart = imagPart = 0.0;	for(i = 1 ; i <= num ; i++){		angle 		= 6.28318530717958648 * fmod((*theUs * h + *theVs * k + *theWs * l),1.0);		realPart 	+= (*theZs * cos(angle));		imagPart	+= (*theZs * sin(angle));		theUs++;		theVs++;		theWs++;		theZs++;	}		total = sqrt(imagPart * imagPart + realPart * realPart) * GetSFRatio() / volume;		return(total);}dcomplex  TotalStructureFactor2D(double h,double k,double *theUs,double *theVs,long num,double *theZs,double *theBs,double volume,double dspace,Crystal *thisCrystal,dcomplex *abC){		dcomplex sF;		sF	= StructureFactor_2D( h, k,theUs,theVs, num,theZs,theBs, volume, dspace);		if(g_absorpFlag){			double ratio;			ratio = GetSFRatio() * (1 + (1.9569341e-3 * gCurrentObj->energy));//1 + 1.959034 is the electron mass ratio//this is already calc. for SF as part of the scattering crossection			*abC = AbsorptionCoefficient(h,k,0,theUs,theVs,0L,thisCrystal,theBs, gCurrentObj->energy,dspace * .5);			abC->i *= ratio;			abC->r *= ratio;			sF.r -= abC->i;// * ratio;// sF.r - absorpFIM, the absorptions needs to be calucualed,ratio converts Vg to Ug			sF.i += abC->r;		}else{			abC->r = abC->i = 0;		}		return sF;	}dcomplex	StructureFactor_2D(double h,double k,double *theUs,double *theVs,long num,double *theZs,double *theBs,double volume,double dspace){	short 	i;	long double 	imagePart = 0;	long double 	realPart = 0;	long double	angle;	dcomplex complexV;	double    ratio;	if(g_DebyeWaller){		return StructureFactorDW_2D( h, k,theUs,theVs, num,theZs,theBs, volume, dspace);	}		i = 0;	while( i < num)	{			angle 		= 6.28318530717958648 * fmod((*theUs * h + *theVs * k),1.0);		realPart 	+= 	*theZs * cos(angle);		imagePart +=	*theZs * sin(angle);				i++;		theUs++;theVs++;theZs++;	}	complexV.r 	= (double)realPart;	complexV.i  = (double)imagePart;	//We use Born approximation to get new values multipy by h2 * eo * pi * 8 / mo e2	ratio = GetSFRatio();	return RCmul( ratio/ volume,complexV);}dcomplex	StructureFactorDW_2D(double h,double k,double *theUs,double *theVs,long num,double *theZs,double *theBs,double volume,double dspace){	short 	i = 0;	double 	imagePart = 0;	double 	realPart = 0;	double	theValue,aValue;	double	s;	dcomplex	value;	double    ratio;	 s = 1/ (4 * dspace * dspace);	while(i < num)	{				aValue			=	*theZs * exp(-(*theBs) * s);		theValue 		= 6.28318530717958648 * fmod((*theUs * h + *theVs * k),1.0);				imagePart  	+=	aValue * sin(theValue);		realPart 	+= 	aValue * cos(theValue);		i++;		theUs++;theVs++;theZs++;theBs++;	}	value.r = realPart;	value.i  = imagePart;	ratio = GetSFRatio();	return RCmul( ratio/ volume,value);}double GetSFRatio(void){			double ratio;		switch(gCurrentObj->theBeamFlag){			case 1:			default:			ratio 	= .318309856;//(47.878009) * (.006648352);			break;			case 2:				ratio 	= 2.818e-5 * ( gCurrentObj->wavelength *  gCurrentObj->wavelength);			break;		}		return ratio;}/* This is the old methodologyif(g_StructureEV){if(g_StructureEV == 2){	double ratio;	switch(gCurrentObj->theBeamFlag){		case 1:		default:		ratio 	= (47.878009) * (.006648352);		break;		case 2:			ratio 	= 2.818e-5 * ( gCurrentObj->wavelength *  gCurrentObj->wavelength);		break;	}	return RCmul( ratio/ volume,value);}return RCmul((47.878009) / volume,value),structureFlag,tlse return complexV;*/dcomplex ConvertStructureFactor(dcomplex sF,short strctFlag,double volume){		switch(strctFlag){		 		case 0:					sF.r *= volume / GetSFRatio();					sF.i *= volume / GetSFRatio();					break;				case 1:					sF.r *=  (47.878009) / GetSFRatio();					sF.i *= (47.878009) / GetSFRatio();					break;				case 2:					break;			 }		 return sF;}Boolean SetScatteringPosAIntensity(Crystal *crystal,double **theUs,double **theVs,double **theWs,double **theZs,double **theBs,short *atom_Count)//Timebomb!!//*atom_Count cannot be the same address as *crystal->Atom_Couynt  or you will continually increase the number{	long	n,num;	AtomPtr theAtoms;	double	*thePtr;			num = crystal->atom_Count + 1;	*theUs =  thePtr = (double*)D_NewPtr(5L * num * sizeof(double));	if(!PtrIsOK((Ptr)theUs)){		return false;	}	D_HLock((Handle)crystal->theAtoms);	*theVs = &(thePtr[num]);	*theWs = &((*theVs)[num]); 	*theZs = &((*theWs)[num]);	*theBs = &((*theWs)[num]);	theAtoms = *(crystal->theAtoms);  /* Code Changed by J.T. 3/14/91 */		for(n = 0 ; n < num ; n++,theAtoms++){		(*theUs)[n] = theAtoms->x;			(*theVs)[n] = theAtoms->y;			(*theWs)[n] = theAtoms->z;		(*theZs)[n] = 1.0;		(*theBs)[n] = theAtoms->bi;	}	crystal->AtomicScatteringByD(gCurrentObj->theBeamFlag,1.5,1,*theZs);	D_HUnlock((Handle)crystal->theAtoms);	*atom_Count = num;	return true;}double CalcExpDenZA(short baseCrystal,Crystal* theCrystal[4],PPT_Info* the_PPT_Info[3],Boolean *plotFlags,double *targetZ,double *targetAtWt){	double 	number = 0;	double targetDensity,	density = 0,weight = 0,zNum = 0;	short	i;	targetDensity 	= density;	*targetAtWt 		= weight;	*targetZ		 	= zNum;		for(i = 0; i <= 3;i++){		if(plotFlags[i]){						density = theCrystal[i]->CrystalDensity(&weight,&zNum);			if(i != baseCrystal){				targetDensity += density * the_PPT_Info[i - 1]->intensity;				*targetAtWt += weight * the_PPT_Info[i - 1]->intensity;				*targetZ += zNum * the_PPT_Info[i - 1]->intensity;				number += the_PPT_Info[i - 1]->intensity;			}else{				targetDensity += density;				*targetAtWt += weight;				*targetZ += zNum;				number += 1;			}		}	}	targetDensity /= number;	*targetAtWt /= number;	*targetZ /= number;	return targetDensity;}		