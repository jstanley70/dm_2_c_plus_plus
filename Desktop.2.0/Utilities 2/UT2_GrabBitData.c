#include "GrabBitData.h"#include	"Diffract_INCs.h"Ptr GetDataFromPICT(PicHandle	thePicture,short *rows,short *columns,short *bitDepth){	unsigned short		*theData,*theDataPtr;	Handle				imageData;	short				*opcodeInfo;	Size				numPixels,lBytesFree,bytesNeeded;	long				i;	Ptr					theCharData;		HLock((Handle)thePicture);		/* Lock down the picture so it doesn't move */	opcodeInfo	= (short*)&(*thePicture)->picFrame;	opcodeInfo	+= (sizeof(Rect) >> 1);		while(*opcodeInfo != 0x00FF){		switch(*opcodeInfo){			case 0x0011:			/* Version Number */				opcodeInfo += 2;				break;							case 0x0C00:			/* Header Info */				opcodeInfo += 13;				break;							case 0x0001:			/* Clip Region */				opcodeInfo += (*(++opcodeInfo) >> 1); /* offset by region size + opcode */				break;							/* 	NOTE: The PackedBitsRect opcode is documented as having a data structure as 				defined above in the PackedBitsInfo structure. However, the data does not  				align unless opcodeInfo is decremented. In other words there is an undocumented 				four byte shift in the data. */ 											case 0x0098:			/* PackedBitsRect	*/					PurgeMem(1000000L);				lBytesFree 	= CompactMem(1000000L);				opcodeInfo--;						/* Note the decrement */				imageData 	= GetTheData((PackedBitsInfoPtr)opcodeInfo,&numPixels,rows,columns);				HUnlock((Handle)thePicture);		/* Unlock to help pack mem */								if(imageData == (Handle)0L){					return((Ptr)0L);				}								bytesNeeded = numPixels * sizeof(short);	/* Pack the memory */				lBytesFree 	= CompactMem(bytesNeeded);				theData 	= (unsigned short*)D_NewPtr(bytesNeeded);  /* Get the mem for array of shorts */				if(theData == (unsigned short*)0L || MemError() != noErr){					DisposeHandle(imageData);					return((Ptr)0L);				}								HLock(imageData);							/* lock down bytewise bitmap */				theCharData = *imageData;				theDataPtr	= theData;				for(i = 0 ; i < numPixels ; i++){					*(theDataPtr++) = ((unsigned short)(*(theCharData++))) & 0X00FF;				}								HUnlock(imageData);				*bitDepth = 8;				DisposeHandle(imageData);					/* Get rid of bytwise bitmap */				return(Ptr)(theData);							/* return array of shorts */				break;						case 0x001C:			case 0x001E:				opcodeInfo++;				break;							default:						/* OOPS */							SysBeep(30);				if(!DoOtherOPCODE(&opcodeInfo)){					HUnlock((Handle)thePicture);	/* OPCODE not recognized */					return(0L);				}				break;		}	}	HUnlock((Handle)thePicture);							/* shouldn't ever get to here */	return (Ptr)0L;}Handle GetTheData(PackedBitsInfoPtr theDataInfo,long* dataSize,short *rows,short *columns){	long				size;	Handle			theData;	Ptr					theDestPtr,theSrcPtr;	short				rowBytes,*theDataBlock,numColors;	long					i,lengthValue;	ColorSpec			*theColorArray;		theDataBlock	= (short*)theDataInfo;	numColors	 	= theDataBlock[28];					/* Avoids struct aligment problems */	theColorArray	= (ColorSpec*)&theDataBlock[29];	/* Avoids struct aligment problems */		if(	theDataInfo->thePixMap.packType 	!= 0 || 	/* Try to trap wrong type of pictures */		theDataInfo->thePixMap.pixelType 	!= 0 ||		theDataInfo->thePixMap.pixelSize 	!= 8 ||		theDataInfo->thePixMap.cmpCount 	!= 1 ||		theDataInfo->thePixMap.cmpSize	 	!= 8 ||		numColors			 				!= 255){		*dataSize = 0;		return((Handle)0L);	}		*rows		= theDataInfo->thePixMap.bounds.bottom - theDataInfo->thePixMap.bounds.top;	*columns	= theDataInfo->thePixMap.bounds.right - theDataInfo->thePixMap.bounds.left;	rowBytes	= theDataInfo->thePixMap.rowBytes & 0x7FFF; /* High bit is a flag bit...Mask it. */	size		= (long)(*rows) * rowBytes;					/* Calculate image size */	theData		= NewHandle(size);							/* get data as a handle so we can pack mem */	if(theData == (Handle)0L || MemError() != noErr){		/* Trap the error if insufficient memory */		*dataSize = 0;		return((Handle)0L);	}		HLock(theData);										/* Lock down handle so we can use pointer */	theDestPtr	= *theData;								/* Get ptr to data */	theSrcPtr	= (Ptr)&theColorArray[256];				/* Address at end of colorTable (avoids alignment problems) */	theSrcPtr 	+= 18;									/* Rect + Rect + short (avoids alignment problems) */		if(rowBytes > 250){									/* Take care of length word */		lengthValue = 2;	} else {		lengthValue = 1;	}	for(i = 1 ; i <= *rows ; i++){						/* Unpack the rows */		theSrcPtr += lengthValue;						/* skip line length word or can't unpack*/		UnpackBits(&theSrcPtr,&theDestPtr,rowBytes);	/* Use O.S. Unpacking routine */	}	HUnlock(theData);									/* Unlock the handle */	*dataSize = size;									/* Return the byte count*/		return(theData);	}void	SetGrayPixel(short h,short v,unsigned short value){	//static short n = -5000;	//static short oldH,oldV;	RGBColor	theColor;/*	if(value == -5000){		n = -5000;		MoveTo(h,v);		return;	}	if(n == value){				return;	}	RGBForeColor(&theColor);	n = value;		/*value = n;	gCurrentObj->DMForeColor((short)value);	//if(n > 14) n = 9;	//n++;	LineTo(h,v);*/	if(value > 256)value = 256;	theColor.red 	= 255 * value;	theColor.green	= theColor.red;	theColor.blue	= theColor.red;		SetCPixel(h,v,&theColor);}void			DrawPixels(unsigned short *theData,short rows,short columns){	short h,v;	//MoveTo(0,0);	for(v = 0 ; v <= rows ; v++){		//MoveTo(0,v);		for(h = 0 ; h <= columns ; h++){			SetGrayPixel(h,v,*theData);			theData++;		}	}}Boolean	DoOtherOPCODE(short **opcodeInfo){	short theOPCODE;		theOPCODE =  **opcodeInfo;		if(theOPCODE >= 0x0030 && theOPCODE <= 0x0037){		*opcodeInfo += 5;		return true;	}		if(theOPCODE >= 0x0038 && theOPCODE <= 0x003F){		(*opcodeInfo)++;		return true;	}		if(theOPCODE >= 0x0040 && theOPCODE <= 0x0047){		*opcodeInfo += 5;		return true;	}		if(theOPCODE >= 0x0048 && theOPCODE <= 0x004F){		(*opcodeInfo)++;		return true;	}		if(theOPCODE >= 0x0050 && theOPCODE <= 0x0057){		*opcodeInfo += 5;		return true;	}		if(theOPCODE >= 0x0058 && theOPCODE <= 0x005F){		(*opcodeInfo)++;		return true;	}		if(theOPCODE >= 0x0060 && theOPCODE <= 0x0067){		*opcodeInfo += 7;		return true;	}		if(theOPCODE >= 0x0068 && theOPCODE <= 0x006F){		*opcodeInfo += 3;		return true;	}		switch(theOPCODE){			case 0x0000:			(*opcodeInfo)++;			return true;			break;				case 0x0003:		case 0x0005:		case 0x0008:		case 0x000D:			*opcodeInfo += 2;			return true;			break;					case 0x0006:		case 0x0007:		case 0x000B:		case 0x000C:		case 0x000E:		case 0x000F:			*opcodeInfo += 3;			return true;			break;					case 0x0002:		case 0x0009:		case 0x000A:		case 0x0010:			*opcodeInfo += 5;			return true;			break;	}	return false;}						