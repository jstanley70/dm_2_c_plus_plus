#include "ML_Multilog.h"#include	"Diffract_INCs.h"extern	ModalFilterUPP	MLogFilterUPP;void	DLOGTest(unsigned char* theTitle);void	DrawIcons(GWorldPtr iconWorld,Rect baseRect,short selectVal,short scrollVal);void		ThumbProc(ControlHandle theControl,scrollInfoPtr	theScrollInfo);void	MultiLog::DoInit(short theId,Ptr	theOwnerObjPtr){	suiteID							= theId;	theOwnerObj						= theOwnerObjPtr;	select							= 0;	scrollValue						= 0;	errorFlag						= false;	horiz_Offset					= ICON_WIDTH + SCROLL_WIDTH;	theDialog						= (DialogPtr)NUL;	theIconPict						= (PicHandle)NUL;	theScrollBar					= (ControlHandle)NUL;	theIconClipRgn					= (RgnHandle)NUL;	theOldClipRgn					= (RgnHandle)NUL;	baseItemList					= (Handle)NUL;	iconWorld						= (GWorldPtr)NULL;	theInfoRec						= (MultiInfoHndl)GetResource('MLOG',suiteID);	SetDAFont(1123);	if((Handle)theInfoRec == (Handle)NUL || ResError() != noErr){		theInfoRec					= (MultiInfoHndl)NUL;		errorFlag					= true;		return;	}	DetachResource((Handle)theInfoRec);}void	MultiLog::DoClose(void){	short	i;		for(i = 0 ; i < (*theInfoRec)->numItems ; i++){		if((*theInfoRec)->itemList[i].myIconPict != (PicHandle)NUL){			KillPicture((*theInfoRec)->itemList[i].myIconPict);		}	}		if((Handle)theInfoRec != (Handle)NUL){		DisposeHandle((Handle)theInfoRec);		theInfoRec	= (MultiInfoHndl)NUL;	}	if(theIconPict != (PicHandle)NUL){		KillPicture(theIconPict);		theIconPict	= (PicHandle)NUL;	}	if(iconWorld)DisposeGWorld(iconWorld);		if(theScrollBar != (ControlHandle)NUL){		DisposeControl(theScrollBar);		theScrollBar	= (ControlHandle)NUL;	}	if(theDialog != (DialogPtr)NUL){		DisposDialog(theDialog);		theDialog	= (DialogPtr)NUL;	}			if(theIconClipRgn != (RgnHandle)NUL){		D_DisposeRgn(&theIconClipRgn);	}		if(theOldClipRgn != (RgnHandle)NUL){		D_DisposeRgn(&theOldClipRgn);	}			delete(this);}void	MultiLog::AssignFunction(short rec_ID,SetupProcPtr setup,HitProcPtr hit,ReadProcPtr finish,Ptr theOwner){	short		i;			for(i = 0 ; i < (*theInfoRec)->numItems ; i++){		if((*theInfoRec)->itemList[i].recID == rec_ID){			(*theInfoRec)->itemList[i].myIconPict		= GetPicture((*theInfoRec)->itemList[i].picResID);			(*theInfoRec)->itemList[i].writeDlogProc	= setup;			(*theInfoRec)->itemList[i].itemHitProc		= hit;			(*theInfoRec)->itemList[i].readDlogProc		= finish;			(*theInfoRec)->itemList[i].owner			= theOwner;			DetachResource((Handle)(*theInfoRec)->itemList[i].myIconPict);			return;		}	}		errorFlag				= true;	SysBeep(30);	SysBeep(30);	SysBeep(30);	SysBeep(30);	SysBeep(30);}Boolean	MultiLog::DoMultiLog(void){	ControlActionUPP	TheScrollProc;	ControlHandle		theControl;	Boolean				quit,changed;	GrafPtr				oldPort;	Handle				theitemList;	Point				thePoint;	Rect 				theDLOGRect,frameDITL;	Ptr					theOwner,theParams;	short				hOffset,theSelect,maxScroll,pageSize,iPartCode,numberItems,lastSelect;	scrollInfo			theScrollInfo;		if(errorFlag){		return(false);	}	SetDAFont(1123);	TheScrollProc		= NewControlActionProc((ProcPtr)TheMLScrollProc);	theIconClipRgn		= D_NewRgn();	theOldClipRgn		= D_NewRgn();		GetPort(&oldPort);	quit				= false;	changed				= false;	hOffset				= FRAME_WIDTH + ICON_WIDTH + SCROLL_WIDTH + FRAME_WIDTH;	frameDITL			= (*theInfoRec)->theDITLFrame;	theDLOGRect.top 	= 38;	theDLOGRect.left	= 4;	theDLOGRect.bottom	= theDLOGRect.top + frameDITL.bottom - frameDITL.top + GO_AWAY_BLOCK;	theDLOGRect.right	= theDLOGRect.left + frameDITL.right - frameDITL.left + hOffset;	baseItemList		= BuildMultiBlock(&theDLOGRect);		theDialog			= NewCDialog(NUL,&theDLOGRect,"\p",true,noGrowDocProc,(WindowPtr)-1L,true,0L,baseItemList);	 // SetWinColor(theDialog,newColorTable);			SetPort(theDialog);	HLock((Handle)theInfoRec);	SetWTitle(theDialog,(*theInfoRec)->itemList[select].title);	HUnlock((Handle)theInfoRec);		pageSize			= (theDLOGRect.bottom - theDLOGRect.top) / ICON_WIDTH;	maxScroll			= (*theInfoRec)->numItems - pageSize;	theScrollBar		= NewControl(theDialog,&scrollRect,"\p",true,scrollValue,0,maxScroll,scrollBarProc,0L);	SetRect(&theIconClipRect,0,0,ICON_WIDTH,pageSize * ICON_WIDTH);	RectRgn(theIconClipRgn,&theIconClipRect);	GetClip(theOldClipRgn);		AssemblePICTs();	InvalRect(&theIconClipRect);//	DrawIconPicts();		theOwner			= (*theInfoRec)->itemList[select].owner;	theitemList			= GetResource('DITL',(*theInfoRec)->itemList[select].ditlResId);//	DetachResource(theitemList);		ShrinkDITL(theitemList,4);	FixDITL(theitemList,hOffset,0);	AppendDITL(theDialog,theitemList,0);	ReleaseResource(theitemList);		(*theInfoRec)->itemList[select].writeDlogProc(theOwner,theDialog,&theParams);	while(!quit){		ModalDialog(MLogFilterUPP,&theSelect);		switch(theSelect){			case MLOG_OK:				quit 	= true;				changed	= true;				break;			case MLOG_CANCEL:			case -1:				quit 	= true;				changed = false;				break;			case MLOG_ICONS:				lastSelect	= select;				GetMouse(&thePoint);				if(DoIconHit(thePoint)){					(*theInfoRec)->itemList[lastSelect].readDlogProc(theOwner,theDialog,theParams,changed);										numberItems	= CountDITL(theDialog);					numberItems	-= 4;					ShortenDITL(theDialog,numberItems);					theOwner			= (*theInfoRec)->itemList[select].owner;					theitemList			= GetResource('DITL',(*theInfoRec)->itemList[select].ditlResId);									//	DetachResource(theitemList);					ShrinkDITL(theitemList,4);					FixDITL(theitemList,hOffset,0);					AppendDITL(theDialog,theitemList,0);					ReleaseResource(theitemList);					SetWTitle(theDialog,(*theInfoRec)->itemList[select].title);					dm_EraseRect(&theDialog->portRect);					SetPort(theDialog);					DrawDialog(theDialog);					(*theInfoRec)->itemList[select].writeDlogProc(theOwner,theDialog,&theParams);					ValidRect(&theDialog->portRect);					InvalRect(&theIconClipRect);				}									break;			case MLOG_SCROLL:				GetMouse(&thePoint);				iPartCode	= FindControl(thePoint,theDialog,&theControl);				switch(iPartCode){					case inUpButton:					case inDownButton:					case inPageUp:					case inPageDown:											theScrollInfo.pictClip			= theIconClipRgn;						theScrollInfo.iconWorld			= iconWorld;						theScrollInfo.oldClip			= theOldClipRgn;						theScrollInfo.thePict			= theIconPict;						theScrollInfo.theIconPictRect	= &theIconPictRect;						theScrollInfo.scrollValue		= &scrollValue;						theScrollInfo.selectValue		= select;						theScrollInfo.pageSize			= pageSize;						SetCRefCon(theScrollBar,(long)&theScrollInfo);						iPartCode = TrackControl(theScrollBar,thePoint,TheScrollProc);						break;					case inThumb:												//SetCRefCon(theScrollBar,(long)&theScrollInfo);						iPartCode = TrackControl(theScrollBar,thePoint,NULL);						if(iPartCode){							theScrollInfo.pictClip			= theIconClipRgn;							theScrollInfo.oldClip			= theOldClipRgn;							theScrollInfo.thePict			= theIconPict;							theScrollInfo.iconWorld			= iconWorld;							theScrollInfo.theIconPictRect	= &theIconPictRect;							theScrollInfo.scrollValue		= &scrollValue;							theScrollInfo.selectValue		= select;							theScrollInfo.pageSize			= pageSize;							ThumbProc(theScrollBar,&theScrollInfo);						}						break;					default:						break;				}				break;			case ML_UPDATE_EVT:				SetPort(theDialog);				BeginUpdate(theDialog);					DrawDialog(theDialog);					(*theInfoRec)->itemList[select].itemHitProc(theOwner,theDialog,ML_UPDATE_EVT,theParams);					DrawIconPicts();				EndUpdate(theDialog);				break;			default:				changed	= true;				(*theInfoRec)->itemList[select].itemHitProc(theOwner,theDialog,theSelect,theParams);				break;		}	}	(*theInfoRec)->itemList[select].readDlogProc(theOwner,theDialog,theParams,changed);	//bloch	DisposePtr((Ptr)TheScrollProc);	SetPort(oldPort);	//ReleaseResource(theitemList);	theitemList = 0L;	if(changed){	//	((DiffractObject*)theOwnerObj)->newPictReq = true;		//((DiffractObject*)theOwnerObj)->SetWindowColors(2110);	}	return changed;}Handle	MultiLog::BuildMultiBlock(Rect	*theRect){	Handle			theHandle;	Ptr				thePtr;	long			size,theBlkSize;	DITLBlockPtr	theDITLBlk;	Rect			buttonRect;	short			selectOffset,cntrlWidth,offset1,offset2,buttonOffset,vertOffset;	short			*theTextPtr,scrollLength;	SetDAFont(1123);		scrollLength			= theRect->bottom - theRect->top - FRAME_WIDTH - FRAME_WIDTH;		SetRect(&scrollRect,0,0,SCROLL_WIDTH,scrollLength);	OffsetRect(&scrollRect,FRAME_WIDTH + ICON_WIDTH,FRAME_WIDTH);	SetRect(&theIconsRect,0,0,ICON_WIDTH,scrollLength);	OffsetRect(&theIconsRect,FRAME_WIDTH,FRAME_WIDTH);	SetRect(&buttonRect,0,0,BUTTON_WIDTH,BUTTON_HEIGHT);		buttonOffset			= BUTTON_WIDTH >> 1;	selectOffset			= FRAME_WIDTH + ICON_WIDTH + SCROLL_WIDTH + FRAME_WIDTH;	cntrlWidth				= (theRect->right - theRect->left - selectOffset) >> 1;	vertOffset				= theRect->bottom - theRect->top - (GO_AWAY_BLOCK >> 1) - (BUTTON_HEIGHT >> 1);	offset1					= selectOffset + (cntrlWidth >> 1) - buttonOffset;	offset2					= selectOffset + cntrlWidth + (cntrlWidth >> 1) - buttonOffset;		theBlkSize				= sizeof(long) + sizeof(Rect) + sizeof(char) + sizeof(char);	size					= (4L * theBlkSize) + 10L;//changed was + 10L	theHandle				= NewHandle(size);//this is 2/99,this is an item list for dialog,Apple takes care of it ??		HLock(theHandle);	thePtr					= *theHandle;	*((short*)thePtr)		= 3;	thePtr					+= sizeof(short);		theDITLBlk				= (DITLBlockPtr)thePtr;	// OK Button	theDITLBlk->pad			= NUL;						theDITLBlk->theRect		= buttonRect;	theDITLBlk->typeChar	= 0x04;	theDITLBlk->length		= 0x02;	thePtr					+= theBlkSize;	theTextPtr				= (short*)thePtr;	*theTextPtr++			= 'OK';	thePtr					+= 2;	OffsetRect(&theDITLBlk->theRect,offset1,vertOffset);		theDITLBlk				= (DITLBlockPtr)thePtr;	// Cancel Button	theDITLBlk->pad			= NUL;						theDITLBlk->theRect		= buttonRect;	theDITLBlk->typeChar	= 0x04;	theDITLBlk->length		= 0x06;	thePtr					+= theBlkSize;	theTextPtr				= (short*)thePtr;	*theTextPtr++			= 'Ca';	*theTextPtr++			= 'nc';	*theTextPtr++			= 'el';	thePtr					+= 6;	OffsetRect(&theDITLBlk->theRect,offset2,vertOffset);		theDITLBlk				= (DITLBlockPtr)thePtr;	// ICON Rect	theDITLBlk->pad			= NUL;						theDITLBlk->theRect		= theIconsRect;	theDITLBlk->typeChar	= 0x00;	theDITLBlk->length		= 0x00;	thePtr					+= theBlkSize;		theDITLBlk				= (DITLBlockPtr)thePtr;	// Scroll Rect	theDITLBlk->pad			= NUL;						theDITLBlk->theRect		= scrollRect;	theDITLBlk->typeChar	= 0x00;	theDITLBlk->length		= 0x00;	thePtr					+= theBlkSize;		HUnlock(theHandle);		return(theHandle);}		void	FixDITL(Handle	DITLHandle,short hOffset,short vOffset){	Ptr				thePtr;	short			numElements,i;	long			offset,baseLength;	unsigned char	*theString;	DITLBlockPtr	theDITLBlk;	D_HLock(DITLHandle);	baseLength					= sizeof(long) + sizeof(Rect) + sizeof(char) + sizeof(char);	thePtr						= *DITLHandle;	numElements					= *((short*)thePtr);	thePtr						+= sizeof(short);		for(i = 0 ; i <= numElements ; i++){		theDITLBlk				= (DITLBlockPtr)thePtr;		theString 				= (unsigned char*)&theDITLBlk->length;		offset					= baseLength;		offset					+= (long)theDITLBlk->length;		offset					+= (offset % 2);		thePtr					+= offset;							// Offset string		if(theDITLBlk->pad == 0L){			OffsetRect(&theDITLBlk->theRect,hOffset,vOffset);			// Move Rect		} else {			SysBeep(15);		}	}		D_HUnlock(DITLHandle);}void	ShrinkDITL(Handle	DITLHandle,short numItems){	//HLock(DITLHandle);	Ptr				thePtr,startAddr;	short			*numElements,i,numXfer;	long			offset,baseLength,newSize;	unsigned char	*theString;	DITLBlockPtr	theDITLBlk;		D_HLock(DITLHandle);	newSize						= GetHandleSize(DITLHandle);	baseLength					= sizeof(long) + sizeof(Rect) + sizeof(char) + sizeof(char);	thePtr						= *DITLHandle;	numElements					= ((short*)thePtr);	numXfer						= *numElements - numItems;	*numElements				= numXfer;	thePtr						+= sizeof(short);	startAddr					= thePtr;	for(i = 1 ; i <= numItems ; i++){		theDITLBlk				= (DITLBlockPtr)thePtr;		theString 				= (unsigned char*)&theDITLBlk->length;		offset					= baseLength;		offset					+= (long)theDITLBlk->length;		offset					+= (offset % 2);		thePtr					+= offset;		newSize					-= offset;	}							BlockMove(thePtr,startAddr,(newSize - sizeof(short)));	D_HUnlock(DITLHandle);	SetHandleSize(DITLHandle,newSize);}	Boolean		MultiLog::DoHit(short theItem){	Point			thePoint;	short			iCtlPart,offset,theValue;	ControlHandle	whichCtl;		GetMouse(&thePoint);	theValue			= GetCtlValue(theScrollBar);		if(theItem == scroll_Item){		iCtlPart 		= FindControl(thePoint,theDialog,&whichCtl);		if(whichCtl != theScrollBar){			return (false);		}		switch(iCtlPart){			case inDownButton:			case inPageDown:				offset	= -1;				break;						case inUpButton:			case inPageUp:				offset	= 1;				break;							default:				offset	= 0;				break;		}			theValue		+= offset;		SetCtlValue(theScrollBar,theValue);		Draw1Control(theScrollBar);		return (false);	} else if(theItem == iconDisplay_Item){		thePoint.v		-= FRAME_WIDTH;		select			= theValue + thePoint.v / ICON_WIDTH;		return(true);	}		return(false);}		 		Boolean		MultiLog::DoIconHit(Point thePoint){	Rect				theIconRect;	short				newSelect;		if(PtInRect(thePoint,&theIconClipRect)){		SetRect(&theIconRect,0,0,ICON_WIDTH,ICON_WIDTH);		OffsetRect(&theIconRect,0,(select - scrollValue) * ICON_WIDTH);		InvalRect(&theIconRect);				newSelect	= scrollValue + thePoint.v / ICON_WIDTH;		SetRect(&theIconRect,0,0,ICON_WIDTH,ICON_WIDTH);		OffsetRect(&theIconRect,0,(newSelect - scrollValue) * ICON_WIDTH);		InvalRect(&theIconRect);		if(newSelect != select){			select	= newSelect;			return true;		}	}	return false;}		/*void		MultiLog::AssemblePICTs(void){	Rect				theIconRect;	short				i;	RGBColor			theColor;		SetRect(&theIconPictRect,0,0,ICON_WIDTH,(*theInfoRec)->numItems * ICON_WIDTH);	SetRect(&theIconRect,0,0,ICON_WIDTH,ICON_WIDTH);	theIconViewRect	= theIconPictRect;	theColor.red	= 65535;	theColor.green	= 65535;	theColor.blue	= 65535;	RGBBackColor(&theColor);		if(theIconPict != (PicHandle)NUL){		KillPicture(theIconPict);	}		theIconPict 					= OpenPicture(&theIconPictRect);	dm_EraseRect(&theIconPictRect);	for(i = 0 ; i < (*theInfoRec)->numItems ; i++){		if((*theInfoRec)->itemList[i].myIconPict != (PicHandle)NUL){			DrawPicture((*theInfoRec)->itemList[i].myIconPict,&theIconRect);		}		OffsetRect(&theIconRect,0,ICON_WIDTH);	}	ClosePicture();	}*/void		MultiLog::AssemblePICTs(void){	CTabHandle	destCTab; 	GWorldPtr currPort;    	GDHandle currDev;       	short err;                    	PaletteHandle	thisPalette;	Rect					theRect;	Rect				theIconRect;	short				i;	RGBColor			theColor;	WindowPtr			theWindow;	SetRect(&theIconPictRect,0,0,ICON_WIDTH,(*theInfoRec)->numItems * ICON_WIDTH);	SetRect(&theIconRect,0,0,ICON_WIDTH,ICON_WIDTH);	theIconViewRect	= theIconPictRect;	theColor.red	= 65535;	theColor.green	= 65535;	theColor.blue	= 65535;	RGBBackColor(&theColor);	theWindow = FrontWindow();		thisPalette 		= GetNewPalette(1111);	destCTab 			= GetCTable(2100);	Palette2CTab(thisPalette,destCTab);	CTabChanged(destCTab);	if(iconWorld != 0L)	DisposeGWorld(iconWorld);	iconWorld = 0L;	theRect = theIconViewRect;	DetachResource((Handle)thisPalette);	DisposePalette(thisPalette);	GetGWorld(&currPort,&currDev);	//err = NewGWorld(&iconWorld, 8, &theRect,destCTab, nil, 0);// Create Offscreen Graphics world.	err = NewGWorld(&iconWorld, (*(currPort->portPixMap))->pixelSize,&theRect,destCTab, nil, 0);// Create Offscreen Graphics world.	if(err){iconWorld = 0L;DisposCTable(destCTab);return;}		GetGWorld(&currPort,&currDev);		LockPixels (iconWorld->portPixMap);	SetGWorld (iconWorld, nil);				PenMode(0);	ForeColor (blackColor);	BackColor (whiteColor);	gCurrentObj->DMForeColor(BLACK);	gCurrentObj->DMBackColor(WHITE);	dm_EraseRect (&theRect);	PenMode(0);	dm_EraseRect(&theRect);	for(i = 0 ; i < (*theInfoRec)->numItems ; i++){		if((*theInfoRec)->itemList[i].myIconPict != (PicHandle)NUL){			DrawPicture((*theInfoRec)->itemList[i].myIconPict,&theIconRect);		}		OffsetRect(&theIconRect,0,ICON_WIDTH);	}		SetGWorld (currPort, currDev);	UnlockPixels (iconWorld->portPixMap);// Now unlock Pixels.	DisposCTable(destCTab);	}	void		MultiLog::DrawIconPicts(void){	RgnHandle	presentClip,newClip;		presentClip	= D_NewRgn();	newClip		= D_NewRgn();	GetClip(presentClip);	SectRgn(presentClip,theIconClipRgn,newClip);	D_SetClip(newClip);		DrawIcons(iconWorld,theIconPictRect,select,scrollValue);	D_SetClip(presentClip);	D_DisposeRgn(&presentClip);	D_DisposeRgn(&newClip);}		void	DLOGTest(unsigned char* theTitle){	Rect		theRect;	DialogPtr	theDialog;		SetRect(&theRect,40,40,512,512);		theDialog			= NewDialog(NUL,&theRect,theTitle,true,noGrowDocProc,(WindowPtr)-1L,true,0L,(Handle)0L);		while(!Button()){		;	}	DisposDialog(theDialog);	while(Button()){		;	}}		pascal void	TheMLScrollProc(ControlHandle theControl,short ctrlPart){	scrollInfoPtr	theScrollInfo;	short			scrollValue,pageSize,limit,select;	Rect			thePictRect;	PicHandle		thePicture;	GWorldPtr		iconWorld;	theScrollInfo	= (scrollInfoPtr)GetCRefCon(theControl);		thePictRect		= *theScrollInfo->theIconPictRect;	scrollValue		= *theScrollInfo->scrollValue;	thePicture		= theScrollInfo->thePict;	iconWorld		= theScrollInfo->iconWorld;	pageSize		= theScrollInfo->pageSize;	select			= theScrollInfo->selectValue;	switch(ctrlPart){		case inUpButton:			if(scrollValue > GetCtlMin(theControl)){				SetCtlValue(theControl,--scrollValue);			}			break;					case inDownButton:			if(scrollValue < GetCtlMax(theControl)){				SetCtlValue(theControl,++scrollValue);			}			break;					case inPageUp:			limit			= GetCtlMin(theControl);			scrollValue 	-= pageSize;			if(scrollValue < limit){				scrollValue	= limit;			}			SetCtlValue(theControl,scrollValue);			break;					case inPageDown:			limit			= GetCtlMax(theControl);			scrollValue 	+= pageSize;			if(scrollValue > limit){				scrollValue	= limit;			}			SetCtlValue(theControl,scrollValue);			break;				default:			break;	}	*theScrollInfo->scrollValue	= scrollValue;	D_SetClip(theScrollInfo->pictClip);	DrawIcons(iconWorld,thePictRect,select,scrollValue);	D_SetClip(theScrollInfo->oldClip);}void DrawIcons(GWorldPtr		iconWorld,Rect baseRect,short selectVal,short scrollVal){	Rect	theRect;	CTabHandle	destCTab;	static Rect dOffBounds;   	PaletteHandle	thisPalette;	WindowPtr		theWindow;	theRect		=	baseRect;	OffsetRect(&baseRect,0,-scrollVal * ICON_WIDTH);	theWindow = FrontWindow();	thisPalette 		= GetNewPalette(1111);	destCTab 	= 	GetCTable(2100);	Palette2CTab	(thisPalette,destCTab);	CTabChanged(destCTab);	DetachResource((Handle)thisPalette);	DisposePalette(thisPalette);		LockPixels 		(iconWorld->portPixMap);	ForeColor (blackColor);	BackColor (whiteColor);		PenMode(0);	CopyBits ( (BitMap *) (*(iconWorld->portPixMap)),					&((GrafPtr)theWindow)->portBits, &theRect, &baseRect,0, nil);//srcCopy	SetRect(&theRect,0,0,ICON_WIDTH,ICON_WIDTH);	OffsetRect(&theRect,0,(selectVal - scrollVal) * ICON_WIDTH);	InvertRect(&theRect);	UnlockPixels (iconWorld->portPixMap);	DisposCTable(destCTab);}void		ThumbProc(ControlHandle theControl,scrollInfoPtr	theScrollInfo){	short			scrollValue,pageSize,select;	Rect			thePictRect;	PicHandle		thePicture;	GWorldPtr		iconWorld;		scrollValue = GetCtlValue(theControl);	thePictRect		= *theScrollInfo->theIconPictRect;	thePicture		= theScrollInfo->thePict;	iconWorld		= theScrollInfo->iconWorld;	*theScrollInfo->scrollValue = scrollValue;	thePicture		= theScrollInfo->thePict;	pageSize		= theScrollInfo->pageSize;	select			= theScrollInfo->selectValue;	D_SetClip(theScrollInfo->pictClip);	DrawIcons(iconWorld,thePictRect,select,scrollValue);	D_SetClip(theScrollInfo->oldClip);	return;}