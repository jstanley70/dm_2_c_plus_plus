#include	"Diffract_INCs.h"#include "ML_Diffractometer.h"#include "ML_SADObj.h"#include "ML_Crystal.h"#include "ML_PPT_Info.h"#include "ML_BeamOrientation.h"#include  "DiffractometerObj.h"#include "ML_CrystalFace.h"#include "ML_Default.h"#include "ML_Misc_Plot.h"void	ML_DoDiffractometerObjSetup(Ptr	owner,DialogPtr theDialog,Ptr *theParams){	DiffractometerObj*			theOwner;	theOwner					= (DiffractometerObj*)owner;	theOwner->SetDefineObj( theDialog);	*theParams = (Ptr)0L;	DrawDialog(theDialog);}void	ML_DoDiffractometerObjHit(Ptr	owner,DialogPtr theDialog, short theSelect,Ptr theParams){	DiffractometerObj*		theOwner;	Boolean		saveData;		theOwner		= (DiffractometerObj*)owner;	theParams		= (Ptr)NUL;             // Eliminates warning;  theParams is required		theOwner->DefineSwitch( theDialog, theSelect,&saveData);}void	ML_DoDiffractometerObjRead(Ptr owner,DialogPtr theDialog,Ptr theParams,Boolean saveData){	DiffractometerObj*		theOwner;	theOwner		= (DiffractometerObj*)owner;	theParams		= (Ptr)NUL; 	theOwner->ReadDefineDialog( theDialog, saveData);}Boolean	DiffractometerObj::DefineSwitch(DialogPtr theDialog,short theSelect,Boolean *saveData){	double theValue;	double	minXX,maxXX;	double dTime,sSize;		minXX =  GetItemValue( theDialog,_7_);		maxXX =  GetItemValue( theDialog,_8_);					switch(theSelect){			case -1:			case 2:				*saveData = false;				return true;				break;			case DLOG_ENTER_OR_CR:			case 1:				*saveData = true;					return true;				break;			case _3_:			case _4_:			case _5_:			case _6_:			case _9_:			case _10_:				SwitchBoolean(theDialog,theSelect,GetBoolean(theDialog,theSelect));				break;			case _16_:			case _15_:				dTime = GetItemValue(theDialog,_16_);				sSize = GetItemValue(theDialog,_15_);				SetItemValue( theDialog,_19_,dTime * (maxXX - minXX) / (60 *sSize),2);			break;			case _19_:				theValue = GetItemValue(theDialog,_19_);				sSize = GetItemValue(theDialog,_15_);				dwellTime = theValue * 60 * sSize/ (maxXX - minXX);				SetItemValue( theDialog,_16_,dwellTime,2);				break;			case _13_:				SwitchBoolean(theDialog,_13_,GetBoolean(theDialog,_13_));				break;			default:				break;			case ML_UPDATE_EVT:			DrawDialog(theDialog);			break;		}		return false;}void  DiffractometerObj::SetDefineObj(DialogPtr theDialog){	double			minXX,maxXX;	short			i;		for(i = _3_; i <= _6_;i++){			GetDItem(theDialog,i,&gType,&gTheHandle,&gTheRect);			SetCtlValue((ControlHandle)gTheHandle,plotFlags[i - _3_]);	}	SetDLogNames(theDialog);				SetDialogValues( theDialog,&minXX,&maxXX);	SwitchBoolean(theDialog,_13_,!fullSim);	HideDItem(theDialog,_13_);	SetItemValue( theDialog,_14_,slitSize,3);	SetItemValue( theDialog,_15_,stepSize,3);	SetItemValue( theDialog,_16_,dwellTime,4);}void	DiffractometerObj::SetDialogValues(DialogPtr theDialog,double *minXX,double *maxXX){		SetItemValue( theDialog,_19_,dwellTime * (maxX - minX) / (60 *stepSize),2);		*minXX = minX;		*maxXX  = maxX;		SetItemValue( theDialog,_7_,minX,2);	SetItemValue( theDialog,_8_,maxX,2);}double	DiffractometerObj::GetMinMax(DialogPtr theDialog){	double oldV;	oldV = maxX;	if( GetItemValue( theDialog,_7_) != minX)newPictReq = true;	if( GetItemValue( theDialog,_7_) < minX)changedFlag = true;	minX = minX =  GetItemValue( theDialog,_7_);	if( GetItemValue( theDialog,_8_) > maxX)changedFlag = true;		maxX =  GetItemValue( theDialog,_8_);	return oldV;}void DiffractometerObj::SetDLogNames(DialogPtr theDialog){	HideDItem(theDialog,_9_);	HideDItem(theDialog,_10_);}void	DiffractometerObj::DoDefine(void){	Boolean			calculateFlag;	MultiLog*		theMultiLog;	short				n = 0;		theMultiLog	= (MultiLog*)new(MultiLog);	theMultiLog->DoInit(262,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoDiffractometerObjSetup,(HitProcPtr)ML_DoDiffractometerObjHit,(ReadProcPtr)ML_DoDiffractometerObjRead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoBeamESetup,(HitProcPtr)ML_DoBeamEHit,(ReadProcPtr)ML_DoBeamERead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[0]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[1]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[2]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[3]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_SetMiscParam,(HitProcPtr)ML_SwitchMiscParam,(ReadProcPtr)ML_ReadMiscParam,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoDefaultSetup,(HitProcPtr)ML_DoDefaultHit,(ReadProcPtr)ML_DoDefaultRead,(Ptr)this);	calculateFlag = theMultiLog->DoMultiLog();	theMultiLog->DoClose();		if(calculateFlag  && screenPict == NUL  && gMyOffG == 0L){		changedFlag = true;		reSizeFlag = true;		//newPictReq = true;/*eliminated line dec 1992*/	} else if(screenPict == NUL  && gMyOffG == 0L){		CloseTheObject(theWindow);	}	return;}Boolean DiffractometerObj::DialogRead(DialogPtr theDialog){	double oldValue;	oldValue = GetMinMax( theDialog);	if(fabs(slitSize	-  GetItemValue(theDialog,_14_)) > .01 && fullSim)changedFlag = true;	slitSize	=  GetItemValue( theDialog,_14_);		stepSize	=  GetItemValue( theDialog,_15_);		dwellTime	=  GetItemValue( theDialog,_18_);		if(oldValue < maxX) return true;	return false;}void		DiffractometerObj::ReadDefineDialog(DialogPtr theDialog,Boolean saveData){	short i;	if(saveData){				/* Eric re-wrote this section July 1993 */				//if(fullSim != GetBoolean(theDialog,_13_) && !fullSim)changedFlag = true;		//fullSim 		=	GetBoolean(theDialog,_13_);		DialogRead(theDialog);		for(i = _3_; i <= _6_;i++){			GetDItem(theDialog,i,&gType,&gTheHandle,&gTheRect);			if(GetCtlValue((ControlHandle)gTheHandle) == 0){				if(plotFlags[i - _3_])newPictReq = true;				plotFlags[i - _3_] = false;			} else {				if(!plotFlags[i - _3_])changedFlag = true;				plotFlags[i - _3_] = true;			}		}				DoDefineOR( theDialog,false,_3_);	}}void DiffractometerObj::DoSetUp(void){	DialogPtr 		theDialog;	short			theSelect;	Boolean			quit = false;	Boolean			saveData = false;		theDialog	= DM_GetNewDialog(304,NUL,IN_FRONT);		SetDefineObj( theDialog);	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			quit = DefineSwitch( theDialog, theSelect,&saveData);			EndUpdate(theDialog);			break;			default:			quit = DefineSwitch( theDialog, theSelect,&saveData);			break;			}			}	ReadDefineDialog( theDialog, saveData);	DM_DisposDialog(&theDialog);		return;}