#include "Diffract_INCs.h"#include "ML_Crystal.h"#include "ML_BeamOrientation.h"#include "ML_Kikuchi.h"	#include "ML_StructFactor.h"#include	"KikuchiObject.h"#include "ML_PPT_Info.h"#include "ML_Default.h"#include "ML_Misc_Plot.h"void	ML_DoKikuchiObjectSetup(Ptr	owner,DialogPtr theDialog,Ptr *theParams){	KikuchiObject*			theOwner;	theOwner					= (KikuchiObject*)owner;	*theParams =  (Ptr)0L;	theOwner->SetDefineObjK( theDialog);	DrawDialog(theDialog);}void	ML_DoKikuchiObjectHit(Ptr	owner,DialogPtr theDialog, short theSelect,Ptr theParams){	KikuchiObject*		theOwner;	Boolean		saveData;		theOwner		= (KikuchiObject*)owner;	theParams =  (Ptr)0L;	theOwner->DefineSwitchK( theDialog, theSelect,&saveData);}void	ML_DoKikuchiObjectRead(Ptr owner,DialogPtr theDialog,Ptr theParams,Boolean saveData){	KikuchiObject*		theOwner;	theOwner		= (KikuchiObject*)owner;	theParams		=	0L;	theOwner->ReadDefineDialogK( theDialog, saveData);}void KikuchiObject::DoSetUp(void){	DialogPtr 		theDialog;	short			theSelect;	Boolean			quit = false;	Boolean			saveData = false;		theDialog	= DM_GetNewDialog(2200,NUL,IN_FRONT);		SetDefineObjK( theDialog);	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			quit = DefineSwitchK( theDialog, theSelect,&saveData);			EndUpdate(theDialog);			break;			default:			quit = DefineSwitchK( theDialog, theSelect,&saveData);			break;			}			}	ReadDefineDialogK( theDialog, saveData);	DM_DisposDialog(&theDialog);		return;}void KikuchiObject::SetDefineObjK(DialogPtr theDialog){	short i;	short n;	for(i = _8_  ; i <= _11_ ; i++){		double nF;		nF = n = planeBounds[i - _8_];		GetDItem(theDialog,i - 5,&gType,&gTheHandle,&gTheRect);		if(n <= 0){			SetCtlValue((ControlHandle)gTheHandle,0);			nF = n = abs(n);		} else {			SetCtlValue((ControlHandle)gTheHandle,1);		}		SetItemValue(theDialog,i,nF,0);	}	SelIText(theDialog,_8_,0,10);	SwitchBoolean(theDialog,_7_,!labelMatrixFlag);	SwitchBoolean(theDialog,_19_,!plotZoneAxes);	SetItemValue(theDialog,_17_,(double)labelBounds,0);	structFactFlag = true;		}Boolean KikuchiObject::DefineSwitchK(DialogPtr theDialog,short theSelect,Boolean *saveData){	Boolean theFlag;	switch(theSelect){			case -1:			case 2:				*saveData = true;					return true;			case 1:				*saveData = true;					return true;			case _3_:			case _4_:			case _5_:			case _6_:			case _7_:			case _18_:			case _19_:				theFlag = GetBoolean(theDialog,theSelect);				SwitchBoolean(theDialog,theSelect,theFlag);				break;			case ML_UPDATE_EVT:			DrawDialog(theDialog);			break;			default:				break;		}		*saveData = false;		return false;}void  KikuchiObject::ReadDefineDialogK(DialogPtr theDialog,Boolean saveData){	short i;	short n;	if(saveData){		for(i = _8_ ; i <= _11_ ; i++){			n = (short)GetItemValue(theDialog,i);			GetDItem(theDialog,i - 5,&gType,&gTheHandle,&gTheRect);			if(GetCtlValue((ControlHandle)gTheHandle) == 1){				if(n > planeBounds[i - _8_]) changedFlag = true;				planeBounds[i - _8_]	= n;				dirBounds[i - _8_]	= n + 2;			} else {				if(planeBounds[i - _8_]) changedFlag = true;				planeBounds[i - _8_]	= 0;				dirBounds[i - _8_]	= 0;			}		}		if(labelMatrixFlag != GetBoolean(theDialog,_7_))changedFlag = true;		labelMatrixFlag = GetBoolean(theDialog,_7_);		if(greyFlag != GetBoolean(theDialog,_18_))newPictReq = true;		greyFlag = GetBoolean(theDialog,_18_);				if(plotZoneAxes != GetBoolean(theDialog,_19_))changedFlag = true;		plotZoneAxes = GetBoolean(theDialog,_19_);				if(labelBounds != GetBoolean(theDialog,_17_))changedFlag = true;		labelBounds = GetItemValue(theDialog,_17_);				structFactFlag = true;				}	DoDefineOR( theDialog,false,_3_);}void KikuchiObject::DoDefine(void){		Boolean			calculateFlag;	MultiLog*		theMultiLog;	short				n = 0;		theMultiLog	= (MultiLog*)new(MultiLog);	theMultiLog->DoInit(261,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoKikuchiObjectSetup,(HitProcPtr)ML_DoKikuchiObjectHit,(ReadProcPtr)ML_DoKikuchiObjectRead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoBeamESetup,(HitProcPtr)ML_DoBeamEHit,(ReadProcPtr)ML_DoBeamERead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoBeamORSetup,(HitProcPtr)ML_DoBeamORHit,(ReadProcPtr)ML_DoBeamORRead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[0]);		theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoStageObjSetup ,(HitProcPtr)ML_DoStageObjHit,(ReadProcPtr)ML_DoStageObjRead,(Ptr)stage);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[1]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[2]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[3]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoPPTSetup,(HitProcPtr)ML_DoPPTHit,(ReadProcPtr)ML_DoPPTRead,(Ptr)the_PPT_Info[0]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoPPTSetup,(HitProcPtr)ML_DoPPTHit,(ReadProcPtr)ML_DoPPTRead,(Ptr)the_PPT_Info[1]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoPPTSetup,(HitProcPtr)ML_DoPPTHit,(ReadProcPtr)ML_DoPPTRead,(Ptr)the_PPT_Info[2]);			theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoFoilSetup,(HitProcPtr)ML_DoFoilHit,(ReadProcPtr)ML_DoFoilRead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoSFSetup,(HitProcPtr)ML_DoSFHit,(ReadProcPtr)ML_DoSFRead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_SetPlotParam,(HitProcPtr)ML_SwitchPlotParam,(ReadProcPtr)ML_ReadPlotParam,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_SetMiscParam,(HitProcPtr)ML_SwitchMiscParam,(ReadProcPtr)ML_ReadMiscParam,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoDefaultSetup,(HitProcPtr)ML_DoDefaultHit,(ReadProcPtr)ML_DoDefaultRead,(Ptr)this);		calculateFlag = theMultiLog->DoMultiLog();	theMultiLog->DoClose();		if(calculateFlag && screenPict == NUL  && gMyOffG == 0L){		changedFlag = true;		reSizeFlag = true;		newPictReq = true;/*eliminated line dec 1992*/	} else if(screenPict == NUL  && gMyOffG == 0L){		CloseTheObject(theWindow);	}	return;}