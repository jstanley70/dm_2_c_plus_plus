#include "ML_TwoDisDef.h"#include "ML_OneDisDef.h"#include 	"OneDisObj.h" #include 	"TwoDisObj.h"#include "ML_Crystal.h"#include "ML_BeamOrientation.h"#include "ML_Elasticity.h"#include "ML_StructFactor.h"#include	"Diffract_INCs.h"#include "ML_Default.h"#include "ML_Misc_Plot.h"void	 ML_DoDisDef2Setup(Ptr	owner,DialogPtr theDialog,Ptr *theParams){	TwoDisObj*			theOwner;	ML_DislocSetPtr  theP;	theOwner					= (TwoDisObj*)owner;	theP = (ML_DislocSetPtr)D_NewPtr(sizeof(ML_DislocSet));	*theParams =  (Ptr)theP;	theOwner->DislocDefSetUp( theDialog,theP);	DrawDialog(theDialog);}void	ML_DoDislocDef2Hit(Ptr	owner,DialogPtr theDialog, short theSelect,Ptr theParams){	TwoDisObj*		theOwner;	Boolean		saveData;	ML_DislocSetPtr  theP;		theOwner		= (TwoDisObj*)owner;	theP			=	(ML_DislocSetPtr)theParams;	theOwner->DislocDefSwitch( theDialog,theP, theSelect,&saveData);}void	ML_DoDislocDef2Read(Ptr owner,DialogPtr theDialog,Ptr theParams,Boolean saveData){	TwoDisObj*		theOwner;	ML_DislocSetPtr  theP;		theOwner		= (TwoDisObj*)owner;	theP			=	(ML_DislocSetPtr)theParams;		theOwner->DislocDefRead( theDialog,theP, saveData);	KillPtr((Ptr)theParams);}void TwoDisObj::DislocDefSetUp(DialogPtr theDialog,ML_DislocSetPtr theParams){		DoDefectSetUp(theDialog);	GetDItem(theDialog,40,&gType,&gTheHandle,&theParams->theRect);	DrawDislocationSchematic(theParams->theRect,lineDirection,burgersVector,true);	}void	TwoDisObj::DislocDefRead(DialogPtr theDialog,ML_DislocSetPtr theParams,Boolean saveData){	ML_DislocSetPtr dummy;	dummy = theParams; //warning	if(saveData){		GetCurrentDefectValues	(theDialog);		InsertCurrentDefects	();	}	}Boolean TwoDisObj::DislocDefSwitch(DialogPtr theDialog,ML_DislocSetPtr theParams,short theSelect,Boolean *saveData){	short i,k;	switch(theSelect){		case -1:		case 2:			*saveData = false;			return true;					case 1:			*saveData = true;			return true;			break;			case _3_:			case _4_:			case _5_:			case _6_:			case _7_:			case _8_:			case _9_:			case _10_:			case _11_:			case _12_:			case _13_:			case _14_:			case _15_:			case _16_:			case _17_:				GetCurrentDefectValues(theDialog);				DrawDislocationSchematic(theParams->theRect,lineDirection,burgersVector,true);			break;			case _18_:				defectFlagsSet[numberDefect_Sets - 1][0] = defectFlags[0] = SwitchBoolean( theDialog, theSelect,defectFlags[0]);				for(i = _3_; i <= _5_;i++){					if(!defectFlags[0])HideDItem( theDialog,i);					else ShowDItem(theDialog,i);				}					break;			case _19_:			case _20_:			case _21_:				i = theSelect - _18_;				defectFlagsSet[numberDefect_Sets - 1][i] = defectFlags[i] = SwitchBoolean( theDialog, theSelect,defectFlags[i]);				for(k = (i * 3) + _6_; k < (i * 3) + _9_;k++){					if(!defectFlags[i])HideDItem( theDialog,k);					else ShowDItem(theDialog,k);				}				break;			case _22_:				if(numberDefect_Sets > 8) break;				GetCurrentDefectValues(theDialog);				InsertCurrentDefects();				numberDefect_Sets++;				if(!ResetDefects(numberDefect_Sets))					AddDefects(theDialog,true);				DoDefectSetUp(theDialog);				break;			case _23_:				if(numberDefect_Sets < 2) break;				GetCurrentDefectValues(theDialog);				InsertCurrentDefects();								numberDefect_Sets--;				ResetDefects(numberDefect_Sets);				DoDefectSetUp(theDialog);				break;			default:				break;			case ML_UPDATE_EVT:			DrawDialog(theDialog);			break;		}	return false;}Boolean TwoDisObj::DefineDislocation(void){	DialogPtr 		theDialog;	short			theSelect;	ML_DislocSetPtr theParams;	Boolean			 saveData,quit = false;		theDialog	= 	DM_GetNewDialog(332,NUL,IN_FRONT);	theParams	=	(ML_DislocSet*)D_NewPtr(sizeof(ML_DislocSet));	DislocDefSetUp(theDialog,theParams);			while(!quit){		ModalDialog(TheFilterUPP,&theSelect);				switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			quit = DislocDefSwitch( theDialog, theParams, theSelect, &saveData);			EndUpdate(theDialog);			break;			default:			quit = DislocDefSwitch( theDialog, theParams, theSelect, &saveData);			break;			}	}	DislocDefRead( theDialog,theParams, saveData);	KillPtr(theParams);	DM_DisposDialog(&theDialog);		return saveData;}void TwoDisObj::DoDefine(void){		Boolean			calculateFlag;	MultiLog*		theMultiLog;	short				n = 0;		theMultiLog	= (MultiLog*)new(MultiLog);	theMultiLog->DoInit(255,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoOneDisObjSetup,(HitProcPtr)ML_DoOneDisObjHit,(ReadProcPtr)ML_DoOneDisObjRead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoBeamESetup,(HitProcPtr)ML_DoBeamEHit,(ReadProcPtr)ML_DoBeamERead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoBeamORSetup,(HitProcPtr)ML_DoBeamORHit,(ReadProcPtr)ML_DoBeamORRead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoFoilSetup,(HitProcPtr)ML_DoFoilHit,(ReadProcPtr)ML_DoFoilRead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[0]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoDisDef2Setup,(HitProcPtr)ML_DoDislocDef2Hit,(ReadProcPtr)ML_DoDislocDef2Read,(Ptr)this);		theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoStageObjSetup ,(HitProcPtr)ML_DoStageObjHit,(ReadProcPtr)ML_DoStageObjRead,(Ptr)stage);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[1]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[2]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[3]);		theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrysElastSetup,(HitProcPtr)ML_DoCrysElastHit,(ReadProcPtr)ML_DoCrysElastRead,(Ptr)theCrystal[0]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrysElastSetup,(HitProcPtr)ML_DoCrysElastHit,(ReadProcPtr)ML_DoCrysElastRead,(Ptr)theCrystal[1]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrysElastSetup,(HitProcPtr)ML_DoCrysElastHit,(ReadProcPtr)ML_DoCrysElastRead,(Ptr)theCrystal[2]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrysElastSetup,(HitProcPtr)ML_DoCrysElastHit,(ReadProcPtr)ML_DoCrysElastRead,(Ptr)theCrystal[3]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoSFSetup,(HitProcPtr)ML_DoSFHit,(ReadProcPtr)ML_DoSFRead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_SetMiscParam,(HitProcPtr)ML_SwitchMiscParam,(ReadProcPtr)ML_ReadMiscParam,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoDefaultSetup,(HitProcPtr)ML_DoDefaultHit,(ReadProcPtr)ML_DoDefaultRead,(Ptr)this);		calculateFlag = theMultiLog->DoMultiLog();	theMultiLog->DoClose();		if(calculateFlag   && screenPict == NUL  && gMyOffG == 0L){		changedFlag = true;		reSizeFlag = true;		newPictReq = true;/*eliminated line dec 1992*/	} else if(screenPict == NUL  && gMyOffG == 0L){		CloseTheObject(theWindow);	}	return;}