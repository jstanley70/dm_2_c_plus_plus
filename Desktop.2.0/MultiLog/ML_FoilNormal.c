#include "ML_FoilNormal.h"#include	"Diffract_INCs.h"Boolean DiffractObject::DefineFoilNormal(void){	DialogPtr 			theDialog;	short						theSelect;	Boolean					quit = false;	Boolean					saveData = false;	ML_FoilParamsPtr theMLParams;		theDialog	= DM_GetNewDialog(11117,NUL,IN_FRONT);	ML_DoFoilSetup((Ptr)this, theDialog,(Ptr*)&theMLParams);	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			quit = DoFoilSwitch(theDialog,theSelect,theMLParams,&saveData);			EndUpdate(theDialog);			break;			default:			quit = DoFoilSwitch(theDialog,theSelect,theMLParams,&saveData);			break;			}			}	ML_DoFoilRead((Ptr)this, theDialog,(Ptr)theMLParams,saveData);	DM_DisposDialog(&theDialog);	return saveData ;}void	ML_DoFoilSetup(Ptr	owner,DialogPtr theDialog,Ptr	*paramBlock){	ML_FoilParamsPtr		theMLParms;	DiffractObject*			theOwner;	short					theSelect;	double				sL,sZ;	Boolean				quit;	short					i;	theOwner					= (DiffractObject*)owner;	theMLParms					= (ML_FoilParamsPtr)D_NewPtr(sizeof(ML_FoilParams));	quit = false;	theMLParms->thisCrystal	=	theOwner->theCrystal[theOwner->baseCrystal];	theMLParms->theIndex	=	(Index*)D_new(Index);	theMLParms->aIndex		=	(Index*)D_new(Index);	theMLParms->bIndex		=	(Index*)D_new(Index);	theMLParms->cIndex		=	(Index*)D_new(Index);	theMLParms->method		=	(PopUpMenu*)D_new(PopUpMenu);	theMLParms->oldIr		=	theOwner->calcFoil;	theMLParms->theFoil		=	theOwner->foilParallel;	theMLParms->x 			=	theOwner->theFNRotationAngle;	theMLParms->y 			=	theOwner->theFNOffLaueDistance;	theMLParms->z			=	0;	theMLParms->theFoil 	= SwitchBoolean(theDialog,ML_FOIL_PARALLEL,!theOwner->foilParallel);	theMLParms->method			->Init(theDialog,ML_METHOD_B,38,theMLParms->oldIr);	theOwner->theFoilNormal		->DoCopy(theMLParms->theIndex);	theOwner->theFNRotationAxis	->DoCopy(theMLParms->aIndex);	theOwner->theFoilBragg		->DoCopy(theMLParms->bIndex);	theMLParms->theIndex->theCrystal = theMLParms->thisCrystal;	theMLParms->aIndex->theCrystal = theMLParms->thisCrystal;	theMLParms->bIndex->theCrystal = theMLParms->thisCrystal;	theOwner->SetForZone(theDialog,theMLParms->oldIr,theMLParms->theIndex,theMLParms->aIndex,theMLParms->bIndex,	theMLParms->x,theMLParms->y);	theMLParms->doSteps = theOwner->GetFoilPtrs(&theMLParms->delFlag,&theMLParms->newSteps,&theMLParms->newInterval);		if(!theMLParms->doSteps)	{		for(theSelect = ML_MACRO_FLAG; theSelect < ML_MORE;theSelect++) 				HideDItem(theDialog,theSelect);	}else{		for(theSelect = ML_MACRO_FLAG; theSelect < ML_MORE;theSelect++) ShowDItem(theDialog,theSelect);				theMLParms->delFlag = SwitchBoolean(theDialog,ML_MACRO_FLAG,!theMLParms->delFlag);		SetItemValue(theDialog,ML_STEPS/*18*/,theMLParms->newSteps,1);		SetItemValue(theDialog,ML_DELTA/*18*/,theMLParms->newInterval,1);	}		SetItemValue(theDialog,ML_W_VALUE,theOwner->CalculateW_OffBragg(theMLParms->theIndex,theMLParms->aIndex,theMLParms->bIndex, theMLParms->x, theMLParms->y, theMLParms->z, theMLParms->oldIr,&sZ,&sL),3);	SetItemValue(theDialog,ML_EXTINCT_B,(theMLParms->bIndex->TheExtinctionDist(1/theOwner->wavelength, 1,  theOwner->theBeamFlag)),1);	SetItemValue(theDialog,ML_FOIL_THICK/*18*/,theOwner->theFoilThickness,1);	if(theMLParms->theFoil){		SetItemValue(theDialog,ML_TRUE_THICK/*21*/,GetItemValue(theDialog,ML_FOIL_THICK/*18*/),1);		theOwner->GetSpikingFactor(theMLParms->theIndex,theMLParms->aIndex,theMLParms->bIndex,theMLParms->x,theMLParms->y,GetItemValue(theDialog,ML_FOIL_THICK/*18*/),theMLParms->oldIr, theMLParms->thisCrystal);		SetItemValue(theDialog,ML_ANGLE_BET/*22*/,0,2);	}else{		theOwner->GetDialogValues(theDialog,theMLParms->oldIr,theMLParms->theIndex,theMLParms->aIndex,theMLParms->bIndex,&theMLParms->x,&theMLParms->y);		theOwner->GetSpikingFactor( theMLParms->theIndex,theMLParms->aIndex,theMLParms->bIndex,theMLParms->x,theMLParms->y,GetItemValue(theDialog,ML_FOIL_THICK/*18*/),theMLParms->oldIr,theMLParms->thisCrystal);		SetItemValue(theDialog,ML_TRUE_THICK/*21*/,theOwner->trueThickness,1);		SetItemValue(theDialog,ML_ANGLE_BET/*22*/,180 * theOwner->AngleBetFoilAndBeam(theMLParms->theIndex,theMLParms->aIndex,theMLParms->bIndex,theMLParms->x,theMLParms->y,theMLParms->z,theMLParms->oldIr) / PI,2);	}	if(theMLParms->theFoil){		for(i = ML_METHOD_B; i < ML_FOIL_PARALLEL;i++)HideDItem(theDialog,i);		HideDItem(theDialog,ML_GVEC_TEXT);		//HideDItem(theDialog,ML_STUFF);		//HideDItem(theDialog,ML_MORE);		HideDItem(theDialog,ML_HOR_ROT);		HideDItem(theDialog,ML_HOR_ROT_TEXT);	}	*paramBlock = (Ptr)theMLParms;}Boolean DiffractObject::DoFoilSwitch(DialogPtr theDialog,short theSelect,ML_FoilParamsPtr theMLParams,Boolean *saveData){		Index			*theIndex,*aIndex,*bIndex,*cIndex;	double			x,y,z;	PopUpMenu		*method;	short			oldIr;	Boolean			theFoil,theChangedFlag = false;	Crystal			*thisCrystal;	double 			matrix[3][3];	short 			theResult;	Boolean			doSteps;	Boolean			delFlag;	short			newSteps;	short			newInterval;	double			oldMatrix[3][3];	short i;		thisCrystal =	theMLParams->thisCrystal;	theIndex = theMLParams->theIndex;	aIndex 	=	theMLParams->aIndex;	bIndex	=	theMLParams->bIndex;	cIndex	=	theMLParams->cIndex;	method	=	theMLParams->method;	oldIr		=	theMLParams->oldIr;	theFoil		=	theMLParams->theFoil;	x				=	theMLParams->x ;	y				=	theMLParams->y;	z				=	theMLParams->z;	doSteps			=	theMLParams->doSteps;	delFlag			=	theMLParams->delFlag;	newSteps		=	theMLParams->newSteps;	newInterval		=	theMLParams->newInterval;	*saveData  = false;			switch(theSelect){		case -1:		case ML_BEAM_CANCEL:			*saveData  = false;			return true;		case ML_BEAM_OK:			ReadBeamORData(theDialog,false, oldIr, &x, &y);			cIndex->x = x;			cIndex->y = y;			cIndex->z = z;			*saveData  = true;			return true;						case ML_GVECTOR:			bIndex->GetIndex(theDialog,ML_GVECTOR);			SetItemValue(theDialog,ML_EXTINCT_B,(bIndex->TheExtinctionDist(1/wavelength, 1,  theBeamFlag)),1);			break;		case ML_FOIL_PARALLEL:			theFoil = SwitchBoolean(theDialog,ML_FOIL_PARALLEL,theFoil);			if(theFoil){				for(i = ML_METHOD_B; i <ML_FOIL_PARALLEL;i++)HideDItem(theDialog,i);				HideDItem(theDialog,ML_GVEC_TEXT);				//HideDItem(theDialog,ML_STUFF);				//HideDItem(theDialog,ML_MORE);			}else{				for(i = ML_METHOD_B; i <ML_FOIL_PARALLEL;i++)ShowDItem(theDialog,i);				ShowDItem(theDialog,ML_GVEC_TEXT);				//ShowDItem(theDialog,ML_STUFF);				//ShowDItem(theDialog,ML_MORE);				method->SetPopUp();				GetDialogValues(theDialog,oldIr,theIndex,aIndex,bIndex,&x,&y);				SetForZone(theDialog,oldIr,theIndex,aIndex,bIndex,x,y);							}			break;		case ML_TOWARD:			if(oldIr >= 5){				bIndex->GetIndex(theDialog,ML_TOWARD);				bIndex->SetIndex(theDialog,ML_GVECTOR);				SetItemValue(theDialog,ML_EXTINCT_B,(bIndex->TheExtinctionDist(1/wavelength, 1,  theBeamFlag)),1);				}			break;		case ML_ZONE_AXIS:			GetDialogValues(theDialog,oldIr,theIndex,aIndex,bIndex,&x,&y);			if(oldIr < 2){				theIndex->x = theIndex->h;				theIndex->y = theIndex->k;				theIndex->z = theIndex->l;			}		case ML_MACRO_FLAG:			delFlag = SwitchBoolean(theDialog,ML_MACRO_FLAG,delFlag);			break;		case ML_METHOD_B:			method->DoPopUp();			theResult = method->lastResult;			if(theResult != oldIr){				oldIr = theResult;				GetDialogValues(theDialog,oldIr,theIndex,aIndex,bIndex,&x,&y);				SetForZone(theDialog,oldIr,theIndex,aIndex,bIndex,x,y);			}else			break;		default:			if(theFoil){				SetItemValue(theDialog,ML_TRUE_THICK/*21*/,GetItemValue(theDialog,ML_FOIL_THICK/*18*/),1);				SetItemValue(theDialog,ML_ANGLE_BET/*22*/,0,2);			}else{				double thick;				GetDialogValues(theDialog,oldIr,theIndex,aIndex,bIndex,&x,&y);				thick = GetItemValue(theDialog,ML_FOIL_THICK/*18*/);				GetSpikingFactor(theIndex,aIndex,bIndex,x,y,thick,oldIr,thisCrystal);				SetItemValue(theDialog,ML_TRUE_THICK/*21*/,trueThickness,1);				SetItemValue(theDialog,ML_ANGLE_BET/*22*/,180 * AngleBetFoilAndBeam(theIndex,aIndex,bIndex,x,y,z,oldIr) / PI,2);			}			GetDialogValues(theDialog,oldIr,theIndex,aIndex,bIndex,&x,&y);			{				double sZ,sL;				CalculateOrientation(theIndex,aIndex,bIndex,x,y,z,0,oldIr,matrix);				theIndex->DoCopy(cIndex);				cIndex->x = cIndex->y = 0; cIndex->z = 1;				InvertMatrix(matrix);				cIndex->GetTheUVWFromXYZ(matrix);				if(!cIndex->direction){					double H,K,L;					H = cIndex->x;					K = cIndex->y;					L = cIndex->z;					cIndex->DirOfPlaneNormal(&H,&K,&L);					cIndex->x = H;					cIndex->y = K;					cIndex->z = L;				}				cIndex->NormalizeToGreatestXYZ();				sprintf(gTheText,"[%6.5f , %6.5f , %6.5f ]",cIndex->x,cIndex->y,cIndex->z);				SetItemText( theDialog, ML_BEAM_IRRATION,c2pstr(gTheText));				SetItemValue(theDialog,ML_W_VALUE,CalculateW_OffBragg(theIndex,aIndex,bIndex, x, y, z, oldIr,&sZ,&sL),3);				SetItemValue(theDialog,ML_EXTINCT_B,(bIndex->TheExtinctionDist(1/wavelength, 1,  theBeamFlag)),1);				}		break;		case ML_UPDATE_EVT:			DrawDialog(theDialog);			break;		case ML_MATRIX_DISPLAY:			GetDialogValues(theDialog,oldIr,theIndex,aIndex,bIndex,&x,&y);			GetOrientation		(oldMatrix);			CalculateOrientation(theIndex,aIndex,bIndex,x,y,z,0,oldIr,matrix);			SetOrientation		(matrix);//the OrientationMatrixDialogBox() expects to use the stored oreintation matrix			OrientationMatrixDialogBox();			SetOrientation		(oldMatrix);			DrawDialog(theDialog);			method->SetPopUp();			break;	}	theMLParams->thisCrystal	= thisCrystal;	theMLParams->theIndex = theIndex;	theMLParams->aIndex 	= aIndex;	theMLParams->bIndex	=	bIndex;	theMLParams->cIndex	=	cIndex;	theMLParams->method	=	method;	theMLParams->oldIr		=	oldIr;	theMLParams->theFoil	=	theFoil;	theMLParams->x				=	x ;	theMLParams->y				=	y;	theMLParams->z				=	z;	theMLParams->doSteps =	doSteps;	theMLParams->delFlag	=	delFlag;	theMLParams->newSteps	=	newSteps;	theMLParams->newInterval	=	newInterval;	return false;}void		ML_DoFoilHit(Ptr	owner,DialogPtr theDialog, short theSelect,	Ptr	paramBlock){	DiffractObject *theOwner;	Boolean			saveData;	theOwner = (DiffractObject*)owner;	theOwner->DoFoilSwitch(theDialog,theSelect,(ML_FoilParamsPtr)paramBlock,&saveData);	return ;}void		ML_DoFoilRead(Ptr owner,DialogPtr theDialog,Ptr	paramBlock,Boolean saveData){	ML_FoilParamsPtr		theMLParms;	DiffractObject*			theOwner;		theMLParms		= (ML_FoilParamsPtr)paramBlock;	theOwner		= (DiffractObject*)owner;	theOwner->foilParallel = theMLParms->theFoil;	if(saveData){		theOwner->DoFoilRead(theDialog,(ML_FoilParamsPtr)theMLParms, saveData);	}		theMLParms->theIndex->DoClose();	theMLParms->aIndex->DoClose();	theMLParms->bIndex->DoClose();	theMLParms->cIndex->DoClose();	theMLParms->method->DoClose();	KillPtr(paramBlock);}void DiffractObject::DoFoilRead(DialogPtr theDialog,ML_FoilParamsPtr theParams,Boolean saveData){	double x,y;	short  oldIr;		oldIr = theParams->oldIr;	if(saveData){		GetDialogValues(theDialog,oldIr,theFoilNormal,theFNRotationAxis,theFoilBragg,&x,&y);		theFNRotationAngle = x;		theFNOffLaueDistance = y;		calcFoil = oldIr;		foilParallel = theParams->theFoil;		if(theParams->doSteps){			theParams->newSteps = GetItemValue(theDialog,ML_STEPS);			theParams->newInterval = GetItemValue(theDialog,ML_DELTA);			theParams->delFlag = GetBoolean(theDialog,ML_MACRO_FLAG);			SetFoilPtrs(theParams->delFlag,theParams->newSteps,theParams->newInterval);		}		if(oldIr < 2){			theFoilNormal->x = theFoilNormal->h;			theFoilNormal->y = theFoilNormal->k;			theFoilNormal->z = theFoilNormal->l;		}					if(foilParallel){//return to original orientation			theZoneAxis		->		DoCopy(theFoilNormal);			theRotationAxis	->		DoCopy(theFNRotationAxis);			g_Vector		->		DoCopy(theFoilBragg);			theFNRotationAngle 		= 	rotationAngle;			theFNOffLaueDistance 	= 	offLaueDistance;			calcFoil 				=	calcIrrational;		}		if(calcFoil == 3 || calcFoil == 4){				if(theFoilNormal->h == theFNRotationAxis->h &&					theFoilNormal->k == theFNRotationAxis->k &&					theFoilNormal->l == theFNRotationAxis->l ||					theFoilNormal->h == -theFNRotationAxis->h &&					theFoilNormal->k == -theFNRotationAxis->k &&					theFoilNormal->l == -theFNRotationAxis->l){						Message(ROTATE_AXIS_BEAM_SAME);				}			}			if(calcFoil >= 5 && calcFoil <= 7){				if(fabs(theFoilNormal->GetTheAngle(theFoilBragg)) > 95 || fabs(theFoilNormal->GetTheAngle(theFoilBragg)) < 85){					Message(BEAM_G_NOT_90);				}			}		theFoilThickness = GetItemValue(theDialog,ML_FOIL_THICK/*18*/);		trueThickness  = GetItemValue(theDialog,ML_TRUE_THICK/*21*/);	}}