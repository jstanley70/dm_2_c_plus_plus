#include "ML_SADObj.h"#include "ML_Crystal.h"#include "ML_PPT_Info.h"#include "ML_BeamOrientation.h"#include "ML_CrystalFace.h"#include "ML_Default.h"#include "ML_Misc_Plot.h"#define SADDEFINE_OBJ 300void	ML_DoSADObjSetup(Ptr	owner,DialogPtr theDialog,Ptr *theParams){	SADObj*			theOwner;	theOwner					= (SADObj*)owner;	theOwner->SetDefineObj( theDialog);	*theParams = (Ptr)0L;	DrawDialog(theDialog);}void	ML_DoSADObjHit(Ptr	owner,DialogPtr theDialog, short theSelect,Ptr theParams){	SADObj*		theOwner;	Boolean		saveData;		theOwner		= (SADObj*)owner;	theParams		= (Ptr)NUL;             // Eliminates warning;  theParams is required		theOwner->DefineSwitch( theDialog, theSelect,&saveData);}void	ML_DoSADObjRead(Ptr owner,DialogPtr theDialog,Ptr theParams,Boolean saveData){	SADObj*		theOwner;	theOwner		= (SADObj*)owner;	theParams		= (Ptr)NUL; 	theOwner->ReadDefineDialog( theDialog, saveData);}Boolean	SADObj::DefineSwitch(DialogPtr theDialog,short theSelect,Boolean *saveData){	switch(theSelect){			Boolean theFlag;			case -1:			case 2:				*saveData = false;				return true;			case DLOG_ENTER_OR_CR:			case 1:				*saveData = true;					return true;			case 5:			case 6:			case 7:			case 8:			case 9:			case 10:			case 11:			case 12:			case 13:				theFlag = GetBoolean(theDialog,theSelect);				theFlag = SwitchBoolean(theDialog,theSelect,theFlag);				if(theSelect == 13 && theFlag == true)PrecipitateSetUp();				break;			default:				break;			case ML_UPDATE_EVT:			DrawDialog(theDialog);			break;		}		return false;}void  SADObj::SetDefineObj(DialogPtr theDialog){	short i,n = 5;	for(i = n; i <= n + 3;i++){		plotFlags[i-n] = SwitchBoolean(theDialog,i,!plotFlags[i-n]);	}	fullCalcPPt = SwitchBoolean(theDialog,13,!fullCalcPPt);	greyFlag = SwitchBoolean(theDialog,10,!greyFlag);	showPeriods = SwitchBoolean(theDialog,11,!showPeriods);	calcPPtSize = SwitchBoolean(theDialog,9,!calcPPtSize);	kikuchiLines = SwitchBoolean(theDialog,12,!kikuchiLines);	SetItemValue(theDialog,14,kLimit,0);	baseCrystal = -1;	i = -1;	while(baseCrystal < 0 && i < 3){		i++;		if(plotFlags[i]){			setCrystal = theCrystal[i];			baseCrystal = i;		}	}	if(baseCrystal < 0){		setCrystal = theCrystal[0];		baseCrystal = 0;	}	DrawDialog(theDialog);}void	SADObj::DoDefine(void){	Boolean			calculateFlag;	MultiLog*		theMultiLog;	short				n = 0;		theMultiLog	= (MultiLog*)new(MultiLog);	theMultiLog->DoInit(252,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoSADObjSetup,(HitProcPtr)ML_DoSADObjHit,(ReadProcPtr)ML_DoSADObjRead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoBeamESetup,(HitProcPtr)ML_DoBeamEHit,(ReadProcPtr)ML_DoBeamERead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoBeamORSetup,(HitProcPtr)ML_DoBeamORHit,(ReadProcPtr)ML_DoBeamORRead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[0]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoStageObjSetup,(HitProcPtr)ML_DoStageObjHit,(ReadProcPtr)ML_DoStageObjRead,(Ptr)stage);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[1]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[2]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrystalSetup,(HitProcPtr)ML_DoCrystalHit,(ReadProcPtr)ML_DoCrystalRead,(Ptr)theCrystal[3]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoPPTSetup,(HitProcPtr)ML_DoPPTHit,(ReadProcPtr)ML_DoPPTRead,(Ptr)the_PPT_Info[0]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoPPTSetup,(HitProcPtr)ML_DoPPTHit,(ReadProcPtr)ML_DoPPTRead,(Ptr)the_PPT_Info[1]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoPPTSetup,(HitProcPtr)ML_DoPPTHit,(ReadProcPtr)ML_DoPPTRead,(Ptr)the_PPT_Info[2]);		theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrysFaceSetup,(HitProcPtr)ML_DoCrysFaceHit,(ReadProcPtr)ML_DoCrysFaceRead,(Ptr)theCrystal[1]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrysFaceSetup,(HitProcPtr)ML_DoCrysFaceHit,(ReadProcPtr)ML_DoCrysFaceRead,(Ptr)theCrystal[2]);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoCrysFaceSetup,(HitProcPtr)ML_DoCrysFaceHit,(ReadProcPtr)ML_DoCrysFaceRead,(Ptr)theCrystal[3]);		theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoFoilSetup,(HitProcPtr)ML_DoFoilHit,(ReadProcPtr)ML_DoFoilRead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_SetPlotParam,(HitProcPtr)ML_SwitchPlotParam,(ReadProcPtr)ML_ReadPlotParam,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_SetMiscParam,(HitProcPtr)ML_SwitchMiscParam,(ReadProcPtr)ML_ReadMiscParam,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoDefaultSetup,(HitProcPtr)ML_DoDefaultHit,(ReadProcPtr)ML_DoDefaultRead,(Ptr)this);	theMultiLog->AssignFunction(n++,(SetupProcPtr)ML_DoSFSetup,(HitProcPtr)ML_DoSFHit,(ReadProcPtr)ML_DoSFRead,(Ptr)this);		calculateFlag = theMultiLog->DoMultiLog();	theMultiLog->DoClose();		if(calculateFlag && screenPict == NUL  && gMyOffG == 0L){		changedFlag = true;		reSizeFlag = true;		newPictReq = true;/*eliminated line dec 1992*/	} else if(screenPict == NUL  && gMyOffG == 0L){		CloseTheObject(theWindow);	}	return;}void		SADObj::ReadDefineDialog(DialogPtr theDialog,Boolean saveData){	short i;	short n = 5;	short	oldLimit;	if(saveData){				/* Eric re-wrote this section July 1993 */		Boolean theFlag;				for(i = n ; i <= n + 3 ; i++){			theFlag = GetBoolean(theDialog,i);			if(plotFlags[i - n] < theFlag)changedFlag = true;			if(plotFlags[i-n] != theFlag)newPictReq = true;			plotFlags[i - n] = theFlag;		}		if(changedFlag)DoDefineOR( theDialog, false,_3_);				if(showPeriods 	!= GetBoolean(theDialog,11))newPictReq = true;				showPeriods 	= GetBoolean(theDialog,11);				if(greyFlag 	!= GetBoolean(theDialog,10))newPictReq = true;				greyFlag 		= GetBoolean(theDialog,10);				if(greyFlag 	!= GetBoolean(theDialog,9))changedFlag = true;				calcPPtSize 	= GetBoolean(theDialog,9);				if(fullCalcPPt  != GetBoolean(theDialog,13))changedFlag = true;				fullCalcPPt 	= GetBoolean(theDialog,13);				if(kikuchiLines 	!= GetBoolean(theDialog,12))changedFlag = true;				kikuchiLines 	= GetBoolean(theDialog,12);			oldLimit = kLimit;		kLimit = GetItemValue(theDialog,14);		if(kLimit != oldLimit && kikuchiLines)changedFlag = true;	}}void SADObj::DoSetUp(void){	DialogPtr 		theDialog;	short			theSelect;	Boolean			quit = false;	Boolean			saveData = false;		theDialog	= DM_GetNewDialog(11114,NUL,IN_FRONT);		SetDefineObj( theDialog);	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			quit = DefineSwitch( theDialog, theSelect,&saveData);			EndUpdate(theDialog);			break;			default:			quit = DefineSwitch( theDialog, theSelect,&saveData);			break;			}			}	ReadDefineDialog( theDialog, saveData);	DM_DisposDialog(&theDialog);		return;}