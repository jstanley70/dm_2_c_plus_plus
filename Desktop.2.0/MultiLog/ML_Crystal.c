#include	"Diffract_INCs.h"#include "ML_Crystal.h"#define	C_CRYSTAL_COLOR 25void	ML_DoCrystalSetup(Ptr	owner,DialogPtr theDialog,Ptr	*paramBlock){	ML_CrysParamsPtr	theMLParms;	Crystal*			theOwner;//will be the copy to be manipulated	RGBColor			theColor;	Handle				theHandle;	Rect				theRect;	short				type;	//whoa nellie!! 2/99		gCurrentObj->crystalDialogFlag = true;		//whoa nellie!! 2/99	theOwner					= (Crystal*)owner;	//gCurrentObj->currentCrystal = 0L;	theMLParms					= (ML_CrysParamsPtr)D_NewPtr(sizeof(ML_CrysParams));	theMLParms->originalOwner	= 0L;	theMLParms->theOwner		= theOwner;//takes the copy and makes it the one to be manipulated	//also insures  open and close files work properly!!!	theMLParms->saveAsMenu 		= GetMenu(124);	theMLParms->fileMenu		= (PopUpMenu*)D_new(PopUpMenu);	theMLParms->popUpMenu		= (PopUpMenu*)D_new(PopUpMenu);	theMLParms->thisColor		= theOwner->crystalColor;	theMLParms->theAtomList 	= (ListHandle)NUL;	*paramBlock					= (Ptr)theMLParms;		ML_InitAtomList(theDialog,theMLParms);		theMLParms->fileMenu->Init(theDialog,FILE_MENU_POP,122,1);	theMLParms->fileMenu->SetPopUp();	theMLParms->popUpMenu->Init(theDialog,LATTICE_TYPE,12,theOwner->lattice_Type);	theMLParms->popUpMenu->lastResult = theOwner->lattice_Type;	theMLParms->popUpMenu->P_CheckCItem(true);		theMLParms->uniqueMenuID 	= theMLParms->fileMenu->theResID;	InsertMenu(theMLParms->saveAsMenu,-1);		ML_CleanTheButton(theDialog,theOwner->lattice_Type);		ML_DisplayCrystalName(theDialog,theOwner->idNum);	ML_SetUnitCell(theOwner,theDialog);	ML_ListAtoms(theOwner,theMLParms->theAtomList);	theMLParms->theAtoms = theOwner->theAtoms;	theMLParms->atom_Count = theOwner->atom_Count;	theMLParms->latticeType = theOwner->lattice_Type;	theMLParms->changed = false;	theMLParms->uc = theOwner->theUnitCell;	D_HandToHand((Handle*)&theMLParms->theAtoms);	GetDItem(theDialog,C_CRYSTAL_COLOR,&type,&theHandle,&theRect);	GetForeColor(&theColor);	RGBForeColor(&theMLParms->thisColor);	PaintOval(&theRect);	RGBForeColor(&theColor);	FrameOval(&theRect);	InvalRect					(&theDialog->portRect);	SelIText(theDialog,A_PRAM,0,1000);	//ML_ResetDialogBox(theDialog,theOwner->lattice_Type,theMLParms);}		void	ML_DoCrystalHit(Ptr	owner,DialogPtr theDialog, short theSelect,	Ptr	paramBlock){	ML_CrysParamsPtr	theMLParms;	ITCCrystalObject 	*iTCCrystalObj;	Crystal*			theOwner;		AtomPtr 			theAtomsPtr;	RGBColor			theColor;	Boolean				dblClick;	Handle				theHandle;	Point				thePoint;	Rect				theRect;	Cell				theCell;	short 				i,length,theValue,type;	unsigned long		theResult;	long				theSize;	Rect				eraseRect;		GetDItem(theDialog,24,&type,&theHandle,&eraseRect);	theOwner					= (Crystal*)owner;	theMLParms					= (ML_CrysParamsPtr)paramBlock;		length = 3000;	switch(theSelect){		case GRAB_CRYSTAL:			i = Alert(SELECT_XTAL,NUL);			switch(i){				case 1:					break;				case 2:				case 3:				case 4:				case 5:					i 				-= 2;					theValue 		= theOwner->idNum;					(gDefault->theCrystal[i])->CopyCrystal(theOwner);					theOwner->idNum = theValue;					break;				case 6:				case 7:				case 8:				case 9:					i -= 6;					theValue 		= theOwner->idNum;					(gCurrentObj->theCrystal[i])->CopyCrystal(theOwner);					theOwner->idNum = theValue;					break;				default:					break;			}						ML_KillAtomList(theMLParms);		//	ML_ResetDialogBox(theDialog,theOwner->lattice_Type,theMLParms);			ML_CleanTheButton(theDialog,theOwner->lattice_Type);			GetDItem(theDialog,GRAB_CRYSTAL,&type,&gTheHandle,&theRect);			//InvalRect(&theRect);				InvalRect(&theDialog->portRect);			theMLParms->thisColor = theOwner->crystalColor;						break;					case SET_DEFAULT:			i = Alert(SELECT_XTAL,NUL);			EraseRect(&eraseRect);			InvalRect(&theDialog->portRect);			switch(i){				case 1:					break;				case 2:				case 3:				case 4:				case 5:					i 				-= 2;					ML_ReadCrystal(theOwner,theDialog,theMLParms);					theOwner->JustifyAtomPos();					theOwner->GetSvals();					theOwner->CellVolume();					//theOwner->SetDSpace();					theOwner->DetermineCrystalFaces();					theOwner->DetermineVertices();					theOwner->DetermineEdges();					theOwner->ElasticConstantSymmetry();					theOwner->CopyCrystal((gDefault->theCrystal[i]));											gDefault->theCrystal[i]->idNum = i;					break;				case 6:			////**********TO HERE!!!!!!!!				case 7:				case 8:				case 9:					i -= 6;					ML_ReadCrystal(theOwner,theDialog,theMLParms);					theOwner->JustifyAtomPos();					theOwner->GetSvals();					theOwner->CellVolume();					//theOwner->SetDSpace();					theOwner->DetermineCrystalFaces();					theOwner->DetermineVertices();					theOwner->DetermineEdges();					theOwner->ElasticConstantSymmetry();					theOwner->CopyCrystal((gCurrentObj->theCrystal[i]));					gCurrentObj->theCrystal[i]->idNum = i;					break;				default:					break;							}					GetDItem(theDialog,SET_DEFAULT,&type,&gTheHandle,&theRect);  // Force Updt Evt			InvalRect(&theDialog->portRect);				//ML_ResetDialogBox(theDialog,theOwner->lattice_Type,theMLParms);		//	theSize = CompactMem(300000);			break;		case	C_SET_NUM_ATOMS:			ML_ReadCrystal(theOwner,theDialog,theMLParms); 			theOwner->SetNumAtoms();			ML_InitAtomList(theDialog,theMLParms);			GetDItem(theDialog,C_THE_LIST_RECT,&type,&gTheHandle,&theRect);			EraseRect(&eraseRect);			InvalRect(&theDialog->portRect);		//	theSize = CompactMem(300000);						break;					case	A_PRAM:			GetDItem(theDialog,A_PRAM,&type,&theHandle,&theRect);			GetIText(theHandle,pTheText);			switch(theOwner->lattice_Type){				case CUBIC:				case TRIGHEX:					GetDItem(theDialog,C_PRAM,&type,&theHandle,&theRect);					SetIText(theHandle,pTheText);				case HEXAGONAL:				case TRIGONAL:				case TETRAGONAL:					GetDItem(theDialog,B_PRAM,&type,&theHandle,&theRect);					SetIText(theHandle,pTheText);					break;				default:					break;			}			break;		case	ALPHA_PRAM:			GetDItem(theDialog,ALPHA_PRAM,&type,&theHandle,&theRect);			GetIText(theHandle,pTheText);			switch(theOwner->lattice_Type){				case TRIGHEX:					GetDItem(theDialog,BETA_PRAM,&type,&theHandle,&theRect);					SetIText(theHandle,pTheText);					GetDItem(theDialog,GAMMA_PRAM,&type,&theHandle,&theRect);					SetIText(theHandle,pTheText);				default:					break;			}			break;		case FILE_MENU_POP:			theResult = theMLParms->fileMenu->DoPopUp();			if(theResult == 0){				break;			}			ML_DoMenu(theDialog,theMLParms,theResult);					SetPort(theDialog);			InvalRect(&theDialog->portRect);			//ML_ResetDialogBox(theDialog,theOwner->lattice_Type,theMLParms);	//		theSize = CompactMem(300000);			break; 					case	LATTICE_TYPE:			theResult = theMLParms->popUpMenu->DoPopUp();			theMLParms->popUpMenu->P_CheckItem(theOwner->lattice_Type,false);			if(theOwner->lattice_Type == theMLParms->popUpMenu->lastResult)break;			theOwner->lattice_Type 		= theMLParms->popUpMenu->lastResult;			theMLParms->popUpMenu		-> P_CheckCItem(true);			ML_ReadCrystal				(theOwner,theDialog,theMLParms);			ML_CleanTheButton			(theDialog,theOwner->lattice_Type);			InvalRect					(&theDialog->portRect);			//ML_ResetDialogBox(theDialog,theOwner->lattice_Type,theMLParms);	//		theSize = CompactMem(300000);			break;		case	C_THE_LIST_RECT:			GlobalToLocal(&(gTheEvent.where));			dblClick = LClick(gTheEvent.where,gTheEvent.modifiers,theMLParms->theAtomList);			theCell = LLastClick(theMLParms->theAtomList);			if(theCell.v > theOwner->atom_Count){				break;			}			if(dblClick && theCell.h == ELEMENT){				theAtomsPtr 						= *(theOwner->theAtoms);				theValue 							= theAtomsPtr[theCell.v].atomicNum;				theOwner->DoUserDefAtom(&theValue);				theAtomsPtr[theCell.v].atomicNum 	= theValue;				theOwner->GetAtomicSymbol(theAtomsPtr[theCell.v].atomicNum,gTheText);				GetDItem(theDialog,C_THE_LIST_DATA,&type,&theHandle,&theRect);				c2pstr(gTheText);				SetIText(theHandle,pTheText);				SelIText(theDialog,C_THE_LIST_DATA,0,length);				LSetCell(&(gTheText[1]),(short)(gTheText[0]),theCell,theMLParms->theAtomList);				EraseRect(&eraseRect);				InvalRect(&theDialog->portRect);			} else if(dblClick && theCell.h == DW_FACTOR){				theAtomsPtr = *(theOwner->theAtoms);				D_HLock((Handle)theOwner->theAtoms);				theOwner->GetDWFactor(&theAtomsPtr[theCell.v]);				D_HUnlock((Handle)theOwner->theAtoms);				SetItemValue(theDialog,C_THE_LIST_DATA,theAtomsPtr[theCell.v].bi,2);				SelIText(theDialog,C_THE_LIST_DATA,0,length);				LSetCell(&(gTheText[1]),(short)(gTheText[0]),theCell,theMLParms->theAtomList);				EraseRect(&eraseRect);				InvalRect(&theDialog->portRect);			}else {				length = 20;				LGetCell(&(gTheText[1]),&length,theCell,theMLParms->theAtomList);				gTheText[0] = (char)length;				GetDItem(theDialog,C_THE_LIST_DATA,&type,&theHandle,&theRect);				SetIText(theHandle,pTheText);				SelIText(theDialog,C_THE_LIST_DATA,0,length);			}			break;		case	DLOG_ENTER_KEY:			GetDItem(theDialog,C_THE_CHECK_BOX,&type,&theHandle,&theRect);			HiliteControl((ControlHandle)theHandle,1);			Delay(8L,&theResult);			HiliteControl((ControlHandle)theHandle,0);  /*  !!!!  NO BREAK  !!!  */		case	C_THE_CHECK_BOX:			theCell.h	= theCell.v	= 0;			if(LGetSelect(true,&theCell,theMLParms->theAtomList)){				ML_DoCellUpdate(theCell,theDialog,theMLParms);			}			break;		case	THE_SCROLL_BARS:			GlobalToLocal(&(gTheEvent.where));			dblClick = LClick(gTheEvent.where,gTheEvent.modifiers,theMLParms->theAtomList);			break;					case SET_COLOR:			thePoint.h 	= 0;			thePoint.v 	= 0;			if(GetColor(thePoint,"\pSelect Crystal Color:",&theMLParms->thisColor,&theColor)){				theMLParms->thisColor = theColor;				GetDItem(theDialog,C_CRYSTAL_COLOR,&type,&theHandle,&theRect);			}			//ML_ResetDialogBox(theDialog,theOwner->lattice_Type,theMLParms);			EraseRect(&eraseRect);			InvalRect(&theDialog->portRect);			break;					case C_DO_MENU:			ML_DoMenu(theDialog,theMLParms,GetWRefCon(theDialog));			ML_CleanTheButton(theDialog,theOwner->lattice_Type);	//		ML_ResetDialogBox(theDialog,theOwner->lattice_Type,theMLParms);			theSize = CompactMem(300000);			break;					case ADD_WYCKOFF:			ML_ReadCrystal(theOwner,theDialog,theMLParms); 			iTCCrystalObj = (ITCCrystalObject*)D_new(ITCCrystalObject);			iTCCrystalObj->InitCrystal(1);			#ifdef _DEMO_VERS_			CrystCopy((Crystal*)theOwner,iTCCrystalObj);			#endif							if(HandleIsOK((Handle)iTCCrystalObj)){				theOwner->CopyCrystal((Crystal*)iTCCrystalObj);					if(iTCCrystalObj->EnterWyCrystalPos()){					#ifdef _DEMO_VERS_					CrystCopy(iTCCrystalObj,(Crystal*)theOwner);					#else					iTCCrystalObj->CopyCrystal((Crystal*)theOwner);					#endif				}				iTCCrystalObj->DoClose();						}			ML_InitAtomList(theDialog,theMLParms);			GetDItem(theDialog,C_THE_LIST_RECT,&type,&gTheHandle,&theRect);			InvalRect(&theDialog->portRect);		//	theSize = CompactMem(300000);			EraseRect(&eraseRect);			InvalRect(&theDialog->portRect);			//ML_ResetDialogBox(theDialog,theOwner->lattice_Type,theMLParms);				break;						case REFERENCES:			if(!theOwner->referenceInfoSet){				theOwner->referenceInfoSet = false;				theOwner->ChemicalFormula();			}			theOwner->ReferenceDITL();			//ML_ResetDialogBox(theDialog,theOwner->lattice_Type,theMLParms);				EraseRect(&eraseRect);			InvalRect(&theDialog->portRect);			break;					case R_TO_T:			ML_ReadCrystal(theOwner,theDialog,theMLParms); 			if(!theOwner->RhomboToTrig()){				break;			}			if(!TRIGHEX == theOwner->lattice_Type){				GetDItem(theDialog,R_TO_T,&gType,&gTheHandle,&gTheRect);				sprintf(gTheText,"T->R");			}else{				GetDItem(theDialog,R_TO_T,&gType,&gTheHandle,&gTheRect);				sprintf(gTheText,"R->T");			}			SetCTitle((ControlHandle)gTheHandle,c2pstr(gTheText));			ML_InitAtomList(theDialog,theMLParms);			//ML_ResetDialogBox(theDialog,theOwner->lattice_Type,theMLParms);			InvalRect(&theDialog->portRect);			break;						case ML_UPDATE_EVT:			SetPort(theDialog);		//{		//	AuxWinHandle		colors;		//	if(GetAuxWin(theDialog,&colors)){		//		RGBBackColor(&(*((*colors)->awCTable))->ctTable[wContentColor].rgb);		//		RGBForeColor(&(*((*colors)->awCTable))->ctTable[wTextColor].rgb);		//	}		//}									//EraseRect(&theDialog->portRect);						ML_ResetDialogBox(theDialog,theOwner->lattice_Type,theMLParms);			{				CTabHandle	destCTab;				PaletteHandle	thisPalette;				WindowPtr		theWindow;				theWindow = FrontWindow();				thisPalette 		= GetNewPalette(1111);				destCTab 	= 	GetCTable(2100);				Palette2CTab	(thisPalette,destCTab);				CTabChanged(destCTab);								DetachResource((Handle)thisPalette);				DisposePalette(thisPalette);				ForeColor (blackColor);				BackColor (whiteColor);						GetDItem(theDialog,C_CRYSTAL_COLOR,&type,&theHandle,&theRect);				GetForeColor(&theColor);				RGBForeColor(&theMLParms->thisColor);				PaintOval(&theRect);				RGBForeColor(&theColor);				FrameOval(&theRect);				DisposCTable(destCTab);			}		default:			break;	}}	void	ML_DoCrystalRead(Ptr owner,DialogPtr theDialog,Ptr	paramBlock,Boolean saveData){	ML_CrysParamsPtr	theMLParms;	Crystal*			theOwner;				theMLParms	= (ML_CrysParamsPtr)paramBlock;	theOwner	= (Crystal*)owner;	StartWatch();	gCurrentObj->crystalDialogFlag = false;	if(saveData){		ML_ReadCrystal(theOwner,theDialog,theMLParms);				if(theMLParms->changed){			short i;			for(i = 0; i < 3;i++){				if(theOwner == gCurrentObj->theCrystal[i])					gCurrentObj->changedFlag = true;			}					theOwner->JustifyAtomPos();			theOwner->GetSvals();			theOwner->CellVolume();			theOwner->DetermineCrystalFaces();			theOwner->DetermineVertices();			theOwner->DetermineEdges();			theOwner->ChemicalFormula();			theOwner->SetDSpace();			theOwner->ElasticConstantSymmetry();			theOwner->crystalColor = theMLParms->thisColor; 			theOwner->PackUDAtoms();		}	}		DeleteMenu(124);		ML_KillAtomList(theMLParms);	KillHandle((Handle*)&theMLParms->theAtoms);	ReleaseResource((Handle)theMLParms->saveAsMenu);	theMLParms->fileMenu->DoClose();	theMLParms->popUpMenu->DoClose();	KillPtr((Ptr)paramBlock);	StopWatch();}void ML_CleanTheButton(DialogPtr theDialog,short lattice_Type){	Handle	theHandle;	Rect	theRect;	short	type;	char	theText[128];		if(lattice_Type == TRIGONAL || lattice_Type == TRIGHEX){		ShowDItem(theDialog,R_TO_T);		if(lattice_Type == TRIGONAL){			GetDItem(theDialog,R_TO_T,&type,&theHandle,&theRect);			sprintf(theText,"T->R");			SetCTitle((ControlHandle)theHandle,c2pstr(theText));		}else{			GetDItem(theDialog,R_TO_T,&type,&theHandle,&theRect);			sprintf(theText,"R->T");			SetCTitle((ControlHandle)theHandle,c2pstr(theText));		}	}else{		HideDItem(theDialog,R_TO_T);	}	}void	ML_DisplayCrystalName(DialogPtr	theDialog, short	idNum){	TextFont(systemFont);	TextSize(12);	switch(idNum + 1){		case MATRIX:			SetWTitle(theDialog,"\pDefine Matrix Parameters");			break;		case PPT_1:			SetWTitle(theDialog,"\pDefine PPT #1 Parameters");			break;		case PPT_2:			SetWTitle(theDialog,"\pDefine PPT #2 Parameters");			break;		case PPT_3:			SetWTitle(theDialog,"\pDefine PPT #3 Parameters");			break;		default:			SetWTitle(theDialog,"\p????");			break;	}}void		ML_InitAtomList(DialogPtr theDialog,ML_CrysParamsPtr theParms)			/*  Initialize the atom list		*/{	FontInfo 	theFont;	Point		cellSize;	Rect		theRect,rBounds;	short		textHeight,type;	Handle		theHandle;		ML_KillAtomList(theParms);		GetFontInfo(&theFont);		textHeight 	= theFont.ascent 						+ theFont.descent 						+ theFont.leading;		GetDItem(theDialog,C_THE_LIST_RECT,&type,&theHandle,&theRect);	EraseRect(&theRect);	SetRect(&rBounds,0,0,6,theParms->theOwner->atom_Count + 1);	cellSize.h 				= 53;	cellSize.v				= textHeight;	theParms->theAtomList 	= LNew(&theRect,&rBounds,cellSize,0,theDialog,true,false,false,true);	(*theParms->theAtomList)->selFlags = 0x80;}void	ML_ListAtoms(Crystal* theOwner,ListHandle theAtomList){	short 	i,j;	Boolean flag;	AtomPtr theAtomPtr;	Cell	theCell;	char	theText[32];		D_HLock((Handle)theOwner->theAtoms);	theAtomPtr = *(theOwner->theAtoms);		for(i = 0 ; i <= theOwner->atom_Count ; i++,theAtomPtr++){		theCell.v = i;		for(j = 0 ; j <= 5 ; j++){			theCell.h = j;			switch(j){				case 0:					sprintf(theText,"%4d",i + 1);					break;				case 1:					sprintf(theText,"%6.5f",theAtomPtr->x);					break;				case 2:					sprintf(theText,"%6.5f",theAtomPtr->y);					break;				case 3:					sprintf(theText,"%6.5f",theAtomPtr->z);					break;				case 4:									flag = theOwner->GetAtomicSymbol(theAtomPtr->atomicNum,theText);					break;				case 5:					if(gCurrentObj->calcDW)theOwner->CorrectAtomDWToTemp(theAtomPtr,gCurrentObj->temperature);					sprintf(theText,"%6.5f",theAtomPtr->bi);					break;			}			c2pstr(theText);			LSetCell(&(theText[1]),(short)(theText[0]),theCell,theAtomList);		}	}	D_HUnlock((Handle)theOwner->theAtoms);	return;}void		ML_KillAtomList(ML_CrysParamsPtr theParms)			/*  Kill atom list					*/{		if(theParms->theAtomList != (ListHandle)NUL){		LDispose(theParms->theAtomList);		theParms->theAtomList = (ListHandle)NUL;	}	return;}void	ML_SetUnitCell(Crystal* theOwner,DialogPtr	theDialog){	Boolean flags[6];	Handle	theHandle;	Rect	erase,theRect;	double	values[6];	short	i,type;		GetDItem(theDialog,LATTICE_TYPE,&type,&theHandle,&theRect);	EraseRect(&theRect);	MoveTo(theRect.left + 3,theRect.bottom - 4);		i = sizeof(short double);	i = sizeof(double);			flags[0] = true;	for(i = 1 ; i <= 5 ; i++){		flags[i] = false;	}	switch(theOwner->lattice_Type){		default:			theOwner->theUnitCell.a 		= 2.0;		case CUBIC: 			theOwner->theUnitCell.b			= theOwner->theUnitCell.a;			theOwner->theUnitCell.c 		= theOwner->theUnitCell.a;			theOwner->theUnitCell.alpha		= 90.0;			theOwner->theUnitCell.beta		= 90.0;			theOwner->theUnitCell.gamma		= 90.0;			DrawDiffractString("\pCubic");			break;		case TETRAGONAL:			flags[2] = true;			theOwner->theUnitCell.b			= theOwner->theUnitCell.a;			theOwner->theUnitCell.c 		= theOwner->theUnitCell.c;			theOwner->theUnitCell.alpha		= 90.0;			theOwner->theUnitCell.beta		= 90.0;			theOwner->theUnitCell.gamma		= 90.0;			DrawDiffractString("\pTetragonal");			break;		case ORTHORHOMBIC:			flags[1] = true;			flags[2] = true;			theOwner->theUnitCell.alpha		= 90.0;			theOwner->theUnitCell.beta		= 90.0;			theOwner->theUnitCell.gamma		= 90.0;			DrawDiffractString("\pOrthorhombic");			break;		case TRIGHEX: 			flags[3] = true;			theOwner->theUnitCell.b			= theOwner->theUnitCell.a;			theOwner->theUnitCell.c 		= theOwner->theUnitCell.a;			theOwner->theUnitCell.beta		= theOwner->theUnitCell.alpha;			theOwner->theUnitCell.gamma		= theOwner->theUnitCell.alpha;			DrawDiffractString("\pRhomb. Set.");			break;		case TRIGONAL: 			flags[2] = true;			theOwner->theUnitCell.b			= theOwner->theUnitCell.a;			theOwner->theUnitCell.alpha		= 90.0;			theOwner->theUnitCell.beta		= 90.0;			theOwner->theUnitCell.gamma		= 120.0;			DrawDiffractString("\pTrigonal");			break;		case HEXAGONAL: 			flags[2] = true;			theOwner->theUnitCell.b			= theOwner->theUnitCell.a;			theOwner->theUnitCell.alpha		= 90.0;			theOwner->theUnitCell.beta		= 90.0;			theOwner->theUnitCell.gamma		= 120.0;			DrawDiffractString("\pHexagonal");			break;		case MONOCLINIC: 			flags[1] = true;			flags[2] = true;			flags[4] = true;			theOwner->theUnitCell.alpha		= 90.0;			theOwner->theUnitCell.gamma		= 90.0;			DrawDiffractString("\pMonoclinic");			break;		case TRICLINIC: 			flags[1] = true;			flags[2] = true;			flags[3] = true;			flags[4] = true;			flags[5] = true;			DrawDiffractString("\pTriclinic");			break;	}		FrameRect(&theRect);	MoveTo(theRect.left + 1, theRect.bottom);	LineTo(theRect.right, theRect.bottom);	LineTo(theRect.right, theRect.top + 1);		values[0] 	= theOwner->theUnitCell.a;	values[1] 	= theOwner->theUnitCell.b;	values[2] 	= theOwner->theUnitCell.c;	values[3] 	= theOwner->theUnitCell.alpha;	values[4] 	= theOwner->theUnitCell.beta;	values[5] 	= theOwner->theUnitCell.gamma;	for(i = A_PRAM ; i <= GAMMA_PRAM ; i++){		GetDItem(theDialog,i,&type,&theHandle,&theRect);		erase = theRect;		if(!flags[i - A_PRAM]){			InsetRect(&erase,-4,-4);			EraseRect(&erase);			SetDItem(theDialog,i,statText,theHandle,&theRect);		} else {			SetDItem(theDialog,i,editText,theHandle,&theRect);			InsetRect(&erase,-3,-3);			FrameRect(&erase);		}		sprintf(gTheText,"%7.5f",values[i - A_PRAM]);		c2pstr(gTheText);		SetIText(theHandle,pTheText);	}}void	ML_ResetDialogBox(DialogPtr theDialog,short lattice_Type,ML_CrysParamsPtr theParms){	short i;		//SetPort(theDialog);	//DrawDialog(theDialog);	HiliteMenu(0);	theParms->fileMenu->SetPopUp();	theParms->popUpMenu->lastResult = lattice_Type;	ML_SetUnitCell(theParms->theOwner,theDialog);	if(theParms->theAtomList == (ListHandle)NUL){		ML_InitAtomList(theDialog,theParms);	}	ML_ListAtoms(theParms->theOwner,theParms->theAtomList);	for(i = 1; i <= 8;i++){		theParms->popUpMenu->P_CheckItem(i,false);	}		theParms->popUpMenu->P_CheckCItem(true);	GetDItem(theDialog,1,&gType,&gTheHandle,&gTheRect);	HiliteControl((ControlHandle)gTheHandle,0);	GetDItem(theDialog,2,&gType,&gTheHandle,&gTheRect);	HiliteControl((ControlHandle)gTheHandle,0);	//ML_CleanTheButton(theDialog,theParms->theOwner->lattice_Type);		ML_DisplayCrystalName(theDialog,theParms->theOwner->idNum);	ML_SetUnitCell(theParms->theOwner,theDialog);	ML_ListAtoms(theParms->theOwner,theParms->theAtomList);}	void	ML_ReadCrystal(Crystal* theOwner,DialogPtr theDialog,ML_CrysParamsPtr theMLParms){	short 	i,type;	char	theText[128];	Handle	theHandle;	Rect	theRect;	short	firstSpaceGrp;	short	lastSpaceGrp;	theOwner->ReconfigureElementList();	theMLParms->changed = false;	for(i = A_PRAM ; i <= GAMMA_PRAM ; i++){		GetDItem(theDialog,i,&type,&theHandle,&theRect);		GetIText(theHandle,(unsigned char*)theText);		p2cstr((unsigned char*)theText);		switch(i){			case A_PRAM:								theOwner->theUnitCell.a		=	atof(theText);				if(fabs(theOwner->theUnitCell.a	-	theMLParms->uc.a) > .00001)theMLParms->changed = true;//august 1996				break;			case B_PRAM:								theOwner->theUnitCell.b		=	atof(theText);				if(fabs(theOwner->theUnitCell.b	-	theMLParms->uc.b) > .00001)theMLParms->changed = true;//august 1996				break;			case C_PRAM:								theOwner->theUnitCell.c		=	atof(theText);				if(fabs(theOwner->theUnitCell.c	-	theMLParms->uc.c) > .00001)theMLParms->changed = true;//august 1996				break;			case ALPHA_PRAM:								theOwner->theUnitCell.alpha	=	atof(theText);				if(fabs(theOwner->theUnitCell.alpha	-	theMLParms->uc.alpha) > .00001)theMLParms->changed = true;//august 1996				break;			case BETA_PRAM:								theOwner->theUnitCell.beta	=	atof(theText);				if(fabs(theOwner->theUnitCell.beta	-	theMLParms->uc.beta) > .00001)theMLParms->changed = true;				break;			case GAMMA_PRAM:								theOwner->theUnitCell.gamma	=	atof(theText);				if(fabs(theOwner->theUnitCell.gamma	-	theMLParms->uc.gamma) > .00001)theMLParms->changed = true;				break;			default:				break;		}	}	if(theMLParms->thisColor.red != theOwner->crystalColor.red)theMLParms->changed = true;	if(theMLParms->thisColor.green != theOwner->crystalColor.green)theMLParms->changed = true;	if(theMLParms->thisColor.blue != theOwner->crystalColor.blue)theMLParms->changed = true;	if(theMLParms->atom_Count != theOwner->atom_Count)theMLParms->changed = true;	if(theMLParms->latticeType != theOwner->lattice_Type)theMLParms->changed = true;	if(!theMLParms->changed){		AtomPtr a1,a2;		a1 = *theMLParms->theAtoms;		a2 = *theOwner->theAtoms;		i = 0;		while(i <= theOwner->atom_Count && !theMLParms->changed){			if(fabs(a1->x - a2->x) > .00001)theMLParms->changed = true;			if(fabs(a1->y - a2->y) > .00001)theMLParms->changed = true;			if(fabs(a1->z - a2->z) > .00001)theMLParms->changed = true;			if(a1->atomicNum != a2->atomicNum)theMLParms->changed = true;			if(fabs(a1->bi - a2->bi) > .01 && g_DebyeWaller)theMLParms->changed = true;			i++;a1++;a2++;		}	}	switch(theOwner->lattice_Type)	{		case TRICLINIC:			firstSpaceGrp = 1;			lastSpaceGrp = 2;			break;		case MONOCLINIC:			firstSpaceGrp = 3;			lastSpaceGrp = 15;			break;		case ORTHORHOMBIC:			firstSpaceGrp = 16;			lastSpaceGrp = 74;			break;		case TETRAGONAL:			firstSpaceGrp = 75;			lastSpaceGrp = 142;			break;		case TRIGONAL:			firstSpaceGrp = 143;			lastSpaceGrp = 167;			break;		case HEXAGONAL:			firstSpaceGrp = 168;			lastSpaceGrp = 194;			break;		case CUBIC:			firstSpaceGrp = 195;			lastSpaceGrp = 230;			break;		case TRIGHEX:			firstSpaceGrp = 1146;			lastSpaceGrp = 1167;			break;	}	if(theOwner->spaceGrpNm > lastSpaceGrp || theOwner->spaceGrpNm < firstSpaceGrp) theOwner->spaceGrpNm = firstSpaceGrp;				//theOwner->ChemicalFormula();}void		ML_DoCellUpdate(Cell theCell,DialogPtr	theDialog,ML_CrysParamsPtr	theMLParms){	Crystal*	theOwner;	Atom		thisAtom;	short		theNum,i,j,oldNum,length,type;	char		theText[128];	Boolean 	flag;	Handle		theHandle;	Rect		theRect;			if(theCell.v < 0)		return;	theOwner	=	theMLParms->theOwner;	GetDItem(theDialog,C_THE_LIST_DATA,&type,&theHandle,&theRect);	GetIText(theHandle,(unsigned char*)theText);	length 		= (short)theText[0];	p2cstr((unsigned char*)theText);	switch(theCell.h){		case ATOM_NUMBER:			theNum = atoi(theText) - 1;			if(theNum < 0 || theNum > theOwner->atom_Count){				SysBeep(30);				SelIText(theDialog,C_THE_LIST_DATA,0,3);				return;				break;			}			oldNum = theCell.v;			thisAtom = (*(theOwner->theAtoms))[oldNum];			if(theNum < oldNum){				for(i = theOwner->atom_Count , j = theOwner->atom_Count ; i >= 0 ; i--){					if(i == oldNum){						j--;						(*(theOwner->theAtoms))[i] = (*(theOwner->theAtoms))[j--];					} else if(i == theNum){						(*(theOwner->theAtoms))[i] = thisAtom;					} else {						(*(theOwner->theAtoms))[i] = (*(theOwner->theAtoms))[j--];					}				}			}						if(theNum > oldNum){				for(i = 0 , j = 0 ; i <= theOwner->atom_Count ; i++){					if(i == oldNum){						j++;						(*(theOwner->theAtoms))[i] = (*(theOwner->theAtoms))[j++];					} else if(i == theNum){						(*(theOwner->theAtoms))[i] = thisAtom;					} else {						(*(theOwner->theAtoms))[i] = (*(theOwner->theAtoms))[j++];					}				}			}						LSetSelect(false,theCell,theMLParms->theAtomList);			ML_ListAtoms(theOwner,theMLParms->theAtomList);			theCell.h = ATOM_NUMBER;			theCell.v = theNum;			LSetSelect(true,theCell,theMLParms->theAtomList);			LAutoScroll(theMLParms->theAtomList);			SelIText(theDialog,C_THE_LIST_DATA,0,3);			return;			break;						case X_LOC:			(*(theOwner->theAtoms))[theCell.v].x = atof(theText);			length = sprintf(theText,"%6.5f",(*(theOwner->theAtoms))[theCell.v].x);			LSetCell(theText,length,theCell,theMLParms->theAtomList);			LSetSelect(false,theCell,theMLParms->theAtomList);			theCell.h = Y_LOC;			break;		case Y_LOC:			(*(theOwner->theAtoms))[theCell.v].y = atof(theText);			length = sprintf(theText,"%6.5f",(*(theOwner->theAtoms))[theCell.v].y);			LSetCell(theText,length,theCell,theMLParms->theAtomList);			LSetSelect(false,theCell,theMLParms->theAtomList);			theCell.h = Z_LOC;			break;		case Z_LOC:			(*(theOwner->theAtoms))[theCell.v].z = atof(theText);			length = sprintf(theText,"%6.5f",(*(theOwner->theAtoms))[theCell.v].z);			LSetCell	(theText,length,theCell,theMLParms->theAtomList);			LSetSelect	(false,theCell,theMLParms->theAtomList);			theCell.h = X_LOC;			if(++theCell.v > theOwner->atom_Count){				theCell.v = 0;			}			break;		case ELEMENT:			(*(theOwner->theAtoms))[theCell.v].atomicNum = theOwner->TheAtomicNum(theText);			flag = theOwner->GetAtomicSymbol((*(theOwner->theAtoms))[theCell.v].atomicNum,theText);						c2pstr(theText);			LSetCell(&(theText[1]),(short)(theText[0]),theCell,theMLParms->theAtomList);			LSetSelect(false,theCell,theMLParms->theAtomList);			if(flag){				theCell.v += 1;				if(theCell.v > theOwner->atom_Count)					theCell.v = 0;			} else {				SysBeep(30);			}			if(gCurrentObj->calcDW){				theOwner->CorrectAtomDWToTemp(&(*(theOwner->theAtoms))[theCell.v],gCurrentObj->temperature);				theCell.h = DW_FACTOR;				length = sprintf(theText,"%6.4f",(*(theOwner->theAtoms))[theCell.v].bi);				LSetCell	(theText,length,theCell,theMLParms->theAtomList);				LSetSelect	(false,theCell,theMLParms->theAtomList);			}						break;		case DW_FACTOR:			(*(theOwner->theAtoms))[theCell.v].bi = atof(theText);			if(gCurrentObj->calcDW)theOwner->CorrectAtomDWToTemp(&(*(theOwner->theAtoms))[theCell.v],gCurrentObj->temperature);			length = sprintf(theText,"%6.4f",(*(theOwner->theAtoms))[theCell.v].bi);			LSetCell	(theText,length,theCell,theMLParms->theAtomList);			LSetSelect	(false,theCell,theMLParms->theAtomList);			theCell.v += 1;			if(theCell.v > theOwner->atom_Count)				theCell.v = 0;			break;	}	LSetSelect(true,theCell,theMLParms->theAtomList);	LAutoScroll(theMLParms->theAtomList);	length	=	20;	LGetCell(&(theText[1]),&length,theCell,theMLParms->theAtomList);	theText[0] = (char)length;	GetDItem(theDialog,C_THE_LIST_DATA,&type,&theHandle,&theRect);	SetIText(theHandle,(unsigned char*)theText);	SelIText(theDialog,C_THE_LIST_DATA,0,length);}void		ML_DoMenu(DialogPtr theDialog,ML_CrysParamsPtr	theMLParms,long	theResult)				/*  Do Menu Items					*/{	short		theItem;	short		fileType;	Crystal*	theOwner;		theOwner		= theMLParms->theOwner;		if(HiWord(theResult) != theMLParms->uniqueMenuID){		theItem 	= HiWord(theResult);		fileType 	= LoWord(theResult);	}else{		theItem 	= LoWord(theResult);	}		switch(theItem){		case CRYS_OPEN:			theOwner->FileOpenCrystal();			ML_KillAtomList(theMLParms);			ML_InitAtomList(theDialog,theMLParms);			break;					case CRYS_SAVE:			ML_ReadCrystal(theOwner,theDialog,theMLParms);			theOwner->JustifyAtomPos();			theOwner->GetSvals();			theOwner->CellVolume();			//theOwner->SetDSpace();			theOwner->DetermineCrystalFaces();			theOwner->DetermineVertices();			theOwner->DetermineEdges();			theOwner->ElasticConstantSymmetry();			theOwner->FileSaveCrystal(1);			break;					case CRYS_SAVE_AS:			ML_ReadCrystal(theOwner,theDialog,theMLParms);			theOwner->JustifyAtomPos();			theOwner->GetSvals();			theOwner->CellVolume();			//theOwner->SetDSpace();			theOwner->DetermineCrystalFaces();			theOwner->DetermineVertices();			theOwner->DetermineEdges();			theOwner->ElasticConstantSymmetry();			theOwner->FileSaveCrystal(fileType);			break;					case CRYS_PAGE:			PrOpen();			SetupPage();			PrClose();			FlushEvents(everyEvent,0L);			break;					case CRYS_PRINT:			ML_ReadCrystal(theOwner,theDialog,theMLParms);			theOwner->JustifyAtomPos();			theOwner->GetSvals();			theOwner->CellVolume();			theOwner->DoPrint();			FlushEvents(everyEvent,0L);			break;					case CRYS_CLOSE:			SysBeep(15);			break;		default:			break;	}}