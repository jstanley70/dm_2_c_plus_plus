// DA2_PoleBox.cp// Created by jstanly on Tue, Mar 21, 1995 @ 10:36 PM.#include "PoleBox.h"#include	"StereoObject.h"#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"SF_MathLib.h"#pragma segment Mainvoid					PoleBox::DoContent(Point thePoint){	short	hitLine = -1;	short i;		if(!Button()){			theLines->DeSelectAll();			DrawExcited(false);			return;	}	if(IsPressed( (unsigned short )58)){//optionkey				if(PtInRgn(thePoint,theRgn) || selected){					selected = true;					DoRotate(thePoint);									}	}	for(i = 0; i < 5; i++){		if(PtInRect(thePoint,&theSpots[i].spotRect)){			selected = true;					  DoMove(thePoint,i);		  DrawExcited(true);		  return;		}	}				if(theLines->TakeCareOfLines( thePoint,thePoint, 3, &hitLine)){		selected = true;		InvalRgn(theRgn);		UpdateRegion();		GetPoleCenter();		GuessPole();		DrawExcited(true);		return;	}	selected = false;	DrawExcited(false);	return;}void					PoleBox::GetPoleCenter(void){	double n = 0, theH = 0,theV = 0;	theLines->AverageHV(&theH,&theV,n);	SetRect(&theSpots[0].spotRect,theH - 3,theV - 3, theH + 3, theV + 3);	}#pragma segment Mainvoid					PoleBox::DoInit(SADObj *aObj)//bloch{					Point			endPoint,startPt,center;		long			flags;		short i;		theCrystal = aObj->theCrystal[aObj->referenceCrystal];		center.h = aObj->centerX;		center.v = aObj->centerY;			SetRect(&theSpots[0].spotRect,center.h - 5,center.v - 5,center.h + 5,center.v + 5);		for(i = 0; i < 5;i++){			theSpots[i].h = 1;			theSpots[i].k = 0;			theSpots[i].l = 0;			theSpots[i].x = 1;			theSpots[i].y = 0;			theSpots[i].z = 0;			theSpots[i].theCrystal = theCrystal;		}		startPt = center;		startPt.h += 30;		startPt.v += 30;		endPoint = startPt;		endPoint.h += -60;		theLines = (LineObj*)D_new(LineObj);		flags = 0;		flags = ALIGN_NEXT + ALIGN_PREVIOUS;		theLines->DoInit(false,theCrystal, true, flags,startPt,endPoint);		scaleFactor = aObj->scaleFactor;		startPt =  endPoint;		endPoint.v -= 60;		theLines->AddLine( startPt,endPoint);		startPt =  endPoint;		endPoint.h += 60;				theLines->AddLine( startPt,endPoint);		startPt =  endPoint;		endPoint.v += 60;				theLines->AddLine( startPt,endPoint);		theRgn = 0L;		UpdateRegion();		theObj = (Handle)aObj;		PenMode(gCurrentObj->gMode);		PenNormal();		GetPoleCenter();		GuessPole();		DrawExcited(true);		theLines->DeSelectAll();		next = 0L;}/*void					PoleBox::DoDblClick(Point thePoint){	if(PtInRect(thePoint,&theSpots->spotRect)){	}}*/#pragma segment Mainvoid					PoleBox::UpdateRegion(void){	short i;	if(theRgn)SetEmptyRgn(theRgn);	else		theRgn =  D_NewRgn();	OpenRgn();		theLines->JustDrawAllLines(true);		for(i = 0; i <= 4;i++){			dm_FrameRect(&theSpots[i].spotRect);		}	CloseRgn(theRgn);}#pragma segment Main/*Handle     PoleBox::PossiblePoles(void){	}*/#pragma segment Mainvoid PoleBox::DrawExcited(Boolean flag){	flag = true;	if(selected){		gCurrentObj->DMForeColor(COMPLEMENT_COLOR);		gCurrentObj->DMBackColor(BACKGROUND_COLOR);		SetMarqueePattern(NUL);		PenMode						(patXor);		TextMode					(srcXor);		DrawPole();		Delay							(4,&gLongScratch);		DrawPole();		PenMode(	gCurrentObj->gMode);		PenNormal();	}else{		//PenMode(gCurrentObj->gMode);		TextMode					(0);		PenNormal();		DrawPole();	}}void PoleBox::DrawPole(void){	short i;	theCrystal 		= 	((SADObj*)theObj)->theCrystal[((SADObj*)theObj)->referenceCrystal];	for(i = 0; i < 5;i++){		theSpots[i].theCrystal = theCrystal;	}	theLines->JustDrawAllLines(true);	for(i = 0; i < 5;i++)		dm_FrameOval(&(theSpots[i].spotRect));	MoveTo(theSpots[1].spotRect.left,theSpots[1].spotRect.top);	sprintf(gTheText,"%d",1);	DrawString(c2pstr(gTheText));}#pragma segment Mainvoid PoleBox::DrawAll(void){	if(next)next->DrawAll();	DrawExcited(true);}#pragma segment Mainvoid				PoleBox::DoDblClick(Point thePoint){	if(PtInRect(thePoint,&theSpots[0].spotRect))	{		if(SetPoleDefinition())			SetPole(0);	}}Boolean	PoleBox::SetPoleDefinition(void){	DialogPtr	theDialog;	short		theSelect;	short		i,j;	Index		*theIndex;	PopUpMenu 	*theMenu;	WindowPeek	theWindow;	StereoObject		*aObj;	Boolean	quit = false,saveData = false;		theDialog = DM_GetNewDialog(362,NUL,IN_FRONT);	theIndex = (Index*)D_new(Index);	theMenu = (PopUpMenu*)D_new(PopUpMenu);	theMenu->Init(theDialog,8,135,1);	theWindow = (WindowPeek)FrontWindow();	if(((SADObj*)theObj)->stereoObj){		GetWTitle(((SADObj*)theObj)->stereoObj->theWindow,pTheText);		theMenu->P_AppendMenu(gTheText);		j = CountMItems(gTheWindowMenu);						for(i = 1; i <= j;i++){						GetItem(gTheWindowMenu,i,pTheText);			theMenu->P_AppendMenu(gTheText);			theWindow = theWindow->nextWindow;			aObj = (StereoObject*)((WindowPeek)theWindow)->refCon;			if(((SADObj*)aObj)->objectType != STEREO_OBJ ) {					DisableItem(theMenu->theMenu,i + 1);			}					}			}else{		sprintf(gTheText,"New Stereogram");		c2pstr(gTheText);		theMenu->P_AppendMenu(gTheText);		j = CountMItems(gTheWindowMenu);		for(i = 1; i <= j;i++){			GetItem(gTheWindowMenu,i,pTheText);			theMenu->P_AppendMenu(gTheText);			theWindow = theWindow->nextWindow;			aObj = (StereoObject*)((WindowPeek)theWindow)->refCon;			if(((SADObj*)aObj)->objectType != STEREO_OBJ ) {					DisableItem(theMenu->theMenu,i + 1);			}		}	}	SetPort(theDialog);	ShowWindow(theDialog);	DrawDialog(theDialog);	for(i = 0; i < 2;i++){		theIndex->CopyPtrToIndex((Ptr)&theSpots[i]);		theIndex->SetIndex(theDialog,i + 4);	}	theMenu->SetPopUp();	SelIText(theDialog,4,0,100);	while(!quit){		ModalDialog(TheFilterUPP/*SmallFilterUPP*/,&theSelect);				switch(theSelect){			case DLOG_ENTER_OR_CR:			case 1:				quit = true;				saveData = 1;				break;			case 2:				quit = true;				saveData = 0;				break;			case 3:				quit = true;				saveData = 2;				break;			case	8:				theMenu->DoPopUp();			break;			default:			break;			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;		}				}	if(saveData){		for(i = 0; i < 2;i++){			theIndex->CopyPtrToIndex((Ptr)&theSpots[i]);			theIndex->GetIndex(theDialog,i + 4);			theIndex->CopyIndexToPtr((Ptr)&theSpots[i]);		}				i = 1;		if(theMenu->lastResult != 1){			theWindow = (WindowPeek)FrontWindow();			while(i < theMenu->lastResult){theWindow = theWindow->nextWindow;i++;}			aObj = (StereoObject*)((WindowPeek)theWindow)->refCon;			if(((SADObj*)aObj)->objectType == STEREO_OBJ ) {				((SADObj*)theObj)->stereoObj = aObj;				((StereoObject*)aObj)->poleObject = ((SADObj*)theObj);			}		}	}	theMenu->DoClose();	theIndex->DoClose();	DM_DisposDialog(&theDialog);	if(saveData == 2) return true;		return false;}void				PoleBox::SetPole(short num){	short dummy;	PolePosition thePole;	double x,y,z;	Crystal *aCrystal;	double 	theValue;	Point		thePoint;	double theXForm[3][3];	double length;	aCrystal 		= 	((SADObj*)theObj)->theCrystal[((SADObj*)theObj)->referenceCrystal];	dummy = num;//warning	thePole.zoneAxis.h = theSpots[0].h;	thePole.zoneAxis.k = theSpots[0].k;	thePole.zoneAxis.l = theSpots[0].l;	thePole.zoneAxis.direction = true;	thePole.zoneAxis.intensity = 1;	thePole.zoneAxis.theCrystal = aCrystal;	theValue = theSpots[0].spotRect.left + theSpots[0].spotRect.right;	thePoint.h = theValue/2;	theValue  = theSpots[0].spotRect.top + theSpots[0].spotRect.bottom;	thePoint.v = theValue/2;	gCurrentObj->projLengthScreen *= 2;	gCurrentObj->CalculateScreenThetas( &x, &y, &z, thePoint);	gCurrentObj->stage->CancelMatrixRotation		(&x,&y,&z,true);	thePole.zoneAxis.x = x;	thePole.zoneAxis.y = y;	thePole.zoneAxis.z = z;	thePole.gvector.flags = theSpots[0].flags;	FIND_CENTER_XFORM(x,y,z,theXForm);	InvertMatrix(theXForm);	thePole.gvector.h = theSpots[1].h;	thePole.gvector.k = theSpots[1].k;	thePole.gvector.l = theSpots[1].l;	thePole.gvector.flags = theSpots[1].flags;	thePole.gvector.direction = false;	thePole.gvector.theCrystal = aCrystal;	if((thePole.gvector.h * thePole.zoneAxis.h + 		thePole.gvector.k * thePole.zoneAxis.k + 		thePole.gvector.l * thePole.zoneAxis.l) != 0){			Message(G_ZONE_NOT_ORTHO);		}	theValue = theSpots[1].spotRect.left + theSpots[1].spotRect.right;	y = theValue/2 - thePoint.h;	theValue = theSpots[1].spotRect.top + theSpots[1].spotRect.bottom;	x = theValue/2 - thePoint.v;	length = sqrt(x * x + y * y);	x /= length;//rotates the g-vector around the zone axis	y /= length;	z = 0;//puts the g-vector 90° from the zone axis	TransFormVector(&x,&y,&z,theXForm);	thePole.gvector.x = x;	thePole.gvector.y = y;	thePole.gvector.z = z;	thePole.zoneAxis.flags = ((SADObj*)theObj)->referenceCrystal;	thePole.gvector.flags = ((SADObj*)theObj)->referenceCrystal;	gCurrentObj->projLengthScreen /= 2;	if(((SADObj*)theObj)->stereoObj){		((SADObj*)theObj)->stereoObj->AddPoleObject(thePole,false);		((SADObj*)theObj)->stereoObj->newPictReq = true;		((SADObj*)theObj)->stereoObj->DoIdle();	}else{		((SADObj*)theObj)->CopyObjTo((DiffractObject*)gDefault,true);		((SADObj*)theObj)->stereoObj = (StereoObject*)AllocStereoObject();		if(!IsValidObj(((SADObj*)theObj)->stereoObj)){			((SADObj*)theObj)->stereoObj = 0L;		 	return;		}		((SADObj*)theObj)->stereoObj->poleObject = (SADObj*)theObj;		((SADObj*)theObj)->CopyObjTo((DiffractObject*)((SADObj*)theObj)->stereoObj,true);						((SADObj*)theObj)->stereoObj->changedFlag = false; 		((SADObj*)theObj)->stereoObj->newPictReq = true;		((SADObj*)theObj)->stereoObj->AddPoleObject(thePole,false);//was true		//((SADObj*)theObj)->stereoObj->DoPoleObjectMenu(8);		((SADObj*)theObj)->stereoObj->planeBounds[0] = 0;		((SADObj*)theObj)->stereoObj->DoIdle();			}}#pragma segment Mainvoid					PoleBox::UpdateToOwner(void){	}void					PoleBox::DoRotate(Point thePoint){	double angle,oldAngle;	double delAngle;	double centerX,centerY,x,y;		InvalRgn(theRgn);	centerX = (theSpots->spotRect.left + theSpots->spotRect.right) * .5;	centerY = (theSpots->spotRect.top + theSpots->spotRect.bottom) * .5;	x = thePoint.h - centerX;	y = centerY - thePoint.v;	oldAngle = atan2(y,x);	while(Button()){		GetMouse(&thePoint);		x = thePoint.h - centerX;		y = centerY - thePoint.v;		//PtToAngle(&(theSpots->spotRect),thePoint,&angle);		angle = atan2(y,x);		if(angle != oldAngle){			delAngle = angle - oldAngle;			RotateBy(delAngle);			oldAngle = angle;		}		DrawExcited(true);	}	EraseRgn(theRgn);	InvalRgn(theRgn);}void					PoleBox::DoMove(Point thePoint,short i){	Point	oldPoint,newPoint;	if(PtInRect(thePoint,&(&theSpots[i])->spotRect)){		oldPoint = thePoint;		InvalRgn(theRgn);		//EraseRgn(theRgn);		while(Button()){			GetMouse(&thePoint);			if(thePoint.h != oldPoint.h || thePoint.v != oldPoint.v){				newPoint = thePoint;				SubPt(oldPoint,&newPoint);				MoveBy(newPoint,i);				oldPoint = thePoint;			}			DrawExcited(true);		}		EraseRgn(theRgn);		InvalRgn(theRgn);	}}#pragma segment Mainvoid					PoleBox::MoveBy(Point delPoint,short spot){	short n;	LineObj *theLine;		if(spot > 0){		n = 1;		theLine = theLines->GetLineNum(n,spot);		theLine->MoveBy(delPoint);	}else{		theLines->MoveAllBy(delPoint);	}	InvalRgn(theRgn);	UpdateRegion();	GetPoleCenter();	GuessPole();}#pragma segment Mainvoid					PoleBox::RotateBy(double delAngle){	short n,i;	LineObj *theLine;	double centerX,centerY,delX,delY;	Point thePoint;	long	theMask;	//delAngle *= PI/180;	centerX = (theSpots->spotRect.left + theSpots->spotRect.right) * .5;	centerY = (theSpots->spotRect.top + theSpots->spotRect.bottom) * .5;		for(n = 1; n < 5;n++){		i = 1;		theLine = theLines->GetLineNum(i,n);		delX = centerX - theLine->hor1;		delY = centerY - theLine->ver1;		thePoint.h = centerX - Round((delX * cos(delAngle) + delY * sin(delAngle)));		thePoint.v = centerY + Round((delX * sin(delAngle) - delY * cos(delAngle)));		theMask = SECOND_RECT + FIRST_RECT + ON_LINE + HIT_MASK;		theLine->ClearFlag(theMask);		theLine->SetFlag(FIRST_RECT);		theLine->ManipulateLine(thePoint);	}	InvalRgn(theRgn);	UpdateRegion();	GetPoleCenter();	GuessPole();}#pragma segment Mainvoid					PoleBox::EnterPole(short num){	short dummy;	dummy = num;//warning}#pragma segment Mainvoid					PoleBox::GuessPole(void){				double 		dspace1,dspace2,x,y,z;		double 		theta,angle1,theValue;		short 			length,i,j,k,theCount,latticeType;		Crystal 		*aCrystal;		Index  			*theIndex1,*theIndex2;		char 			theText[255];		CrystalFace 	newFaces[100],theFace;		short 			maxLines = 3;		static short 	hitLine;		static short 	lastDefLine = -1;		short	 		hRes,vRes;			LineObj	*aLine;		short			theH,theV;		aCrystal 		= 	((SADObj*)theObj)->theCrystal[((SADObj*)theObj)->referenceCrystal];		theIndex1		= 	(Index*)D_new(Index);		theIndex2		=		(Index*)D_new(Index);		theIndex2		->	DoInit(false,aCrystal);		theIndex1		->	DoInit(false,aCrystal);		latticeType 	= 	theIndex2->theCrystal->lattice_Type;		aLine = theLines;		for(i = 0; i < 4 && aLine;i++){			aLine->MidPoint(&theH,&theV);			SetRect(&theSpots[i + 1].spotRect,theH - 3,theV - 3,theH + 3,theV + 3);			aLine = aLine->next;		}		x = theSpots[0].spotRect.left - theSpots[1].spotRect.left;		y = theSpots[0].spotRect.top - theSpots[1].spotRect.top;		dspace1 = scaleFactor / sqrt(x * x + y * y);				x = theSpots[0].spotRect.left - theSpots[2].spotRect.left;		y = theSpots[0].spotRect.top - theSpots[2].spotRect.top;		dspace2 = scaleFactor / sqrt(x * x + y * y);						theta 		= 	180 * fabs(theLines->AngleBetween(theLines->next)) / PI;		if(theta > 180) theta -= 180;		theText[0] = 0;		ScreenRes(&hRes,&vRes);		theValue =theLines->GetLength() * 25.4/(hRes * ((SADObj*)theObj)->magnification);		sprintf(gTheText,"%8.2f Å %8.2f Å %6.2f ° L.L. Length = %d",dspace1,dspace2,theta, (short)theValue);		for(i = 0; i < MAX_STORE_DSPACE; i++){			if(fabs(dspace2 - aCrystal->dspacings[i].x) < (.1 * dspace1)){				theSpots[1].h = theIndex1->h = aCrystal->dspacings[i].h;				theSpots[1].k = theIndex1->k = aCrystal->dspacings[i].k;				theSpots[1].l = theIndex1->l = aCrystal->dspacings[i].l;				theSpots[3].h = -theSpots[1].h;				theSpots[3].k = -theSpots[1].k;				theSpots[3].l = -theSpots[1].l;				for(j = 0; j <  MAX_STORE_DSPACE; j++){					if(fabs(dspace1 - aCrystal->dspacings[j].x) < (.1 * dspace1)){						theFace.h = theIndex2->h = aCrystal->dspacings[j].h;						theFace.k = theIndex2->k = aCrystal->dspacings[j].k;						theFace.l = theIndex2->l = aCrystal->dspacings[j].l;						theCount = -1;						CubicPermutate(&theCount,theFace,newFaces,true,latticeType);												for(k = 0; k <= theCount;k++){							theSpots[2].h = theIndex2->h = newFaces[k].h;							theSpots[2].k = theIndex2->k = newFaces[k].k;							theSpots[2].l = theIndex2->l = newFaces[k].l;							angle1 = fabs(theIndex1->GetTheAngle(theIndex2));							theSpots[4].h = -theSpots[2].h;							theSpots[4].k = -theSpots[2].k;							theSpots[4].l = -theSpots[2].l;							if(fabs(angle1 - theta) <= 3.){								CrossProduct(&x,&y,&z,(double)newFaces[k].h,											(double)newFaces[k].k,(double)newFaces[k].l											,(double)theIndex1->h,(double)theIndex1->k,(double)theIndex1->l);								goto THESPOT2;															}						}					}				}			}		}		goto THESPOT3;		THESPOT2:		theSpots[0].h = theIndex2->h = (short)x;		theSpots[0].k = theIndex2->k = (short)y;		theSpots[0].l = theIndex2->l = (short)z;				theSpots[0].direction = theIndex2->direction 	= 	true;		theText[0] 		= 	0;		theIndex2			->	IndexToIndecies(theText);		length 			= 	strlen(gTheText);		strcpy		(&gTheText[length],p2cstr((unsigned char*)theText));		length 			= 	strlen(gTheText);				gTheText				[length++] = ' ';			theText[0] = 0;		theIndex2->h = newFaces[k].h;		theIndex2->k = newFaces[k].k;		theIndex2->l = newFaces[k].l;		theSpots[1].direction = theIndex2->direction = false;		theIndex2->IndexToIndecies(theText);				strcpy(&gTheText[length],p2cstr((unsigned char*)theText));				length = strlen(gTheText);		gTheText[length++] = ' ';				theText[0] = 0;				theIndex1->IndexToIndecies(theText);		strcpy(&gTheText[length],p2cstr((unsigned char*)theText));			THESPOT3:		theIndex1->DoClose();		theIndex2->DoClose();		PenNormal();		((SADObj*)theObj)->theRuler->SetInfo(gTheText);		return;}#pragma segment MainHandle     		PoleBox::GuessPoles(void){	return 0L;}#pragma segment Mainvoid				  PoleBox::KillAll(void){	if(next)next->KillAll();	Kill(0L);}#pragma segment MainPoleBox*					PoleBox::Kill(PoleBox *previous){	PoleBox *aObj;	theLines->KillAll();	aObj = next;	if(next && previous)previous->next = next;		if(theRgn)D_DisposeRgn(&theRgn);	D_delete(this);	if(!previous)return aObj;	return previous;}#pragma segment MainHandle					PoleBox::GetPoles(void){	return 0L;}void PoleBox::NewReferenceCrystal(void){	short i;	theCrystal = ((SADObj*)theObj)->theCrystal[((SADObj*)theObj)->referenceCrystal];	for(i = 0;i < 5;i++){		theSpots[i].theCrystal = theCrystal;		theSpots[i].flags = ((SADObj*)theObj)->referenceCrystal;	}	if(next)next->NewReferenceCrystal();}