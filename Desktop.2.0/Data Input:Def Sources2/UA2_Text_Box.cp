// UA2_Text_Box.cp// Created by jstanly on Fri, Dec 23, 1994 @ 10:51 AM.#define kBarWidth 15#define kScreenWidth (qd.screenBits.bounds.right - qd.screenBits.bounds.left)#define kScreenHeight (qd.screenBits.bounds.bottom - qd.screenBits.bounds.top)#ifndef __UA2_Text_Box__#include "UA2_Text_Box.h"#endif#include	"Diffract_INCs.h"#define		event	gTheEvent/*DA2_Text_Box::DA2_Text_Box() {}DA2_Text_Box::~DA2_Text_Box(){}*/void			DA2_Text_Box::DoClose(void){	//Rect theRect;	//theRect = (*gUpdateAll)->rgnBBox;		Error();	//DisposePtr((Ptr)ext.resID);	TMX_Dispose(theList);	InsetRect(&frameRect, -2, -2);	EraseRect(&frameRect);	InvalRect(&frameRect);	//DisposeHandle((Handle)theList);	D_delete(this);	}long  DA2_Text_Box::GetCell(Cell theCell,Ptr thePtr){	Size theSize;	theSize = GetPtrSize(thePtr);	TMX_GetCellText (thePtr,&theSize,theCell,theList);	Error();	return theSize;}void  DA2_Text_Box::ResetCell(void){	currentCell.h = currentCell.v =  lastCell.v = 0;	lastCell.h = -1;}void DA2_Text_Box::SetText(void){	TextFont(fontName);	TextSize(fontSize);	TextFace(fontFace);}void	DA2_Text_Box::DoPrint(void)				/*  Object Print method				*/{	GrafPtr thePort;		PrOpen();	GetPort(&thePort);		if(!gPrintRecHandle) gPrintRecHandle = (THPrint)GetResource('PREC',(short)1000);		if(GetHandleSize((Handle)gPrintRecHandle) != sizeof(TPrint)){		SetHandleSize((Handle)gPrintRecHandle,sizeof(TPrint));		ChangedResource((Handle)gPrintRecHandle);		WriteResource((Handle)gPrintRecHandle);	}		if(PrValidate(gPrintRecHandle))		SysBeep(30);	if(PrJobDialog(gPrintRecHandle)){		TPrStatus		theStatus;		TPPrPort		thePrintPort;						thePrintPort = PrOpenDoc(gPrintRecHandle,NUL,NUL);		SetPort(&thePrintPort->gPort);						PrOpenPage(thePrintPort,NUL);			TMX_Print(theList);			PrClosePage(thePrintPort);		PrCloseDoc(thePrintPort);				if((*gPrintRecHandle)->prJob.bJDocLoop == bSpoolLoop){			PrPicFile(gPrintRecHandle,NUL,NUL,NUL,&theStatus);		}		PrSetError(noErr);	}	SetPort(thePort);	PrClose();	return;}void DA2_Text_Box::ReturnText(void){	TextFont(0);	TextSize(0);	TextFace(0);}void DA2_Text_Box::SetDrawFlag(Boolean flag){	drawFlag = flag;	TMX_DoDraw(drawFlag,theList);	Error();}Point DA2_Text_Box::Move(Point thePoint){	short totalH,totalV;	Point oldPoint;	MoveARect(frameRect,&totalH,&totalV);	if(totalH || totalV){				OffsetRect(&frameRect,totalH,totalV);		TMX_Offset(totalH,totalV,theList);		TMX_Click(thePoint,0,theList);		Error();	//	gCurrentObj -> newPictReq = true;		//gCurrentObj->refreshFlag = true;			}	gCurrentObj->DoResetOrigin();	oldPoint.h = totalH;	oldPoint.v = totalV;		return oldPoint;}void			DA2_Text_Box::DrawList(void){}Boolean			DA2_Text_Box::DoContent(Point thePoint){	Boolean dblClick;	static Cell  theCell;	Point					mouse;		mouse 			= gTheEvent.where;	GlobalToLocal		(&(mouse));	TMX_Activate(true, theList);	Error();	dblClick 			= TMX_Click(mouse,gTheEvent.modifiers,theList);	currentCell 	= TMX_LastClick(theList);	Error();	if((event.modifiers & cmdKey) != 0){		Move(thePoint); return false;	}		theCell = currentCell;		return dblClick;}Boolean DA2_Text_Box::DoMenu(long theResult){	short item;	short menuNo;	Cell aCell;	if(!selected)return false;	item = LoWord(theResult);	menuNo = HiWord(theResult);	switch(menuNo){		case	8:				switch(item){					case 1:					OpenFile();					return true;					break;				case 2:					SaveFile();					return true;					break;				case 3:					DoPrint();					return true;				default:					break;			}			break;		case FILE_MENU:/*File Menu*/				switch(item){								case SAVE_AS:					SaveFile();					return true;					break;				case PRINT:					DoPrint();					return true;				default:					break;			}			break;		case  EDIT_MENU:			aCell.v = aCell.h = tmSelected;						switch (item) 				{				case CUT:					TMX_Cut(theList);					Error();					return true;					break;				case COPY:					TMX_Copy(theList);					Error();					return true;					break;				case PASTE:					TMX_Paste(theList);					Error();					return true;					break;				case DO_CLEAR:					TMX_Clear(theList);					Error();					return true;					break;				}			break;			case  9:				aCell.v = aCell.h = tmSelected;						switch (item) 				{				case 1:					TMX_Cut(theList);					Error();					return true;					break;				case 2:					TMX_Copy(theList);					Error();					return true;					break;				case 3:					TMX_Paste(theList);					Error();					return true;					break;				case 4:					TMX_Clear(theList);					Error();					return true;					break;				}			break;		}		return false;}void			DA2_Text_Box::DoIdle(void){			WindowPtr window;		Point		mouse;		Boolean			activate;		Cell		theCell;		GrafPtr		save_port;		static Boolean		activated = false;				switch (event.what) 		{		case nullEvent:			window = FrontWindow();			if (window == theWindow)			{				// This keeps the I Beam blinking if any incell editing				// is going on.				TMX_Idle(theList);				Error();				mouse = event.where;				GlobalToLocal(&mouse);				// Changes the cursor as it move around in the table.				(void) TMX_WhatCursor(true, mouse, event.modifiers, NULL, theList);				// If Balloon Help is turned on, this pops the balloons up.				(void) TMX_Where(mouse, &theCell, theList);				Error();			}			break;		case activateEvt:			window = (WindowPtr) event.message;			if(theWindow != window)break;			SetPort(window);			activate = ((event.modifiers & activeFlag) != 0);			// ---- IMPORTANT ----			// This call must be present so that the initial table is			// displayed. As a tables window is activated/deactivated,			// the selected cell and scroll bars will be turned on/off.			TMX_Activate(activate, theList);			Error();			if (activate)				myDrawGrowIcon(window);						break;		case updateEvt:			window = (WindowPtr) event.message;			if(window != theWindow)break;			GetPort		(&save_port);			SetPort		(window);			BeginUpdate(window);						UpdateEvent		();						EndUpdate			(window);			SetPort				(save_port);			break;		default:			break;		}		}void DA2_Text_Box::doKey(char theChar){	theChar = theChar;	if(!selected)return;		//TMX_Key(false,theChar,theList);	Error();}	void			DA2_Text_Box::doClickGrow(EventRecord event){	WindowPtr		window;	Rect			box;	long			newSize;	short			newWindowWidth;	short			newWindowHeight;	short			oldWindowWidth;	short			oldWindowHeight;	(void) FindWindow(event.where, &window);	SetRect(&box, 100, 50, kScreenWidth, (kScreenHeight - GetMBarHeight()));	oldWindowWidth = window->portRect.right - window->portRect.left;	oldWindowHeight = window->portRect.bottom - window->portRect.top;	newSize = GrowWindow(window, event.where, &box);	if (newSize)		{		newWindowWidth = LoWord(newSize);		newWindowHeight = HiWord(newSize);		SizeWindow(window, newWindowWidth,  newWindowHeight, true);		box = window->portRect;		box.right = box.left + newWindowWidth;		box.bottom = box.top + newWindowHeight;		dm_EraseRect(&box);		box.bottom -= kBarWidth;		box.right -= kBarWidth;		TMX_Size(box.right-box.left, box.bottom-box.top, theList);		Error();		}	myDrawGrowIcon(window);}	/* doClickGrow */void			DA2_Text_Box::myDrawGrowIcon(WindowPtr window){	RgnHandle		saveClip;	RgnHandle		myClip;	Rect			growRect;		// Get the window rectangle, find the location of the growbox.	growRect = window->portRect;	growRect.top = growRect.bottom - 15;	growRect.left = growRect.right - 15;		// Create a new clip region that will hide everything except	// the acutal growbox. The lines for the scroll bars are hidden.	myClip = D_NewRgn();	RectRgn(myClip, &growRect);	saveClip = D_NewRgn();	GetClip(saveClip);	D_SetClip(myClip);	DrawGrowIcon(window);		// Restore and cleanup things.	D_SetClip(saveClip);	D_DisposeRgn(&saveClip);	D_DisposeRgn(&myClip);}	/* myDrawGrowIcon */void			DA2_Text_Box::Error(void){	short error;	return;	error = TMX_Error(theList);	if(error != noErr ){		switch(error){		case tmErrBounds:		case tmErrMemory:		case tmErrCellNotSet:		case tmErrCellNotSelected:		case tmErrParm:			WarnUser(error + 4);		break;				case tmErrNotTM:			WarnUser(10);		break;				default:		break;		}			}}void			DA2_Text_Box::doClickMenu(EventRecord event){	WindowPtr		window;	long			choice;	window = FrontWindow();	choice = MenuSelect(event.where);	DoMenu(choice);}	/* doClickMenu */void			DA2_Text_Box::doMouse(EventRecord event){	WindowPtr		window;	Rect			box;	short			which_part;		which_part = FindWindow(event.where, &window);	switch (which_part) 		{		case inDesk:			selected = false;			break;		case inMenuBar:	    	doClickMenu(event);			break;		case inDrag:			box = qd.screenBits.bounds;			box.top += GetMBarHeight();			InsetRect(&box, 4, 4);			DragWindow(window, event.where, &box);			break;		case inContent:			if(DoContent(event.where))DoDblClick(event.where);			break;	    case inGrow:	    	doClickGrow(event);			break;		case inGoAway:			if (TrackGoAway(window, event.where))				return;			break;		}}	/* doMouse */void			DA2_Text_Box::startUp(){	}	/* startUp */void			DA2_Text_Box::AddListText(char* theText){	char	text[255];	long j = 0,i = 0,iInsRow;	short	length;	length = strlen(theText);	STARTUP: while(*theText != 13 && j < length){text[i++] = *theText;theText++;j++;}	theText++;	j++;		if(lastCell.v == rBounds.bottom && lastCell.h == rBounds.right){		rBounds.bottom = iInsRow = TMX_AddRow(1,rBounds.bottom,theList);		Error();		rBounds.bottom += 1;		lastCell.v = iInsRow;lastCell.h = 0;	}else{		if(lastCell.h == rBounds.right && lastCell.v < rBounds.bottom){lastCell.v++;lastCell.h = 0;}		else {lastCell.h++;}	}	TMX_SetCellText(text,i,lastCell,theList);	Error();	i = 0;	if(j < length) goto STARTUP;}void			DA2_Text_Box::SetListText(char* theText,Cell 	theCell){	short length;	if(theCell.v >= rBounds.bottom){		lastCell = theCell;		rBounds.bottom = TMX_AddRow(1,rBounds.bottom,theList);		Error();		//rBounds.bottom += 1;	}	length = strlen(theText);	TMX_SetCell(theText,length,theCell,theList);	Error();}void DA2_Text_Box::SaveFile(void){	Cell 	theCell;	char	**theText;	char	aText[255];	long 	allowedLength = 300;	long 	length;	long	neededLength;	GetWTitle(theWindow,gTheFile->theFileInfo.sfFile.name);	gTheFile->SaveFileOpen('TEXT');		if(!gTheFile->file_is_Open) return;			theText = (char**)D_NewHandle(sizeof(char) *  allowedLength);	**theText = 0;	neededLength = 0;	aText[0] = 0;	for(theCell.v = 0;theCell.v <= rBounds.bottom;theCell.v++){		for(theCell.h = 0; theCell.h <= rBounds.right;theCell.h++){			length = 50;			TMX_GetCellText((Ptr)aText,&length,theCell,theList);			Error();			length /= sizeof(char);			neededLength += length + 1;			D_HLock(theText);			CheckHandleSize((Handle)theText, &allowedLength,neededLength,sizeof(char));			aText[length++] = '\t';			aText[length] = 0;						strcat(*theText,aText);			aText[0] = 0;			D_HUnlock(theText);		}		D_HLock(theText);		neededLength = strlen(*theText);		(*theText)[neededLength - 1] = '\r';		(*theText)[neededLength] = 0;		D_HUnlock(theText);	}	SetHandleSize((Handle)theText,(Size)(neededLength * sizeof(char)));	gTheFile->WriteTextHandle((Handle)theText);	gTheFile->DoFileClose();}void DA2_Text_Box::OpenFile(void){	SFTypeList 		myFileTypes;	short 			numFileTypes;	OSErr 			theErr;	StandardFileReply		theFileInfo;	short			refNum;	short			k,j;	short			sizeOfString;	char			*theText;	long			curEOF;		numFileTypes = -1;	StandardGetFile((FileFilterUPP)NUL,numFileTypes,myFileTypes,&theFileInfo);	k = 0;		if(theFileInfo.sfGood)	{		theErr 			= 	FSpOpenDF(&theFileInfo.sfFile,fsRdWrPerm,&refNum);			if(theErr)return ;		theErr 			= 	GetEOF(refNum,&curEOF);		if(theErr)return ;		theText			=	D_NewPtr(curEOF);		sizeOfString	=	curEOF / sizeof(char);		theErr 			=	FSRead(refNum,&curEOF,(Ptr)(theText));		if(theErr){			KillPtr((Ptr)theText);			return ;		}		j = 0;		AddListText(theText);		theErr = FSClose(refNum);				return ;	}else{		return ;	}}void DA2_Text_Box::SetFrame(void){	frameRect = (*theList)->rViewPlus;	if(vScroll)frameRect.right 	+= 15;	if(hScroll)frameRect.bottom += 15;}void DA2_Text_Box::Iconize(Point thePoint){	Point dummy;	dummy = thePoint;//warning}void DA2_Text_Box::DoDblClick(Point thePoint){	Point dummy;	dummy = thePoint;//warning}void DA2_Text_Box::SetColumnWidth(short columnNo,short width){	if(selected){				TMX_SetColumnWidth(columnNo,width,theList);		Error();	}else{		if(next != 0L)next->SetColumnWidth(columnNo,width);	}			return;}void DA2_Text_Box::UpdateEvent(void){		DrawList();	TMX_Update		(theWindow->visRgn, theList);	Error();	myDrawGrowIcon(theWindow);}Boolean			DA2_Text_Box::DoInit(Rect *rView,Rect *rDataBnds,Point cellSize,ProcPtr procID,WindowPtr aWindow,Boolean drawIt,										Boolean hasGrow,Boolean scrollHoriz,Boolean scrollVert,Boolean hasMove,Boolean hasClose,short textFont										,short textSize,short textFace){		Point				location;	//QDErr				theError;	TMStyle				style;	Cell				theCell;	short				palatino;			procID = 0L;	closes = 	hasClose;	moves = hasMove;	SetPort(aWindow);	//TMX_SetExtIgnoreAll(&ext);	//ext.mfMemory = true;	/*ext.resID = (TMResID*)NewPtrClear(sizeof(TMResID));	ext.resID->MENU_font		= 80;	ext.resID->MENU_size 		= 81;	ext.resID->MENU_style 	= 82;	ext.resID->MENU_fore 		= 83;	ext.resID->MENU_back 		= 84;	ext.resID->MENU_justtext = 85;	ext.resID->MENU_justpict = 86;*/	theListRect	=	*rView;	rBounds							=	*rDataBnds;	rDataBnds->right 		+= 1;	rDataBnds->bottom 	+= 1;	theWindow						=	aWindow;	drawFlag						=	drawIt;	vScroll							=	scrollVert;	hScroll							=	scrollHoriz;	theList = TMX_New(rView, rDataBnds, cellSize, NULL, theWindow, drawIt,hasGrow,hScroll,vScroll);	//theList = TMX_NewExt(rView, rDataBnds, cellSize, NULL/*procID*/, theWindow, drawIt,hasGrow,hScroll,vScroll,&ext);//,(TMP_TDEF)	if(theList == 0L)return false;		Error();	//TMX_Extra(theList);	Error();		//if (theList == NULL) return false;	TMX_SetColorTable(tm8C_CLUT, tm8C_PAPER, false, theList);	TMX_SetOptions( /*tmBorder | tmColNumber | tmRowNumber | |*/ tmDoHAutoScroll, theList);	TMX_SetOptions( /*tmBorder | tmColNumber | tmRowNumber | |*/ tmRowNumber | tmDoVAutoScroll, theList);		TMX_DragDrop(true, nil, nil,theList);		TMX_SetGrid((Pattern *) &qd.gray, (Pattern *) &qd.gray, theList);			// Define the width of each column.			// Define the default cell style.	// Always call TMX_SetStyleIgnoreAll to set each field to be ignored.	TMX_SetStyleIgnoreAll(&style);//, theList);	Error();	style.font 			= monaco;	style.size 			= 9;	style.style 		= normal;	style.just 			= teJustLeft;	style.firstLine = 0;	style.crOnly 		= true;	style.backColor = tm8C_WHITE;	style.foreColor = tm8C_BLACK;	theCell.h 			= tmAll;	theCell.v 			= tmAll;	TMX_SetFont			(theCell, &style, theList);	//if (TMX_Error(theList) != noErr);	// Define the border style.	TMX_SetStyleIgnoreAll(&style);// theList);	Error();	GetFNum("\pPalatino", &palatino);	style.font = geneva;	style.size = 9;	style.style = bold;	style.just = teJustCenter;	style.firstLine = 0;	style.crOnly = true;	style.backColor = tm8C_GRAY;	style.foreColor = tm8C_BLACK;	TMX_SetBorderFont(&style, theList);			lastCell.h = currentCell.v	=	0;	lastCell.h = currentCell.v	=	0;	fontName	=	textFont;	fontSize	=	textSize;	fontFace	=	textFace;				location.h	= 0;//h;					/* these lines do nothing */	location.v	= 0;//v;		GlobalToLocal(&location);	SetFrame();		next = (DA2_Text_Box*)0L;	TMX_Activate(true, theList);	Error();	SetDrawFlag(true);	selected = true;	return true;}void							DA2_Text_Box::AddListFloat(Handle theHandle){		char	text[255];		short  i = 0,iInsRow;		short	length;		float	*value;		length = GetHandleSize(theHandle)/ sizeof(float);		D_HLock(theHandle);		value = (float*)*theHandle;				for(i = 0; i < length;i++,value++){			if(lastCell.v == rBounds.bottom && lastCell.h == rBounds.right){			rBounds.bottom = iInsRow = TMX_AddRow(1,rBounds.bottom,theList);			Error();			rBounds.bottom += 1;			lastCell.v = iInsRow;lastCell.h = 0;			}else{				if(lastCell.h == rBounds.right && lastCell.v < rBounds.bottom){lastCell.v++;lastCell.h = 0;}				else {lastCell.h++;}			}			sprintf(text,"%f",*value);			TMX_SetCell(text,i,lastCell,theList);			Error();		}			}