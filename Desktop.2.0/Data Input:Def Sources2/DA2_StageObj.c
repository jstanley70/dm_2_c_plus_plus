//Macintosh HD:CodeWarriorª DR/3 Gold Ä:Metrowerks  C/C++ Ä:Projects:D.M. v2.0:Sources.Jim:Desktop.2.0:Data Input/Def Sources2:DA2_StageObj.c#include	"Diffract_INCs.h"#include 	"StageObj.h"#include 	"ML_StageObj.h"#include	"UT_VectorMacros.c"void HolderExplanation(void);StageObj*		StageObj::DoInit(short typeA){	Vector positionA;			next = 0L;	positionA.x = 0;	positionA.y = 0;	positionA.z = 0;	y_Tilt_Sense = 1;	SetUp(typeA,0,0, positionA);	rockZA = (Index*)D_new(Index);	rockGVect	= (Index*)D_new(Index);	rockRotVec = (Index*)D_new(Index);	//old SetFoundation(0L,0L);	 	gCurrentObj->CopyAxesIntoMatrix(oldAxes);//new 2.1	SetFoundation(0L,0L);//new 2.1	return this;}void		StageObj::DoControl(void){}void		StageObj::DoClose(void){	if(next != 0L) next->DoClose();	rockZA->DoClose();	rockGVect->DoClose();	rockRotVec->DoClose();	D_delete(this);}void		StageObj::DoCopy(StageObj *theObj){	position.x 	= 	theObj->position.x;	position.y 	= 	theObj->position.y;	position.z 	= 	theObj->position.z;	tilt		=	theObj->tilt;	azimuth		=	theObj->azimuth;	type		=	theObj->type;	rotTiltToVer = 	theObj->rotTiltToVer;	rotAzimToVer = 	theObj->rotAzimToVer;	SetMatrixAEqB(oldAxes,theObj->oldAxes);	/*added DM3.0*/	/*	SetMatrixAEqB(rockAxes,theObj->oldAxes);	theObj->rockZA->DoCopy(rockZA);	rockCalcIrr = theObj->rockCalcIrr;	theObj->rockGVect->DoCopy(rockGVect),	theObj->rockRotVec->DoCopy(rockRotVec),	rockRotAng 				= theObj->rockRotAng;	rockOffLaueD 			=  theObj->rockOffLaueD;	rockTotalRot			=	theObj->rockTotalRot;	rockBeamAximuth 	= theObj->rockBeamAximuth;	rockStageTilt			= theObj->rockStageTilt;	rockStageAzimuth 	= theObj->rockStageAzimuth;	*/}void StageObj::SetFoundation(DialogPtr theDialog,ML_StageObjParamsPtr	theMLParms){	SetMatrixAEqB(rockAxes,oldAxes);	gCurrentObj->theZoneAxis->DoCopy(rockZA);	rockCalcIrr = gCurrentObj->calcIrrational;	gCurrentObj->g_Vector->DoCopy(rockGVect),	gCurrentObj->theRotationAxis->DoCopy(rockRotVec),	rockRotAng 			= gCurrentObj->rotationAngle;	rockOffLaueD 		=  gCurrentObj->offLaueDistance;	rockTotalRot		=	gCurrentObj->totalRot;	rockBeamAximuth = gCurrentObj->beamAzimuth;	rockStageTilt		= tilt;	rockStageAzimuth = azimuth;	rockDialog = theDialog;	rockMLParms = theMLParms;}void		StageObj::SetUp(short typeA,float tiltA,float azimuthA,Vector positionA){	position.x 	= 	positionA.x;	position.y 	= 	positionA.y;	position.z 	= 	positionA.z;	tilt		=	tiltA;	azimuth		=	azimuthA;	type		=	typeA;	rotTiltToVer = 0;	rotAzimToVer = 90;}Boolean	StageObj::SetStageDialogBox(void/*double radius,short centerX,short centerY*/){		DialogPtr 	theDialog;	Boolean 		calculateFlag , quit = false;	short 			theSelect;		ML_StageObjParamsPtr		theMLParms;		theDialog	= 	DM_GetNewDialog(11124,NUL,IN_FRONT);//was 204		ML_DoStageObjSetup(	(Ptr)this, theDialog,(Ptr*)&theMLParms);	theMLParms->enableBragg = enableBragg;	SetPort(theDialog);	PenMode(theMLParms->thePenState.pnMode);	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				quit = DoStageSwitchDef(theDialog, theSelect, theMLParms,&calculateFlag);				EndUpdate(theDialog);				break;			default:			quit = DoStageSwitchDef(theDialog, theSelect, theMLParms,&calculateFlag);			break;		}	}	ML_DoStageObjRead((Ptr)this,theDialog,(Ptr)theMLParms,calculateFlag);	DM_DisposDialog(&theDialog);	if(calculateFlag){		return true;	}	return false;}void  StageObj::ReadStageDialog(DialogPtr theDialog,ML_StageObjParamsPtr theMLParms,Boolean saveData){		if(saveData){			double x,y,z;			x = GetItemValue(theDialog,BEAM_H);			y = GetItemValue(theDialog,BEAM_K);			z = GetItemValue(theDialog,BEAM_L);			DetermineZAFromTilts(theDialog,0,0,false,theMLParms,false);			tilt				=	GetItemValue(theDialog,TILTAxis);			azimuth 		= GetItemValue(theDialog,AZUMAXIS);						if(fabs(gCurrentObj->theZoneAxis->x - x) > .0001 || fabs(gCurrentObj->theZoneAxis->y - y) > .0001			 || fabs(gCurrentObj->theZoneAxis->z - z) > .0001)Message(TILTS_WRONG);									gCurrentObj->changedFlag = true; 			rotTiltToVer 	=	GetItemValue(theDialog,SETUPANGLE);			rotAzimToVer 	=	rotTiltToVer + 90;			type					=	theMLParms->theMenu->lastResult;						if(GetBoolean(theDialog,Y_SENSE))				y_Tilt_Sense = 1;			else				y_Tilt_Sense = -1;		}else{			gCurrentObj->CopyMatrixIntoAxes(oldAxes);			gCurrentObj->calcIrrational 	= theMLParms->oldIr;			theMLParms->oldZone->DoCopy(gCurrentObj->theZoneAxis);			theMLParms->oldgvec->DoCopy(gCurrentObj->g_Vector),			theMLParms->rotVec->DoCopy(gCurrentObj->theRotationAxis),			gCurrentObj->rotationAngle 		= theMLParms->rotAng;			gCurrentObj->offLaueDistance 	=  theMLParms->offLaueD;			gCurrentObj->totalRot 				=  theMLParms->totalRot;			gCurrentObj->beamAzimuth			=		theMLParms->beamAzimuth;			if(gCurrentObj->foilParallel){				gCurrentObj->SetOrientation(oldAxes);			}			tilt = theMLParms->oldTilt;			azimuth = theMLParms->oldAzimuth;			y_Tilt_Sense = theMLParms->y_Tilt_Sense;		}		theMLParms->oldZone->DoClose();		theMLParms->oldgvec->DoClose();		theMLParms->rotVec->DoClose();		theMLParms->theMenu->DoClose();}Boolean StageObj::DoStageSwitchDef(DialogPtr theDialog,short theSelect,ML_StageObjParamsPtr theMLParms,Boolean *saveData){	Point aPoint;	Boolean 		 quit;	Point				thePoint;	double 			x,y,z;	Boolean   	flag = false;	Boolean			flagSetUp;	double matrix2[3][3];	FreeRotate( theDialog, theMLParms);	SetPort				(theDialog);	GetMouse(&thePoint);	flagSetUp = GetBoolean(theDialog,SETUP_STAGE);	aPoint = thePoint;	quit = false;	if(PtInRect(aPoint,&(theDialog->portRect)) || !Button()){		if(type == 1 && GetItemValue(theDialog,AZUMAXIS) != 0)SetItemValue(theDialog,AZUMAXIS,0,1);			switch(theSelect){			case -1:			case 2:							quit = true;				*saveData = false;				break;			case 1:				*saveData = true;				quit = true;				break;			case	HOLDER:				theMLParms->theMenu->DoPopUp();				type = theMLParms->theMenu->lastResult;				break;			case APPLY:			UpdateOR( theDialog,0,0,theMLParms);			break;			case SETUP_STAGE:					flagSetUp  =	SwitchBoolean(theDialog,SETUP_STAGE,flagSetUp);					if(flagSetUp){						HideDItem(theDialog,1);						HideDItem(theDialog,2);						HideDItem(theDialog,5);						HideDItem(theDialog,9);						HideDItem(theDialog,15);												ShowDItem(theDialog,Y_SENSE);						ShowDItem(theDialog,SETUPANGLE);												HideDItem(theDialog,BEAM_H);						HideDItem(theDialog,BEAM_K);						HideDItem(theDialog,BEAM_L);					}else{						ShowDItem(theDialog,1);						ShowDItem(theDialog,2);						ShowDItem(theDialog,5);						ShowDItem(theDialog,9);						ShowDItem(theDialog,15);												ShowDItem(theDialog,BEAM_H);						ShowDItem(theDialog,BEAM_K);						ShowDItem(theDialog,BEAM_L);												HideDItem(theDialog,Y_SENSE);						HideDItem(theDialog,SETUPANGLE);																		UpdateStageAndOrientation(theDialog,theMLParms);						UpdateOR( theDialog,0,0,theMLParms);						SetFoundation(theDialog,theMLParms);//this stores the new setup in the rock set of variables					}					BeginUpdate(theDialog);					DrawDialog(theDialog);					theMLParms->theMenu->SetPopUp();					EndUpdate(theDialog);					break;			case SET_BEAM:					if(gCurrentObj->DefineOrientation(true,&x,&y,&z)){						SetItemValue(theDialog,BEAM_H,x,5);						SetItemValue(theDialog,BEAM_K,y,5);						SetItemValue(theDialog,BEAM_L,z,5);						DrawDialog(theDialog);						theMLParms->theMenu->SetPopUp();						if(flagSetUp)break;					}else{						DrawDialog(theDialog);						theMLParms->theMenu->SetPopUp();					} break;			case	BEAM_FLAG:				{						flag = false;						x = GetItemValue(theDialog,BEAM_H);						y = GetItemValue(theDialog, BEAM_K);						z = GetItemValue(theDialog,BEAM_L);						if(fabs(gCurrentObj->theZoneAxis->x - x) < .001								&& fabs(gCurrentObj->theZoneAxis->y - y) < .001								&& fabs(gCurrentObj->theZoneAxis->z - z) < .001)flag = true;						gCurrentObj->theCrystal[gCurrentObj->baseCrystal]->Get001XForm(matrix2);						TransFormVector					(&x,&y,&z,matrix2);/*&h,k,l values converted to x,y,z cartesian values*/						TransFormVector					(&x,&y,&z,oldAxes);/*x,y,z values rotated to current orientation*/						NormalizeVector(&x,&y,&z);						DetermineTiltsFromZA		(theDialog,x,y,z);							if(type == 1 && GetItemValue(theDialog,AZUMAXIS) != 0){							SetItemValue(theDialog,AZUMAXIS,0,1);							flag = false;						}					//						DetermineZAFromTilts(theDialog,0,0,false /*true*/,theMLParms,false);						SetItemValue(theDialog,BEAM_H,gCurrentObj->theZoneAxis->x,5);						SetItemValue(theDialog,BEAM_K,gCurrentObj->theZoneAxis->y,5);						SetItemValue(theDialog,BEAM_L,gCurrentObj->theZoneAxis->z,5);					}				break;										case SET_THETAS:					DetermineZAFromTilts(theDialog,0,0,false,theMLParms,false);					SetItemValue(theDialog,BEAM_H,gCurrentObj->theZoneAxis->x,5);					SetItemValue(theDialog,BEAM_K,gCurrentObj->theZoneAxis->y,5);					SetItemValue(theDialog,BEAM_L,gCurrentObj->theZoneAxis->z,5);					{						flag = false;						x = GetItemValue(theDialog,BEAM_H);						y = GetItemValue(theDialog, BEAM_K);						z = GetItemValue(theDialog,BEAM_L);						gCurrentObj->theCrystal[gCurrentObj->baseCrystal]->Get001XForm(matrix2);						TransFormVector					(&x,&y,&z,matrix2);//&h,k,l values converted to x,y,z cartesian values						TransFormVector					(&x,&y,&z,oldAxes);//x,y,z values rotated to current orientation						NormalizeVector					(&x,&y,&z);						DetermineTiltsFromZA		(theDialog,x,y,z);					}				break;			case Y_SENSE:					SwitchBoolean(theDialog,Y_SENSE,GetBoolean(theDialog,Y_SENSE));					break;				case 17:					HolderExplanation();									case ML_UPDATE_EVT:					BeginUpdate(theDialog);					DrawDialog(theDialog);					theMLParms->theMenu->SetPopUp();					EndUpdate(theDialog);					break;				case DISPLAY_MATRIX:					gCurrentObj->OrientationMatrixDialogBox();					SetPort(theDialog);					DrawDialog(theDialog);					theMLParms->theMenu->SetPopUp();				break;						}	}else if(Button() && !flagSetUp){		Point		lastPoint;		GetMouse(&thePoint);		lastPoint = thePoint;				while(Button()){			GetMouse(&thePoint);						if(gCurrentObj->theWindow)SetPort				(gCurrentObj->theWindow);								GlobalToLocal	(&thePoint);			if(theMLParms->enableBragg){				unsigned long	time;					SetMarqueePattern(NUL);					PenMode(patXor);					gCurrentObj->PlotMovedPeriod(lastPoint.h,lastPoint.v);					Delay(2,&time);					gCurrentObj->PlotMovedPeriod(lastPoint.h,lastPoint.v);					PenMode(gCurrentObj->gMode);				}				SetPort				(theDialog);				LocalToGlobal	(&thePoint);				if(!EqualPt(thePoint,lastPoint)){					lastPoint = thePoint;								gCurrentObj->CalculateScreenThetas( &x, &y, &z, thePoint);							DetermineTiltsFromZA( theDialog, x, y, z);				if(type == 1 && GetItemValue(theDialog,AZUMAXIS) != 0){					SetItemValue(theDialog,AZUMAXIS,0,1);					flag = false;				}				DetermineZAFromTilts(theDialog,0,0,false,theMLParms,false);							}		}	}	return quit;}StageObj* StageObj::Add(short typeA){		if(next != 0L){		 return next->DoInit(typeA);	}	next = (StageObj*)D_new(StageObj);		next->SetUp(typeA,azimuth,rotAzimToVer, position);	next->next			=	0L;	return next;}void StageObj::CancelMatrixRotation(double *xx,double *yy,double *zz,Boolean onlyVector){	double		xForm[3][3],restoreM[3][3];	double		xForm2[3][3],restoreM2[3][3];	double		x_010 = 0,y_010 = -1,z_010 = 0;	double		x_100 = 1,y_100 = 0,z_100 = 0;	double		x,y;	//	x 			= tilt * cos((-rotTiltToVer * PI / 180)) - azimuth * sin((-rotTiltToVer * PI / 180)); /*orient x & y with respect to screen*///	y 			=  tilt * sin((-rotTiltToVer * PI / 180)) + azimuth * cos((-rotTiltToVer * PI / 180));	x = tilt * PI/180;	y = y_Tilt_Sense * azimuth * PI/180;	RotatateMatrixAxis(xForm,(rotTiltToVer - 90) * PI/180,2);	TransFormVector(&x_010,&y_010,&z_010,xForm);	TransFormVector(&x_100,&y_100,&z_100,xForm);		FindRotateAboutPoleXform(x_010,y_010,z_010,cos(x),sin(x), xForm,restoreM);	TransFormVector(&x_100,&y_100,&z_100,xForm);	TransFormVector(&x_100,&y_100,&z_100,restoreM);		FindRotateAboutPoleXform(x_100,y_100,z_100,cos(y ),sin(y), xForm2,restoreM2);	InvertMatrix(restoreM2); //this should reverse the four rotations required to orient the crystal	InvertMatrix(xForm2);	InvertMatrix(restoreM);	InvertMatrix(xForm);	TransFormVector(xx,yy,zz,restoreM2);	TransFormVector(xx,yy,zz,xForm2);	TransFormVector(xx,yy,zz,restoreM);	TransFormVector(xx,yy,zz,xForm);	if(onlyVector)return;	gCurrentObj->TransformAxes(restoreM2);	gCurrentObj->TransformAxes(xForm2);		gCurrentObj->TransformAxes(restoreM);	gCurrentObj->TransformAxes(xForm);	}void StageObj::FreeRotate(DialogPtr theDialog,ML_StageObjParamsPtr theMLParms){	//ML_StageObjParamsPtr theMLParms = 0;	SetPort(gCurrentObj->theWindow);		while(IsPressed( (unsigned short )123)){UpdateOR( theDialog,-gCurrentObj->delAngle,0,theMLParms);}		while(IsPressed( (unsigned short )124)){UpdateOR( theDialog,gCurrentObj->delAngle,0,theMLParms);}		while(IsPressed( (unsigned short )125)){UpdateOR( theDialog,0,-gCurrentObj->delAngle,theMLParms);}		while(IsPressed( (unsigned short )126)){UpdateOR( theDialog,0,gCurrentObj->delAngle,theMLParms);}}void StageObj::UpdateOR(DialogPtr theDialog,double addTilt,double addAzimuth,ML_StageObjParamsPtr theMLParms){	double value;	value = gCurrentObj->projLengthScreen;	if(IsPressed(56)) addTilt *= 5;	if(IsPressed(58) && !IsPressed(56)) addTilt /= 5;	if(gCurrentObj->theWindow)SetPort(gCurrentObj->theWindow);		DetermineZAFromTilts( theDialog,addTilt,addAzimuth,true,theMLParms,false);	if(gCurrentObj->linking == 2)gCurrentObj->CopyObjTo(gDefault,false);		gCurrentObj->changedFlag = true;		gCurrentObj->DoIdle();	if(gCurrentObj->linking == 2)gCurrentObj->DynamicLinking();	gCurrentObj->projLengthScreen = value;	SetPort(theDialog);	}void StageObj::RenormalizeToFoundation(void){	double ttilt,tazimuth;	SetMatrixAEqB(oldAxes,rockAxes);	gCurrentObj->CopyMatrixIntoAxes(oldAxes);	rockZA->DoCopy(gCurrentObj->theZoneAxis);		gCurrentObj->calcIrrational = rockCalcIrr;	rockGVect->DoCopy(gCurrentObj->g_Vector),	rockRotVec->DoCopy(gCurrentObj->theRotationAxis),	gCurrentObj->rotationAngle = rockRotAng;	gCurrentObj->offLaueDistance = rockOffLaueD;	gCurrentObj->totalRot = rockTotalRot;	gCurrentObj->beamAzimuth = rockBeamAximuth;	ttilt = tilt;	tazimuth = azimuth;	tilt = rockStageTilt;	azimuth = rockStageAzimuth;	DetermineZAFromTilts(rockDialog,0,0,false /*true*/,rockMLParms,false);}void StageObj::NewMatrixRotation(double *xx,double *yy,double *zz,Boolean justVector){	double		xForm[3][3],restoreM[3][3];	double		x_010 = 0,y_010 = -1,z_010 = 0;	double		x_100 = 1,y_100 = 0,z_100 = 0;	double		x,y;	//	x 			= tilt * cos((-rotTiltToVer * PI / 180)) - azimuth * sin((-rotTiltToVer * PI / 180)); /*orient x & y with respect to screen*///	y 			=  tilt * sin((-rotTiltToVer * PI / 180)) + azimuth * cos((-rotTiltToVer * PI / 180));	x = tilt;	y = y_Tilt_Sense * azimuth;	RotatateMatrixAxis(xForm,(rotTiltToVer - 90) * PI/180,2);	TransFormVector(&x_010,&y_010,&z_010,xForm);	TransFormVector(&x_100,&y_100,&z_100,xForm);		FindRotateAboutPoleXform(x_010,y_010,z_010,cos(x * PI/180),sin(x * PI/180), xForm,restoreM);	TransFormVector(&x_100,&y_100,&z_100,xForm);	TransFormVector(&x_100,&y_100,&z_100,restoreM);	TransFormVector(xx,yy,zz,xForm);	TransFormVector(xx,yy,zz,restoreM);		if(!justVector){		gCurrentObj->TransformAxes(xForm);		gCurrentObj->TransformAxes(restoreM);		}	FindRotateAboutPoleXform(x_100,y_100,z_100,cos(y * PI/180),sin(y * PI/180), xForm,restoreM);		TransFormVector(xx,yy,zz,xForm);	TransFormVector(xx,yy,zz,restoreM);		if(!justVector){		gCurrentObj->TransformAxes(xForm);		gCurrentObj->TransformAxes(restoreM);		}	}void StageObj::DetermineZAFromTilts(DialogPtr theDialog,double addTilt,double addAzimuth,Boolean permanent,ML_StageObjParamsPtr theMLParms,Boolean flagZAset){	double		matrix3[3][3];	double		a,t,rTV,rATV,x = 0,y = 0,z = 1,yOld;		if(fabs(tilt -	GetItemValue(theDialog,TILTAxis)) < .0001		&& fabs(azimuth - 	GetItemValue(theDialog,AZUMAXIS)) < .0001		&& fabs(addTilt) < .0001 && fabs(addAzimuth) < .0001 ){		SetItemValue(theDialog,BEAM_H,theMLParms->oldZone->x,5);		SetItemValue(theDialog,BEAM_K,theMLParms->oldZone->y,5);		SetItemValue(theDialog,BEAM_L,theMLParms->oldZone->z,5);		SetItemValue(theDialog,TILTAxis,tilt,3);		SetItemValue(theDialog,AZUMAXIS,azimuth,3);		gCurrentObj->CopyMatrixIntoAxes(oldAxes);		gCurrentObj->calcIrrational = theMLParms->oldIr;		theMLParms->oldZone->DoCopy(gCurrentObj->theZoneAxis);		theMLParms->oldgvec->DoCopy(gCurrentObj->g_Vector),		theMLParms->rotVec->DoCopy(gCurrentObj->theRotationAxis),		gCurrentObj->rotationAngle = theMLParms->rotAng;		gCurrentObj->offLaueDistance =  theMLParms->offLaueD;		gCurrentObj->totalRot					=	theMLParms->totalRot;		gCurrentObj->beamAzimuth			=		theMLParms->beamAzimuth;		return; //if  return to original settings, why bother calculate??	}	gCurrentObj->CopyMatrixIntoAxes(oldAxes);/*copy original oriented axes into matrix*/	CancelMatrixRotation(&x,&y,&z,false);// restores crystal orientation to original OR minus	//original tilts (0,0)		t = tilt;	a = azimuth ;	rTV = rotTiltToVer;	rATV = rotAzimToVer;	yOld = y_Tilt_Sense;	tilt 				=		GetItemValue(theDialog,TILTAxis);	azimuth			= 	GetItemValue(theDialog,AZUMAXIS);		tilt += addTilt;	azimuth += addAzimuth;	SetItemValue(theDialog,TILTAxis,tilt,3);	SetItemValue(theDialog,AZUMAXIS,azimuth,3);		rotTiltToVer 	=		GetItemValue(theDialog,SETUPANGLE);	rotAzimToVer 	=		rotTiltToVer + 90;	if(GetBoolean(theDialog,Y_SENSE))y_Tilt_Sense = 1;	else y_Tilt_Sense = -1;	NewMatrixRotation(&x,&y,&z,false);/*determine new rotation matrix from 001*///converts the gCurrentObj->001 etc. to new one with rotation,does not alter orientation parameters	if(flagZAset){		tilt		= t;		azimuth 	= a;			rotTiltToVer = rTV;		rotAzimToVer = rATV;		y_Tilt_Sense = yOld;		return;	}	gCurrentObj->CopyAxesIntoMatrix(matrix3);/*copy oriented axes into matrix*/			gCurrentObj->ZoneAxisFromMatrix (false,matrix3,&gCurrentObj->calcIrrational,																	gCurrentObj->theZoneAxis,gCurrentObj->theRotationAxis,gCurrentObj->g_Vector,																	&gCurrentObj->rotationAngle,&gCurrentObj->offLaueDistance,&gCurrentObj->totalRot,&gCurrentObj->beamAzimuth);/*determine z.a.*///returns new OR and replaces gCurrentObj values		SetItemValue(theDialog,BEAM_H,gCurrentObj->theZoneAxis->x,5);	SetItemValue(theDialog,BEAM_K,gCurrentObj->theZoneAxis->y,5);	SetItemValue(theDialog,BEAM_L,gCurrentObj->theZoneAxis->z,5);	gCurrentObj->CopyMatrixIntoAxes(matrix3);	/*Return current values to original values*/	if(permanent){		UpdateStageAndOrientation(theDialog,theMLParms);		return;	}	tilt		= t;	azimuth 	= a;		rotTiltToVer = rTV;	rotAzimToVer = rATV;	y_Tilt_Sense = yOld;}void StageObj::UpdateStageAndOrientation(DialogPtr theDialog,ML_StageObjParamsPtr theMLParms){	gCurrentObj->theZoneAxis->DoCopy(theMLParms->oldZone);	gCurrentObj->g_Vector->DoCopy(theMLParms->oldgvec);	gCurrentObj->theRotationAxis->DoCopy(theMLParms->rotVec);	if(theDialog){		theMLParms->oldIr 		= gCurrentObj->calcIrrational;		theMLParms->rotAng  	= gCurrentObj->rotationAngle;		theMLParms->offLaueD  = gCurrentObj->offLaueDistance;		theMLParms->totalRot	=	gCurrentObj->totalRot;		theMLParms->beamAzimuth			=		gCurrentObj->beamAzimuth;	}	gCurrentObj->CopyAxesIntoMatrix(oldAxes);	gCurrentObj->SetOrientation(oldAxes);	if(theDialog){			tilt 				=		GetItemValue(theDialog,TILTAxis);			azimuth			= 	GetItemValue(theDialog,AZUMAXIS);			rotTiltToVer 	=		GetItemValue(theDialog,SETUPANGLE);			rotAzimToVer 	=		rotTiltToVer + 90;			if(GetBoolean(theDialog,Y_SENSE))y_Tilt_Sense = 1;			else y_Tilt_Sense 				= -1;			theMLParms->oldTilt 			= tilt;			theMLParms->oldAzimuth 		= azimuth;				theMLParms->y_Tilt_Sense 	= y_Tilt_Sense;	}}void StageObj::DetermineTiltsFromZA(DialogPtr theDialog,double x,double y,double z){	double		mu,lambda,length,temp;	double		value;	CancelMatrixRotation		(&x,&y,&z,false);/* cancel stage rotations  and brings the orientation vector back after loss of original rotation	tilts are set at (0,0)*/	NormalizeVector(&x,&y,&z);	mu 			= x;// we know that this vector must be reoriented to normal so this gives x and y tilts)	lambda 	= y;	length	=	sqrt(x * x + y * y);	if(length < 0.00001){//if length is zero the tilts are now (0,0)		SetItemValue( theDialog,TILTAxis,0,3);		SetItemValue( theDialog,AZUMAXIS,0,3);		//gCurrentObj->CopyMatrixIntoAxes(oldAxes);/*return to original*/		return;	}	x 			=  mu * cos((-(rotTiltToVer - 90) * PI / 180)) - lambda * sin((-(rotTiltToVer - 90) * PI / 180)); /*orient x & y with respect to screen*/	y 			=  mu * sin((-(rotTiltToVer - 90) * PI / 180)) + lambda * cos((-(rotTiltToVer - 90) * PI / 180));	temp = sin(acos(z)) / length;	x *= temp;	y *= temp;		NormalizeVector(&x,&y,&z);	mu 		= asin(x);	value = cos(mu);	if(fabs(value) < .00001){		temp = 1;	}else{		temp	=	y / cos(mu);	}		if(temp > 1){		 temp = 1;	}	if(temp < -1){		 temp = -1;	}	lambda 		= asin(temp);	mu 			*= (180. / PI);	lambda 	*= (180. / PI);	SetItemValue( theDialog,TILTAxis,mu,3);	SetItemValue( theDialog,AZUMAXIS,y_Tilt_Sense * lambda,3);		NewMatrixRotation(&x,&y,&z,false);//return orientation to new azimuth	//gCurrentObj->CopyMatrixIntoAxes(oldAxes);/*return to original*///watch this	return ;	}void HolderExplanation(void){		DialogPtr 	theDialog;	Boolean 		quit = false;	short 			theSelect;	GrafPtr			oldPort;	GetPort(&oldPort);	theDialog	= 	GetNewDialog(11125,NUL,IN_FRONT);//was 204		SetPort(theDialog);	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){		case -1:		case 2:				quit = true;				break;		case 1:				quit = true;				break;		case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;		}			}	DisposDialog(theDialog);	SetPort(oldPort);}void	StageObj::DoWrite(void){	gTheFile		->WriteShort(type);	gTheFile		->WriteFloat(tilt);	gTheFile		->WriteFloat(azimuth);	gTheFile		->WriteFloat(rotTiltToVer);	gTheFile		->WriteFloat(rotAzimToVer);	gTheFile		->WriteMatrix(oldAxes);	gTheFile		->WriteVector(position);	gTheFile		->WriteShort(y_Tilt_Sense);	gTheFile		->WriteBoolean(enableBragg);}void StageObj::DoRead(void){	type 					= gTheFile		->ReadShort();	tilt					=	gTheFile		->ReadFloat();	azimuth 			= gTheFile		->ReadFloat();	rotTiltToVer 	= gTheFile		->ReadFloat();	rotAzimToVer 	= gTheFile		->ReadFloat();	gTheFile		->ReadMatrix(oldAxes);	gTheFile		->ReadVector(&position);	y_Tilt_Sense = gTheFile		->ReadShort();	enableBragg = gTheFile		->ReadBoolean();}void StageObj::SetStageToNewTilts(double tilt1,double azi1){	double		matrix3[3][3];	double		a,t,rTV,rATV,x = 0,y = 0,z = 1,yOld;		gCurrentObj->CopyMatrixIntoAxes(oldAxes);/*copy original oriented axes into matrix*/	CancelMatrixRotation(&x,&y,&z,false);// restores crystal orientation to original OR minus	//original tilts (0,0)		t = tilt;	a = azimuth ;	rTV = rotTiltToVer;	rATV = rotAzimToVer;	yOld = y_Tilt_Sense;		tilt = tilt1;	azimuth = azi1;	NewMatrixRotation(&x,&y,&z,false);/*determine new rotation matrix from 001*///converts the gCurrentObj->001 etc. to new one with rotation,does not alter orientation parameters	gCurrentObj->CopyAxesIntoMatrix(matrix3);/*copy oriented axes into matrix*/			gCurrentObj->ZoneAxisFromMatrix (false,matrix3,&gCurrentObj->calcIrrational,																	gCurrentObj->theZoneAxis,gCurrentObj->theRotationAxis,gCurrentObj->g_Vector,																	&gCurrentObj->rotationAngle,&gCurrentObj->offLaueDistance,&gCurrentObj->totalRot,&gCurrentObj->beamAzimuth);/*determine z.a.*///returns new OR and replaces gCurrentObj values		gCurrentObj->CopyMatrixIntoAxes(matrix3);/*Return current values to original values*/	//UpdateStageAndOrientation(0L,0L);	gCurrentObj->CopyAxesIntoMatrix(oldAxes);	gCurrentObj->SetOrientation(oldAxes);	SetFoundation(0L,0L);}