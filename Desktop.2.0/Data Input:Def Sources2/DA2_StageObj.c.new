//Macintosh HD:CodeWarriorª DR/3 Gold Ä:Metrowerks  C/C++ Ä:Projects:D.M. v2.0:Sources.Jim:Desktop.2.0:Data Input/Def Sources2:DA2_StageObj.c#include	"Diffract_INCs.h"#include 	"StageObj.h"#include 	"ML_StageObj.h"StageObj*		StageObj::DoInit(short typeA){	Vector positionA;			next = 0L;	positionA.x = 0;	positionA.y = 0;	positionA.z = 0;		SetUp(typeA,0,0, positionA);	return this;}void		StageObj::DoControl(void){}void		StageObj::DoClose(void){	if(next != 0L) next->DoClose();	D_delete(this);}void		StageObj::DoCopy(StageObj *theObj){	position.x 	= 	theObj->position.x;	position.y 	= 	theObj->position.y;	position.z 	= 	theObj->position.z;	tilt		=	theObj->tilt;	azimuth		=	theObj->azimuth;	type		=	theObj->type;	rotTiltToVer = 	theObj->rotTiltToVer;	rotAzimToVer = 	theObj->rotAzimToVer;	}void		StageObj::SetUp(short typeA,float tiltA,float azimuthA,Vector positionA){	position.x 	= 	positionA.x;	position.y 	= 	positionA.y;	position.z 	= 	positionA.z;	tilt		=	tiltA;	azimuth		=	azimuthA;	type		=	typeA;	rotTiltToVer = 0;	rotAzimToVer = 90;}Boolean	StageObj::SetStageDialogBox(void/*double radius,short centerX,short centerY*/){		DialogPtr 	theDialog;	Boolean 		calculateFlag , quit = false;	short 			theSelect;		ML_StageObjParamsPtr		theMLParms;		Boolean		theFlag = false;	theDialog	= 	DM_GetNewDialog(11113,NUL,IN_FRONT);//was 204		ML_DoStageObjSetup(	(Ptr)this, theDialog,(Ptr*)&theMLParms);	theMLParms->enableBragg = enableBragg;	SetPort(theDialog);	PenMode(theMLParms->thePenState.pnMode);	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		quit = DoStageSwitchDef(theDialog, theSelect, theMLParms,&calculateFlag);	}	ML_DoStageObjRead((Ptr)this,theDialog,(Ptr)theMLParms,calculateFlag);	DM_DisposDialog(&theDialog);	if(calculateFlag){		return true;	}	return false;}void  StageObj::ReadStageDialog(DialogPtr theDialog,ML_StageObjParamsPtr theMLParms,Boolean saveData){				if(saveData){			tilt				=	GetItemValue(theDialog,TILTAxis);			azimuth 		= GetItemValue(theDialog,AZUMAXIS);			position.x	=	GetItemValue(theDialog,X_POS);			position.y	=	GetItemValue(theDialog,Y_POS);			position.z	=	GetItemValue(theDialog,Z_POS);			rotTiltToVer 	=	GetItemValue(theDialog,SETUPANGLE);			rotAzimToVer 	=	rotTiltToVer + 90;			type					=	theMLParms->theMenu->lastResult;		}else{			gCurrentObj->CopyMatrixIntoAxes(oldAxes);			gCurrentObj->calcIrrational = theMLParms->oldIr;			theMLParms->oldZone->DoCopy(gCurrentObj->theZoneAxis);			theMLParms->oldgvec->DoCopy(gCurrentObj->g_Vector),			theMLParms->rotVec->DoCopy(gCurrentObj->theRotationAxis),			gCurrentObj->rotationAngle = theMLParms->rotAng;			gCurrentObj->offLaueDistance =  theMLParms->offLaueD;			tilt = theMLParms->oldTilt;			azimuth = theMLParms->oldAzimuth;		}		theMLParms->oldZone->DoClose();		theMLParms->oldgvec->DoClose();		theMLParms->rotVec->DoClose();		theMLParms->theMenu->DoClose		();}Boolean StageObj::DoStageSwitchDef(DialogPtr theDialog,short theSelect,ML_StageObjParamsPtr theMLParms,Boolean *saveData){	Point aPoint;	Boolean 		 quit;	Point				thePoint;	double 		x,y,z;	//FreeRotate( theDialog);	SetPort				(theDialog);	GetMouse(&thePoint);	aPoint = thePoint;	quit = false;	if(PtInRect(aPoint,&(theDialog->portRect)) || !Button()){		if(type == 1 && GetItemValue(theDialog,AZUMAXIS) != 0)SetItemValue(theDialog,AZUMAXIS,0,1);			switch(theSelect){			case -1:			case 2:			if(theMLParms->theFlag){					double matrix2[3][3];					x = GetItemValue(theDialog,BEAM_H);					y = GetItemValue(theDialog, BEAM_K);					z = GetItemValue(theDialog,BEAM_L);					gCurrentObj->theCrystal[gCurrentObj->baseCrystal]->Get001XForm(matrix2);					TransFormVector(&x,&y,&z,matrix2);/*&h,k,l values converted to x,y,z cartesian values*/					TransFormVector					(&x,&y,&z,oldAxes);/*x,y,z values rotated to current orientation*/					DetermineTiltsFromZA		(theDialog,x,y,z);					if(type == 1 && GetItemValue(theDialog,AZUMAXIS) != 0){						SetItemValue(theDialog,AZUMAXIS,0,1);						DetermineZAFromTilts(theDialog,0,0,true,theMLParms);					}									}				if(!theMLParms->theFlag){					DetermineZAFromTilts(theDialog,0,0,false,theMLParms);				}			//	quit = true;			//	*saveData = false;				break;			case 1:				*saveData = true;				quit = true;				break;			case	HOLDER:				theMLParms->theMenu->DoPopUp();				type = theMLParms->theMenu->lastResult;				break;			case APPLY:			UpdateOR( theDialog,0,0,theMLParms);			break;			case	BEAM_FLAG:				theMLParms->theFlag = SwitchBoolean( theDialog,BEAM_FLAG,theMLParms->theFlag);				break;			case SET_BEAM:					if(!theMLParms->theFlag)break;					if(gCurrentObj->DefineOrientation(true,&x,&y,&z)){						SetItemValue(theDialog,BEAM_H,x,5);						SetItemValue(theDialog,BEAM_K,y,5);						SetItemValue(theDialog,BEAM_L,z,5);					}			default:			/*	if(theMLParms->theFlag){					double matrix2[3][3];					x = GetItemValue(theDialog,BEAM_H);					y = GetItemValue(theDialog, BEAM_K);					z = GetItemValue(theDialog,BEAM_L);					gCurrentObj->theCrystal[gCurrentObj->baseCrystal]->Get001XForm(matrix2);					TransFormVector(&x,&y,&z,matrix2);//&h,k,l values converted to x,y,z cartesian values					TransFormVector					(&x,&y,&z,oldAxes);//x,y,z values rotated to current orientation					DetermineTiltsFromZA		(theDialog,x,y,z);					if(type == 1 && GetItemValue(theDialog,AZUMAXIS) != 0){						SetItemValue(theDialog,AZUMAXIS,0,1);						DetermineZAFromTilts(theDialog,0,0,true,theMLParms);					}									}				if(!theMLParms->theFlag){					DetermineZAFromTilts(theDialog,0,0,false,theMLParms);				}*/				break;		}	}else if(Button()){		theMLParms->theFlag = SwitchBoolean( theDialog,BEAM_FLAG,true);		while(Button()){			Point		lastPoint;			GetMouse(&thePoint);						if(!EqualPt(thePoint,lastPoint)){				//Point invertPoint;				lastPoint = thePoint;				LocalToGlobal	(&thePoint);				if(gCurrentObj->theWindow)SetPort				(gCurrentObj->theWindow);				PenMode				(patXor);				GlobalToLocal	(&thePoint);				if(theMLParms->enableBragg){					gCurrentObj->PlotMovedPeriod(h,v);					gCurrentObj->PlotMovedPeriod(thePoint.h,thePoint.v);				}			//	h = thePoint.h;										gCurrentObj->CalculateScreenThetas( &x, &y, &z, thePoint);							DetermineTiltsFromZA( theDialog, x, y, z);								if(type == 1 && GetItemValue(theDialog,AZUMAXIS) != 0){					SetItemValue(theDialog,AZUMAXIS,0,1);				}				DetermineZAFromTilts(theDialog,0,0,false,theMLParms);				SetPort				(theDialog);			}		}	}	return quit;}StageObj* StageObj::Add(short typeA){		if(next != 0L){		 return next->DoInit(typeA);	}	next = (StageObj*)D_new(StageObj);		next->SetUp(typeA,azimuth,rotAzimToVer, position);	next->next			=	0L;	return next;}void StageObj::FreeRotate(DialogPtr theDialog){	ML_StageObjParamsPtr theMLParms = 0;		while(IsPressed( (unsigned short )123)){UpdateOR( theDialog,-gCurrentObj->delAngle,0,theMLParms);}		while(IsPressed( (unsigned short )124)){UpdateOR( theDialog,gCurrentObj->delAngle,0,theMLParms);}		while(IsPressed( (unsigned short )125)){UpdateOR( theDialog,0,-gCurrentObj->delAngle,theMLParms);}		while(IsPressed( (unsigned short )126)){UpdateOR( theDialog,0,gCurrentObj->delAngle,theMLParms);}}void StageObj::UpdateOR(DialogPtr theDialog,double addTilt,double addAzimuth,ML_StageObjParamsPtr theMLParms){	double value;	value = gCurrentObj->projLengthScreen;	if(gCurrentObj->theWindow)SetPort(gCurrentObj->theWindow);		DetermineZAFromTilts( theDialog,addTilt,addAzimuth,true,theMLParms);	if(gCurrentObj->linking == 2)gCurrentObj->CopyObjTo(gDefault,false);		gCurrentObj->changedFlag = true;		gCurrentObj->DoIdle();	if(gCurrentObj->linking == 2)gCurrentObj->DynamicLinking();	gCurrentObj->projLengthScreen = value;	SetPort(theDialog);	}void StageObj::CancelMatrixRotation(double *xx,double *yy,double *zz){	double		xForm[3][3],restoreM[3][3];	double		xForm2[3][3],restoreM2[3][3];	double		x_010 = 0,y_010 = -1,z_010 = 0;	double		x_100 = 1,y_100 = 0,z_100 = 0;	double		x,y;	//	x 			= tilt * cos((-rotTiltToVer * PI / 180)) - azimuth * sin((-rotTiltToVer * PI / 180)); /*orient x & y with respect to screen*///	y 			=  tilt * sin((-rotTiltToVer * PI / 180)) + azimuth * cos((-rotTiltToVer * PI / 180));	x = tilt;	y = azimuth;	RotatateMatrixAxis(xForm,rotTiltToVer * PI/180,2);	TransFormVector(&x_010,&y_010,&z_010,xForm);	TransFormVector(&x_100,&y_100,&z_100,xForm);		FindRotateAboutPoleXform(x_010,y_010,z_010,cos(x * PI/180),sin(x * PI/180), xForm,restoreM);	TransFormVector(&x_100,&y_100,&z_100,xForm);	TransFormVector(&x_100,&y_100,&z_100,restoreM);		FindRotateAboutPoleXform(x_100,y_100,z_100,cos(y * PI/180),sin(y * PI/180), xForm2,restoreM2);	InvertMatrix(restoreM2); //this should reverse the four rotations required to orient the crystal	InvertMatrix(xForm2);	InvertMatrix(restoreM);	InvertMatrix(xForm);		TransFormVector(xx,yy,zz,restoreM2);//this gives an anti-rotation vector	TransFormVector(xx,yy,zz,xForm2);	TransFormVector(xx,yy,zz,restoreM);	TransFormVector(xx,yy,zz,xForm);		gCurrentObj->TransformAxes(restoreM2);//this restores the old axes to the old axes without the	gCurrentObj->TransformAxes(xForm2);	//sample holder tilts, tilts are now at 0,0	gCurrentObj->TransformAxes(restoreM);	gCurrentObj->TransformAxes(xForm);	}void StageObj::NewMatrixRotation(void/*double matrix2[3][3]*/){	double		xForm[3][3],restoreM[3][3],xForm2[3][3],restoreM2[3][3];	double		x_010 = 0,y_010 = -1,z_010 = 0;	double		x_100 = 1,y_100 = 0,z_100 = 0;	double		x,y;	//	x 			= tilt * cos((-rotTiltToVer * PI / 180)) - azimuth * sin((-rotTiltToVer * PI / 180)); /*orient x & y with respect to screen*///	y 			=  tilt * sin((-rotTiltToVer * PI / 180)) + azimuth * cos((-rotTiltToVer * PI / 180));	x = tilt;	y = azimuth;	RotatateMatrixAxis(xForm,rotTiltToVer * PI/180,2);	TransFormVector(&x_010,&y_010,&z_010,xForm);	TransFormVector(&x_100,&y_100,&z_100,xForm);		FindRotateAboutPoleXform(x_010,y_010,z_010,cos(x * PI/180),sin(x * PI/180), xForm,restoreM);		TransFormVector(&x_100,&y_100,&z_100,xForm);	TransFormVector(&x_100,&y_100,&z_100,restoreM);			FindRotateAboutPoleXform(x_100,y_100,z_100,cos(y * PI/180),sin(y * PI/180), xForm2,restoreM2);	/*	InvertMatrix(restoreM2);	InvertMatrix(xForm2);	InvertMatrix(restoreM);	InvertMatrix(xForm);*/		gCurrentObj->TransformAxes(xForm);	gCurrentObj->TransformAxes(restoreM);		gCurrentObj->TransformAxes(xForm2);	gCurrentObj->TransformAxes(restoreM2);	}void StageObj::DetermineZAFromTilts(DialogPtr theDialog,double addTilt,double addAzimuth,Boolean permanent,ML_StageObjParamsPtr theMLParms){	double		matrix3[3][3];	double		a,t,rTV,rATV,x = 0,y = 0,z = 1;		if(fabs(tilt -	GetItemValue(theDialog,TILTAxis)) < .0001		&& fabs(azimuth - 	GetItemValue(theDialog,AZUMAXIS)) < .0001		&& fabs(addTilt) < .0001 && fabs(addAzimuth) < .0001 )return; //if nothings changed why bother??		gCurrentObj->CopyMatrixIntoAxes(oldAxes);/*copy original oriented axes into matrix*/	CancelMatrixRotation(&x,&y,&z);// restores crystal orientation to original OR minus	//original tilts (0,0)		t = tilt;	a = azimuth ;	rTV = rotTiltToVer;	rATV = rotAzimToVer;		tilt 				=		GetItemValue(theDialog,TILTAxis);	azimuth			= 	GetItemValue(theDialog,AZUMAXIS);		tilt += addTilt;	azimuth += addAzimuth;	SetItemValue(theDialog,TILTAxis,tilt,3);	SetItemValue(theDialog,AZUMAXIS,azimuth,3);		rotTiltToVer 	=		GetItemValue(theDialog,SETUPANGLE);	rotAzimToVer 	=		rotTiltToVer + 90;		NewMatrixRotation();/*determine new rotation matrix from 001*///converts the gCurrentObj->oldAxes to new one with rotation,does not alter orientation parameters	gCurrentObj->CopyAxesIntoMatrix(matrix3);/*copy oriented axes into matrix*/	gCurrentObj->ZoneAxisFromMatrix (matrix3,&gCurrentObj->calcIrrational,																	gCurrentObj->theZoneAxis,gCurrentObj->g_Vector,																	&gCurrentObj->rotationAngle,&gCurrentObj->offLaueDistance);/*determine z.a.*///returns new OR and replaces gCurrentObj values		SetItemValue(theDialog,BEAM_H,gCurrentObj->theZoneAxis->x,5);	SetItemValue(theDialog,BEAM_K,gCurrentObj->theZoneAxis->y,5);	SetItemValue(theDialog,BEAM_L,gCurrentObj->theZoneAxis->z,5);		/*Return current values to original values*/if(permanent){	gCurrentObj->theZoneAxis->DoCopy(theMLParms->oldZone);	gCurrentObj->g_Vector->DoCopy(theMLParms->oldgvec);	theMLParms->oldIr = gCurrentObj->calcIrrational;	theMLParms->rotAng  = gCurrentObj->rotationAngle;	theMLParms->offLaueD  = gCurrentObj->offLaueDistance;	gCurrentObj->CopyAxesIntoMatrix(oldAxes);	return;}		tilt		= t;	azimuth 	= a;		rotTiltToVer = rTV;	rotAzimToVer = rATV;	}/*void StageObj::DetermineTiltsFromZA(DialogPtr theDialog,double x,double y,double z){	double		mu,lambda;		NormalizeVector(&x,&y,&z);	mu = asin(x);		lambda = asin(y / cos(mu));	x = mu * cos((rotTiltToVer * PI / 180)) + lambda * sin((rotTiltToVer * PI / 180));	y = mu * cos((rotAzimToVer * PI / 180)) + lambda * sin((rotAzimToVer * PI / 180));		mu 		= x;	lambda 	= y;	mu *= (180. / PI);	lambda *= (180. / PI);	SetItemValue( theDialog,3,lambda,3);	SetItemValue( theDialog,4,mu,3);}*/void StageObj::DetermineTiltsFromZA(DialogPtr theDialog,double x,double y,double z){	double		mu,lambda,length,temp;	CancelMatrixRotation		(&x,&y,&z);/* cancel stage rotations  and brings the orientation vector back after loss of original rotation	tilts are set at (0,0)*/	NormalizeVector(&x,&y,&z);	mu 			= x;// we know that this vector must be reoriented to normal so this gives x and y tilts)	lambda 	= y;	length	=	sqrt(x * x + y * y);	if(length == 0){//if length is zero the tilts are now (0,0)		SetItemValue( theDialog,TILTAxis,0,3);		SetItemValue( theDialog,AZUMAXIS,0,3);		//gCurrentObj->CopyMatrixIntoAxes(oldAxes);/*return to original*/		return;	}	x 			=  mu * cos((-rotTiltToVer * PI / 180)) - lambda * sin((-rotTiltToVer * PI / 180)); /*orient x & y with respect to screen*/	y 			=  mu * sin((-rotTiltToVer * PI / 180)) + lambda * cos((-rotTiltToVer * PI / 180));	temp = sin(acos(z)) / length;	x *= temp;	y *= temp;		NormalizeVector(&x,&y,&z);	mu 		= asin(x);	temp	=	y / cos(mu);	if(temp > 1) temp = 1;	if(temp < -1) temp = -1;	lambda 	= asin(temp);	mu 		*= (180. / PI);	lambda 	*= (180. / PI);	SetItemValue( theDialog,TILTAxis,mu,3);	SetItemValue( theDialog,AZUMAXIS,lambda,3);	NewMatrixRotation();	//gCurrentObj->CopyMatrixIntoAxes(oldAxes);/*return to original*/}