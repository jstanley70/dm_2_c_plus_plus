/* cbal.f -- translated by f2c (version 19941113).   You must link the resulting object file with the libraries:	-lf2c -lm   (in that order)*///rows and columns switched/*#define	IJ	i][j#define JI	j][i#define	MI	m][i#define IM	i][m*/#define	IJ	j][i#define JI	i][j#define	MI	i][m#define IM	m][i#include "f2c.h"/* Subroutine */ int cbal_(integer *nm, integer *n, rreal **ar, rreal **ai,integer *low, integer *igh, rreal *scale){    /* System generated locals */   // integer ar_dim1, ar_offset, ai_dim1, ai_offset,   integer i__1, i__2;    rreal r__1, r__2;    /* Local variables */    integer iexc;    rreal c, f, g;    integer i, j, k, l, m;    rreal r, s, radix, b2;    integer jj;    logical noconv; *nm =  *nm;/*     THE FOLLOWING PORTABLE VALUE OF RADIX WORKS WELL ENOUGH *//*     FOR ALL MACHINES WHOSE BASE IS A POWER OF TWO. *//* ***FIRST EXECUTABLE STATEMENT  CBAL */    /* Parameter adjustments */   // ai_dim1 = *nm;  //  ai_offset = ai_dim1 + 1;  //  ai -= ai_offset;  //  ar_dim1 = *nm;  //  ar_offset = ar_dim1 + 1;  //  ar -= ar_offset;  //  --scale;    /* Function Body */    radix = 16.f;    b2 = radix * radix;    k = 1;    l = *n;    goto L100;/*     .......... IN-LINE PROCEDURE FOR ROW AND *//*                COLUMN EXCHANGE .......... */L20:    scale[m] = (rreal) j;    if (j == m) {	goto L50;    }    i__1 = l;    for (i = 1; i <= i__1; ++i) {	f = ar[IJ];	ar[IJ] = ar[IM];	ar[IM] = f;	f = ai[IJ];	ai[IJ] = ai[IM];	ai[IM] = f;/* L30: */    }    i__1 = *n;    for (i = k; i <= i__1; ++i) {	f = ar[JI];	ar[JI] = ar[MI];	ar[MI] = f;	f = ai[JI];	ai[JI] = ai[MI];	ai[MI] = f;/* L40: */    }L50:    switch (iexc) {	case 1:  goto L80;	case 2:  goto L130;    }/*     .......... SEARCH FOR ROWS ISOLATING AN EIGENVALUE *//*                AND PUSH THEM DOWN .......... */L80:    if (l == 1) {	goto L280;    }    --l;/*     .......... FOR J=L STEP -1 UNTIL 1 DO -- .......... */L100:    i__1 = l;    for (jj = 1; jj <= i__1; ++jj) {	j = l + 1 - jj;	i__2 = l;	for (i = 1; i <= i__2; ++i) {	    if (i == j) {		goto L110;	    }	    if (ar[JI] != 0.f || ai[JI] != 0.f) {		goto L120;	    }L110:	    ;	}	m = l;	iexc = 1;	goto L20;L120:	;    }    goto L140;/*     .......... SEARCH FOR COLUMNS ISOLATING AN EIGENVALUE *//*                AND PUSH THEM LEFT .......... */L130:    ++k;L140:    i__1 = l;    for (j = k; j <= i__1; ++j) {	i__2 = l;	for (i = k; i <= i__2; ++i) {	    if (i == j) {		goto L150;	    }	    if (ar[IJ] != 0.f || ai[IJ] != 0.f) {		goto L170;	    }L150:	    ;	}	m = k;	iexc = 2;	goto L20;L170:	;    }/*     .......... NOW BALANCE THE SUBMATRIX IN ROWS K TO L .......... */    i__1 = l;    for (i = k; i <= i__1; ++i) {/* L180: */	scale[i] = 1.f;    }/*     .......... ITERATIVE LOOP FOR NORM REDUCTION .......... */L190:    noconv = FALSE_;    i__1 = l;    for (i = k; i <= i__1; ++i) {	c = 0.f;	r = 0.f;	i__2 = l;	for (j = k; j <= i__2; ++j) {	    if (j == i) {		goto L200;	    }	    c = c + (r__1 = ar[JI], abs(r__1)) + (r__2 = ai[JI], abs(r__2));	    r = r + (r__1 = ar[IJ], abs(r__1)) + (r__2 = ai[IJ], abs(r__2));L200:	    ;	}/*     .......... GUARD AGAINST ZERO C OR R DUE TO UNDERFLOW .......... */	if (c == 0.f || r == 0.f) {	    goto L270;	}	g = r / radix;	f = 1.f;	s = c + r;L210:	if (c >= g) {	    goto L220;	}	f *= radix;	c *= b2;	goto L210;L220:	g = r * radix;L230:	if (c < g) {	    goto L240;	}	f /= radix;	c /= b2;	goto L230;/*     .......... NOW BALANCE .......... */L240:	if ((c + r) / f >= s * .95f) {	    goto L270;	}	g = 1.f / f;	scale[i] *= f;	noconv = TRUE_;	i__2 = *n;	for (j = k; j <= i__2; ++j) {	    ar[IJ] *= g;	    ai[IJ] *= g;/* L250: */	}	i__2 = l;	for (j = 1; j <= i__2; ++j) {	    ar[JI] *= f;	    ai[JI] *= f;/* L260: */	}L270:	;    }    if (noconv) {	goto L190;    }L280:    *low = k;    *igh = l;    return 0;} /* cbal_ */