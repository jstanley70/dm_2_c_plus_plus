/* comqr2.f -- translated by f2c (version 19941113).   You must link the resulting object file with the libraries:	-lf2c -lm   (in that order)*///rows and columns switched#define IJ		j][i#define	JI		i][j#define KI_1 	i - 1][k#define II_1 	i - 1][i#define I_1J 	j][i - 1#define I_1I_1 	i - 1][i - 1#define I_1I   	i][i - 1#define	LL_1	l - 1][l#define ENM1_EN		en][enm1#define EN_ENM1	 	enm1][en#define ENM1_EN_2 	en - 2][enm1#define EN_J		j][en#define IJ_1		j - 1][i#define JJ_1		j - 1][j#define	KJ			j][k#define	IK			k][i#define	I_EN		en][i#define	J_EN		en][j/*#define IJ		i][j#define	JI		j][i#define KI_1 	k][i - 1#define II_1 	i][i - 1#define I_1J 	i - 1][j#define I_1I_1 	i - 1][i - 1#define I_1I   	i - 1][i#define	LL_1	l][l - 1#define ENM1_EN	enm1][en#define EN_ENM1 en][enm1#define ENM1_EN_2 enm1][en - 2#define EN_J		en][j#define IJ_1		i][j - 1#define JJ_1		j][j - 1#define	KJ			k][j#define	IK			i][k#define	I_EN		i][en#define	J_EN		j][en*/#include "f2c.h"/* Subroutine */ int comqr2_(integer *nm, integer *n, integer *low, integer *	igh, rreal *ortr, rreal *orti, rreal **hr, rreal **hi, rreal *wr, rreal *wi, 	rreal **zr, rreal **zi, integer *ierr){    /* System generated locals */    integer i__1, i__2, i__3;    rreal r__1, r__2, r__3, r__4;    /* Local variables */    integer iend;    extern /* Subroutine */ int cdiv_(rreal *, rreal *, rreal *, rreal *, rreal *, 	    rreal *);    rreal norm;    integer i, j, k, l, m;    rreal s1, s2;    integer ii, en, jj, ll, nn;    rreal si, ti, xi, yi, sr, tr, xr, yr;    extern rreal pythag_(rreal *, rreal *);    extern /* Subroutine */ int csroot_(rreal *, rreal *, rreal *, rreal *);    integer ip1, lp1, itn, its;    rreal zzi, zzr;    integer enm1;*nm = *nm;/* ***FIRST EXECUTABLE STATEMENT  COMQR2 */    /* Parameter adjustments *///    zi_dim1 = *nm;//    zi_offset = zi_dim1 + 1;//    zi -= zi_offset;//    zr_dim1 = *nm;//    zr_offset = zr_dim1 + 1;//    zr -= zr_offset;//    hi_dim1 = *nm;//    hi_offset = hi_dim1 + 1;//    hi -= hi_offset;//    hr_dim1 = *nm;//    hr_offset = hr_dim1 + 1;//    hr -= hr_offset;//    --ortr;//    --orti;//    --wr;//    --wi;    /* Function Body */    *ierr = 0;/*     .......... INITIALIZE EIGENVECTOR MATRIX .......... */    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	i__2 = *n;	for (j = 1; j <= i__2; ++j) {	    zr[IJ] = 0.f;	    zi[IJ] = 0.f;	    if (i == j) {		zr[IJ] = 1.f;	    }/* L100: */	}    }/*     .......... FORM THE MATRIX OF ACCUMULATED TRANSFORMATIONS *//*                FROM THE INFORMATION LEFT BY CORTH .......... */    iend = *igh - *low - 1;    if (iend < 0) {	goto L180;    } else if (iend == 0) {	goto L150;    } else {	goto L105;    }/*     .......... FOR I=IGH-1 STEP -1 UNTIL LOW+1 DO -- .......... */L105:    i__2 = iend;    for (ii = 1; ii <= i__2; ++ii) {	i = *igh - ii;	if (ortr[i] == 0.f && orti[i] == 0.f) {	    goto L140;	}	if (hr[II_1] == 0.f && hi[II_1] == 		0.f) {	    goto L140;	}/*     .......... NORM BELOW IS NEGATIVE OF H FORMED IN CORTH .......... */	norm = hr[II_1] * ortr[i] + hi[II_1] * orti[i];	ip1 = i + 1;	i__1 = *igh;	for (k = ip1; k <= i__1; ++k) {	    ortr[k] = hr[KI_1];	    orti[k] = hi[KI_1];/* L110: */	}	i__1 = *igh;	for (j = i; j <= i__1; ++j) {	    sr = 0.f;	    si = 0.f;	    i__3 = *igh;	    for (k = i; k <= i__3; ++k) {		sr = sr + ortr[k] * zr[KJ] + orti[k] * zi[KJ];		si = si + ortr[k] * zi[KJ] - orti[k] * zr[KJ];/* L115: */	    }	    sr /= norm;	    si /= norm;	    i__3 = *igh;	    for (k = i; k <= i__3; ++k) {		zr[KJ] = zr[KJ] + sr * ortr[k] - si * orti[k];		zi[KJ] = zi[KJ] + sr * orti[k] + si * ortr[k];/* L120: */	    }/* L130: */	}L140:	;    }/*     .......... CREATE REAL SUBDIAGONAL ELEMENTS .......... */L150:    l = *low + 1;    i__2 = *igh;    for (i = l; i <= i__2; ++i) {/* Computing MIN */	i__1 = i + 1;	ll = min(i__1,*igh);	if (hi[II_1] == 0.f) {	    goto L170;	}	norm = pythag_(&hr[II_1], &hi[II_1])		;	yr = hr[II_1] / norm;	yi = hi[II_1] / norm;	hr[II_1] = norm;	hi[II_1] = 0.f;	i__1 = *n;	for (j = i; j <= i__1; ++j) {	    si = yr * hi[IJ] - yi * hr[IJ];	    hr[IJ] = yr * hr[IJ] + yi * hi[IJ];	    hi[IJ] = si;/* L155: */	}	i__1 = ll;	for (j = 1; j <= i__1; ++j) {	    si = yr * hi[JI] + yi * hr[JI];	    hr[JI] = yr * hr[JI] - yi * hi[JI];	    hi[JI] = si;/* L160: */	}	i__1 = *igh;	for (j = *low; j <= i__1; ++j) {	    si = yr * zi[JI] + yi * zr[JI];	    zr[JI] = yr * zr[JI] - yi * zi[JI];	    zi[JI] = si;/* L165: */	}L170:	;    }/*     .......... STORE ROOTS ISOLATED BY CBAL .......... */L180:    i__2 = *n;    for (i = 1; i <= i__2; ++i) {	if (i >= *low && i <= *igh) {	    goto L200;	}	wr[i] = hr[i][i];	wi[i] = hi[i][i];L200:	;    }    en = *igh;    tr = 0.f;    ti = 0.f;    itn = *n * 30;/*     .......... SEARCH FOR NEXT EIGENVALUE .......... */L220:    if (en < *low) {	goto L680;    }    its = 0;    enm1 = en - 1;/*     .......... LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT *//*                FOR L=EN STEP -1 UNTIL LOW DO -- .......... */L240:    i__2 = en;    for (ll = *low; ll <= i__2; ++ll) {	l = en + *low - ll;	if (l == *low) {	    goto L300;	}	s1 = (r__1 = hr[l - 1][l - 1], abs(r__1)) + (r__2 = hi[l - 1][l - 1], abs(r__2)) + (r__3 = 		hr[l][l], abs(r__3)) + (r__4 = hi[l][l], abs(r__4));	s2 = s1 + (r__1 = hr[LL_1], abs(r__1));	if (s2 == s1) {	    goto L300;	}/* L260: */    }/*     .......... FORM SHIFT .......... */L300:    if (l == en) {	goto L660;    }    if(Quit()){    	goto L1000;    }    if (itn == 0) {    	itn = 0;	goto L1000;    }    if (its == 10 || its == 20) {	goto L320;    }    sr = hr[en][en];    si = hi[en][en];    xr = hr[ENM1_EN] * hr[EN_ENM1];    xi = hi[ENM1_EN] * hr[EN_ENM1];    if (xr == 0.f && xi == 0.f) {	goto L340;    }    yr = (hr[enm1][enm1] - sr) / 2.f;    yi = (hi[enm1][enm1] - si) / 2.f;/* Computing 2nd power */    r__2 = yr;/* Computing 2nd power */    r__3 = yi;    r__1 = r__2 * r__2 - r__3 * r__3 + xr;    r__4 = yr * 2.f * yi + xi;    csroot_(&r__1, &r__4, &zzr, &zzi);    if (yr * zzr + yi * zzi >= 0.f) {	goto L310;    }    zzr = -zzr;    zzi = -zzi;L310:    r__1 = yr + zzr;    r__2 = yi + zzi;    cdiv_(&xr, &xi, &r__1, &r__2, &xr, &xi);    sr -= xr;    si -= xi;    goto L340;/*     .......... FORM EXCEPTIONAL SHIFT .......... */L320:    sr = (r__1 = hr[EN_ENM1], abs(r__1)) + (r__2 = hr[ENM1_EN_2], abs(r__2));    si = 0.f;L340:    i__2 = en;    for (i = *low; i <= i__2; ++i) {	hr[i][i] -= sr;	hi[i][i] -= si;/* L360: */    }    tr += sr;    ti += si;    ++its;    --itn;/*     .......... REDUCE TO TRIANGLE (ROWS) .......... */    lp1 = l + 1;    i__2 = en;    for (i = lp1; i <= i__2; ++i) {	sr = hr[II_1];	hr[II_1] = 0.f;	r__1 = pythag_(&hr[I_1I_1], &hi[I_1I_1]);	norm = pythag_(&r__1, &sr);	xr = hr[I_1I_1] / norm;	wr[i - 1] = xr;	xi = hi[I_1I_1]/ norm;	wi[i - 1] = xi;	hr[I_1I_1] = norm;	hi[I_1I_1] = 0.f;	hi[II_1] = sr / norm;	i__1 = *n;	for (j = i; j <= i__1; ++j) {	    yr = hr[I_1J];	    yi = hi[I_1J];	    zzr = hr[IJ];	    zzi = hi[IJ];	    hr[I_1J] = xr * yr + xi * yi + hi[II_1] * zzr;	    hi[I_1J] = xr * yi - xi * yr + hi[II_1] * zzi;	    hr[IJ] = xr * zzr - xi * zzi - hi[II_1] * yr;	    hi[IJ] = xr * zzi + xi * zzr - hi[II_1] * yi;/* L490: */	}/* L500: */    }    si = hi[en][en];    if (si == 0.f) {	goto L540;    }    norm = pythag_(&hr[en][en], &si);    sr = hr[en][en] / norm;    si /= norm;    hr[en][en] = norm;    hi[en][en] = 0.f;    if (en == *n) {	goto L540;    }    ip1 = en + 1;    i__2 = *n;    for (j = ip1; j <= i__2; ++j) {	yr = hr[EN_J];	yi = hi[EN_J];	hr[EN_J] = sr * yr + si * yi;	hi[EN_J] = sr * yi - si * yr;/* L520: */    }/*     .......... INVERSE OPERATION (COLUMNS) .......... */L540:    i__2 = en;    for (j = lp1; j <= i__2; ++j) {	xr = wr[j - 1];	xi = wi[j - 1];	i__1 = j;	for (i = 1; i <= i__1; ++i) {	    yr = hr[IJ_1];	    yi = 0.f;	    zzr = hr[IJ];	    zzi = hi[IJ];	    if (i == j) {		goto L560;	    }	    yi = hi[IJ_1];	    hi[IJ_1] = xr * yi + xi * yr + hi[JJ_1] * zzi;L560:	    hr[IJ_1] = xr * yr - xi * yi + hi[JJ_1] * zzr;	    hr[IJ]= xr * zzr + xi * zzi - hi[JJ_1] * yr;	    hi[IJ] = xr * zzi - xi * zzr - hi[JJ_1] * yi;/* L580: */	}	i__1 = *igh;	for (i = *low; i <= i__1; ++i) {	    yr = zr[IJ_1];	    yi = zi[IJ_1];	    zzr = zr[IJ];	    zzi = zi[IJ];	    zr[IJ_1] = xr * yr - xi * yi + hi[JJ_1] * zzr;	    zi[IJ_1] = xr * yi + xi * yr + hi[JJ_1]* zzi;	    zr[IJ] = xr * zzr + xi * zzi - hi[JJ_1] * yr;	    zi[IJ] = xr * zzi - xi * zzr - hi[JJ_1] * yi;/* L590: */	}/* L600: */    }    if (si == 0.f) {	goto L240;    }    i__2 = en;    for (i = 1; i <= i__2; ++i) {	yr = hr[I_EN];	yi = hi[I_EN];	hr[I_EN] = sr * yr - si * yi;	hi[I_EN] = sr * yi + si * yr;/* L630: */    }    i__2 = *igh;    for (i = *low; i <= i__2; ++i) {	yr = zr[I_EN];	yi = zi[I_EN];	zr[I_EN] = sr * yr - si * yi;	zi[I_EN] = sr * yi + si * yr;/* L640: */    }    goto L240;/*     .......... A ROOT FOUND .......... */L660:    hr[en][en] += tr;    wr[en] = hr[en][en];    hi[en][en] += ti;    wi[en] = hi[en][en];    en = enm1;    goto L220;/*     .......... ALL ROOTS FOUND.  BACKSUBSTITUTE TO FIND *//*                VECTORS OF UPPER TRIANGULAR FORM .......... */L680:    norm = 0.f;    i__2 = *n;    for (i = 1; i <= i__2; ++i) {	i__1 = *n;	for (j = i; j <= i__1; ++j) {	    norm = norm + (r__1 = hr[IJ], abs(r__1)) + (r__2 = hi[IJ], abs(r__2));/* L720: */	}    }    if (*n == 1 || norm == 0.f) {	goto L1001;    }/*     .......... FOR EN=N STEP -1 UNTIL 2 DO -- .......... */    i__1 = *n;    for (nn = 2; nn <= i__1; ++nn) {	en = *n + 2 - nn;	xr = wr[en];	xi = wi[en];	enm1 = en - 1;/*     .......... FOR I=EN-1 STEP -1 UNTIL 1 DO -- .......... */	i__2 = enm1;	for (ii = 1; ii <= i__2; ++ii) {	    i = en - ii;	    zzr = hr[I_EN];	    zzi = hi[I_EN];	    if (i == enm1) {		goto L760;	    }	    ip1 = i + 1;	    i__3 = enm1;	    for (j = ip1; j <= i__3; ++j) {		zzr = zzr + hr[IJ] * hr[J_EN] - hi[IJ] * hi[J_EN];		zzi = zzi + hr[IJ] * hi[J_EN] + hi[IJ] * hr[J_EN];/* L740: */	    }L760:	    yr = xr - wr[i];	    yi = xi - wi[i];	    if (yr != 0.f || yi != 0.f) {		goto L775;	    }	    yr = norm;L770:	    yr *= .5f;	    if (norm + yr > norm) {		goto L770;	    }	    yr *= 2.f;L775:	    cdiv_(&zzr, &zzi, &yr, &yi, &hr[I_EN], &hi[I_EN]);/* L780: */	}/* L800: */    }/*     .......... END BACKSUBSTITUTION .......... */    enm1 = *n - 1;/*     .......... VECTORS OF ISOLATED ROOTS .......... */    i__1 = enm1;    for (i = 1; i <= i__1; ++i) {	if (i >= *low && i <= *igh) {	    goto L840;	}	ip1 = i + 1;	i__2 = *n;	for (j = ip1; j <= i__2; ++j) {	    zr[IJ] = hr[IJ];	    zi[IJ] = hi[IJ];/* L820: */	}L840:	;    }/*     .......... MULTIPLY BY TRANSFORMATION MATRIX TO GIVE *//*                VECTORS OF ORIGINAL FULL MATRIX. *//*                FOR J=N STEP -1 UNTIL LOW+1 DO -- .......... */    i__1 = enm1;    for (jj = *low; jj <= i__1; ++jj) {	j = *n + *low - jj;/* Computing MIN */	i__2 = j - 1;	m = min(i__2,*igh);	i__2 = *igh;	for (i = *low; i <= i__2; ++i) {	    zzr = zr[IJ];	    zzi = zi[IJ];	    i__3 = m;	    for (k = *low; k <= i__3; ++k) {		zzr = zzr + zr[IK] * hr[KJ] - zi[IK] * hi[KJ];		zzi = zzi + zr[IK] * hi[KJ] + zi[IK] * hr[KJ];/* L860: */	    }	    zr[IJ] = zzr;	    zi[IJ] = zzi;/* L880: */	}    }    goto L1001;/*     .......... SET ERROR -- NO CONVERGENCE TO AN *//*                EIGENVALUE AFTER 30*N ITERATIONS .......... */L1000:    *ierr = en;L1001:    return 0;} /* comqr2_ */