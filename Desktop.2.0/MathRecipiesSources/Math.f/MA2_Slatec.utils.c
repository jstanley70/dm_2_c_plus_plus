/* Slatec.utils.f -- translated by f2c (version 19941113).   You must link the resulting object file with the libraries:	-lf2c -lm   (in that order)*/#include "f2c.h"/* Table of constant values */static integer c__1 = 1;static integer c__2 = 2;static integer c__5 = 5;static integer c__0 = 0;static logical c_false = FALSE_;static integer c__4 = 4;static integer c_n1 = -1;static integer c__72 = 72;static logical c_true = TRUE_;static integer c__3 = 3;/* *** NOTE *** This file contains the source code of the 37 most *//* frequently cross-referenced subroutines in the SLATEC library.  We *//* recommend that you compile it as a unit and link it with any other *//* SLATEC routines that you use -- chances are they need at least several *//* of these routines in any case. *//* *** FURTHER NOTE*** You must edit the first five routines (R1MACH, *//* D1MACH, I1MACH, FDUMP, and XERHLT) to make them correspond to your *//* machine type.  For further information on these routines, consult *//* their header files in the alphabetical header-file directory. */rreal r1mach_(integer *i){    /* Initialized data */    static struct {	rreal e_1[5];	integer fill_2[1];	} equiv_4 = { 8388608.f, 2139095039.f, 864026624.f, 872415232.f, 		1050288283.f };    /* System generated locals */    rreal ret_val;    /* Local variables *///#define log10 ((integer *)&equiv_4 + 4)#define large ((integer *)&equiv_4 + 1)#define rmach ((rreal *)&equiv_4)#define small ((integer *)&equiv_4)#define diver ((integer *)&equiv_4 + 3)#define right ((integer *)&equiv_4 + 2)    extern /* Subroutine */ int xermsg_(char *, char *, char *, integer *, 	    integer *, ftnlen, ftnlen, ftnlen);/*     MACHINE CONSTANTS FOR THE AMIGA *//*     ABSOFT FORTRAN COMPILER USING THE 68020/68881 COMPILER OPTION *//*     DATA SMALL(1) / Z'00800000' / *//*     DATA LARGE(1) / Z'7F7FFFFF' / *//*     DATA RIGHT(1) / Z'33800000' / *//*     DATA DIVER(1) / Z'34000000' / *//*     DATA LOG10(1) / Z'3E9A209B' / *//*     MACHINE CONSTANTS FOR THE AMIGA *//*     ABSOFT FORTRAN COMPILER USING SOFTWARE FLOATING POINT *//*     DATA SMALL(1) / Z'00800000' / *//*     DATA LARGE(1) / Z'7EFFFFFF' / *//*     DATA RIGHT(1) / Z'33800000' / *//*     DATA DIVER(1) / Z'34000000' / *//*     DATA LOG10(1) / Z'3E9A209B' / *//*     MACHINE CONSTANTS FOR THE APOLLO *//*     DATA SMALL(1) / 16#00800000 / *//*     DATA LARGE(1) / 16#7FFFFFFF / *//*     DATA RIGHT(1) / 16#33800000 / *//*     DATA DIVER(1) / 16#34000000 / *//*     DATA LOG10(1) / 16#3E9A209B / *//*     MACHINE CONSTANTS FOR THE BURROUGHS 1700 SYSTEM *//*     DATA RMACH(1) / Z400800000 / *//*     DATA RMACH(2) / Z5FFFFFFFF / *//*     DATA RMACH(3) / Z4E9800000 / *//*     DATA RMACH(4) / Z4EA800000 / *//*     DATA RMACH(5) / Z500E730E8 / *//*     MACHINE CONSTANTS FOR THE BURROUGHS 5700/6700/7700 SYSTEMS *//*     DATA RMACH(1) / O1771000000000000 / *//*     DATA RMACH(2) / O0777777777777777 / *//*     DATA RMACH(3) / O1311000000000000 / *//*     DATA RMACH(4) / O1301000000000000 / *//*     DATA RMACH(5) / O1157163034761675 / *//*     MACHINE CONSTANTS FOR THE CDC 170/180 SERIES USING NOS/VE *//*     DATA RMACH(1) / Z"3001800000000000" / *//*     DATA RMACH(2) / Z"4FFEFFFFFFFFFFFE" / *//*     DATA RMACH(3) / Z"3FD2800000000000" / *//*     DATA RMACH(4) / Z"3FD3800000000000" / *//*     DATA RMACH(5) / Z"3FFF9A209A84FBCF" / *//*     MACHINE CONSTANTS FOR THE CDC 6000/7000 SERIES *//*     DATA RMACH(1) / 00564000000000000000B / *//*     DATA RMACH(2) / 37767777777777777776B / *//*     DATA RMACH(3) / 16414000000000000000B / *//*     DATA RMACH(4) / 16424000000000000000B / *//*     DATA RMACH(5) / 17164642023241175720B / *//*     MACHINE CONSTANTS FOR THE CELERITY C1260 *//*     DATA SMALL(1) / Z'00800000' / *//*     DATA LARGE(1) / Z'7F7FFFFF' / *//*     DATA RIGHT(1) / Z'33800000' / *//*     DATA DIVER(1) / Z'34000000' / *//*     DATA LOG10(1) / Z'3E9A209B' / *//*     MACHINE CONSTANTS FOR THE CONVEX *//*     USING THE -fn COMPILER OPTION *//*     DATA RMACH(1) / Z'00800000' / *//*     DATA RMACH(2) / Z'7FFFFFFF' / *//*     DATA RMACH(3) / Z'34800000' / *//*     DATA RMACH(4) / Z'35000000' / *//*     DATA RMACH(5) / Z'3F9A209B' / *//*     MACHINE CONSTANTS FOR THE CONVEX *//*     USING THE -fi COMPILER OPTION *//*     DATA RMACH(1) / Z'00800000' / *//*     DATA RMACH(2) / Z'7F7FFFFF' / *//*     DATA RMACH(3) / Z'33800000' / *//*     DATA RMACH(4) / Z'34000000' / *//*     DATA RMACH(5) / Z'3E9A209B' / *//*     MACHINE CONSTANTS FOR THE CONVEX *//*     USING THE -p8 OR -pd8 COMPILER OPTION *//*     DATA RMACH(1) / Z'0010000000000000' / *//*     DATA RMACH(2) / Z'7FFFFFFFFFFFFFFF' / *//*     DATA RMACH(3) / Z'3CC0000000000000' / *//*     DATA RMACH(4) / Z'3CD0000000000000' / *//*     DATA RMACH(5) / Z'3FF34413509F79FF' / *//*     MACHINE CONSTANTS FOR THE CRAY *//*     DATA RMACH(1) / 200034000000000000000B / *//*     DATA RMACH(2) / 577767777777777777776B / *//*     DATA RMACH(3) / 377224000000000000000B / *//*     DATA RMACH(4) / 377234000000000000000B / *//*     DATA RMACH(5) / 377774642023241175720B / *//*     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200 *//*     NOTE - IT MAY BE APPROPRIATE TO INCLUDE THE FOLLOWING CARD - *//*     STATIC RMACH(5) *//*     DATA SMALL /    20K,       0 / *//*     DATA LARGE / 77777K, 177777K / *//*     DATA RIGHT / 35420K,       0 / *//*     DATA DIVER / 36020K,       0 / *//*     DATA LOG10 / 40423K,  42023K / *//*     MACHINE CONSTANTS FOR THE DEC RISC *//*     MACHINE CONSTANTS FOR THE ELXSI 6400 *//*     (ASSUMING REAL*4 IS THE DEFAULT REAL) *//*     DATA SMALL(1) / '00800000'X / *//*     DATA LARGE(1) / '7F7FFFFF'X / *//*     DATA RIGHT(1) / '33800000'X / *//*     DATA DIVER(1) / '34000000'X / *//*     DATA LOG10(1) / '3E9A209B'X / *//*     MACHINE CONSTANTS FOR THE HARRIS 220 *//*     DATA SMALL(1), SMALL(2) / '20000000, '00000201 / *//*     DATA LARGE(1), LARGE(2) / '37777777, '00000177 / *//*     DATA RIGHT(1), RIGHT(2) / '20000000, '00000352 / *//*     DATA DIVER(1), DIVER(2) / '20000000, '00000353 / *//*     DATA LOG10(1), LOG10(2) / '23210115, '00000377 / *//*     MACHINE CONSTANTS FOR THE HONEYWELL 600/6000 SERIES *//*     DATA RMACH(1) / O402400000000 / *//*     DATA RMACH(2) / O376777777777 / *//*     DATA RMACH(3) / O714400000000 / *//*     DATA RMACH(4) / O716400000000 / *//*     DATA RMACH(5) / O776464202324 / *//*     MACHINE CONSTANTS FOR THE HP 730 *//*     DATA RMACH(1) / Z'00800000' / *//*     DATA RMACH(2) / Z'7F7FFFFF' / *//*     DATA RMACH(3) / Z'33800000' / *//*     DATA RMACH(4) / Z'34000000' / *//*     DATA RMACH(5) / Z'3E9A209B' / *//*     MACHINE CONSTANTS FOR THE HP 2100 *//*     3 WORD DOUBLE PRECISION WITH FTN4 *//*     DATA SMALL(1), SMALL(2) / 40000B,       1 / *//*     DATA LARGE(1), LARGE(2) / 77777B, 177776B / *//*     DATA RIGHT(1), RIGHT(2) / 40000B,    325B / *//*     DATA DIVER(1), DIVER(2) / 40000B,    327B / *//*     DATA LOG10(1), LOG10(2) / 46420B,  46777B / *//*     MACHINE CONSTANTS FOR THE HP 2100 *//*     4 WORD DOUBLE PRECISION WITH FTN4 *//*     DATA SMALL(1), SMALL(2) / 40000B,       1 / *//*     DATA LARGE(1), LARGE(2) / 77777B, 177776B / *//*     DATA RIGHT(1), RIGHT(2) / 40000B,    325B / *//*     DATA DIVER(1), DIVER(2) / 40000B,    327B / *//*     DATA LOG10(1), LOG10(2) / 46420B,  46777B / *//*     MACHINE CONSTANTS FOR THE HP 9000 *//*     DATA SMALL(1) / 00004000000B / *//*     DATA LARGE(1) / 17677777777B / *//*     DATA RIGHT(1) / 06340000000B / *//*     DATA DIVER(1) / 06400000000B / *//*     DATA LOG10(1) / 07646420233B / *//*     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES, *//*     THE XEROX SIGMA 5/7/9, THE SEL SYSTEMS 85/86  AND *//*     THE PERKIN ELMER (INTERDATA) 7/32. *//*     DATA RMACH(1) / Z00100000 / *//*     DATA RMACH(2) / Z7FFFFFFF / *//*     DATA RMACH(3) / Z3B100000 / *//*     DATA RMACH(4) / Z3C100000 / *//*     DATA RMACH(5) / Z41134413 / *//*     MACHINE CONSTANTS FOR THE IBM PC *//*     DATA SMALL(1) / 1.18E-38      / *//*     DATA LARGE(1) / 3.40E+38      / *//*     DATA RIGHT(1) / 0.595E-07     / *//*     DATA DIVER(1) / 1.19E-07      / *//*     DATA LOG10(1) / 0.30102999566 / *//*     MACHINE CONSTANTS FOR THE IBM RS 6000 *//*     DATA RMACH(1) / Z'00800000' / *//*     DATA RMACH(2) / Z'7F7FFFFF' / *//*     DATA RMACH(3) / Z'33800000' / *//*     DATA RMACH(4) / Z'34000000' / *//*     DATA RMACH(5) / Z'3E9A209B' / *//*     MACHINE CONSTANTS FOR THE INTEL i860 *//*     DATA RMACH(1) / Z'00800000' / *//*     DATA RMACH(2) / Z'7F7FFFFF' / *//*     DATA RMACH(3) / Z'33800000' / *//*     DATA RMACH(4) / Z'34000000' / *//*     DATA RMACH(5) / Z'3E9A209B' / *//*     MACHINE CONSTANTS FOR THE PDP-10 (KA OR KI PROCESSOR) *//*     DATA RMACH(1) / "000400000000 / *//*     DATA RMACH(2) / "377777777777 / *//*     DATA RMACH(3) / "146400000000 / *//*     DATA RMACH(4) / "147400000000 / *//*     DATA RMACH(5) / "177464202324 / *//*     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING *//*     32-BIT INTEGERS (EXPRESSED IN INTEGER AND OCTAL). *//*     DATA SMALL(1) /    8388608 / *//*     DATA LARGE(1) / 2147483647 / *//*     DATA RIGHT(1) /  880803840 / *//*     DATA DIVER(1) /  889192448 / *//*     DATA LOG10(1) / 1067065499 / *//*     DATA RMACH(1) / O00040000000 / *//*     DATA RMACH(2) / O17777777777 / *//*     DATA RMACH(3) / O06440000000 / *//*     DATA RMACH(4) / O06500000000 / *//*     DATA RMACH(5) / O07746420233 / *//*     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING *//*     16-BIT INTEGERS  (EXPRESSED IN INTEGER AND OCTAL). *//*     DATA SMALL(1), SMALL(2) /   128,     0 / *//*     DATA LARGE(1), LARGE(2) / 32767,    -1 / *//*     DATA RIGHT(1), RIGHT(2) / 13440,     0 / *//*     DATA DIVER(1), DIVER(2) / 13568,     0 / *//*     DATA LOG10(1), LOG10(2) / 16282,  8347 / *//*     DATA SMALL(1), SMALL(2) / O000200, O000000 / *//*     DATA LARGE(1), LARGE(2) / O077777, O177777 / *//*     DATA RIGHT(1), RIGHT(2) / O032200, O000000 / *//*     DATA DIVER(1), DIVER(2) / O032400, O000000 / *//*     DATA LOG10(1), LOG10(2) / O037632, O020233 / *//*     MACHINE CONSTANTS FOR THE SUN *//*     DATA RMACH(1) / Z'00800000' / *//*     DATA RMACH(2) / Z'7F7FFFFF' / *//*     DATA RMACH(3) / Z'33800000' / *//*     DATA RMACH(4) / Z'34000000' / *//*     DATA RMACH(5) / Z'3E9A209B' / *//*     MACHINE CONSTANTS FOR THE SUN *//*     USING THE -r8 COMPILER OPTION *//*     DATA RMACH(1) / Z'0010000000000000' / *//*     DATA RMACH(2) / Z'7FEFFFFFFFFFFFFF' / *//*     DATA RMACH(3) / Z'3CA0000000000000' / *//*     DATA RMACH(4) / Z'3CB0000000000000' / *//*     DATA RMACH(5) / Z'3FD34413509F79FF' / *//*     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES *//*     DATA RMACH(1) / O000400000000 / *//*     DATA RMACH(2) / O377777777777 / *//*     DATA RMACH(3) / O146400000000 / *//*     DATA RMACH(4) / O147400000000 / *//*     DATA RMACH(5) / O177464202324 / *//*     MACHINE CONSTANTS FOR THE VAX *//*     (EXPRESSED IN INTEGER AND HEXADECIMAL) *//*     THE HEX FORMAT BELOW MAY NOT BE SUITABLE FOR UNIX SYSTEMS *//*     THE INTEGER FORMAT SHOULD BE OK FOR UNIX SYSTEMS *//*     DATA SMALL(1) /       128 / *//*     DATA LARGE(1) /    -32769 / *//*     DATA RIGHT(1) /     13440 / *//*     DATA DIVER(1) /     13568 / *//*     DATA LOG10(1) / 547045274 / *//*     DATA SMALL(1) / Z00000080 / *//*     DATA LARGE(1) / ZFFFF7FFF / *//*     DATA RIGHT(1) / Z00003480 / *//*     DATA DIVER(1) / Z00003500 / *//*     DATA LOG10(1) / Z209B3F9A / *//*     MACHINE CONSTANTS FOR THE Z80 MICROPROCESSOR *//*     DATA SMALL(1), SMALL(2) /     0,    256/ *//*     DATA LARGE(1), LARGE(2) /    -1,   -129/ *//*     DATA RIGHT(1), RIGHT(2) /     0,  26880/ *//*     DATA DIVER(1), DIVER(2) /     0,  27136/ *//*     DATA LOG10(1), LOG10(2) /  8347,  32538/ *//* ***FIRST EXECUTABLE STATEMENT  R1MACH */    if (*i < 1 || *i > 5) {	xermsg_("SLATEC", "R1MACH", "I OUT OF BOUNDS", &c__1, &c__2, 6L, 6L, 		15L);    }    ret_val = rmach[*i - 1];    return ret_val;} /* r1mach_ */#undef right#undef diver#undef small#undef rmach#undef large#undef log10doublerreal d1mach_(integer *i){    /* Initialized data */    static struct {	integer e_1[10];	doublerreal fill_2[1];	doublerreal e_3;	} equiv_4 = { 0, 1048576, -1, 2146435071, 0, 1017118720, 0, 		1018167296, 1352628735, 1070810131, {0}, 0. };    /* System generated locals */    doublerreal ret_val;    /* Local variables */#define log10 ((integer *)&equiv_4 + 8)#define dmach ((doublerreal *)&equiv_4)#define large ((integer *)&equiv_4 + 2)#define small ((integer *)&equiv_4)#define diver ((integer *)&equiv_4 + 6)#define right ((integer *)&equiv_4 + 4)    extern /* Subroutine */ int xermsg_(char *, char *, char *, integer *, 	    integer *, ftnlen, ftnlen, ftnlen);/*     MACHINE CONSTANTS FOR THE CONVEX *//*     USING THE -fi COMPILER OPTION *//*     DATA DMACH(1) / Z'0010000000000000' / *//*     DATA DMACH(2) / Z'7FEFFFFFFFFFFFFF' / *//*     DATA DMACH(3) / Z'3CA0000000000000' / *//*     DATA DMACH(4) / Z'3CB0000000000000' / *//*     DATA DMACH(5) / Z'3FD34413509F79FF' / *//*     MACHINE CONSTANTS FOR THE CONVEX *//*     USING THE -p8 COMPILER OPTION *//*     DATA DMACH(1) / Z'00010000000000000000000000000000' / *//*     DATA DMACH(2) / Z'7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' / *//*     DATA DMACH(3) / Z'3F900000000000000000000000000000' / *//*     DATA DMACH(4) / Z'3F910000000000000000000000000000' / *//*     DATA DMACH(5) / Z'3FFF34413509F79FEF311F12B35816F9' / *//*     MACHINE CONSTANTS FOR THE CRAY *//*     DATA SMALL(1) / 201354000000000000000B / *//*     DATA SMALL(2) / 000000000000000000000B / *//*     DATA LARGE(1) / 577767777777777777777B / *//*     DATA LARGE(2) / 000007777777777777774B / *//*     DATA RIGHT(1) / 376434000000000000000B / *//*     DATA RIGHT(2) / 000000000000000000000B / *//*     DATA DIVER(1) / 376444000000000000000B / *//*     DATA DIVER(2) / 000000000000000000000B / *//*     DATA LOG10(1) / 377774642023241175717B / *//*     DATA LOG10(2) / 000007571421742254654B / *//*     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200 *//*     NOTE - IT MAY BE APPROPRIATE TO INCLUDE THE FOLLOWING CARD - *//*     STATIC DMACH(5) *//*     DATA SMALL /    20K, 3*0 / *//*     DATA LARGE / 77777K, 3*177777K / *//*     DATA RIGHT / 31420K, 3*0 / *//*     DATA DIVER / 32020K, 3*0 / *//*     DATA LOG10 / 40423K, 42023K, 50237K, 74776K / *//*     MACHINE CONSTANTS FOR THE DEC RISC *//*     DATA LARGE(1), LARGE(2) / "377777777777, "344777777777 / *//*     DATA RIGHT(1), RIGHT(2) / "113400000000, "000000000000 / *//*     DATA DIVER(1), DIVER(2) / "114400000000, "000000000000 / *//*     DATA LOG10(1), LOG10(2) / "177464202324, "144117571776 / *//*     MACHINE CONSTANTS FOR THE PDP-10 (KI PROCESSOR) *//*     DATA SMALL(1), SMALL(2) / "000400000000, "000000000000 / *//*     DATA LARGE(1), LARGE(2) / "377777777777, "377777777777 / *//*     DATA RIGHT(1), RIGHT(2) / "103400000000, "000000000000 / *//*     DATA DIVER(1), DIVER(2) / "104400000000, "000000000000 / *//*     DATA LOG10(1), LOG10(2) / "177464202324, "476747767461 / *//*     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING *//*     32-BIT INTEGERS (EXPRESSED IN INTEGER AND OCTAL). *//*     DATA SMALL(1), SMALL(2) /    8388608,           0 / *//*     DATA LARGE(1), LARGE(2) / 2147483647,          -1 / *//*     DATA RIGHT(1), RIGHT(2) /  612368384,           0 / *//*     DATA DIVER(1), DIVER(2) /  620756992,           0 / *//*     DATA LOG10(1), LOG10(2) / 1067065498, -2063872008 / *//*     DATA SMALL(1), SMALL(2) / O00040000000, O00000000000 / *//*     DATA LARGE(1), LARGE(2) / O17777777777, O37777777777 / *//*     DATA RIGHT(1), RIGHT(2) / O04440000000, O00000000000 / *//*     DATA DIVER(1), DIVER(2) / O04500000000, O00000000000 / *//*     DATA LOG10(1), LOG10(2) / O07746420232, O20476747770 / *//*     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING *//*     16-BIT INTEGERS (EXPRESSED IN INTEGER AND OCTAL). *//*     DATA SMALL(1), SMALL(2) /    128,      0 / *//*     DATA SMALL(3), SMALL(4) /      0,      0 / *//*     DATA LARGE(1), LARGE(2) /  32767,     -1 / *//*     DATA LARGE(3), LARGE(4) /     -1,     -1 / *//*     DATA RIGHT(1), RIGHT(2) /   9344,      0 / *//*     DATA RIGHT(3), RIGHT(4) /      0,      0 / *//*     DATA DIVER(1), DIVER(2) /   9472,      0 / *//*     DATA DIVER(3), DIVER(4) /      0,      0 / *//*     DATA LOG10(1), LOG10(2) /  16282,   8346 / *//*     DATA LOG10(3), LOG10(4) / -31493, -12296 / *//*     DATA SMALL(1), SMALL(2) / O000200, O000000 / *//*     DATA SMALL(3), SMALL(4) / O000000, O000000 / *//*     DATA LARGE(1), LARGE(2) / O077777, O177777 / *//*     DATA LARGE(3), LARGE(4) / O177777, O177777 / *//*     DATA RIGHT(1), RIGHT(2) / O022200, O000000 / *//*     DATA RIGHT(3), RIGHT(4) / O000000, O000000 / *//*     DATA DIVER(1), DIVER(2) / O022400, O000000 / *//*     DATA DIVER(3), DIVER(4) / O000000, O000000 / *//*     DATA LOG10(1), LOG10(2) / O037632, O020232 / *//*     DATA LOG10(3), LOG10(4) / O102373, O147770 / *//*     MACHINE CONSTANTS FOR THE SUN *//*     DATA DMACH(1) / Z'0010000000000000' / *//*     DATA DMACH(2) / Z'7FEFFFFFFFFFFFFF' / *//*     DATA DMACH(3) / Z'3CA0000000000000' / *//*     DATA DMACH(4) / Z'3CB0000000000000' / *//*     DATA DMACH(5) / Z'3FD34413509F79FF' / *//*     MACHINE CONSTANTS FOR THE SUN *//*     USING THE -r8 COMPILER OPTION *//*     DATA DMACH(1) / Z'00010000000000000000000000000000' / *//*     DATA DMACH(2) / Z'7FFEFFFFFFFFFFFFFFFFFFFFFFFFFFFF' / *//*     DATA DMACH(3) / Z'3F8E0000000000000000000000000000' / *//*     DATA DMACH(4) / Z'3F8F0000000000000000000000000000' / *//*     DATA DMACH(5) / Z'3FFD34413509F79FEF311F12B35816F9' / *//*     MACHINE CONSTANTS FOR THE SUN 386i *//*     DATA SMALL(1), SMALL(2) / Z'FFFFFFFD', Z'000FFFFF' / *//*     DATA LARGE(1), LARGE(2) / Z'FFFFFFB0', Z'7FEFFFFF' / *//*     DATA RIGHT(1), RIGHT(2) / Z'000000B0', Z'3CA00000' / *//*     DATA DIVER(1), DIVER(2) / Z'FFFFFFCB', Z'3CAFFFFF' *//*     DATA LOG10(1), LOG10(2) / Z'509F79E9', Z'3FD34413' / *//*     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES FTN COMPILER *//*     DATA SMALL(1), SMALL(2) / O000040000000, O000000000000 / *//*     DATA LARGE(1), LARGE(2) / O377777777777, O777777777777 / *//*     DATA RIGHT(1), RIGHT(2) / O170540000000, O000000000000 / *//*     DATA DIVER(1), DIVER(2) / O170640000000, O000000000000 / *//*     DATA LOG10(1), LOG10(2) / O177746420232, O411757177572 / *//*     MACHINE CONSTANTS FOR THE VAX (D-FLOATING) *//*     (EXPRESSED IN INTEGER AND HEXADECIMAL) *//*     THE HEX FORMAT BELOW MAY NOT BE SUITABLE FOR UNIX SYSYEMS *//*     THE INTEGER FORMAT SHOULD BE OK FOR UNIX SYSTEMS *//*     DATA SMALL(1), SMALL(2) /        128,           0 / *//*     DATA LARGE(1), LARGE(2) /     -32769,          -1 / *//*     DATA RIGHT(1), RIGHT(2) /       9344,           0 / *//*     DATA DIVER(1), DIVER(2) /       9472,           0 / *//*     DATA LOG10(1), LOG10(2) /  546979738,  -805796613 / *//*     DATA SMALL(1), SMALL(2) / Z00000080, Z00000000 / *//*     DATA LARGE(1), LARGE(2) / ZFFFF7FFF, ZFFFFFFFF / *//*     DATA RIGHT(1), RIGHT(2) / Z00002480, Z00000000 / *//*     DATA DIVER(1), DIVER(2) / Z00002500, Z00000000 / *//*     DATA LOG10(1), LOG10(2) / Z209A3F9A, ZCFF884FB / *//*     MACHINE CONSTANTS FOR THE VAX (G-FLOATING) *//*     (EXPRESSED IN INTEGER AND HEXADECIMAL) *//*     THE HEX FORMAT BELOW MAY NOT BE SUITABLE FOR UNIX SYSYEMS *//*     THE INTEGER FORMAT SHOULD BE OK FOR UNIX SYSTEMS *//*     DATA SMALL(1), SMALL(2) /         16,           0 / *//*     DATA LARGE(1), LARGE(2) /     -32769,          -1 / *//*     DATA RIGHT(1), RIGHT(2) /      15552,           0 / *//*     DATA DIVER(1), DIVER(2) /      15568,           0 / *//*     DATA LOG10(1), LOG10(2) /  1142112243, 2046775455 / *//*     DATA SMALL(1), SMALL(2) / Z00000010, Z00000000 / *//*     DATA LARGE(1), LARGE(2) / ZFFFF7FFF, ZFFFFFFFF / *//*     DATA RIGHT(1), RIGHT(2) / Z00003CC0, Z00000000 / *//*     DATA DIVER(1), DIVER(2) / Z00003CD0, Z00000000 / *//*     DATA LOG10(1), LOG10(2) / Z44133FF3, Z79FF509F / *//* ***FIRST EXECUTABLE STATEMENT  D1MACH */    if (*i < 1 || *i > 5) {	xermsg_("SLATEC", "D1MACH", "I OUT OF BOUNDS", &c__1, &c__2, 6L, 6L, 		15L);    }    ret_val = dmach[*i - 1];    return ret_val;} /* d1mach_ */#undef right#undef diver#undef small#undef large#undef dmach#undef log10integer i1mach_(integer *i){    /* Initialized data */    static struct {	integer e_1[16];	} equiv_0 = { 5, 6, 6, 6, 32, 4, 2, 31, 2147483647, 2, 24, -125, 128, 		53, -1021, 1024 };    /* Format strings */    static char fmt_9000[] = "(\0021ERROR    1 IN I1MACH - I OUT OF BOUND"	    "S\002)";    /* System generated locals */    integer ret_val = 0;    /* Builtin functions */    integer s_wsfe(cilist *), e_wsfe(void);    /* Subroutine */ int s_stop(char *, ftnlen);    /* Local variables */#define imach ((integer *)&equiv_0)#define output ((integer *)&equiv_0 + 3)    /* Fortran I/O blocks */    static cilist io___15 = { 0, 0, 0, fmt_9000, 0 };/*     DATA IMACH( 9) / 00007777777777777777B / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         47 / *//*     DATA IMACH(12) /       -929 / *//*     DATA IMACH(13) /       1070 / *//*     DATA IMACH(14) /         94 / *//*     DATA IMACH(15) /       -929 / *//*     DATA IMACH(16) /       1069 / *//*     MACHINE CONSTANTS FOR THE CELERITY C1260 *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          6 / *//*     DATA IMACH( 4) /          0 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         31 / *//*     DATA IMACH( 9) / Z'7FFFFFFF' / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         24 / *//*     DATA IMACH(12) /       -126 / *//*     DATA IMACH(13) /        127 / *//*     DATA IMACH(14) /         53 / *//*     DATA IMACH(15) /      -1022 / *//*     DATA IMACH(16) /       1023 / *//*     MACHINE CONSTANTS FOR THE CONVEX *//*     USING THE -fn COMPILER OPTION *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          7 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         31 / *//*     DATA IMACH( 9) / 2147483647 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         24 / *//*     DATA IMACH(12) /       -127 / *//*     DATA IMACH(13) /        127 / *//*     DATA IMACH(14) /         53 / *//*     DATA IMACH(15) /      -1023 / *//*     DATA IMACH(16) /       1023 / *//*     MACHINE CONSTANTS FOR THE CONVEX *//*     USING THE -fi COMPILER OPTION *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          7 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         31 / *//*     DATA IMACH( 9) / 2147483647 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         24 / *//*     DATA IMACH(12) /       -125 / *//*     DATA IMACH(13) /        128 / *//*     DATA IMACH(14) /         53 / *//*     DATA IMACH(15) /      -1021 / *//*     DATA IMACH(16) /       1024 / *//*     MACHINE CONSTANTS FOR THE CONVEX *//*     USING THE -p8 COMPILER OPTION *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          7 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         63 / *//*     DATA IMACH( 9) / 9223372036854775807 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         53 / *//*     DATA IMACH(12) /      -1023 / *//*     DATA IMACH(13) /       1023 / *//*     DATA IMACH(14) /        113 / *//*     DATA IMACH(15) /     -16383 / *//*     DATA IMACH(16) /      16383 / *//*     MACHINE CONSTANTS FOR THE CONVEX *//*     USING THE -pd8 COMPILER OPTION *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          7 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         63 / *//*     DATA IMACH( 9) / 9223372036854775807 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         53 / *//*     DATA IMACH(12) /      -1023 / *//*     DATA IMACH(13) /       1023 / *//*     DATA IMACH(14) /         53 / *//*     DATA IMACH(15) /      -1023 / *//*     DATA IMACH(16) /       1023 / *//*     MACHINE CONSTANTS FOR THE CRAY *//*     USING THE 46 BIT INTEGER COMPILER OPTION *//*     DATA IMACH( 1) /        100 / *//*     DATA IMACH( 2) /        101 / *//*     DATA IMACH( 3) /        102 / *//*     DATA IMACH( 4) /        101 / *//*     DATA IMACH( 5) /         64 / *//*     DATA IMACH( 6) /          8 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         46 / *//*     DATA IMACH( 9) / 1777777777777777B / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         47 / *//*     DATA IMACH(12) /      -8189 / *//*     DATA IMACH(13) /       8190 / *//*     DATA IMACH(14) /         94 / *//*     DATA IMACH(15) /      -8099 / *//*     DATA IMACH(16) /       8190 / *//*     MACHINE CONSTANTS FOR THE CRAY *//*     USING THE 64 BIT INTEGER COMPILER OPTION *//*     DATA IMACH( 1) /        100 / *//*     DATA IMACH( 2) /        101 / *//*     DATA IMACH( 3) /        102 / *//*     DATA IMACH( 4) /        101 / *//*     DATA IMACH( 5) /         64 / *//*     DATA IMACH( 6) /          8 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         63 / *//*     DATA IMACH( 9) / 777777777777777777777B / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         47 / *//*     DATA IMACH(12) /      -8189 / *//*     DATA IMACH(13) /       8190 / *//*     DATA IMACH(14) /         94 / *//*     DATA IMACH(15) /      -8099 / *//*     DATA IMACH(16) /       8190 / *//*     MACHINE CONSTANTS FOR THE DATA GENERAL ECLIPSE S/200 *//*     DATA IMACH( 1) /         11 / *//*     DATA IMACH( 2) /         12 / *//*     DATA IMACH( 3) /          8 / *//*     DATA IMACH( 4) /         10 / *//*     DATA IMACH( 5) /         16 / *//*     DATA IMACH( 6) /          2 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         15 / *//*     DATA IMACH( 9) /      32767 / *//*     DATA IMACH(10) /         16 / *//*     DATA IMACH(11) /          6 / *//*     DATA IMACH(12) /        -64 / *//*     DATA IMACH(13) /         63 / *//*     DATA IMACH(14) /         14 / *//*     DATA IMACH(15) /        -64 / *//*     DATA IMACH(16) /         63 / *//*     MACHINE CONSTANTS FOR THE DEC RISC *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         24 / *//*     DATA IMACH(12) /       -126 / *//*     DATA IMACH(13) /        127 / *//*     DATA IMACH(14) /         53 / *//*     DATA IMACH(15) /      -1015 / *//*     DATA IMACH(16) /       1017 / *//*     MACHINE CONSTANTS FOR THE IBM 360/370 SERIES, *//*     THE XEROX SIGMA 5/7/9, THE SEL SYSTEMS 85/86, AND *//*     THE PERKIN ELMER (INTERDATA) 7/32. *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          7 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         31 / *//*     DATA IMACH( 9) /  Z7FFFFFFF / *//*     DATA IMACH(10) /         16 / *//*     DATA IMACH(11) /          6 / *//*     DATA IMACH(12) /        -64 / *//*     DATA IMACH(13) /         63 / *//*     DATA IMACH(14) /         14 / *//*     DATA IMACH(15) /        -64 / *//*     DATA IMACH(16) /         63 / *//*     MACHINE CONSTANTS FOR THE IBM PC *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          0 / *//*     DATA IMACH( 4) /          0 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         31 / *//*     DATA IMACH( 9) / 2147483647 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         24 / *//*     DATA IMACH(12) /       -125 / *//*     DATA IMACH(13) /        127 / *//*     DATA IMACH(14) /         53 / *//*     DATA IMACH(15) /      -1021 / *//*     DATA IMACH(16) /       1023 / *//*     MACHINE CONSTANTS FOR THE IBM RS 6000 *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          6 / *//*     DATA IMACH( 4) /          0 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         31 / *//*     DATA IMACH( 9) / 2147483647 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         24 / *//*     DATA IMACH(12) /       -125 / *//*     DATA IMACH(13) /        128 / *//*     DATA IMACH(14) /         53 / *//*     DATA IMACH(15) /      -1021 / *//*     DATA IMACH(16) /       1024 / *//*     MACHINE CONSTANTS FOR THE INTEL i860 *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          6 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         31 / *//*     DATA IMACH( 9) / 2147483647 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         24 / *//*     DATA IMACH(12) /       -125 / *//*     DATA IMACH(13) /        128 / *//*     DATA IMACH(14) /         53 / *//*     DATA IMACH(15) /      -1021 / *//*     DATA IMACH(16) /       1024 / *//*     MACHINE CONSTANTS FOR THE PDP-10 (KA PROCESSOR) *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          5 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         36 / *//*     DATA IMACH( 6) /          5 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         35 / *//*     DATA IMACH( 9) / "377777777777 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         27 / *//*     DATA IMACH(12) /       -128 / *//*     DATA IMACH(13) /        127 / *//*     DATA IMACH(14) /         54 / *//*     DATA IMACH(15) /       -101 / *//*     DATA IMACH(16) /        127 / *//*     MACHINE CONSTANTS FOR THE PDP-10 (KI PROCESSOR) *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          5 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         36 / *//*     DATA IMACH( 6) /          5 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         35 / *//*     DATA IMACH( 9) / "377777777777 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         27 / *//*     DATA IMACH(12) /       -128 / *//*     DATA IMACH(13) /        127 / *//*     DATA IMACH(14) /         62 / *//*     DATA IMACH(15) /       -128 / *//*     DATA IMACH(16) /        127 / *//*     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          5 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         31 / *//*     DATA IMACH( 9) / 2147483647 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         24 / *//*     DATA IMACH(12) /       -127 / *//*     DATA IMACH(13) /        127 / *//*     DATA IMACH(14) /         56 / *//*     DATA IMACH(15) /       -127 / *//*     DATA IMACH(16) /        127 / *//*     MACHINE CONSTANTS FOR PDP-11 FORTRAN SUPPORTING *//*     16-BIT INTEGER ARITHMETIC. *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          5 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         16 / *//*     DATA IMACH( 6) /          2 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         15 / *//*     DATA IMACH( 9) /      32767 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         24 / *//*     DATA IMACH(12) /       -127 / *//*     DATA IMACH(13) /        127 / *//*     DATA IMACH(14) /         56 / *//*     DATA IMACH(15) /       -127 / *//*     DATA IMACH(16) /        127 / *//*     MACHINE CONSTANTS FOR THE SUN *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          6 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         31 / *//*     DATA IMACH( 9) / 2147483647 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         24 / *//*     DATA IMACH(12) /       -125 / *//*     DATA IMACH(13) /        128 / *//*     DATA IMACH(14) /         53 / *//*     DATA IMACH(15) /      -1021 / *//*     DATA IMACH(16) /       1024 / *//*     MACHINE CONSTANTS FOR THE SUN *//*     USING THE -r8 COMPILER OPTION *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          6 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         31 / *//*     DATA IMACH( 9) / 2147483647 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         53 / *//*     DATA IMACH(12) /      -1021 / *//*     DATA IMACH(13) /       1024 / *//*     DATA IMACH(14) /        113 / *//*     DATA IMACH(15) /     -16381 / *//*     DATA IMACH(16) /      16384 / *//*     MACHINE CONSTANTS FOR THE UNIVAC 1100 SERIES FTN COMPILER *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          1 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         36 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         35 / *//*     DATA IMACH( 9) / O377777777777 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         27 / *//*     DATA IMACH(12) /       -128 / *//*     DATA IMACH(13) /        127 / *//*     DATA IMACH(14) /         60 / *//*     DATA IMACH(15) /      -1024 / *//*     DATA IMACH(16) /       1023 / *//*     MACHINE CONSTANTS FOR THE VAX (D-FLOATING) *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          5 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         31 / *//*     DATA IMACH( 9) / 2147483647 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         24 / *//*     DATA IMACH(12) /       -127 / *//*     DATA IMACH(13) /        127 / *//*     DATA IMACH(14) /         56 / *//*     DATA IMACH(15) /       -127 / *//*     DATA IMACH(16) /        127 / *//*     MACHINE CONSTANTS FOR THE VAX (G-FLOATING) *//*     DATA IMACH( 1) /          5 / *//*     DATA IMACH( 2) /          6 / *//*     DATA IMACH( 3) /          5 / *//*     DATA IMACH( 4) /          6 / *//*     DATA IMACH( 5) /         32 / *//*     DATA IMACH( 6) /          4 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         31 / *//*     DATA IMACH( 9) / 2147483647 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         24 / *//*     DATA IMACH(12) /       -127 / *//*     DATA IMACH(13) /        127 / *//*     DATA IMACH(14) /         53 / *//*     DATA IMACH(15) /      -1023 / *//*     DATA IMACH(16) /       1023 / *//*     MACHINE CONSTANTS FOR THE Z80 MICROPROCESSOR *//*     DATA IMACH( 1) /          1 / *//*     DATA IMACH( 2) /          1 / *//*     DATA IMACH( 3) /          0 / *//*     DATA IMACH( 4) /          1 / *//*     DATA IMACH( 5) /         16 / *//*     DATA IMACH( 6) /          2 / *//*     DATA IMACH( 7) /          2 / *//*     DATA IMACH( 8) /         15 / *//*     DATA IMACH( 9) /      32767 / *//*     DATA IMACH(10) /          2 / *//*     DATA IMACH(11) /         24 / *//*     DATA IMACH(12) /       -127 / *//*     DATA IMACH(13) /        127 / *//*     DATA IMACH(14) /         56 / *//*     DATA IMACH(15) /       -127 / *//*     DATA IMACH(16) /        127 / *//* ***FIRST EXECUTABLE STATEMENT  I1MACH */    if (*i < 1 || *i > 16) {	goto L10;    }    ret_val = imach[*i - 1];    return ret_val;L10:    io___15.ciunit = *output;    s_wsfe(&io___15);    e_wsfe();/*     CALL FDUMP */    s_stop("", 0L);    return ret_val;} /* i1mach_ */#undef output#undef imach/* Subroutine */ int fdump_(void){/* ***FIRST EXECUTABLE STATEMENT  FDUMP */    return 0;} /* fdump_ *//* Subroutine */ int xerhlt_(char *messg, ftnlen messg_len){    /* Builtin functions */    /* Subroutine */ int s_stop(char *, ftnlen);	*messg = *messg;	messg_len = messg_len;/* ***FIRST EXECUTABLE STATEMENT  XERHLT */    s_stop("PROGRAM STOP THROUGH CALL TO XERHLT", 35L);    return 0;} /* xerhlt_ *//* *** END OF FILES REQUIRING USER EDIT *** */integer j4save_(integer *iwhich, integer *ivalue, logical *iset){    /* Initialized data */    static integer iparam[9] = { 0,2,0,10,1,0,0,0,0 };    /* System generated locals */    integer ret_val;/* ***FIRST EXECUTABLE STATEMENT  J4SAVE */    ret_val = iparam[*iwhich - 1];    if (*iset) {	iparam[*iwhich - 1] = *ivalue;    }    return ret_val;} /* j4save_ *//* Subroutine */ int xgetua_(integer *iunita, integer *n){    /* System generated locals */    integer i__1;    /* Local variables */    integer i, index;    extern integer j4save_(integer *, integer *, logical *);/* ***FIRST EXECUTABLE STATEMENT  XGETUA */    /* Parameter adjustments */    //--iunita;    /* Function Body */    *n = j4save_(&c__5, &c__0, &c_false);    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	index = i + 4;	if (i == 1) {	    index = 3;	}	iunita[i] = j4save_(&index, &c__0, &c_false);/* L30: */    }    return 0;} /* xgetua_ *//* Subroutine */ int xersve_(char *librar, char *subrou, char *messg, integer 	*kflag, integer *nerr, integer *level, integer *icount, ftnlen 	librar_len, ftnlen subrou_len, ftnlen messg_len){    /* Initialized data */    static integer kountx = 0;    static integer nmsg = 0;    /* Format strings */    static char fmt_9000[] = "(\0020          ERROR MESSAGE SUMMARY\002/\002"	    " LIBRARY    SUBROUTINE MESSAGE START             NERR\002,\002  "	    "   LEVEL     COUNT\002)";    static char fmt_9010[] = "(1x,a,3x,a,3x,a,3i10)";    static char fmt_9020[] = "(\0020OTHER ERRORS NOT INDIVIDUALLY TABULATED "	    "= \002,i10)";    static char fmt_9030[] = "(1x)";    /* System generated locals */    integer i__1, i__2;    /* Builtin functions */    integer s_wsfe(cilist *), e_wsfe(void), do_fio(integer *, char *, ftnlen);    void s_copy(char *, char *, ftnlen, ftnlen);    integer s_cmp(char *, char *, ftnlen, ftnlen);    /* Local variables */    integer i, iunit, kunit, nunit;    static integer kount[10];    extern integer i1mach_(integer *);    static char libtab[8*10], mestab[20*10];    static integer nertab[10], levtab[10];    static char subtab[8*10];    extern /* Subroutine */ int xgetua_(integer *, integer *);    char lib[8], mes[20], sub[8];    integer lun[5];    /* Fortran I/O blocks */    static cilist io___25 = { 0, 0, 0, fmt_9000, 0 };    static cilist io___27 = { 0, 0, 0, fmt_9010, 0 };    static cilist io___34 = { 0, 0, 0, fmt_9020, 0 };    static cilist io___35 = { 0, 0, 0, fmt_9030, 0 };/* ***FIRST EXECUTABLE STATEMENT  XERSVE */    if (*kflag <= 0) {/*        Dump the table. */	if (nmsg == 0) {	    return 0;	}/*        Print to each unit. */	xgetua_(lun, &nunit);	i__1 = nunit;	for (kunit = 1; kunit <= i__1; ++kunit) {	    iunit = lun[kunit - 1];	    if (iunit == 0) {		iunit = i1mach_(&c__4);	    }/*           Print the table header. */	    io___25.ciunit = iunit;	    s_wsfe(&io___25);	    e_wsfe();/*           Print body of table. */	    i__2 = nmsg;	    for (i = 1; i <= i__2; ++i) {		io___27.ciunit = iunit;		s_wsfe(&io___27);		do_fio(&c__1, libtab + (i - 1 << 3), 8L);		do_fio(&c__1, subtab + (i - 1 << 3), 8L);		do_fio(&c__1, mestab + (i - 1) * 20, 20L);		do_fio(&c__1, (char *)&nertab[i - 1], (ftnlen)sizeof(integer))			;		do_fio(&c__1, (char *)&levtab[i - 1], (ftnlen)sizeof(integer))			;		do_fio(&c__1, (char *)&kount[i - 1], (ftnlen)sizeof(integer));		e_wsfe();/* L10: */	    }/*           Print number of other errors. */	    if (kountx != 0) {		io___34.ciunit = iunit;		s_wsfe(&io___34);		do_fio(&c__1, (char *)&kountx, (ftnlen)sizeof(integer));		e_wsfe();	    }	    io___35.ciunit = iunit;	    s_wsfe(&io___35);	    e_wsfe();/* L20: */	}/*        Clear the error tables. */	if (*kflag == 0) {	    nmsg = 0;	    kountx = 0;	}    } else {/*        PROCESS A MESSAGE... *//*        SEARCH FOR THIS MESSG, OR ELSE AN EMPTY SLOT FOR THIS MESSG, *//*        OR ELSE DETERMINE THAT THE ERROR TABLE IS FULL. */	s_copy(lib, librar, 8L, librar_len);	s_copy(sub, subrou, 8L, subrou_len);	s_copy(mes, messg, 20L, messg_len);	i__1 = nmsg;	for (i = 1; i <= i__1; ++i) {	    if (s_cmp(lib, libtab + (i - 1 << 3), 8L, 8L) == 0 && s_cmp(sub, 		    subtab + (i - 1 << 3), 8L, 8L) == 0 && s_cmp(mes, mestab 		    + (i - 1) * 20, 20L, 20L) == 0 && *nerr == nertab[i - 1] 		    && *level == levtab[i - 1]) {		++kount[i - 1];		*icount = kount[i - 1];		return 0;	    }/* L30: */	}	if (nmsg < 10) {/*           Empty slot found for new message. */	    ++nmsg;	    s_copy(libtab + (i - 1 << 3), lib, 8L, 8L);	    s_copy(subtab + (i - 1 << 3), sub, 8L, 8L);	    s_copy(mestab + (i - 1) * 20, mes, 20L, 20L);	    nertab[i - 1] = *nerr;	    levtab[i - 1] = *level;	    kount[i - 1] = 1;	    *icount = 1;	} else {/*           Table is full. */	    ++kountx;	    *icount = 0;	}    }    return 0;/*     Formats. */} /* xersve_ *//* Subroutine */ int xercnt_(char *librar, char *subrou, char *messg, integer 	*nerr, integer *level, integer *kontrl, ftnlen librar_len, ftnlen 	subrou_len, ftnlen messg_len){	*librar = *librar;//warning	*subrou = *subrou;//warning	*messg = *messg;//warning	*nerr = *nerr;//warning	*level = *level;//warning	*kontrl = *kontrl;//warning/* ***FIRST EXECUTABLE STATEMENT  XERCNT */    return 0;} /* xercnt_ *//* Subroutine */ int xerprn_(char *prefix, integer *npref, char *messg, 	integer *nwrap, ftnlen prefix_len, ftnlen messg_len){    /* System generated locals */    integer i__1, i__2;    cilist ci__1;    /* Builtin functions */    integer i_len(char *, ftnlen);    void s_copy(char *, char *, ftnlen, ftnlen);    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void),	     i_indx(char *, char *, ftnlen, ftnlen), s_cmp(char *, char *, 	    ftnlen, ftnlen);    /* Local variables */    integer i, n;    char cbuff[148];    integer lpref, nextc, lwrap, nunit;    extern integer i1mach_(integer *);    integer iu[5], lpiece, idelta, lenmsg;    extern /* Subroutine */ int xgetua_(integer *, integer *);/* ***FIRST EXECUTABLE STATEMENT  XERPRN */    xgetua_(iu, &nunit);/*       A ZERO VALUE FOR A LOGICAL UNIT NUMBER MEANS TO USE THE STANDARD *//*       ERROR MESSAGE UNIT INSTEAD.  I1MACH(4) RETRIEVES THE STANDARD *//*       ERROR MESSAGE UNIT. */    n = i1mach_(&c__4);    i__1 = nunit;    for (i = 1; i <= i__1; ++i) {	if (iu[i - 1] == 0) {	    iu[i - 1] = n;	}/* L10: */    }/*       LPREF IS THE LENGTH OF THE PREFIX.  THE PREFIX IS PLACED AT THE *//*       BEGINNING OF CBUFF, THE CHARACTER BUFFER, AND KEPT THERE DURING *//*       THE REST OF THIS ROUTINE. */    if (*npref < 0) {	lpref = i_len(prefix, prefix_len);    } else {	lpref = *npref;    }    lpref = min(16,lpref);    if (lpref != 0) {	s_copy(cbuff, prefix, lpref, prefix_len);    }/*       LWRAP IS THE MAXIMUM NUMBER OF CHARACTERS WE WANT TO TAKE AT ONE *//*       TIME FROM MESSG TO PRINT ON ONE LINE. *//* Computing MAX */    i__1 = 16, i__2 = min(132,*nwrap);    lwrap = max(i__1,i__2);/*       SET LENMSG TO THE LENGTH OF MESSG, IGNORE ANY TRAILING BLANKS. */    lenmsg = i_len(messg, messg_len);    n = lenmsg;    i__1 = n;    for (i = 1; i <= i__1; ++i) {	if (*(unsigned char *)&messg[lenmsg - 1] != ' ') {	    goto L30;	}	--lenmsg;/* L20: */    }L30:/*       IF THE MESSAGE IS ALL BLANKS, THEN PRINT ONE BLANK LINE. */    if (lenmsg == 0) {	i__1 = lpref;	s_copy(cbuff + i__1, " ", lpref + 1 - i__1, 1L);	i__1 = nunit;	for (i = 1; i <= i__1; ++i) {	    ci__1.cierr = 0;	    ci__1.ciunit = iu[i - 1];	    ci__1.cifmt = "(A)";	    s_wsfe(&ci__1);	    do_fio(&c__1, cbuff, lpref + 1);	    e_wsfe();/* L40: */	}	return 0;    }/*       SET NEXTC TO THE POSITION IN MESSG WHERE THE NEXT SUBSTRING *//*       STARTS.  FROM THIS POSITION WE SCAN FOR THE NEW LINE SENTINEL. *//*       WHEN NEXTC EXCEEDS LENMSG, THERE IS NO MORE TO PRINT. *//*       WE LOOP BACK TO LABEL 50 UNTIL ALL PIECES HAVE BEEN PRINTED. *//*       WE LOOK FOR THE NEXT OCCURRENCE OF THE NEW LINE SENTINEL.  THE *//*       INDEX INTRINSIC FUNCTION RETURNS ZERO IF THERE IS NO OCCURRENCE *//*       OR IF THE LENGTH OF THE FIRST ARGUMENT IS LESS THAN THE LENGTH *//*       OF THE SECOND ARGUMENT. *//*       THERE ARE SEVERAL CASES WHICH SHOULD BE CHECKED FOR IN THE *//*       FOLLOWING ORDER.  WE ARE ATTEMPTING TO SET LPIECE TO THE NUMBER *//*       OF CHARACTERS THAT SHOULD BE TAKEN FROM MESSG STARTING AT *//*       POSITION NEXTC. *//*       LPIECE .EQ. 0   THE NEW LINE SENTINEL DOES NOT OCCUR IN THE *//*                       REMAINDER OF THE CHARACTER STRING.  LPIECE *//*                       SHOULD BE SET TO LWRAP OR LENMSG+1-NEXTC, *//*                       WHICHEVER IS LESS. *//*       LPIECE .EQ. 1   THE NEW LINE SENTINEL STARTS AT MESSG(NEXTC: *//*                       NEXTC).  LPIECE IS EFFECTIVELY ZERO, AND WE *//*                       PRINT NOTHING TO AVOID PRODUCING UNNECESSARY *//*                       BLANK LINES.  THIS TAKES CARE OF THE SITUATION *//*                       WHERE THE LIBRARY ROUTINE HAS A MESSAGE OF *//*                       EXACTLY 72 CHARACTERS FOLLOWED BY A NEW LINE *//*                       SENTINEL FOLLOWED BY MORE CHARACTERS.  NEXTC *//*                       SHOULD BE INCREMENTED BY 2. *//*       LPIECE .GT. LWRAP+1  REDUCE LPIECE TO LWRAP. *//*       ELSE            THIS LAST CASE MEANS 2 .LE. LPIECE .LE. LWRAP+1 *//*                       RESET LPIECE = LPIECE-1.  NOTE THAT THIS *//*                       PROPERLY HANDLES THE END CASE WHERE LPIECE .EQ. *//*                       LWRAP+1.  THAT IS, THE SENTINEL FALLS EXACTLY *//*                       AT THE END OF A LINE. */    nextc = 1;L50:    lpiece = i_indx(messg + (nextc - 1), "$$", lenmsg - (nextc - 1), 2L);    if (lpiece == 0) {/*       THERE WAS NO NEW LINE SENTINEL FOUND. */	idelta = 0;/* Computing MIN */	i__1 = lwrap, i__2 = lenmsg + 1 - nextc;	lpiece = min(i__1,i__2);	if (lpiece < lenmsg + 1 - nextc) {	    for (i = lpiece + 1; i >= 2; --i) {		i__1 = nextc + i - 2;		if (s_cmp(messg + i__1, " ", nextc + i - 1 - i__1, 1L) == 0) {		    lpiece = i - 1;		    idelta = 1;		    goto L54;		}/* L52: */	    }	}L54:	i__1 = lpref;	s_copy(cbuff + i__1, messg + (nextc - 1), lpref + lpiece - i__1, 		nextc + lpiece - 1 - (nextc - 1));	nextc = nextc + lpiece + idelta;    } else if (lpiece == 1) {/*       WE HAVE A NEW LINE SENTINEL AT MESSG(NEXTC:NEXTC+1). *//*       DON'T PRINT A BLANK LINE. */	nextc += 2;	goto L50;    } else if (lpiece > lwrap + 1) {/*       LPIECE SHOULD BE SET DOWN TO LWRAP. */	idelta = 0;	lpiece = lwrap;	for (i = lpiece + 1; i >= 2; --i) {	    i__1 = nextc + i - 2;	    if (s_cmp(messg + i__1, " ", nextc + i - 1 - i__1, 1L) == 0) {		lpiece = i - 1;		idelta = 1;		goto L58;	    }/* L56: */	}L58:	i__1 = lpref;	s_copy(cbuff + i__1, messg + (nextc - 1), lpref + lpiece - i__1, 		nextc + lpiece - 1 - (nextc - 1));	nextc = nextc + lpiece + idelta;    } else {/*       IF WE ARRIVE HERE, IT MEANS 2 .LE. LPIECE .LE. LWRAP+1. *//*       WE SHOULD DECREMENT LPIECE BY ONE. */	--lpiece;	i__1 = lpref;	s_copy(cbuff + i__1, messg + (nextc - 1), lpref + lpiece - i__1, 		nextc + lpiece - 1 - (nextc - 1));	nextc = nextc + lpiece + 2;    }/*       PRINT */    i__1 = nunit;    for (i = 1; i <= i__1; ++i) {	ci__1.cierr = 0;	ci__1.ciunit = iu[i - 1];	ci__1.cifmt = "(A)";	s_wsfe(&ci__1);	do_fio(&c__1, cbuff, lpref + lpiece);	e_wsfe();/* L60: */    }    if (nextc <= lenmsg) {	goto L50;    }    return 0;} /* xerprn_ *//* Subroutine */ int xermsg_(char *librar, char *subrou, char *messg, integer 	*nerr, integer *level, ftnlen librar_len, ftnlen subrou_len, ftnlen 	messg_len){    /* System generated locals */    address a__1[2];    integer i__1, i__2, i__3[2];    char ch__1[87];    icilist ici__1;    /* Builtin functions */    void s_copy(char *, char *, ftnlen, ftnlen);    integer i_len(char *, ftnlen), s_wsfi(icilist *), do_fio(integer *, char *	    , ftnlen), e_wsfi(void);    void s_cat(char *, char **, integer *, integer *, ftnlen);    /* Local variables */    integer lerr;    char temp[72];    integer i;    extern /* Subroutine */ int fdump_(void);    char xlibr[8];    integer ltemp, kount;    char xsubr[8];    extern integer j4save_(integer *, integer *, logical *);    integer llevel, maxmes;    char lfirst[20];    extern /* Subroutine */ int xercnt_(char *, char *, char *, integer *, 	    integer *, integer *, ftnlen, ftnlen, ftnlen);    integer lkntrl, kdummy;    extern /* Subroutine */ int xerhlt_(char *, ftnlen);    integer mkntrl;    extern /* Subroutine */ int xersve_(char *, char *, char *, integer *, 	    integer *, integer *, integer *, ftnlen, ftnlen, ftnlen), xerprn_(	    char *, integer *, char *, integer *, ftnlen, ftnlen);/* ***FIRST EXECUTABLE STATEMENT  XERMSG */    lkntrl = j4save_(&c__2, &c__0, &c_false);    maxmes = j4save_(&c__4, &c__0, &c_false);/*       LKNTRL IS A LOCAL COPY OF THE CONTROL FLAG KONTRL. *//*       MAXMES IS THE MAXIMUM NUMBER OF TIMES ANY PARTICULAR MESSAGE *//*          SHOULD BE PRINTED. *//*       WE PRINT A FATAL ERROR MESSAGE AND TERMINATE FOR AN ERROR IN *//*          CALLING XERMSG.  THE ERROR NUMBER SHOULD BE POSITIVE, *//*          AND THE LEVEL SHOULD BE BETWEEN 0 AND 2. */    if (*nerr < -9999999 || *nerr > 99999999 || *nerr == 0 || *level < -1 || *	    level > 2) {	xerprn_(" ***", &c_n1, "FATAL ERROR IN...$$ XERMSG -- INVALID ERROR "		"NUMBER OR LEVEL$$ JOB ABORT DUE TO FATAL ERROR.", &c__72, 4L, 		91L);	xersve_(" ", " ", " ", &c__0, &c__0, &c__0, &kdummy, 1L, 1L, 1L);	xerhlt_(" ***XERMSG -- INVALID INPUT", 27L);	return 0;    }/*       RECORD THE MESSAGE. */    i = j4save_(&c__1, nerr, &c_true);    xersve_(librar, subrou, messg, &c__1, nerr, level, &kount, librar_len, 	    subrou_len, messg_len);/*       HANDLE PRINT-ONCE WARNING MESSAGES. */    if (*level == -1 && kount > 1) {	return 0;    }/*       ALLOW TEMPORARY USER OVERRIDE OF THE CONTROL FLAG. */    s_copy(xlibr, librar, 8L, librar_len);    s_copy(xsubr, subrou, 8L, subrou_len);    s_copy(lfirst, messg, 20L, messg_len);    lerr = *nerr;    llevel = *level;    xercnt_(xlibr, xsubr, lfirst, &lerr, &llevel, &lkntrl, 8L, 8L, 20L);/* Computing MAX */    i__1 = -2, i__2 = min(2,lkntrl);    lkntrl = max(i__1,i__2);    mkntrl = abs(lkntrl);/*       SKIP PRINTING IF THE CONTROL FLAG VALUE AS RESET IN XERCNT IS *//*       ZERO AND THE ERROR IS NOT FATAL. */    if (*level < 2 && lkntrl == 0) {	goto L30;    }    if (*level == 0 && kount > maxmes) {	goto L30;    }    if (*level == 1 && kount > maxmes && mkntrl == 1) {	goto L30;    }    if (*level == 2 && kount > max(1,maxmes)) {	goto L30;    }/*       ANNOUNCE THE NAMES OF THE LIBRARY AND SUBROUTINE BY BUILDING A *//*       MESSAGE IN CHARACTER VARIABLE TEMP (NOT EXCEEDING 66 CHARACTERS) *//*       AND SENDING IT OUT VIA XERPRN.  PRINT ONLY IF CONTROL FLAG *//*       IS NOT ZERO. */    if (lkntrl != 0) {	s_copy(temp, "MESSAGE FROM ROUTINE ", 21L, 21L);/* Computing MIN */	i__1 = i_len(subrou, subrou_len);	i = min(i__1,16);	s_copy(temp + 21, subrou, i, i);	i__1 = i + 21;	s_copy(temp + i__1, " IN LIBRARY ", i + 33 - i__1, 12L);	ltemp = i + 33;/* Computing MIN */	i__1 = i_len(librar, librar_len);	i = min(i__1,16);	i__1 = ltemp;	s_copy(temp + i__1, librar, ltemp + i - i__1, i);	i__1 = ltemp + i;	s_copy(temp + i__1, ".", ltemp + i + 1 - i__1, 1L);	ltemp = ltemp + i + 1;	xerprn_(" ***", &c_n1, temp, &c__72, 4L, ltemp);    }/*       IF LKNTRL IS POSITIVE, PRINT AN INTRODUCTORY LINE BEFORE *//*       PRINTING THE MESSAGE.  THE INTRODUCTORY LINE TELLS THE CHOICE *//*       FROM EACH OF THE FOLLOWING THREE OPTIONS. *//*       1.  LEVEL OF THE MESSAGE *//*              'INFORMATIVE MESSAGE' *//*              'POTENTIALLY RECOVERABLE ERROR' *//*              'FATAL ERROR' *//*       2.  WHETHER CONTROL FLAG WILL ALLOW PROGRAM TO CONTINUE *//*              'PROG CONTINUES' *//*              'PROG ABORTED' *//*       3.  WHETHER OR NOT A TRACEBACK WAS REQUESTED.  (THE TRACEBACK *//*           MAY NOT BE IMPLEMENTED AT SOME SITES, SO THIS ONLY TELLS *//*           WHAT WAS REQUESTED, NOT WHAT WAS DELIVERED.) *//*              'TRACEBACK REQUESTED' *//*              'TRACEBACK NOT REQUESTED' *//*       NOTICE THAT THE LINE INCLUDING FOUR PREFIX CHARACTERS WILL NOT *//*       EXCEED 74 CHARACTERS. *//*       WE SKIP THE NEXT BLOCK IF THE INTRODUCTORY LINE IS NOT NEEDED. */    if (lkntrl > 0) {/*       THE FIRST PART OF THE MESSAGE TELLS ABOUT THE LEVEL. */	if (*level <= 0) {	    s_copy(temp, "INFORMATIVE MESSAGE,", 20L, 20L);	    ltemp = 20;	} else if (*level == 1) {	    s_copy(temp, "POTENTIALLY RECOVERABLE ERROR,", 30L, 30L);	    ltemp = 30;	} else {	    s_copy(temp, "FATAL ERROR,", 12L, 12L);	    ltemp = 12;	}/*       THEN WHETHER THE PROGRAM WILL CONTINUE. */	if (mkntrl == 2 && *level >= 1 || mkntrl == 1 && *level == 2) {	    i__1 = ltemp;	    s_copy(temp + i__1, " PROG ABORTED,", ltemp + 14 - i__1, 14L);	    ltemp += 14;	} else {	    i__1 = ltemp;	    s_copy(temp + i__1, " PROG CONTINUES,", ltemp + 16 - i__1, 16L);	    ltemp += 16;	}/*       FINALLY TELL WHETHER THERE SHOULD BE A TRACEBACK. */	if (lkntrl > 0) {	    i__1 = ltemp;	    s_copy(temp + i__1, " TRACEBACK REQUESTED", ltemp + 20 - i__1, 		    20L);	    ltemp += 20;	} else {	    i__1 = ltemp;	    s_copy(temp + i__1, " TRACEBACK NOT REQUESTED", ltemp + 24 - i__1,		     24L);	    ltemp += 24;	}	xerprn_(" ***", &c_n1, temp, &c__72, 4L, ltemp);    }/*       NOW SEND OUT THE MESSAGE. */    xerprn_(" *  ", &c_n1, messg, &c__72, 4L, messg_len);/*       IF LKNTRL IS POSITIVE, WRITE THE ERROR NUMBER AND REQUEST A *//*          TRACEBACK. */    if (lkntrl > 0) {	ici__1.icierr = 0;	ici__1.icirnum = 1;	ici__1.icirlen = 72;	ici__1.iciunit = temp;	ici__1.icifmt = "('ERROR NUMBER = ', I8)";	s_wsfi(&ici__1);	do_fio(&c__1, (char *)&(*nerr), (ftnlen)sizeof(integer));	e_wsfi();	for (i = 16; i <= 22; ++i) {	    if (*(unsigned char *)&temp[i - 1] != ' ') {		goto L20;	    }/* L10: */	}L20:/* Writing concatenation */	i__3[0] = 15, a__1[0] = temp;	i__3[1] = 23 - (i - 1), a__1[1] = temp + (i - 1);	s_cat(ch__1, a__1, i__3, &c__2, 87L);	xerprn_(" *  ", &c_n1, ch__1, &c__72, 4L, 23 - (i - 1) + 15);	fdump_();    }/*       IF LKNTRL IS NOT ZERO, PRINT A BLANK LINE AND AN END OF MESSAGE. */    if (lkntrl != 0) {	xerprn_(" *  ", &c_n1, " ", &c__72, 4L, 1L);	xerprn_(" ***", &c_n1, "END OF MESSAGE", &c__72, 4L, 14L);	xerprn_("    ", &c__0, " ", &c__72, 4L, 1L);    }/*       IF THE ERROR IS NOT FATAL OR THE ERROR IS RECOVERABLE AND THE *//*       CONTROL FLAG IS SET FOR RECOVERY, THEN RETURN. */L30:    if (*level <= 0 || *level == 1 && mkntrl <= 1) {	return 0;    }/*       THE PROGRAM WILL BE STOPPED DUE TO AN UNRECOVERED ERROR OR A *//*       FATAL ERROR.  PRINT THE REASON FOR THE ABORT AND THE ERROR *//*       SUMMARY IF THE CONTROL FLAG AND THE MAXIMUM ERROR COUNT PERMIT. */    if (lkntrl > 0 && kount < max(1,maxmes)) {	if (*level == 1) {	    xerprn_(" ***", &c_n1, "JOB ABORT DUE TO UNRECOVERED ERROR.", &		    c__72, 4L, 35L);	} else {	    xerprn_(" ***", &c_n1, "JOB ABORT DUE TO FATAL ERROR.", &c__72, 		    4L, 29L);	}	xersve_(" ", " ", " ", &c_n1, &c__0, &c__0, &kdummy, 1L, 1L, 1L);	xerhlt_(" ", 1L);    } else {	xerhlt_(messg, messg_len);    }    return 0;} /* xermsg_ */rreal sdot_(integer *n, rreal *sx, integer *incx, rreal *sy, integer *incy){    /* System generated locals */    integer i__1, i__2;    rreal ret_val;    /* Local variables */    integer i, m, ix, iy, ns, mp1;/* ***FIRST EXECUTABLE STATEMENT  SDOT */    /* Parameter adjustments */    //--sy;    //--sx;    /* Function Body */    ret_val = 0.f;    if (*n <= 0) {	return ret_val;    }    if (*incx == *incy) {	if ((i__1 = *incx - 1) < 0) {	    goto L5;	} else if (i__1 == 0) {	    goto L20;	} else {	    goto L60;	}    }/*     Code for unequal or nonpositive increments. */L5:    ix = 1;    iy = 1;    if (*incx < 0) {	ix = (-(*n) + 1) * *incx + 1;    }    if (*incy < 0) {	iy = (-(*n) + 1) * *incy + 1;    }    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	ret_val += sx[ix] * sy[iy];	ix += *incx;	iy += *incy;/* L10: */    }    return ret_val;/*     Code for both increments equal to 1. *//*     Clean-up loop so remaining vector length is a multiple of 5. */L20:    m = *n % 5;    if (m == 0) {	goto L40;    }    i__1 = m;    for (i = 1; i <= i__1; ++i) {	ret_val += sx[i] * sy[i];/* L30: */    }    if (*n < 5) {	return ret_val;    }L40:    mp1 = m + 1;    i__1 = *n;    for (i = mp1; i <= i__1; i += 5) {	ret_val = ret_val + sx[i] * sy[i] + sx[i + 1] * sy[i + 1] + sx[i + 2] 		* sy[i + 2] + sx[i + 3] * sy[i + 3] + sx[i + 4] * sy[i + 4];/* L50: */    }    return ret_val;/*     Code for equal, positive, non-unit increments. */L60:    ns = *n * *incx;    i__1 = ns;    i__2 = *incx;    for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2) {	ret_val += sx[i] * sy[i];/* L70: */    }    return ret_val;} /* sdot_ */doublerreal ddot_(integer *n, doublerreal *dx, integer *incx, doublerreal *dy, 	integer *incy){    /* System generated locals */    integer i__1, i__2;    doublerreal ret_val;    /* Local variables */    integer i, m, ix, iy, ns, mp1;/* ***FIRST EXECUTABLE STATEMENT  DDOT */    /* Parameter adjustments */    //--dy;    //--dx;    /* Function Body */    ret_val = 0.;    if (*n <= 0) {	return ret_val;    }    if (*incx == *incy) {	if ((i__1 = *incx - 1) < 0) {	    goto L5;	} else if (i__1 == 0) {	    goto L20;	} else {	    goto L60;	}    }/*     Code for unequal or nonpositive increments. */L5:    ix = 1;    iy = 1;    if (*incx < 0) {	ix = (-(*n) + 1) * *incx + 1;    }    if (*incy < 0) {	iy = (-(*n) + 1) * *incy + 1;    }    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	ret_val += dx[ix] * dy[iy];	ix += *incx;	iy += *incy;/* L10: */    }    return ret_val;/*     Code for both increments equal to 1. *//*     Clean-up loop so remaining vector length is a multiple of 5. */L20:    m = *n % 5;    if (m == 0) {	goto L40;    }    i__1 = m;    for (i = 1; i <= i__1; ++i) {	ret_val += dx[i] * dy[i];/* L30: */    }    if (*n < 5) {	return ret_val;    }L40:    mp1 = m + 1;    i__1 = *n;    for (i = mp1; i <= i__1; i += 5) {	ret_val = ret_val + dx[i] * dy[i] + dx[i + 1] * dy[i + 1] + dx[i + 2] 		* dy[i + 2] + dx[i + 3] * dy[i + 3] + dx[i + 4] * dy[i + 4];/* L50: */    }    return ret_val;/*     Code for equal, positive, non-unit increments. */L60:    ns = *n * *incx;    i__1 = ns;    i__2 = *incx;    for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2) {	ret_val += dx[i] * dy[i];/* L70: */    }    return ret_val;} /* ddot_ *//* Subroutine */ int saxpy_(integer *n, rreal *sa, rreal *sx, integer *incx, 	rreal *sy, integer *incy){    /* System generated locals */    integer i__1, i__2;    /* Local variables */    integer i, m, ix, iy, ns, mp1;/* ***FIRST EXECUTABLE STATEMENT  SAXPY */    /* Parameter adjustments */   // --sy;   // --sx;    /* Function Body */    if (*n <= 0 || *sa == 0.f) {	return 0;    }    if (*incx == *incy) {	if ((i__1 = *incx - 1) < 0) {	    goto L5;	} else if (i__1 == 0) {	    goto L20;	} else {	    goto L60;	}    }/*     Code for unequal or nonpositive increments. */L5:    ix = 1;    iy = 1;    if (*incx < 0) {	ix = (-(*n) + 1) * *incx + 1;    }    if (*incy < 0) {	iy = (-(*n) + 1) * *incy + 1;    }    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	sy[iy] += *sa * sx[ix];	ix += *incx;	iy += *incy;/* L10: */    }    return 0;/*     Code for both increments equal to 1. *//*     Clean-up loop so remaining vector length is a multiple of 4. */L20:    m = *n % 4;    if (m == 0) {	goto L40;    }    i__1 = m;    for (i = 1; i <= i__1; ++i) {	sy[i] += *sa * sx[i];/* L30: */    }    if (*n < 4) {	return 0;    }L40:    mp1 = m + 1;    i__1 = *n;    for (i = mp1; i <= i__1; i += 4) {	sy[i] += *sa * sx[i];	sy[i + 1] += *sa * sx[i + 1];	sy[i + 2] += *sa * sx[i + 2];	sy[i + 3] += *sa * sx[i + 3];/* L50: */    }    return 0;/*     Code for equal, positive, non-unit increments. */L60:    ns = *n * *incx;    i__1 = ns;    i__2 = *incx;    for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2) {	sy[i] = *sa * sx[i] + sy[i];/* L70: */    }    return 0;} /* saxpy_ *//* Subroutine */ int daxpy_(integer *n, doublerreal *da, doublerreal *dx, 	integer *incx, doublerreal *dy, integer *incy){    /* System generated locals */    integer i__1, i__2;    /* Local variables */    integer i, m, ix, iy, ns, mp1;/* ***FIRST EXECUTABLE STATEMENT  DAXPY */    /* Parameter adjustments */   // --dy;   // --dx;    /* Function Body */    if (*n <= 0 || *da == 0.) {	return 0;    }    if (*incx == *incy) {	if ((i__1 = *incx - 1) < 0) {	    goto L5;	} else if (i__1 == 0) {	    goto L20;	} else {	    goto L60;	}    }/*     Code for unequal or nonpositive increments. */L5:    ix = 1;    iy = 1;    if (*incx < 0) {	ix = (-(*n) + 1) * *incx + 1;    }    if (*incy < 0) {	iy = (-(*n) + 1) * *incy + 1;    }    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	dy[iy] += *da * dx[ix];	ix += *incx;	iy += *incy;/* L10: */    }    return 0;/*     Code for both increments equal to 1. *//*     Clean-up loop so remaining vector length is a multiple of 4. */L20:    m = *n % 4;    if (m == 0) {	goto L40;    }    i__1 = m;    for (i = 1; i <= i__1; ++i) {	dy[i] += *da * dx[i];/* L30: */    }    if (*n < 4) {	return 0;    }L40:    mp1 = m + 1;    i__1 = *n;    for (i = mp1; i <= i__1; i += 4) {	dy[i] += *da * dx[i];	dy[i + 1] += *da * dx[i + 1];	dy[i + 2] += *da * dx[i + 2];	dy[i + 3] += *da * dx[i + 3];/* L50: */    }    return 0;/*     Code for equal, positive, non-unit increments. */L60:    ns = *n * *incx;    i__1 = ns;    i__2 = *incx;    for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2) {	dy[i] = *da * dx[i] + dy[i];/* L70: */    }    return 0;} /* daxpy_ *//* Subroutine */ int xerbla_(char *srname, integer *info, ftnlen srname_len){    /* System generated locals */    address a__1[5];    integer i__1[5];    char ch__1[59];    icilist ici__1;	*srname = *srname;    /* Builtin functions */    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)	    ;    void s_cat(char *, char **, integer *, integer *, ftnlen);    /* Local variables */    char xern1[2];    extern /* Subroutine */ int xermsg_(char *, char *, char *, integer *, 	    integer *, ftnlen, ftnlen, ftnlen);/*     ..    Scalar Arguments .. *//* ***FIRST EXECUTABLE STATEMENT  XERBLA */    ici__1.icierr = 0;    ici__1.icirnum = 1;    ici__1.icirlen = 2;    ici__1.iciunit = xern1;    ici__1.icifmt = "(I2)";    s_wsfi(&ici__1);    do_fio(&c__1, (char *)&(*info), (ftnlen)sizeof(integer));    e_wsfi();/* Writing concatenation */    i__1[0] = 12, a__1[0] = "On entry to ";    i__1[1] = 6, a__1[1] = srname;    i__1[2] = 18, a__1[2] = " parameter number ";    i__1[3] = 2, a__1[3] = xern1;    i__1[4] = 21, a__1[4] = " had an illegal value";    s_cat(ch__1, a__1, i__1, &c__5, 59L);    xermsg_("SLATEC", srname, ch__1, info, &c__1, 6L, 6L, 59L);    return 0;/*     End of XERBLA. */} /* xerbla_ */logical lsame_(char *ca, char *cb, ftnlen ca_len, ftnlen cb_len){    /* Initialized data */    static logical first = TRUE_;	ca_len = ca_len;	cb_len = cb_len;    /* System generated locals */    logical ret_val;    /* Local variables */    integer ioff;/*     .. Scalar Arguments .. *//*     .. Local Scalars .. *//*     .. Intrinsic Functions .. *//*     .. Save statement .. *//*     .. Data statements .. *//* ***FIRST EXECUTABLE STATEMENT  LSAME */    if (first) {	ioff = 'a' - 'A';    }    first = FALSE_;/*     Test if the characters are equal */    ret_val = *(unsigned char *)ca == *(unsigned char *)cb;/*     Now test for equivalence */    if (! ret_val) {	ret_val = *(unsigned char *)ca - ioff == *(unsigned char *)cb;    }    return ret_val;/*  The following comments contain code for CDC systems using 6-12 bit *//*  representations. *//*     .. Parameters .. *//*     INTEGER                ICIRFX *//*     PARAMETER            ( ICIRFX=62 ) *//*     .. Scalar Arguments .. *//*     CHARACTER*1            CB *//*     .. Array Arguments .. *//*     CHARACTER*1            CA(*) *//*     .. Local Scalars .. *//*     INTEGER                IVAL *//*     .. Intrinsic Functions .. *//*     INTRINSIC              ICHAR, CHAR *//*     .. Executable Statements .. *//*     INTRINSIC              ICHAR, CHAR *//*     See if the first character in string CA equals string CB. *//*     LSAME = CA(1) .EQ. CB .AND. CA(1) .NE. CHAR(ICIRFX) *//*     IF (LSAME) RETURN *//*     The characters are not identical. Now check them for equivalence. *//*     Look for the 'escape' character, circumflex, followed by the *//*     letter. *//*     IVAL = ICHAR(CA(2)) *//*     IF (IVAL.GE.ICHAR('A') .AND. IVAL.LE.ICHAR('Z')) THEN *//*        LSAME = CA(1) .EQ. CHAR(ICIRFX) .AND. CA(2) .EQ. CB *//*     ENDIF *//*     RETURN *//*     End of LSAME. */} /* lsame_ */integer inits_(rreal *os, integer *nos, rreal *eta){    /* System generated locals */    integer ret_val, i__1;    rreal r__1;    /* Local variables */    integer i, ii;    extern /* Subroutine */ int xermsg_(char *, char *, char *, integer *, 	    integer *, ftnlen, ftnlen, ftnlen);    rreal err;/* ***FIRST EXECUTABLE STATEMENT  INITS */    /* Parameter adjustments */    //--os;    /* Function Body */    if (*nos < 1) {	xermsg_("SLATEC", "INITS", "Number of coefficients is less than 1", &		c__2, &c__1, 6L, 5L, 37L);    }    err = 0.f;    i__1 = *nos;    for (ii = 1; ii <= i__1; ++ii) {	i = *nos + 1 - ii;	err += (r__1 = os[i], abs(r__1));	if (err > *eta) {	    goto L20;	}/* L10: */    }L20:    if (i == *nos) {	xermsg_("SLATEC", "INITS", "Chebyshev series too short for specified"		" accuracy", &c__1, &c__1, 6L, 5L, 49L);    }    ret_val = i;    return ret_val;} /* inits_ *//* Subroutine */ int scopy_(integer *n, rreal *sx, integer *incx, rreal *sy, 	integer *incy){    /* System generated locals */    integer i__1, i__2;    /* Local variables */    integer i, m, ix, iy, ns, mp1;/* ***FIRST EXECUTABLE STATEMENT  SCOPY */    /* Parameter adjustments */   // --sy;   // --sx;    /* Function Body */    if (*n <= 0) {	return 0;    }    if (*incx == *incy) {	if ((i__1 = *incx - 1) < 0) {	    goto L5;	} else if (i__1 == 0) {	    goto L20;	} else {	    goto L60;	}    }/*     Code for unequal or nonpositive increments. */L5:    ix = 1;    iy = 1;    if (*incx < 0) {	ix = (-(*n) + 1) * *incx + 1;    }    if (*incy < 0) {	iy = (-(*n) + 1) * *incy + 1;    }    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	sy[iy] = sx[ix];	ix += *incx;	iy += *incy;/* L10: */    }    return 0;/*     Code for both increments equal to 1. *//*     Clean-up loop so remaining vector length is a multiple of 7. */L20:    m = *n % 7;    if (m == 0) {	goto L40;    }    i__1 = m;    for (i = 1; i <= i__1; ++i) {	sy[i] = sx[i];/* L30: */    }    if (*n < 7) {	return 0;    }L40:    mp1 = m + 1;    i__1 = *n;    for (i = mp1; i <= i__1; i += 7) {	sy[i] = sx[i];	sy[i + 1] = sx[i + 1];	sy[i + 2] = sx[i + 2];	sy[i + 3] = sx[i + 3];	sy[i + 4] = sx[i + 4];	sy[i + 5] = sx[i + 5];	sy[i + 6] = sx[i + 6];/* L50: */    }    return 0;/*     Code for equal, positive, non-unit increments. */L60:    ns = *n * *incx;    i__1 = ns;    i__2 = *incx;    for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2) {	sy[i] = sx[i];/* L70: */    }    return 0;} /* scopy_ */rreal csevl_(rreal *x, rreal *cs, integer *n){    /* Initialized data */    static logical first = TRUE_;    /* System generated locals */    integer i__1;    rreal ret_val;    /* Local variables */    rreal twox;    integer i;    static rreal onepl;    rreal b0, b1, b2;    extern rreal r1mach_(integer *);    integer ni;    extern /* Subroutine */ int xermsg_(char *, char *, char *, integer *, 	    integer *, ftnlen, ftnlen, ftnlen);    /* Parameter adjustments */    //--cs;    /* Function Body *//* ***FIRST EXECUTABLE STATEMENT  CSEVL */    if (first) {	onepl = r1mach_(&c__4) + 1.f;    }    first = FALSE_;    if (*n < 1) {	xermsg_("SLATEC", "CSEVL", "NUMBER OF TERMS .LE. 0", &c__2, &c__2, 6L,		 5L, 22L);    }    if (*n > 1000) {	xermsg_("SLATEC", "CSEVL", "NUMBER OF TERMS .GT. 1000", &c__3, &c__2, 		6L, 5L, 25L);    }    if (abs(*x) > onepl) {	xermsg_("SLATEC", "CSEVL", "X OUTSIDE THE INTERVAL (-1,+1)", &c__1, &		c__1, 6L, 5L, 30L);    }    b1 = 0.f;    b0 = 0.f;    twox = *x * 2.f;    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	b2 = b1;	b1 = b0;	ni = *n + 1 - i;	b0 = twox * b1 - b2 + cs[ni];/* L10: */    }    ret_val = (b0 - b2) * .5f;    return ret_val;} /* csevl_ */doublerreal dcsevl_(doublerreal *x, doublerreal *cs, integer *n){    /* Initialized data */    static logical first = TRUE_;    /* System generated locals */    integer i__1;    doublerreal ret_val;    /* Local variables */    doublerreal twox;    integer i;    static doublerreal onepl;    doublerreal b0, b1, b2;    extern doublerreal d1mach_(integer *);    integer ni;    extern /* Subroutine */ int xermsg_(char *, char *, char *, integer *, 	    integer *, ftnlen, ftnlen, ftnlen);    /* Parameter adjustments */   // --cs;    /* Function Body *//* ***FIRST EXECUTABLE STATEMENT  DCSEVL */    if (first) {	onepl = d1mach_(&c__4) + 1.;    }    first = FALSE_;    if (*n < 1) {	xermsg_("SLATEC", "DCSEVL", "NUMBER OF TERMS .LE. 0", &c__2, &c__2, 		6L, 6L, 22L);    }    if (*n > 1000) {	xermsg_("SLATEC", "DCSEVL", "NUMBER OF TERMS .GT. 1000", &c__3, &c__2,		 6L, 6L, 25L);    }    if (abs(*x) > onepl) {	xermsg_("SLATEC", "DCSEVL", "X OUTSIDE THE INTERVAL (-1,+1)", &c__1, &		c__1, 6L, 6L, 30L);    }    b1 = 0.;    b0 = 0.;    twox = *x * 2.;    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	b2 = b1;	b1 = b0;	ni = *n + 1 - i;	b0 = twox * b1 - b2 + cs[ni];/* L10: */    }    ret_val = (b0 - b2) * .5;    return ret_val;} /* dcsevl_ */integer initds_(doublerreal *os, integer *nos, rreal *eta){    /* System generated locals */    integer ret_val, i__1;    rreal r__1;    /* Local variables */    integer i, ii;    extern /* Subroutine */ int xermsg_(char *, char *, char *, integer *, 	    integer *, ftnlen, ftnlen, ftnlen);    rreal err;/* ***FIRST EXECUTABLE STATEMENT  INITDS */    /* Parameter adjustments */   // --os;    /* Function Body */    if (*nos < 1) {	xermsg_("SLATEC", "INITDS", "Number of coefficients is less than 1", &		c__2, &c__1, 6L, 6L, 37L);    }    err = 0.f;    i__1 = *nos;    for (ii = 1; ii <= i__1; ++ii) {	i = *nos + 1 - ii;	err += (r__1 = os[i], abs(r__1));	if (err > *eta) {	    goto L20;	}/* L10: */    }L20:    if (i == *nos) {	xermsg_("SLATEC", "INITDS", "Chebyshev series too short for specifie"		"d accuracy", &c__1, &c__1, 6L, 6L, 49L);    }    ret_val = i;    return ret_val;} /* initds_ *//* Subroutine */ int sscal_(integer *n, rreal *sa, rreal *sx, integer *incx){    /* System generated locals */    integer i__1;    /* Local variables */    integer i, m, ix, mp1;/* ***FIRST EXECUTABLE STATEMENT  SSCAL */    /* Parameter adjustments */   // --sx;    /* Function Body */    if (*n <= 0) {	return 0;    }    if (*incx == 1) {	goto L20;    }/*     Code for increment not equal to 1. */    ix = 1;    if (*incx < 0) {	ix = (-(*n) + 1) * *incx + 1;    }    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	sx[ix] = *sa * sx[ix];	ix += *incx;/* L10: */    }    return 0;/*     Code for increment equal to 1. *//*     Clean-up loop so remaining vector length is a multiple of 5. */L20:    m = *n % 5;    if (m == 0) {	goto L40;    }    i__1 = m;    for (i = 1; i <= i__1; ++i) {	sx[i] = *sa * sx[i];/* L30: */    }    if (*n < 5) {	return 0;    }L40:    mp1 = m + 1;    i__1 = *n;    for (i = mp1; i <= i__1; i += 5) {	sx[i] = *sa * sx[i];	sx[i + 1] = *sa * sx[i + 1];	sx[i + 2] = *sa * sx[i + 2];	sx[i + 3] = *sa * sx[i + 3];	sx[i + 4] = *sa * sx[i + 4];/* L50: */    }    return 0;} /* sscal_ */doublerreal dnrm2_(integer *n, doublerreal *dx, integer *incx){    /* Initialized data */    static doublerreal zero = 0.;    static doublerreal one = 1.;    static doublerreal cutlo = 8.232e-11;    static doublerreal cuthi = 1.304e19;    /* Format strings */    static char fmt_30[] = "";    static char fmt_50[] = "";    static char fmt_70[] = "";    static char fmt_110[] = "";    /* System generated locals */    integer i__1, i__2;    doublerreal ret_val, d__1;    /* Builtin functions */    double sqrt(doublerreal);    /* Local variables */    doublerreal xmax;    integer next, i, j, nn;    doublerreal hitest, sum;    /* Assigned format variables */    char *next_fmt;    /* Parameter adjustments */    //--dx;    /* Function Body *//* ***FIRST EXECUTABLE STATEMENT  DNRM2 */    if (*n > 0) {	goto L10;    }    ret_val = zero;    goto L300;L10:    next = 0;    next_fmt = fmt_30;    sum = zero;    nn = *n * *incx;/*                                                 BEGIN MAIN LOOP */    i = 1;L20:    switch (next) {	case 0: goto L30;	case 1: goto L50;	case 2: goto L70;	case 3: goto L110;    }L30:    if ((d__1 = dx[i], abs(d__1)) > cutlo) {	goto L85;    }    next = 1;    next_fmt = fmt_50;    xmax = zero;/*                        PHASE 1.  SUM IS ZERO */L50:    if (dx[i] == zero) {	goto L200;    }    if ((d__1 = dx[i], abs(d__1)) > cutlo) {	goto L85;    }/*                                PREPARE FOR PHASE 2. */    next = 2;    next_fmt = fmt_70;    goto L105;/*                                PREPARE FOR PHASE 4. */L100:    i = j;    next = 3;    next_fmt = fmt_110;    sum = sum / dx[i] / dx[i];L105:    xmax = (d__1 = dx[i], abs(d__1));    goto L115;/*                   PHASE 2.  SUM IS SMALL. *//*                             SCALE TO AVOID DESTRUCTIVE UNDERFLOW. */L70:    if ((d__1 = dx[i], abs(d__1)) > cutlo) {	goto L75;    }/*                     COMMON CODE FOR PHASES 2 AND 4. *//*                     IN PHASE 4 SUM IS LARGE.  SCALE TO AVOID OVERFLOW. */L110:    if ((d__1 = dx[i], abs(d__1)) <= xmax) {	goto L115;    }/* Computing 2nd power */    d__1 = xmax / dx[i];    sum = one + sum * (d__1 * d__1);    xmax = (d__1 = dx[i], abs(d__1));    goto L200;L115:/* Computing 2nd power */    d__1 = dx[i] / xmax;    sum += d__1 * d__1;    goto L200;/*                  PREPARE FOR PHASE 3. */L75:    sum = sum * xmax * xmax;/*     FOR REAL OR D.P. SET HITEST = CUTHI/N *//*     FOR COMPLEX      SET HITEST = CUTHI/(2*N) */L85:    hitest = cuthi / *n;/*                   PHASE 3.  SUM IS MID-RANGE.  NO SCALING. */    i__1 = nn;    i__2 = *incx;    for (j = i; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {	if ((d__1 = dx[j], abs(d__1)) >= hitest) {	    goto L100;	}/* L95: *//* Computing 2nd power */	d__1 = dx[j];	sum += d__1 * d__1;    }    ret_val = sqrt(sum);    goto L300;L200:    i += *incx;    if (i <= nn) {	goto L20;    }/*              END OF MAIN LOOP. *//*              COMPUTE SQUARE ROOT AND ADJUST FOR SCALING. */    ret_val = xmax * sqrt(sum);L300:    return ret_val;} /* dnrm2_ */rreal snrm2_(integer *n, rreal *sx, integer *incx){    /* Initialized data */    static rreal zero = 0.f;    static rreal one = 1.f;    static rreal cutlo = 4.441e-16f;    static rreal cuthi = 1.304e19f;    /* Format strings */    static char fmt_30[] = "";    static char fmt_50[] = "";    static char fmt_70[] = "";    static char fmt_110[] = "";    /* System generated locals */    integer i__1, i__2;    rreal ret_val, r__1;    /* Builtin functions */    double sqrt(doublerreal);    /* Local variables */    rreal xmax;    integer next, i, j, nn;    rreal hitest, sum;    /* Assigned format variables */    char *next_fmt;    /* Parameter adjustments */    //--sx;    /* Function Body *//* ***FIRST EXECUTABLE STATEMENT  SNRM2 */    if (*n > 0) {	goto L10;    }    ret_val = zero;    goto L300;L10:    next = 0;    next_fmt = fmt_30;    sum = zero;    nn = *n * *incx;/*                                                 BEGIN MAIN LOOP */    i = 1;L20:    switch (next) {	case 0: goto L30;	case 1: goto L50;	case 2: goto L70;	case 3: goto L110;    }L30:    if ((r__1 = sx[i], abs(r__1)) > cutlo) {	goto L85;    }    next = 1;    next_fmt = fmt_50;    xmax = zero;/*                        PHASE 1.  SUM IS ZERO */L50:    if (sx[i] == zero) {	goto L200;    }    if ((r__1 = sx[i], abs(r__1)) > cutlo) {	goto L85;    }/*                                PREPARE FOR PHASE 2. */    next = 2;    next_fmt = fmt_70;    goto L105;/*                                PREPARE FOR PHASE 4. */L100:    i = j;    next = 3;    next_fmt = fmt_110;    sum = sum / sx[i] / sx[i];L105:    xmax = (r__1 = sx[i], abs(r__1));    goto L115;/*                   PHASE 2.  SUM IS SMALL. *//*                             SCALE TO AVOID DESTRUCTIVE UNDERFLOW. */L70:    if ((r__1 = sx[i], abs(r__1)) > cutlo) {	goto L75;    }/*                     COMMON CODE FOR PHASES 2 AND 4. *//*                     IN PHASE 4 SUM IS LARGE.  SCALE TO AVOID OVERFLOW. */L110:    if ((r__1 = sx[i], abs(r__1)) <= xmax) {	goto L115;    }/* Computing 2nd power */    r__1 = xmax / sx[i];    sum = one + sum * (r__1 * r__1);    xmax = (r__1 = sx[i], abs(r__1));    goto L200;L115:/* Computing 2nd power */    r__1 = sx[i] / xmax;    sum += r__1 * r__1;    goto L200;/*                  PREPARE FOR PHASE 3. */L75:    sum = sum * xmax * xmax;/*     FOR REAL OR D.P. SET HITEST = CUTHI/N *//*     FOR COMPLEX      SET HITEST = CUTHI/(2*N) */L85:    hitest = cuthi / *n;/*                   PHASE 3.  SUM IS MID-RANGE.  NO SCALING. */    i__1 = nn;    i__2 = *incx;    for (j = i; i__2 < 0 ? j >= i__1 : j <= i__1; j += i__2) {	if ((r__1 = sx[j], abs(r__1)) >= hitest) {	    goto L100;	}/* L95: *//* Computing 2nd power */	r__1 = sx[j];	sum += r__1 * r__1;    }    ret_val = sqrt(sum);    goto L300;L200:    i += *incx;    if (i <= nn) {	goto L20;    }/*              END OF MAIN LOOP. *//*              COMPUTE SQUARE ROOT AND ADJUST FOR SCALING. */    ret_val = xmax * sqrt(sum);L300:    return ret_val;} /* snrm2_ *//* Subroutine */ int dscal_(integer *n, doublerreal *da, doublerreal *dx, 	integer *incx){    /* System generated locals */    integer i__1;    /* Local variables */    integer i, m, ix, mp1;/* ***FIRST EXECUTABLE STATEMENT  DSCAL */    /* Parameter adjustments */    //--dx;    /* Function Body */    if (*n <= 0) {	return 0;    }    if (*incx == 1) {	goto L20;    }/*     Code for increment not equal to 1. */    ix = 1;    if (*incx < 0) {	ix = (-(*n) + 1) * *incx + 1;    }    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	dx[ix] = *da * dx[ix];	ix += *incx;/* L10: */    }    return 0;/*     Code for increment equal to 1. *//*     Clean-up loop so remaining vector length is a multiple of 5. */L20:    m = *n % 5;    if (m == 0) {	goto L40;    }    i__1 = m;    for (i = 1; i <= i__1; ++i) {	dx[i] = *da * dx[i];/* L30: */    }    if (*n < 5) {	return 0;    }L40:    mp1 = m + 1;    i__1 = *n;    for (i = mp1; i <= i__1; i += 5) {	dx[i] = *da * dx[i];	dx[i + 1] = *da * dx[i + 1];	dx[i + 2] = *da * dx[i + 2];	dx[i + 3] = *da * dx[i + 3];	dx[i + 4] = *da * dx[i + 4];/* L50: */    }    return 0;} /* dscal_ *//* Subroutine */ int caxpy_(integer *n, ccomplex *ca, ccomplex *cx, integer *	incx, ccomplex *cy, integer *incy){    /* System generated locals */    integer i__1, i__2, i__3, i__4, i__5;    ccomplex q__1, q__2;    /* Local variables */    integer i, ns, kx, ky;/* ***FIRST EXECUTABLE STATEMENT  CAXPY */    /* Parameter adjustments */   // --cy;   // --cx;    /* Function Body */    if (*n <= 0 || ca->r == 0.f && ca->i == 0.f) {	return 0;    }    if (*incx == *incy && *incx > 0) {	goto L20;    }/*     Code for unequal or nonpositive increments. */    kx = 1;    ky = 1;    if (*incx < 0) {	kx = (1 - *n) * *incx + 1;    }    if (*incy < 0) {	ky = (1 - *n) * *incy + 1;    }    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	i__2 = ky;	i__3 = ky;	i__4 = kx;	q__2.r = ca->r * cx[i__4].r - ca->i * cx[i__4].i, q__2.i = ca->r * cx[		i__4].i + ca->i * cx[i__4].r;	q__1.r = cy[i__3].r + q__2.r, q__1.i = cy[i__3].i + q__2.i;	cy[i__2].r = q__1.r, cy[i__2].i = q__1.i;	kx += *incx;	ky += *incy;/* L10: */    }    return 0;/*     Code for equal, positive, non-unit increments. */L20:    ns = *n * *incx;    i__1 = ns;    i__2 = *incx;    for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2) {	i__3 = i;	i__4 = i;	q__2.r = ca->r * cx[i__4].r - ca->i * cx[i__4].i, q__2.i = ca->r * cx[		i__4].i + ca->i * cx[i__4].r;	i__5 = i;	q__1.r = q__2.r + cy[i__5].r, q__1.i = q__2.i + cy[i__5].i;	cy[i__3].r = q__1.r, cy[i__3].i = q__1.i;/* L30: */    }    return 0;} /* caxpy_ */integer isamax_(integer *n, rreal *sx, integer *incx){    /* System generated locals */    integer ret_val, i__1;    rreal r__1;    /* Local variables */    rreal xmag, smax;    integer i, ix;/* ***FIRST EXECUTABLE STATEMENT  ISAMAX */    /* Parameter adjustments */   // --sx;    /* Function Body */    ret_val = 0;    if (*n <= 0) {	return ret_val;    }    ret_val = 1;    if (*n == 1) {	return ret_val;    }    if (*incx == 1) {	goto L20;    }/*     Code for increment not equal to 1. */    ix = 1;    if (*incx < 0) {	ix = (-(*n) + 1) * *incx + 1;    }    smax = (r__1 = sx[ix], abs(r__1));    ix += *incx;    i__1 = *n;    for (i = 2; i <= i__1; ++i) {	xmag = (r__1 = sx[ix], abs(r__1));	if (xmag > smax) {	    ret_val = i;	    smax = xmag;	}	ix += *incx;/* L10: */    }    return ret_val;/*     Code for increments equal to 1. */L20:    smax = abs(sx[1]);    i__1 = *n;    for (i = 2; i <= i__1; ++i) {	xmag = (r__1 = sx[i], abs(r__1));	if (xmag > smax) {	    ret_val = i;	    smax = xmag;	}/* L30: */    }    return ret_val;} /* isamax_ *//* Subroutine */ int dcopy_(integer *n, doublerreal *dx, integer *incx, 	doublerreal *dy, integer *incy){    /* System generated locals */    integer i__1, i__2;    /* Local variables */    integer i, m, ix, iy, ns, mp1;/* ***FIRST EXECUTABLE STATEMENT  DCOPY */    /* Parameter adjustments */   // --dy;   // --dx;    /* Function Body */    if (*n <= 0) {	return 0;    }    if (*incx == *incy) {	if ((i__1 = *incx - 1) < 0) {	    goto L5;	} else if (i__1 == 0) {	    goto L20;	} else {	    goto L60;	}    }/*     Code for unequal or nonpositive increments. */L5:    ix = 1;    iy = 1;    if (*incx < 0) {	ix = (-(*n) + 1) * *incx + 1;    }    if (*incy < 0) {	iy = (-(*n) + 1) * *incy + 1;    }    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	dy[iy] = dx[ix];	ix += *incx;	iy += *incy;/* L10: */    }    return 0;/*     Code for both increments equal to 1. *//*     Clean-up loop so remaining vector length is a multiple of 7. */L20:    m = *n % 7;    if (m == 0) {	goto L40;    }    i__1 = m;    for (i = 1; i <= i__1; ++i) {	dy[i] = dx[i];/* L30: */    }    if (*n < 7) {	return 0;    }L40:    mp1 = m + 1;    i__1 = *n;    for (i = mp1; i <= i__1; i += 7) {	dy[i] = dx[i];	dy[i + 1] = dx[i + 1];	dy[i + 2] = dx[i + 2];	dy[i + 3] = dx[i + 3];	dy[i + 4] = dx[i + 4];	dy[i + 5] = dx[i + 5];	dy[i + 6] = dx[i + 6];/* L50: */    }    return 0;/*     Code for equal, positive, non-unit increments. */L60:    ns = *n * *incx;    i__1 = ns;    i__2 = *incx;    for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2) {	dy[i] = dx[i];/* L70: */    }    return 0;} /* dcopy_ */integer idamax_(integer *n, doublerreal *dx, integer *incx){    /* System generated locals */    integer ret_val, i__1;    doublerreal d__1;    /* Local variables */    doublerreal dmax__, xmag;    integer i, ix;/* ***FIRST EXECUTABLE STATEMENT  IDAMAX */    /* Parameter adjustments */   // --dx;    /* Function Body */    ret_val = 0;    if (*n <= 0) {	return ret_val;    }    ret_val = 1;    if (*n == 1) {	return ret_val;    }    if (*incx == 1) {	goto L20;    }/*     Code for increments not equal to 1. */    ix = 1;    if (*incx < 0) {	ix = (-(*n) + 1) * *incx + 1;    }    dmax__ = (d__1 = dx[ix], abs(d__1));    ix += *incx;    i__1 = *n;    for (i = 2; i <= i__1; ++i) {	xmag = (d__1 = dx[ix], abs(d__1));	if (xmag > dmax__) {	    ret_val = i;	    dmax__ = xmag;	}	ix += *incx;/* L10: */    }    return ret_val;/*     Code for increments equal to 1. */L20:    dmax__ = abs(dx[1]);    i__1 = *n;    for (i = 2; i <= i__1; ++i) {	xmag = (d__1 = dx[i], abs(d__1));	if (xmag > dmax__) {	    ret_val = i;	    dmax__ = xmag;	}/* L30: */    }    return ret_val;} /* idamax_ *//* Complex */ VOID cdotc_(ccomplex * ret_val, integer *n, ccomplex *cx, integer 	*incx, ccomplex *cy, integer *incy){    /* System generated locals */    integer i__1, i__2, i__3;    ccomplex q__1, q__2, q__3;    /* Builtin functions */    void r_cnjg(ccomplex *, ccomplex *);    /* Local variables */    integer i, ns, kx, ky;/* ***FIRST EXECUTABLE STATEMENT  CDOTC */    /* Parameter adjustments */   // --cy;  //  --cx;    /* Function Body */     ret_val->r = 0.f,  ret_val->i = 0.f;    if (*n <= 0) {	return ;    }    if (*incx == *incy && *incx > 0) {	goto L20;    }/*     Code for unequal or nonpositive increments. */    kx = 1;    ky = 1;    if (*incx < 0) {	kx = (1 - *n) * *incx + 1;    }    if (*incy < 0) {	ky = (1 - *n) * *incy + 1;    }    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	r_cnjg(&q__3, &cx[kx]);	i__2 = ky;	q__2.r = q__3.r * cy[i__2].r - q__3.i * cy[i__2].i, q__2.i = q__3.r * 		cy[i__2].i + q__3.i * cy[i__2].r;	q__1.r =  ret_val->r + q__2.r, q__1.i =  ret_val->i + q__2.i;	 ret_val->r = q__1.r,  ret_val->i = q__1.i;	kx += *incx;	ky += *incy;/* L10: */    }    return ;/*     Code for equal, positive increments. */L20:    ns = *n * *incx;    i__1 = ns;    i__2 = *incx;    for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2) {	r_cnjg(&q__3, &cx[i]);	i__3 = i;	q__2.r = q__3.r * cy[i__3].r - q__3.i * cy[i__3].i, q__2.i = q__3.r * 		cy[i__3].i + q__3.i * cy[i__3].r;	q__1.r =  ret_val->r + q__2.r, q__1.i =  ret_val->i + q__2.i;	 ret_val->r = q__1.r,  ret_val->i = q__1.i;/* L30: */    }    return ;} /* cdotc_ *//* Subroutine */ int sswap_(integer *n, rreal *sx, integer *incx, rreal *sy, 	integer *incy){    /* System generated locals */    integer i__1, i__2;    /* Local variables */    integer i, m;    rreal stemp1, stemp2, stemp3;    integer ix, iy, ns, mp1;/* ***FIRST EXECUTABLE STATEMENT  SSWAP */    /* Parameter adjustments */  //  --sy;  //  --sx;    /* Function Body */    if (*n <= 0) {	return 0;    }    if (*incx == *incy) {	if ((i__1 = *incx - 1) < 0) {	    goto L5;	} else if (i__1 == 0) {	    goto L20;	} else {	    goto L60;	}    }/*     Code for unequal or nonpositive increments. */L5:    ix = 1;    iy = 1;    if (*incx < 0) {	ix = (-(*n) + 1) * *incx + 1;    }    if (*incy < 0) {	iy = (-(*n) + 1) * *incy + 1;    }    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	stemp1 = sx[ix];	sx[ix] = sy[iy];	sy[iy] = stemp1;	ix += *incx;	iy += *incy;/* L10: */    }    return 0;/*     Code for both increments equal to 1. *//*     Clean-up loop so remaining vector length is a multiple of 3. */L20:    m = *n % 3;    if (m == 0) {	goto L40;    }    i__1 = m;    for (i = 1; i <= i__1; ++i) {	stemp1 = sx[i];	sx[i] = sy[i];	sy[i] = stemp1;/* L30: */    }    if (*n < 3) {	return 0;    }L40:    mp1 = m + 1;    i__1 = *n;    for (i = mp1; i <= i__1; i += 3) {	stemp1 = sx[i];	stemp2 = sx[i + 1];	stemp3 = sx[i + 2];	sx[i] = sy[i];	sx[i + 1] = sy[i + 1];	sx[i + 2] = sy[i + 2];	sy[i] = stemp1;	sy[i + 1] = stemp2;	sy[i + 2] = stemp3;/* L50: */    }    return 0;/*     Code for equal, positive, non-unit increments. */L60:    ns = *n * *incx;    i__1 = ns;    i__2 = *incx;    for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2) {	stemp1 = sx[i];	sx[i] = sy[i];	sy[i] = stemp1;/* L70: */    }    return 0;} /* sswap_ *//* Subroutine */ int dswap_(integer *n, doublerreal *dx, integer *incx, 	doublerreal *dy, integer *incy){    /* System generated locals */    integer i__1, i__2;    /* Local variables */    integer i, m;    doublerreal dtemp1, dtemp2, dtemp3;    integer ix, iy, ns, mp1;/* ***FIRST EXECUTABLE STATEMENT  DSWAP */    /* Parameter adjustments */  // --dy;  //  --dx;    /* Function Body */    if (*n <= 0) {	return 0;    }    if (*incx == *incy) {	if ((i__1 = *incx - 1) < 0) {	    goto L5;	} else if (i__1 == 0) {	    goto L20;	} else {	    goto L60;	}    }/*     Code for unequal or nonpositive increments. */L5:    ix = 1;    iy = 1;    if (*incx < 0) {	ix = (-(*n) + 1) * *incx + 1;    }    if (*incy < 0) {	iy = (-(*n) + 1) * *incy + 1;    }    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	dtemp1 = dx[ix];	dx[ix] = dy[iy];	dy[iy] = dtemp1;	ix += *incx;	iy += *incy;/* L10: */    }    return 0;/*     Code for both increments equal to 1. *//*     Clean-up loop so remaining vector length is a multiple of 3. */L20:    m = *n % 3;    if (m == 0) {	goto L40;    }    i__1 = m;    for (i = 1; i <= i__1; ++i) {	dtemp1 = dx[i];	dx[i] = dy[i];	dy[i] = dtemp1;/* L30: */    }    if (*n < 3) {	return 0;    }L40:    mp1 = m + 1;    i__1 = *n;    for (i = mp1; i <= i__1; i += 3) {	dtemp1 = dx[i];	dtemp2 = dx[i + 1];	dtemp3 = dx[i + 2];	dx[i] = dy[i];	dx[i + 1] = dy[i + 1];	dx[i + 2] = dy[i + 2];	dy[i] = dtemp1;	dy[i + 1] = dtemp2;	dy[i + 2] = dtemp3;/* L50: */    }    return 0;/*     Code for equal, positive, non-unit increments. */L60:    ns = *n * *incx;    i__1 = ns;    i__2 = *incx;    for (i = 1; i__2 < 0 ? i >= i__1 : i <= i__1; i += i__2) {	dtemp1 = dx[i];	dx[i] = dy[i];	dy[i] = dtemp1;/* L70: */    }    return 0;} /* dswap_ */rreal pythag_(rreal *a, rreal *b){    /* System generated locals */    rreal ret_val, r__1, r__2;    /* Local variables */    rreal p, q, r, s, t;/* ***FIRST EXECUTABLE STATEMENT  PYTHAG *//* Computing MAX */    r__1 = abs(*a), r__2 = abs(*b);    p = max(r__1,r__2);/* Computing MIN */    r__1 = abs(*a), r__2 = abs(*b);    q = min(r__1,r__2);    if (q == 0.f) {	goto L20;    }L10:/* Computing 2nd power */    r__1 = q / p;    r = r__1 * r__1;    t = r + 4.f;    if (t == 4.f) {	goto L20;    }    s = r / t;    p += p * 2.f * s;    q *= s;    goto L10;L20:    ret_val = p;    return ret_val;} /* pythag_ */doublerreal zabs_(doublerreal *zr, doublerreal *zi){    /* System generated locals */    doublerreal ret_val;    /* Builtin functions */    double sqrt(doublerreal);    /* Local variables */    doublerreal q, s, u, v;/* ***FIRST EXECUTABLE STATEMENT  ZABS */    u = abs(*zr);    v = abs(*zi);    s = u + v;/* ----------------------------------------------------------------------- *//*     S*1.0D0 MAKES AN UNNORMALIZED UNDERFLOW ON CDC MACHINES INTO A *//*     TRUE FLOATING ZERO *//* ----------------------------------------------------------------------- */    s *= 1.;    if (s == 0.) {	goto L20;    }    if (u > v) {	goto L10;    }    q = u / v;    ret_val = v * sqrt(q * q + 1.);    return ret_val;L10:    q = v / u;    ret_val = u * sqrt(q * q + 1.);    return ret_val;L20:    ret_val = 0.;    return ret_val;} /* zabs_ */rreal sasum_(integer *n, rreal *sx, integer *incx){    /* System generated locals */    integer i__1;    rreal ret_val, r__1, r__2, r__3, r__4, r__5, r__6;    /* Local variables */    integer i, m, ix, mp1;/* ***FIRST EXECUTABLE STATEMENT  SASUM */    /* Parameter adjustments */   // --sx;    /* Function Body */    ret_val = 0.f;    if (*n <= 0) {	return ret_val;    }    if (*incx == 1) {	goto L20;    }/*     Code for increment not equal to 1. */    ix = 1;    if (*incx < 0) {	ix = (-(*n) + 1) * *incx + 1;    }    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	ret_val += (r__1 = sx[ix], abs(r__1));	ix += *incx;/* L10: */    }    return ret_val;/*     Code for increment equal to 1. *//*     Clean-up loop so remaining vector length is a multiple of 6. */L20:    m = *n % 6;    if (m == 0) {	goto L40;    }    i__1 = m;    for (i = 1; i <= i__1; ++i) {	ret_val += (r__1 = sx[i], abs(r__1));/* L30: */    }    if (*n < 6) {	return ret_val;    }L40:    mp1 = m + 1;    i__1 = *n;    for (i = mp1; i <= i__1; i += 6) {	ret_val = ret_val + (r__1 = sx[i], abs(r__1)) + (r__2 = sx[i + 1], 		abs(r__2)) + (r__3 = sx[i + 2], abs(r__3)) + (r__4 = sx[i + 3]		, abs(r__4)) + (r__5 = sx[i + 4], abs(r__5)) + (r__6 = sx[i + 		5], abs(r__6));/* L50: */    }    return ret_val;} /* sasum_ */rreal pimach_(rreal *dum){    /* System generated locals */    rreal ret_val;	 *dum =  *dum;/* ***FIRST EXECUTABLE STATEMENT  PIMACH */    ret_val = 3.14159265358979f;    return ret_val;} /* pimach_ */