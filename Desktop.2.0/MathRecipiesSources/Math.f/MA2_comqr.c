/* comqr.f -- translated by f2c (version 19941113).   You must link the resulting object file with the libraries:	-lf2c -lm   (in that order)*///rows and columns switched#define	II_1	i][i - 1#define	IJ_1	i][j - 1#define JJ_1	j][j - 1#define	IJ		i][j#define	JI		j][i#define	LL_1	l][l-1#define	ENM1_EN	enm1][en#define EN_ENM1	en][enm1#define ENM1_EN_2	enm1][en - 2#define I_1J	i - 1][j#define I_EN	i][en/*#define	II_1	i - 1][i#define	IJ_1	j - 1][i#define JJ_1	j - 1][j#define	IJ		j][i#define	JI		i][j#define	LL_1	l - 1][l#define	ENM1_EN	en][enm1#define EN_ENM1	enm1][en#define ENM1_EN_2	en - 2][enm1#define I_1J	j][i - 1#define I_EN	en][i#include "f2c.h"*//* Subroutine */ int comqr_(integer *nm, integer *n, integer *low, integer *	igh, rreal **hr, rreal **hi, rreal *wr, rreal *wi, integer *ierr){    /* System generated locals */    integer  i__1, i__2;    rreal r__1, r__2, r__3, r__4;    /* Local variables */    extern /* Subroutine */ int cdiv_(rreal *, rreal *, rreal *, rreal *, rreal *, 	    rreal *);    rreal norm;    integer i, j, l;    rreal s1, s2;    integer en, ll;    rreal si, ti, xi, yi, sr, tr, xr, yr;    extern rreal pythag_(rreal *, rreal *);    extern /* Subroutine */ int csroot_(rreal *, rreal *, rreal *, rreal *);    integer lp1, itn, its;    rreal zzi, zzr;    integer enm1;	*nm = *nm;/* ***FIRST EXECUTABLE STATEMENT  COMQR */    /* Parameter adjustments *///    hi_dim1 = *nm;//    hi_offset = hi_dim1 + 1;//    hi -= hi_offset;//    hr_dim1 = *nm;//    hr_offset = hr_dim1 + 1;//    hr -= hr_offset;//    --wr;//    --wi;    /* Function Body */    *ierr = 0;    if (*low == *igh) {	goto L180;    }/*     .......... CREATE REAL SUBDIAGONAL ELEMENTS .......... */    l = *low + 1;    i__1 = *igh;    for (i = l; i <= i__1; ++i) {/* Computing MIN */	i__2 = i + 1;	ll = min(i__2,*igh);	if (hi[II_1] == 0.f) {	    goto L170;	}	norm = pythag_(&hr[II_1], &hi[II_1])		;	yr = hr[II_1] / norm;	yi = hi[II_1] / norm;	hr[II_1] = norm;	hi[II_1] = 0.f;	i__2 = *igh;	for (j = i; j <= i__2; ++j) {	    si = yr * hi[IJ] - yi * hr[IJ];	    hr[IJ] = yr * hr[IJ] + yi * hi[IJ];	    hi[IJ] = si;/* L155: */	}	i__2 = ll;	for (j = *low; j <= i__2; ++j) {	    si = yr * hi[JI] + yi * hr[JI];	    hr[JI] = yr * hr[JI] - yi * hi[JI];	    hi[JI] = si;/* L160: */	}L170:	;    }/*     .......... STORE ROOTS ISOLATED BY CBAL .......... */L180:    i__1 = *n;    for (i = 1; i <= i__1; ++i) {	if (i >= *low && i <= *igh) {	    goto L200;	}	wr[i] = hr[i][i];	wi[i] = hi[i][i];L200:	;    }    en = *igh;    tr = 0.f;    ti = 0.f;    itn = *n * 30;/*     .......... SEARCH FOR NEXT EIGENVALUE .......... */L220:    if (en < *low) {	goto L1001;    }    its = 0;    enm1 = en - 1;/*     .......... LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT *//*                FOR L=EN STEP -1 UNTIL LOW E0 -- .......... */L240:    i__1 = en;    for (ll = *low; ll <= i__1; ++ll) {	l = en + *low - ll;	if (l == *low) {	    goto L300;	}	s1 = (r__1 = hr[l - 1][l - 1], abs(r__1)) + (r__2 = hi[l - 1][l - 1], abs(r__2)) + (r__3 = hr[l][l], abs(r__3)) + (r__4 = hi[l][l], abs(r__4))		;	s2 = s1 + (r__1 = hr[LL_1], abs(r__1));	if (s2 == s1) {	    goto L300;	}/* L260: */    }/*     .......... FORM SHIFT .......... */L300:    if (l == en) {	goto L660;    }    if (itn == 0) {	goto L1000;    }    if (its == 10 || its == 20) {	goto L320;    }    sr = hr[en][en];    si = hi[en][en];    xr = hr[ENM1_EN] * hr[EN_ENM1];    xi = hi[ENM1_EN] * hr[EN_ENM1];    if (xr == 0.f && xi == 0.f) {	goto L340;    }    yr = (hr[enm1][enm1] - sr) / 2.f;    yi = (hi[enm1][enm1] - si) / 2.f;/* Computing 2nd power */    r__2 = yr;/* Computing 2nd power */    r__3 = yi;    r__1 = r__2 * r__2 - r__3 * r__3 + xr;    r__4 = yr * 2.f * yi + xi;    csroot_(&r__1, &r__4, &zzr, &zzi);    if (yr * zzr + yi * zzi >= 0.f) {	goto L310;    }    zzr = -zzr;    zzi = -zzi;L310:    r__1 = yr + zzr;    r__2 = yi + zzi;    cdiv_(&xr, &xi, &r__1, &r__2, &xr, &xi);    sr -= xr;    si -= xi;    goto L340;/*     .......... FORM EXCEPTIONAL SHIFT .......... */L320:    sr = (r__1 = hr[EN_ENM1], abs(r__1)) + (r__2 = hr[ENM1_EN_2], abs(r__2));    si = 0.f;L340:    i__1 = en;    for (i = *low; i <= i__1; ++i) {	hr[i][i] -= sr;	hi[i][i] -= si;/* L360: */    }    tr += sr;    ti += si;    ++its;    --itn;/*     .......... REDUCE TO TRIANGLE (ROWS) .......... */    lp1 = l + 1;    i__1 = en;    for (i = lp1; i <= i__1; ++i) {	sr = hr[II_1];	hr[II_1] = 0.f;	r__1 = pythag_(&hr[i - 1][i - 1], &hi[i - 1][i - 1]);	norm = pythag_(&r__1, &sr);	xr = hr[i - 1][i - 1] / norm;	wr[i - 1] = xr;	xi = hi[i - 1][i - 1] / norm;	wi[i - 1] = xi;	hr[i - 1][i - 1] = norm;	hi[i - 1][i - 1] = 0.f;	hi[II_1] = sr / norm;	i__2 = en;	for (j = i; j <= i__2; ++j) {	    yr = hr[I_1J];	    yi = hi[I_1J];	    zzr = hr[IJ];	    zzi = hi[IJ];	    hr[I_1J] = xr * yr + xi * yi + hi[II_1] * zzr;	    hi[I_1J] = xr * yi - xi * yr + hi[II_1] * zzi;	    hr[IJ] = xr * zzr - xi * zzi - hi[II_1] * yr;	    hi[IJ] = xr * zzi + xi * zzr - hi[II_1] * yi;/* L490: */	}/* L500: */    }    si = hi[en][en];    if (si == 0.f) {	goto L540;    }    norm = pythag_(&hr[en][en], &si);    sr = hr[en][en] / norm;    si /= norm;    hr[en][en] = norm;    hi[en][en] = 0.f;/*     .......... INVERSE OPERATION (COLUMNS) .......... */L540:    i__1 = en;    for (j = lp1; j <= i__1; ++j) {	xr = wr[j - 1];	xi = wi[j - 1];	i__2 = j;	for (i = l; i <= i__2; ++i) {	    yr = hr[IJ_1];	    yi = 0.f;	    zzr = hr[IJ];	    zzi = hi[IJ];	    if (i == j) {		goto L560;	    }	    yi = hi[IJ_1];	    hi[IJ_1] = xr * yi + xi * yr + hi[JJ_1] * zzi;L560:	    hr[IJ_1] = xr * yr - xi * yi + hi[JJ_1] * zzr;	    hr[IJ] = xr * zzr + xi * zzi - hi[JJ_1] * yr;	    hi[IJ] = xr * zzi - xi * zzr - hi[JJ_1] * yi;/* L580: */	}/* L600: */    }    if (si == 0.f) {	goto L240;    }    i__1 = en;    for (i = l; i <= i__1; ++i) {	yr = hr[I_EN];	yi = hi[I_EN];	hr[I_EN] = sr * yr - si * yi;	hi[I_EN] = sr * yi + si * yr;/* L630: */    }    goto L240;/*     .......... A ROOT FOUND .......... */L660:    wr[en] = hr[en][en] + tr;    wi[en] = hi[en][en] + ti;    en = enm1;    goto L220;/*     .......... SET ERROR -- NO CONVERGENCE TO AN *//*                EIGENVALUE AFTER 30*N ITERATIONS .......... */L1000:    *ierr = en;L1001:    return 0;} /* comqr_ */