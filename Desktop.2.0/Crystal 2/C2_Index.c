//C2_Index.c#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"SF_MathLib.h"Boolean	Index::EliminateIndexComponent(Index *index1){	double factor = 1,a;	Boolean		flag = false,theFlag = false;		while(!flag){		a = ((x  * index1->x) + (y * index1->y) + (z * index1->z)		) / index1->GetLength();		if(fabs(a) < .001) return theFlag;		factor = a / fabs(a);		if(fabs(a) > index1->GetLength() - .02 ){			x -= (factor * index1->x);			y -= (factor * index1->y);			z -= (factor * index1->z);			theFlag = true;		} else flag = true;	}	return theFlag;}Boolean  Index::SameIndex(Index *theObj){	if(direction != theObj->direction)return false;	if(h != theObj->h)return false;	if(k != theObj->k)return false;	if(l != theObj->l)return false;	return true;}void  Index::GetXYZFrHKL_Full(DiffractObject *theObj,short orNum)//does the complete transformation including orientation and ppt {	double matrix[3][3],xFormMatrix[3][3];;	double x1,y1,z1;	theObj->GetOrientation(xFormMatrix);	theObj->GetPPTXFormMatrixBase		(matrix,theCrystal,orNum);	MatrixMultiply			(matrix,xFormMatrix,matrix); 		if(!direction){			ConverttoReciprocal		(matrix,(double)theCrystal->volume,true);	}	x1 = h;	y1 = k;	z1 = l;	TRANSFORM_VECTOR(x1,y1,z1,matrix);	//NormalizeVector(&x1,&y1,&z1);	x = x1;	y = y1;	z = z1;	return;}void  Index::GetXYZFromHKL(double orientationMatrix[3][3]){	double matrix[3][3];	double x1,y1,z1;	theCrystal->Get001XForm(matrix);	MatrixMultiply			(matrix,orientationMatrix,matrix); 	if(!direction){			ConverttoReciprocal		(matrix,(double)theCrystal->volume,true);	}	x1 = h;	y1 = k;	z1 = l;	TRANSFORM_VECTOR(x1,y1,z1,matrix);	//NormalizeVector(&x1,&y1,&z1);	x = x1;	y = y1;	z = z1;	return;}#pragma segment MainBoolean Index::G_Vector(Index *zaIndex,Index *theG){		double 	x1,y1,z1,x2,y2,z2;	double	theXForm[3][3],u1,u2,v1,v2,w1,w2;	short 	h1,k1,l1,h2,k2,l2;	h1 = h;	k1 = k;	l1 = l;	h2 = zaIndex->h;	k2 = zaIndex->k;	l2 = zaIndex->l;	if(!zaIndex->direction || !direction && theCrystal->idNum != zaIndex->theCrystal->idNum) return false;	if(theCrystal->idNum != zaIndex->theCrystal->idNum){				DirOfPlaneNormal(&u1,&v1,&w1);		gCurrentObj->GetPPTXFormMatrixBase(theXForm,theCrystal,0);		TransFormVector(&u1,&v1,&w1,theXForm);	    NormalizeVector(&u1,&v1,&w1);	    Identity_Matrix(theXForm);	    x = u1;	    y = v1;	    z = w1;	    GetTheUVWFromXYZ(theXForm);	    ConvertXYZToHKLReduce();		if(direction == false) reduceFlag = false;		zaIndex->DirOfPlaneNormal(&u2,&v2,&w2);		gCurrentObj->GetPPTXFormMatrixBase(theXForm,zaIndex->theCrystal,0);		TransFormVector(&u2,&v2,&w2,theXForm);	    NormalizeVector(&u2,&v2,&w2);	    Identity_Matrix(theXForm);	    zaIndex->x = u2;	    zaIndex->y = v2;	    zaIndex->z = w2;	    zaIndex->GetTheUVWFromXYZ(theXForm);		zaIndex->ConvertXYZToHKLReduce();		if(zaIndex->direction == false) zaIndex->reduceFlag = false;	}		x1 = (double)h;	y1 = (double)k;	z1 = (double)l;	x2 = (double)zaIndex->h;	y2 = (double)zaIndex->k;	z2 = (double)zaIndex->l;	CrossProduct(&u2,&v2,&w2,x1,y1,z1,x2,y2,z2);	theG->h = (short)u2;	theG->k = (short)v2;	theG->l = (short)w2;	theG->direction = true;	theG->reduceFlag = true;	//h1 and h2 etc are only changed if zaIndex and this are not same crystal	h = h1;	k = k1;	l = l1;	zaIndex->h = h2;	zaIndex->k = k2;	zaIndex->l = l2;	theG->ReduceIndex();	theG->direction = false;	return true;}#pragma segment Mainvoid Index::FindLowestDiffractingG(void){		short h1,k1,l1,i = 1;	dcomplex sF;	if(direction)return;	h1 = h;	k1 = k;	l1 = l;	while(fabs(sF.r) < 0.01 && i < 8){			sF	= GetStructureFactor();			i++;			h1 = h * i;			k1 = k * i;			l1 = l * i;	}	h = h1;	k = k1;	l = l1;}#pragma segment Maindcomplex Index::GetStructureFactor(void){	Ptr*		theHandle;	double 	*theUs,*theVs,*theWs,*theZs,*theBs;	dcomplex	sF;	dcomplex cAb;	double  dspacing;	short atom_Count;	dspacing = 1/TheDSpacing();	theHandle = theCrystal->AtomicScatteringSet(1,1);//(electronMass Ratio = 1 && electron is beamtype	sF.r = 0; sF.i = 0;	if(!SetScatteringPosAIntensity(theCrystal,&theUs,&theVs,&theWs,&theZs,&theBs,&atom_Count)) return sF;	sF = TotalStructureFactor(h,k,l,theUs,theVs,theWs,atom_Count,theZs,theBs,theCrystal->volume,dspacing,theCrystal,&cAb);	theCrystal->ClearAtomicScatSet(theHandle);	KillPtr((Ptr)theUs);	return sF;}