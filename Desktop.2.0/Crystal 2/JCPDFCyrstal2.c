typedef struct	ElementKeyComplet{  // PDF2.S018	int 		offSet;	int			size;	int			theCSReq[5];}ElementKeyComplet;void SearchObject::MakeElementKey(KeyElementNBS* theValue,long noFound){	short i,k,l;	unsigned short flag[16],macFlag[16];	unsigned short theNum;		KeyElementNBS	*theSets,*theSet;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flagEOF = true,flagFound = true;	OSErr 		theErr;	long		number = 30000;	char		*theText[30],testLength = 2;	short		refNum,vRefNum;	Handle		theValues[30];	long		dataLength[30],l;	long		foundCrys[30];	char		aText[255];	long int	offSet;	short		compare;	ElementKeyComplet** theKey,	if(!logic || noDifrntElem < 1)return 0L;	SetConversionFlags(flag,macFlag);	switch(dataBase){		case 3:			return SearchElementKeyJC(logic, totalFound);		break;		case 4:			sprintf(aText,"CRYSTAL.S02");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum))return 0L;		break;			default:		return 0L;	}	theErr 			= 	GetEOF(refNum,&curEOF);		sizeOfBlock 	= 	sizeof(KeyElementNBS) * number ;	theSets 		= 	(KeyElementNBS*) D_NewPtr(sizeOfBlock);		number 			= 	30000;	sizeOfBlock 	= 	sizeof(KeyElementNBS) * number ;	m = -1;	theKey			=	D_NewHandle(sizeof(ElementKeyComplet) * 90000);	flagEOF = true;	D_HLock(theKey);	do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flagEOF = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyElementNBS);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));		theSet = theSets;		for(i = 0; i < number;i++,theSet++)		{			flagFound = false;			element = GetAtomicNumber(theValue->element);			for(i = 0 i < noFound;i++,theKey++){				if(theKey->offSet == theValue->offSet){					flagFound = true;					goto FOUNDACRYSTAL;				}			}			if(!flagFound){				noFound++;				aKey = (*theKey[noFound]);				for(k = 0; k <= 5; k++) aKey->theCSReq[k] = 0;				aKey->offSet = theValue->offSet;				aKey->size = theValue->size;			}else{				aKey = (*theKey[i]);			}			if(10 >= element && element <= 85){					k = (element - 10)/ 16;					l = (element - 10) - (k * 16);					theNum = flag[l];					aKey->theCSReq[k] += theNum;			}			for(element < 10){				element += 86;				k = (element) / 16;				l = element - (k * 16);				theNum = flag[l];				aKey->theCSReq[k] += theNum;			}		}	}while(flagEOF && !Quit());				qsort(theKey,noFound,sizeof(ElementKeyComplet),(/*__cmp_func*/_Cmpfun* )IndexCompare);	D_HUnlock(theKey);		gTheFile->SaveFileOpen(DIF_OBJ);	gTheFile->WriteHandle(theKey);	gTheFile->DoFileClose();}short	IndexCompare(ElementKeyComplet* x,ElementKeyComplet* y){	double z1 = 0,z2 = 0;	double i;	for(i = 0;i <= 5;i += 1)  z1 += x->theCSReq[i] * pow(2,i);	for(i = 0;i <= 5;i += 1)  z2 += y->theCSReq[i] * pow(2,i);		return((short)((z1 > z2) ? -1 : ((z1 == z2) ? 0 : 1)));}