#include	"Diffract_INCs.h"#include 	"JCPDFCrystal.h"#include 	"ITCCrystalDef.h"#include	"Dir_Paths.h"KeyDMElement* SortAndSearch(long cmpOffSet,KeyDMElement *theKeys,long total,long *final);void JCPDFCrystal::MakeElementKey(short dataBase,DialogPtr zDialog){	KeyElementNBS	*theSets,*theSet;	long 			i,sizeOfBlock,curEOF;	Boolean			flagEOF = true,flag = true;;	OSErr 			theErr;	long			start = 0,m = -1;	short			refNum,vRefNum;	long			dataLength,number,posOff;	KeyDMElement	*baseValue,theValue,*aValue;	Handle			baseValues;	short			kk,kp,jp;	long			totalCrys,structSize;	char			aText[250];	long			element[4];	FSSpec 			dir;	float			totalCycles;		switch(dataBase){		case 3:			MakeElementKeyJC(zDialog);		return;		case 4:			sprintf(aText,"CRYSTAL.S02");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return ;}		break;			default:		return;	}	theErr 			= 	GetEOF(refNum,&curEOF);	number 			=	dataLength	=	3000;		sizeOfBlock 	= 	sizeof(KeyElementNBS) * number ;	theSets 		= 	(KeyElementNBS*) D_NewPtr(sizeOfBlock);		baseValues 		=  	D_NewHandle((dataLength + 1) * sizeof(KeyDMElement));	//	tempValue		=	(KeyDMElement*)D_NewPtr((dataLength + 1) * sizeof(KeyDMElement));	D_HLock				(baseValues);	baseValue 		= 	(KeyDMElement*)*baseValues;	sizeOfBlock 	= 	sizeof(KeyElementNBS) * number ;	structSize		=	sizeof(KeyDMElement);	aValue 			= 	baseValue;	aValue->offSet 	= 	0;	aValue->size 	= 	0;	for(i = 0; i < 4;i++)aValue->elements[i] = 0L;	for(i = 0;i < 4;i++)element[i] = 0;	totalCrys = 0;	totalCycles = curEOF/ sizeOfBlock;	do{		long set;		set = 1L;		number 			=	3000;		sprintf(gTheText,"Percentage Completed %6.2f,TAKES SOME TIME,NEED 2 MB,cmd-. to stop,Must Be and Will Be Stored In DM Crystal Folder",(100 * (m + 1))/totalCycles);		c2pstr(gTheText);		SetItemText(zDialog,5,pTheText);		m++;			theSet = theSets;		posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyElementNBS);//KeySpaceGrpNBS		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));		if(m == 0){//seed the array so SortSearch works			aValue->offSet = ConvertToMac(theSet->offSet);			aValue->size 	= ConvertToMac(theSet->size);			aText[0] = theSet->element[0];			aText[1] = theSet->element[1];			aText[2] = 0;			kk = this->TheAtomicNum(aText);			kk--;			jp = kk >> 5;//(divide by 32)			kp = kk%32; // get the remainder: gives number of shifts			aValue->elements[jp] = (set << kp); //(sets the bit in the 1 position to the correct power)			number--;			theSet++;			totalCrys++;		}				for(i = 0; i < number;i++,theSet++)		{			long final;									theValue.offSet = ConvertToMac(theSet->offSet);			theValue.size 	= ConvertToMac(theSet->size);			aText[0] = theSet->element[0];			aText[1] = theSet->element[1];			aText[2] = 0;			kk = this->TheAtomicNum(aText);			kk--;			jp = kk >> 5;//(divide by 32)			kp = kk%32; // get the remainder: gives number of shifts			element[jp] += (set << kp); //(sets the bit in the 1 position to the correct power)			aValue = SortAndSearch(theValue.offSet,baseValue,totalCrys,&final);			if(final != 0){				KeyDMElement *repValue,*incValue,*lastValue;				totalCrys++;				if(!CheckHandleSize(baseValues,&dataLength,totalCrys,structSize)){					baseValue = (KeyDMElement*)*baseValues;					lastValue = &(baseValue[totalCrys - 1]);					goto TEST_SAVE;				}else{					 baseValue = (KeyDMElement*)*baseValues;					 lastValue = &(baseValue[totalCrys - 1]);					 					 if(curEOF == 0){						StopAlert(OUT_OF_MEM,NUL);					 }				}				if(final > 0)aValue++;												for(incValue = lastValue,repValue = &lastValue[-1];incValue > aValue && repValue >= baseValue;incValue--,repValue--){					*incValue = *repValue;				}				if(final > 0)aValue--;				aValue->size 	= theValue.size;				aValue->offSet 	= theValue.offSet;				for(kk = 0; kk < 4;kk++)aValue->elements[kk] = element[kk];				element[jp] = 0L;							}else{				aValue->elements[jp] += element[jp];				element[jp] = 0L;			}					}	}while(flag && !Quit());	TEST_SAVE:	theErr = 	FSClose(refNum);		//gTheFile->fileError = GetDirPath(SEARCH_DMCRYSTALS,&dir);	gTheFile->fileError = 	SetSearchVol('UnC2',&dir);	gTheFile->DoFileError();	if(gTheFile->fileError) goto CANT_STORE_2;	if(!gTheFile->CreateNewFile('TEXT',"NBS ELEMENT KEY"))goto CANT_STORE_2;	if(!gTheFile->file_is_Open)		goto CANT_STORE_2;	//	gTheFile->SaveFileOpen('TEXT');//	if(gTheFile->fileError)goto CANT_STORE_2 ;		baseValue =	(KeyDMElement*)*baseValues;		//gTheFile->WriteDataBlock((Ptr)baseValue,(sizeof(KeyDMElement) * totalCrys));	sizeOfBlock = (sizeof(KeyDMElement) * totalCrys);	theErr = 	FSWrite(refNum,&sizeOfBlock,(Ptr)(baseValue));	gTheFile->DoFileClose();CANT_STORE_2:	KillPtr		(theSets);	D_HUnlock	((Handle)baseValues);	KillHandle((Handle*)&baseValues);}void JCPDFCrystal::MakeElementKeyJC(DialogPtr zDialog){	KeyElementsJC	*theSets,*theSet;	long 			i,sizeOfBlock,curEOF;	Boolean			flagEOF = true,flag = true;;	OSErr 			theErr;	long			start = 0,m = -1;	short			refNum,vRefNum;	long			dataLength,number,posOff;	KeyDMElement	*baseValue,theValue,*aValue;	Handle			baseValues;	short			kk,kp,jp;	long			totalCrys,structSize;	char			aText[250];	long			element[4];	FSSpec 			dir;	float			totalCycles;			sprintf(aText,"PDF2.S06");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return ;}	theErr 			= 	GetEOF(refNum,&curEOF);	number 			=	dataLength	=	3000;		sizeOfBlock 	= 	sizeof(KeyElementsJC) * number ;	theSets 		= 	(KeyElementsJC*) D_NewPtr(sizeOfBlock);		baseValues 		=  	D_NewHandle((dataLength + 1) * sizeof(KeyDMElement));	//	tempValue		=	(KeyDMElement*)D_NewPtr((dataLength + 1) * sizeof(KeyDMElement));	D_HLock				(baseValues);	baseValue 		= 	(KeyDMElement*)*baseValues;	sizeOfBlock 	= 	sizeof(KeyElementsJC) * number ;	structSize		=	sizeof(KeyDMElement);	aValue 			= 	baseValue;	aValue->offSet 	= 	0;	aValue->size 	= 	0;	for(i = 0; i < 4;i++)aValue->elements[i] = 0L;	for(i = 0;i < 4;i++)element[i] = 0;	totalCrys = 0;	totalCycles = curEOF/ sizeOfBlock;	do{		long set;		set = 1L;		number 			=	3000;		sprintf(gTheText,"Percentage Completed %6.2f,TAKES SOME TIME,NEED 2 MB,cmd-. to stop,Must Be and Will Be Stored In DM Crystal Folder",(100 * (m + 1))/totalCycles);		c2pstr(gTheText);		SetItemText(zDialog,5,pTheText);		m++;			theSet = theSets;		posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyElementsJC);//KeySpaceGrpNBS		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));		if(m == 0){//seed the array so SortSearch works			aValue->offSet = ConvertToMac(theSet->offSet);			aValue->size 	= ConvertToMac(theSet->size);			aText[0] = theSet->element[0];			aText[1] = theSet->element[1];			aText[2] = 0;			kk = this->TheAtomicNum(aText);			kk--;			jp = kk >> 5;//(divide by 32)			kp = kk%32; // get the remainder: gives number of shifts			aValue->elements[jp] = (set << kp); //(sets the bit in the 1 position to the correct power)			number--;			theSet++;			totalCrys++;		}				for(i = 0; i < number;i++,theSet++)		{			long final;									theValue.offSet = ConvertToMac(theSet->offSet);			theValue.size 	= ConvertToMac(theSet->size);			aText[0] = theSet->element[0];			aText[1] = theSet->element[1];			aText[2] = 0;			kk = this->TheAtomicNum(aText);			kk--;			jp = kk >> 5;//(divide by 32)			kp = kk%32; // get the remainder: gives number of shifts			element[jp] += (set << kp); //(sets the bit in the 1 position to the correct power)			aValue = SortAndSearch(theValue.offSet,baseValue,totalCrys,&final);			if(final != 0){				KeyDMElement *repValue,*incValue,*lastValue;				totalCrys++;				if(!CheckHandleSize(baseValues,&dataLength,totalCrys,structSize)){					baseValue = (KeyDMElement*)*baseValues;					lastValue = &(baseValue[totalCrys - 1]);					goto TEST_SAVE;				}else{					 baseValue = (KeyDMElement*)*baseValues;					 lastValue = &(baseValue[totalCrys - 1]);					 					 if(curEOF == 0){						StopAlert(OUT_OF_MEM,NUL);					 }				}				if(final > 0)aValue++;												for(incValue = lastValue,repValue = &lastValue[-1];incValue > aValue && repValue >= baseValue;incValue--,repValue--){					*incValue = *repValue;				}				if(final > 0)aValue--;				aValue->size 	= theValue.size;				aValue->offSet 	= theValue.offSet;				for(kk = 0; kk < 4;kk++)aValue->elements[kk] = element[kk];				element[jp] = 0L;							}else{				aValue->elements[jp] += element[jp];				element[jp] = 0L;			}					}	}while(flag && !Quit());	TEST_SAVE:	theErr = 	FSClose(refNum);		//gTheFile->fileError = GetDirPath(SEARCH_DMCRYSTALS,&dir);	gTheFile->fileError = 	SetSearchVol('UnC2',&dir);	gTheFile->DoFileError();	if(gTheFile->fileError) goto CANT_STORE_2;	if(!gTheFile->CreateNewFile('TEXT',"JCPDF ELEMENT KEY"))goto CANT_STORE_2;	if(!gTheFile->file_is_Open)		goto CANT_STORE_2;	//	gTheFile->SaveFileOpen('TEXT');//	if(gTheFile->fileError)goto CANT_STORE_2 ;		baseValue =	(KeyDMElement*)*baseValues;		//gTheFile->WriteDataBlock((Ptr)baseValue,(sizeof(KeyDMElement) * totalCrys));	sizeOfBlock = (sizeof(KeyDMElement) * totalCrys);	theErr = 	FSWrite(refNum,&sizeOfBlock,(Ptr)(baseValue));	gTheFile->DoFileClose();CANT_STORE_2:	KillPtr		(theSets);	D_HUnlock	((Handle)baseValues);	KillHandle((Handle*)&baseValues);}KeyDMElement* SortAndSearch(long cmpOffSet,KeyDMElement *theKeys,long total,long *final){	KeyDMElement *low = &theKeys[0];	KeyDMElement *high = &theKeys[total];	KeyDMElement *mid;	long			cond;	while (low < high){		mid = low + ( high - low) / 2;		cond = (cmpOffSet - mid->offSet);		if(cond > 0){			low = mid + 1;		}else if(cond < 0){			high = mid;		}else{			*final = 0;			return mid;		}	}	cond = (cmpOffSet - low->offSet);	*final = cond;	return low;}/*void OpenFolder(void){	//FSSpec	theFSSpec;	FSSpec	*theFSSpec	if(gAppleEvtsOK){					gTheFile->fileError = GetDirPath(SEARCH_DMCRYSTALS,theFSSpec);		gTheFile->DoFileError();		if(gTheFile->fileError) return;		//theFSSpec.parID 	= GetDirIDFromFSSpec(theFSSpec);	} else {		char fName[255];		HFileInfo		myCPB;			    gTheFile->fileError = HGetVol((unsigned char*)fName,&myCPB.ioVRefNum,&myCPB.ioDirID);	    if(gTheFile->fileError != 0) gTheFile->DoFileError();	    myCPB.ioNamePtr = (StringPtr)fName;	    sprintf(fName,"Desktop Crystals");	    c2pstr(fName);	    myCPB.ioFDirIndex = 0;	    PBGetCatInfo((CInfoPBPtr)&myCPB,false);	    *theFSSpec.parID 	= myCPB.ioDirID;	    *theFSSpec.vRefNum	= myCPB.ioDirID;	  }  }*/Handle	JCPDFCrystal::SearchElementKey		(short logic,long *totalFound,short dataBase,short allowed,char *theText2){	KeyDMElement		*theSets,*theSet;	long 				i,k,sizeOfBlock,curEOF,oldCurEOF;	Boolean				flagEOF = true,flag = true;;	OSErr 				theErr;	long				number,start = 0,m = -1;	short				refNum,vRefNum;	long				l,maxFound,dataLength,posOff;	char				aText[255];	DataBaseLoc			*tempValue,*temp2,*baseValue,*theValue;	Handle				baseValues;	short				p,reqMatches;	long				set = 1L,notElements[4],mustElements[4];		if(!logic)return 0L;	switch(dataBase){		case 3:			sprintf(aText,"JCPDF ELEMENT KEY");			if(OpenNamedFileEM(SEARCH_DMCRYSTALS,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}		break;		case 4:			sprintf(aText,"NBS ELEMENT KEY");			if(OpenNamedFileEM(SEARCH_DMCRYSTALS,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}		break;			default:		return 0L;	}	theErr 			= 	GetEOF(refNum,&curEOF);	number 			= 	5000;		sizeOfBlock 	= 	sizeof(KeyDMElement) * number;	theSets 		= 	(KeyDMElement*) D_NewPtr(sizeOfBlock);	dataLength		=	1000;	baseValues 		=  	D_NewHandle((dataLength + 1) * sizeof(DataBaseLoc));		tempValue		=	(DataBaseLoc*)D_NewPtr((dataLength + 1) * sizeof(DataBaseLoc));	D_HLock				(baseValues);	baseValue 		= 	(DataBaseLoc*)*baseValues;	for(i = 0; i < 4;i++){mustElements[i] = 0L;notElements[i] = 0L;}		set = 1L;//this is the variable used to set the bits in the test key			reqMatches = 0;	for(i = 0; i < 96; i++){		long j,k;		set = 1L;		if(theSearchObj->theElements[1][i]){//required elements			j = i >> 5;//(divide by 32)			k = i%32; // get the remainder: gives number of shifts			mustElements[j] += (set << k); //(sets the bit in the 1 position to the correct power)			reqMatches++;		}		if(!(theSearchObj->theElements[1][i] || theSearchObj->theElements[0][i])){//required elements			j = i >> 5;//(divide by 32)			k = i%32; // get the remainder: gives number of shifts			notElements[j] += (set << k); //(sets the bit in the 1 position to the correct power)		}	}	if(reqMatches == 0)return 0L;		l = 0;	maxFound = 0;	theValue = baseValue;	m = -1;	oldCurEOF = curEOF;	do{		m++;			theSet = theSets;		posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyDMElement);//KeySpaceGrpNBS		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));		for(i = 0; i < number;i++,theSet++)		{			long mm;			for(k = 0; k < 4;k++){				mm = theSet->elements[k] & mustElements[k];				if((~mm & mustElements[k])){//fix					goto CONTINUE_IT;				}			}			for(k = 0; k < 4;k++){				if(theSet->elements[k] & notElements[k]){//fix					goto CONTINUE_IT;				}			}			theValue->size 		= theSet->size;			theValue->offSet 	= theSet->offSet;								maxFound++;			theValue++;			CONTINUE_IT:;		}											}while(flag && !Quit());		theErr = 	FSClose(refNum);	EliminateBadCrys(baseValue,tempValue, &maxFound);	theValue = baseValue = (DataBaseLoc*)*baseValues;	temp2 = tempValue;	for(p = 0; p < maxFound;p++,theValue++,temp2++) *theValue = *temp2;					KillPtr		(theSets);	KillPtr		(tempValue);	D_HUnlock	((Handle)baseValues);		*totalFound = maxFound;	if(maxFound == 0){KillHandle((Handle*)&baseValues);  return 0L;}	return baseValues;	}