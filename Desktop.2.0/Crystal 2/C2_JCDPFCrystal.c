//C2_JCDPFCrystal.c#include	"Diffract_INCs.h"#include 	"JCPDFCrystal.h"#include 	"ITCCrystalDef.h"#include	"Dir_Paths.h"Boolean	JCPDFCrystal::InitCrystal(short theValue){	short i;	Boolean valueB;	valueB 			= inherited::InitCrystal(theValue);	radiation 		= 0;//added	source 			= 0;//added	structureCode 	= 0;//added	editorialCode 	= 0;//added	avgErr 			= 0;	cardNo			= 0;	fileNo			= 0;	edCodeAveErr 	= 0;	formUnits 		= 0;	edCodeFormU 	= 0;	qualityIndex 	= 0;	spGrpText 		= (char*)D_NewPtr(7 * sizeof(char));	spGrpText[0] 	= 0;	edCodeSpGr 		= 0;	aspectCode 		= 0;	orCodeSpGr 		= 0;	densityMeasured = 0;	materialClass 	= 0;	empiricalText 	= (char*)D_NewPtr(1 * sizeof(char));	empiricalText[0] = NUL;	pearsonNum  	= 0;	edCodPearson 	= 0;	structType 		= (char*)D_NewPtr(1 * sizeof(char));	structType[0] 	= NUL;	comments 		= (char*)D_NewPtr(1 * sizeof(char));	comments[0] 	= NUL;	crystalDataCell.a = 0;	crystalDataCell.alpha = 0;	standardDev.a = 0;	standardDev.alpha = 0;	reducedForm  	= 0;	firstDetermRatio = 0;	secDetermRatio 	= 0;	density 		= 0;	nameCode 		= 0;	Identity_Matrix		(cMatrix);	for(i = 0; i <= 99;i++){		expDspacings[i].x = 0;		expDspacings[i].y = 0;		expDspacings[i].z = 0;		expDspacings[i].intensity = 0;		expDspacings[i].h = 1;		expDspacings[i].k = 0;		expDspacings[i].l = 0;	}	numExpLines = 0;	return valueB;}Boolean	JCPDFCrystal::DecipherJCPDFLine(char *theText,short *lines){	if(theText[68] == 'A' || theText[68] == 'D' ) return false;	switch(theText[79])	{		case '1':			OriginalCellParameters(theText);		break;		case '2':			CellDeviations(theText);		break;		case '3':			SpaceGroupLine(theText);		break;		case '4':			CrystalData(theText);		break;		case '5':			MaterialClass(theText);		break;		case '6':			CompoundName(theText,lines);		break;		case '7':			ChemicalFormulaJCPDF(theText,lines);		break;		case '8':			EmpiricalFormula(theText,lines);		break;		case '9':			LitReference(theText,lines);		break;		case 'A':			StructureType(theText,lines);		break;		case 'B':			Comments(theText,lines);		break;		case 'C':			MatrixInitialCell(theText);		break;		case 'D':			ReducedCell(theText);		break;		case 'E':			CrystalDataCell(theText);		break;		case 'F':			RadiationExact(theText);		break;		case 'G':					break;		case 'H':		break;		case 'I':			LinesPosAndHKL(theText,lines);		break;		case 'J':			Update(theText);		break;			case 'K':			ProcessingHistory(theText,lines);		break;		default:		break;	}	return true;}void	JCPDFCrystal::OriginalCellParameters(char *theText){	ReadUnitCell(&theUnitCell,theText,9,8);	switch(theText[78])	{		case 'A':			lattice_Type = TRICLINIC;			break;		case 'M':			lattice_Type = MONOCLINIC;			break;		case 'O':			lattice_Type = ORTHORHOMBIC;			break;		case 'T':			lattice_Type = TETRAGONAL;			break;		case 'H':			lattice_Type = HEXAGONAL;			break;		case 'R':			lattice_Type = TRIGHEX;			break;		case 'C':			lattice_Type = CUBIC;			break;		default:			lattice_Type = CUBIC;			break;	}	JustifyUCellToLatType	(&theUnitCell);	radiation 		= theText[64];	source 			= theText[66];	structureCode 	= theText[69];	editorialCode 	= theText[52];	leastSquares[0] = theText[53];	leastSquares[1] = theText[54];	strncpy(pdfNorID,&theText[72],6);	pdfNorID[6] = 0;	{		char aText[5];		strncpy(aText,pdfNorID,2);		aText[2] = 0;		cardNo = atof(aText);		strncpy(aText,&pdfNorID[2],4);		aText[4] = 0;		fileNo = atof(aText);;	}}void	JCPDFCrystal::ReadUnitCell(UnitCell *theCell,char* theText,short length,short angle){	char 	aText[255];	short	posOff = 0;	aText[length] 	= 	0;	strncpy				(aText,theText,length);	theCell->a 		= 	atof(aText);	posOff 			+= 	length;	strncpy				(aText,&theText[posOff],length);	theCell->b 		= 	atof(aText);	posOff 			+= 	length;	strncpy				(aText,&theText[posOff],length);	theCell->c 		= 	atof(aText);	posOff 			+= 	length;		aText[angle] 	= 	0;	strncpy				(aText,&theText[posOff],angle);	theCell->alpha 	= 	atof(aText);	posOff 			+= 	angle;	strncpy(aText,&theText[posOff],angle);	theCell->beta = atof(aText);	posOff += angle;	strncpy(aText,&theText[posOff],angle);	theCell->gamma = atof(aText);}void 	JCPDFCrystal::CopyCrystalWDspacing(Crystal *theCrystal){	short i,n;	GetSvals();	CellVolume();	if(numExpLines < MAX_STORE_DSPACE)		SetDSpace();	inherited::CopyCrystal(theCrystal);				if(MAX_STORE_DSPACE > numExpLines)n = numExpLines;	else n = MAX_STORE_DSPACE; 	for(i = 0; i< n;i++){		 theCrystal->dspacings[i] = expDspacings[i];			 theCrystal->dspacings[i].theCrystal = theCrystal;	}}void	JCPDFCrystal::JustifyUCellToLatType	(UnitCell *theCell){				switch(lattice_Type){		case	CUBIC:			theCell->c = theCell->b = theCell->a;			theCell->alpha = theCell->beta = theCell->gamma = 90;			break;		case	TETRAGONAL:			theCell->b = theCell->a;			theCell->alpha = theCell->beta = theCell->gamma = 90;			break;		case	ORTHORHOMBIC:			theCell->alpha = theCell->beta = theCell->gamma = 90;			break;		case	TRIGONAL:		case	HEXAGONAL:			theCell->b = theCell->a;			theCell->alpha = theCell->beta = 90;			theCell->gamma = 120;			break;		case	TRIGHEX:			theCell->c = theCell->b = theCell->a;			theCell->beta = theCell->gamma = theCell->alpha;			break;				case	MONOCLINIC:			if(fabs(theCell->alpha) > 0) {				theCell->beta = theCell->gamma = 90;				break;			}			if(fabs(theCell->beta) > 0){				theCell->alpha = theCell->gamma = 90;				break;			}			if(fabs(theCell->gamma) > 0){				theCell->alpha = theCell->beta = 90;				break;			}			break;		default:			break;	}}void	JCPDFCrystal::CellDeviations(char *theText){	char aText[255];	ReadUnitCell(&standardDev,theText,9,8);	JustifyUCellToLatType	(&standardDev);	aText[4] = 0;	strncpy		(aText,&theText[52],4);	avgErr 			= atof(aText) / 100000;	edCodeAveErr 	= theText[56];	qualityIndex 	= 256 * theText[58] + theText[59];		}void	JCPDFCrystal::SpaceGroupLine(char *theText){	strncpy(spGrpText,theText,4);	spGrpText[4] = 0;	edCodeSpGr 	= 	theText[8];	aspectCode	=	theText[10];	spaceGrpNm	=	(short)GetDataBaseValue(&theText[11],3);	orCodeSpGr	=	theText[14];	formUnits	=	(float)GetDataBaseValue(&theText[19],6);	edCodeFormU	=	theText[25];		densityMeasured	=	GetDataBaseValue(&theText[29],6);	density			=	GetDataBaseValue(&theText[37],6);	volume			=	GetDataBaseValue(&theText[60],9);}float	JCPDFCrystal::GetDataBaseValue(char *theText,short numberChar){	char aText[255];	strncpy(aText,theText,numberChar);	aText[numberChar] = 0;	return atof(aText);}void	JCPDFCrystal::CrystalData(char *theText){	theText[0] = 0;}void	JCPDFCrystal::MaterialClass(char *theText){	short i;	for(i = 0; i < 3;i++){		if(theText[i] != ' ')			materialClass = theText[i];	}	for(i = 0; i < 6;i++){		cmpdResidue[i] = theText[(i * 4) + 24];		strncpy(&(cmpdSubForm[i][0]),&theText[(i * 4) + 25],3);		cmpdSubForm[i][3] = 0;	}	strncpy(chemAbsRegistry,&theText[53],11);	chemAbsRegistry[11] = 0;	if(theText[70] != ' ')addRegisterFlag = true;}void	JCPDFCrystal::CompoundName(char *theText,short *lines){	nameCode = theText[68];	if(crystalName != 0L){		KillPtr((Ptr)crystalName);	}	crystalName = ReadLongName(theText,0,lines);	}void	JCPDFCrystal::ChemicalFormulaJCPDF(char *theText,short *lines){	if(formulaText != 0L){		KillPtr((Ptr)formulaText);	}	formulaText = ReadLongName(theText,0,lines);}char* JCPDFCrystal::ReadLongName(char *theText,short maxChar,short *lines){	char 	*aText;	char	*zText;	Boolean flag = true;	short 	i = 0,j = 0;	if(theText[68] == 'A' || theText[68] == 'D' ){			zText = (char*)D_NewPtr(sizeof(char) * (2));			zText[0] = 0;		return zText;	}	if(maxChar == 0) maxChar = 66;	aText = (char*)D_NewPtr(sizeof(char) * 1500);	while(flag && i < 1500){		if(theText[i] == ' ' && theText[i + 1] == ' ')			flag = false;		if(j > maxChar || flag == false){			if(theText[69] == 'C'){				theText = &(theText)[80];				j = 0;				*lines += 1;				flag = true;			}else{				flag = false;			}		}		aText[i] = theText[j];		i++;		j++;	}	aText[i] = 0;	if(i <= 1) i = 2;	zText = (char*)D_NewPtr(sizeof(char) * (i + 1));		strcpy(zText,aText);	KillPtr((Ptr)aText);	return zText;}void	JCPDFCrystal::EmpiricalFormula(char *theText,short *lines){	if(empiricalText != 0L){		KillPtr((Ptr)empiricalText);	}	empiricalText = ReadLongName(theText,0,lines);}void	JCPDFCrystal::LitReference(char *theText,short *lines){	short volN,pgNum;	char	cText[200];		strncpy(cODEN,theText,6);	cODEN[6] = 0;	ConvertCODENToJournal();	year	=	(short)GetDataBaseValue(&theText[16],4);	volN	=	(short)GetDataBaseValue(&theText[6],4);	pgNum	=	(short)GetDataBaseValue(&theText[10],5);		sprintf(cText,"%4d/%5d",volN,pgNum);	strcpy(reference,cText);	if(author != 0){		KillPtr((Ptr)author);	}	author =  ReadLongName(&(theText[21]),46,lines);	strncpy(refCode,&theText[67],2);}void	JCPDFCrystal::StructureType(char *theText,short *lines){	strncpy(pearsonSym,theText,2);	pearsonNum =	GetDataBaseValue(&theText[2],7);	edCodPearson = theText[9];	if(structType != 0){		KillPtr((Ptr)structType);	}	structType =  ReadLongName(&(theText[17]),50,lines);}void	JCPDFCrystal::Comments(char *theText,short *lines){	if(comments != 0){			KillPtr((Ptr)comments);	}	comments =  ReadLongName(theText,0,lines);}void	JCPDFCrystal::MatrixInitialCell(char *theText){	cMatrix[0][0] = GetDataBaseValue(&theText[6],5);	cMatrix[0][1] = GetDataBaseValue(&theText[12],5);	cMatrix[0][2] = GetDataBaseValue(&theText[18],5);		cMatrix[1][0] = GetDataBaseValue(&theText[25],5);	cMatrix[1][1] = GetDataBaseValue(&theText[31],5);	cMatrix[1][2] = GetDataBaseValue(&theText[37],5);		cMatrix[2][0] = GetDataBaseValue(&theText[44],5);	cMatrix[2][1] = GetDataBaseValue(&theText[50],5);	cMatrix[2][2] = GetDataBaseValue(&theText[56],5);}void	JCPDFCrystal::ReducedCell(char *theText){		ReadUnitCell(&theReducedCell,theText,8,7);	JustifyUCellToLatType(&theReducedCell);	volumeReduced = GetDataBaseValue(&theText[45],9);	reducedForm		=	(short)GetDataBaseValue(&theText[65],2);}void	JCPDFCrystal::CrystalDataCell(char *theText){	ReadUnitCell(&crystalDataCell,theText,8,7);	JustifyUCellToLatType(&crystalDataCell);	firstDetermRatio = GetDataBaseValue(&theText[45],9);	secDetermRatio = GetDataBaseValue(&theText[54],9);}void	JCPDFCrystal::RadiationExact(char *theText){	theText[0] = 0;}void	JCPDFCrystal::LinesPosAndHKL(char *theText,short *lines){	Boolean flag = true;	short	i = 0,j = 0,k;	char	*aText;	aText = theText;	while(flag && i < 96){		for(k = 0 ; k <= 46;k += 23){			expDspacings[i].x = GetDataBaseValue(&(aText[k]),7);			expDspacings[i].intensity = GetDataBaseValue(&(aText[7 + k]),3) / 100;			expDspacings[i].h = GetDataBaseValue(&(aText[11 + k]),3);			expDspacings[i].k = GetDataBaseValue(&(aText[13 + k]),3);			expDspacings[i].l = GetDataBaseValue(&(aText[16 + k]),3);			i++;			numExpLines++;		}		(*lines)++;		if(aText[159] != 'I') flag = false;		aText = &(aText[80]);	}	(*lines)--;}void	JCPDFCrystal::Update(char *theText){	theText[0] = 0;}void	JCPDFCrystal::ProcessingHistory(char *theText,short *lines){	char *history;	history =  ReadLongName(theText,0,lines);	KillPtr((Ptr)history);}void	JCPDFCrystal::DrawCard(void){	}void	JCPDFCrystal::DoClose(void){	KillPtr((Ptr)spGrpText);	KillPtr((Ptr)empiricalText);	KillPtr((Ptr)structType);	KillPtr((Ptr)comments);		inherited::DoClose();}void JCPDFCrystal::AtomsFromFormula(short totalAtoms){		totalAtoms = atom_Count = -1;	D_HLock(theAtoms); 	AtomsFromFormulaUnit(formulaText);	D_HUnlock(theAtoms); 	ReconfigureElementList();}void 	JCPDFCrystal::GeneratePotentialAtomPos(void){	if(spaceGrpNm > 0){		ITCCrystalObject *testCrystal;		testCrystal = (ITCCrystalObject*)D_new(ITCCrystalObject);		testCrystal->InitCrystal(0);		CopyCrystal(testCrystal);		testCrystal->JustifyAtomPositions(formUnits);		testCrystal->CopyCrystal(this);		testCrystal->DoClose();	}}char* JCPDFCrystal::AtomsFromFormulaUnit(char *charText){	short 	i,k,l,m;	long 	sizeOfTheAtoms;	short 	theElement,originalPos;	long	atom_Max;	short 	theNumber; 	char 	theText[6];	AtomPtr theAtomPtr,theAtomsPtr;	Boolean flag,flag1,flag2;	char	theNumbers[3] = {'0',/*'1','2','3','4','5','6','7','8',*/'9','.'};	char	theCaps[2] = {'A',/*'B','C','D','E','F','G','H','I','J','K',     					'L','M','N','O','P','Q','R','S','T','U','V','W','X','Y',*/'Z'};    char    theLower[2] = {'a',/*'b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',    						'q','r','s','t','u','v','w','x','y',*/'z'};      		i = 0,	originalPos = atom_Max = atom_Count;	m = 0;	if(originalPos < 0) originalPos = 0;	theAtomsPtr = &((*theAtoms)[originalPos]);	sizeOfTheAtoms = sizeof(Atom);	if(*charText == NUL) return charText;	while(*charText != ')' && *charText != ']')	{		if(*charText == NUL) return charText;		if(*charText == '(' || *charText == '['){			charText++;			charText = AtomsFromFormulaUnit(charText);			if(*charText == 0) return 0;		}		flag = false;		flag1 = false;		l = 0;		k = 0;		theElement = 0;		if(*charText >= theCaps[0] && *charText <= theCaps[1]){theText[l++] = *charText;flag = true;++charText;}				if(flag){			if(*charText >= theLower[0] || *charText <= theLower[1]) { 					flag1 = true;					theText[l++] = *charText;					++charText;			}		}		theText[l] = NUL;		if(l >= 1) theElement = this->TheAtomicNum(theText);					k = 0;		l = 0;		theNumber = 0;		flag2 = false;		if(flag){			while(*charText >= theNumbers[0] && *charText <= theNumbers[1] || *charText == theNumbers[2]) { 				flag2 = true;				theText[l++] = *charText;				++charText;			}		}		if(!flag2)theNumber = 1;		if(l > 0){			theText[l] = 0;			theNumber = atof(theText);		}		if(!flag) charText++;		else		{			if(theElement != 104){				for(k = 1; k <= theNumber;k++){					if(!CheckHandleSize((Handle)theAtoms,&atom_Max,(long)atom_Count,sizeOfTheAtoms)){						return 0;					}					atom_Count++;					theAtomPtr  = &((*theAtoms)[atom_Count]);										m++;					theAtomPtr->atomicNum = theElement;					theAtomPtr->x = 0;					theAtomPtr->y = 0;					theAtomPtr->z = 0;				}			}		}		}	theNumber = 0;	l = 0;	if(*charText == NUL) return charText;	if(*charText == ')' || *charText == ']'){		while(*charText >= theNumbers[0] && *charText <= theNumbers[1] ||*charText == theNumbers[2]) { 					flag2 = true;					theText[l++] = *charText;					++charText;			}			if(!flag2)theNumber = 1;	}	if(l > 0){		theText[l] = 0;		theNumber = atof(theText);	}	if(theNumber > 1){		theAtomsPtr = &((*theAtoms)[originalPos]);		for(i = 1; i < theNumber;i++){			for(k = 0; k < m;k++){				if(!CheckHandleSize((Handle)theAtoms,&atom_Max,atom_Count,sizeOfTheAtoms)){					return 0;				}				theAtomsPtr = &((*theAtoms)[originalPos]);				atom_Count++;				theAtomPtr  = &((*theAtoms)[atom_Count]);				theAtomPtr->atomicNum = theAtomsPtr[k].atomicNum;				theAtomPtr->x = 0;				theAtomPtr->y = 0;				theAtomPtr->z = 0;			}		}	}	if(atom_Count < 0){		theAtomPtr = &(theAtomsPtr[0]);		theAtomPtr->atomicNum = 29;		theAtomPtr->x = 0;		theAtomPtr->y = 0;		theAtomPtr->z = 0;		atom_Count = 0;	}		return charText;}Handle	JCPDFCrystal::SearchSpaceGrpKey(short logic,long *totalFound,short dataBase){	KeySpaceGrpNBS *theSets,*theSet;	long 		posOff = 0,m = -1,i,k,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		theText[10];	short		refNum,vRefNum,spcNum;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	short		lastSpcNum = 0,highSp,lowSp;	char		aText[255];	DataBaseLoc *theValue;	if(!logic)return 0L;	switch(dataBase){		case 3:			return 0L;		break;		case 4:			sprintf(aText,"CRYSTAL.S01");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}					break;		default:		break;	}	theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeySpaceGrpNBS) * number ;	theText[3] = 0;	theSets = (KeySpaceGrpNBS*) D_NewPtr(sizeOfBlock);	theValues = (DataBaseLoc**) D_NewHandle(500 * sizeof(DataBaseLoc));	foundCrys = 0;	dataLength = 500;	D_HLock((Handle)theValues);	theValue = *theValues;	lowSp = theSearchObj->logicFields.spaceGrpLow;	highSp = theSearchObj->logicFields.spaceGrpHigh;	do{		m++;			theSet = theSets;		posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeySpaceGrpNBS);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++,theSet++)		{			for(k = 0; k < 3;k++)				theText[k] = theSet->spaceGrp[k];			if(theText[0] == ' ' && theText[1] == ' ' && theText[2] == ' ')				continue;			spcNum = (short)atof(theText);			/*if(spcNum < lastSpcNum || spcNum < 0 || spcNum > spaceGrpNm){				if(posOff > curEOF/2){					flag = false;				}			}*/			lastSpcNum = spcNum;			if(lowSp <= spcNum && spcNum <= highSp){				if(foundCrys >= dataLength - 1){					if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;					theValue = &((*theValues)[foundCrys]);				}				foundCrys++;				theValue->offSet = ConvertToMac(theSet->offSet);				theValue->size = ConvertToMac(theSet->size);				theValue++;			}		}	}while(flag && !Quit());	*totalFound = 	foundCrys;	KillPtr			(theSets);	D_HUnlock		((Handle)theValues);	theErr 		= 	FSClose(refNum);		return (Handle)theValues;	}typedef struct	ElementCode{//CRYSTAL.S06	char		element[3];}ElementCode;short   OffsetCompareDB(DataBaseLoc* x,DataBaseLoc* y);short  	AlphabeticSort(ElementCode* x,ElementCode* y);short	AlphabetSortENBS(KeyElementNBS *x,KeyElementNBS *y);short OffsetCompareENBS(KeyElementNBS *x,KeyElementNBS *y);Handle JCPDFCrystal::SearchColorKeyNBS  (short logic,long *totalFound,short dataBase){	if(!logic)return 0L;	switch(dataBase){		case 3:			return SearchColorKeyJC( logic, totalFound);		break;		case 4:			return 0L;		break;		default:		return 0L;	}		return (Handle)0L;	}Handle	JCPDFCrystal::SearchVolumeKey			(short logic,long *totalFound,short dataBase){	KeyVolumeNBS *theSets,*theSet;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	double		compareL,compareH,compare2;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum;	DataBaseLoc	**theValues,*theValue;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	switch(dataBase){		case 3:			return SearchVolumeKeyJC( logic, totalFound);		break;		case 4:			sprintf(aText,"CRYSTAL.S04");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}					break;		default:		return 0L;	}	theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyVolumeNBS) * number ;		theSets 		= 	(KeyVolumeNBS*)D_NewPtr(sizeOfBlock);	dataLength 		= 	1000;	theValues 		= 	(DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	foundCrys =		 0;	D_HLock			((Handle)theValues);	theValue		=	(DataBaseLoc*)*theValues;	compareL			=	theSearchObj->logicFields.volumeLow * 100;	compareH			=	theSearchObj->logicFields.volumeHigh * 100;	compare2		=	volumeReduced * 100;	do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyVolumeNBS);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr 		= 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));		theSet		=	theSets;		for(i = 0; i < number;i++,theSet++)		{			double aValue;			aValue = (double)ConvertToMac(theSet->volume);			if(compareL <= aValue && aValue <= compareH){//InRange(aValue, compare,.1,0) ){				DataBaseLoc *theValue;								if(dataLength >= foundCrys){					if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;						theValue = &((*theValues)[foundCrys]);				}				theValue->offSet = ConvertToMac(theSet->offSet);				theValue->size = ConvertToMac(theSet->size);				foundCrys++;				theValue++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchDensityKey		(short logic,long *totalFound,short dataBase){	KeyDensityNBS *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum,l;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	double		compareL,compareH;	char		aText[255];	if(!logic)return 0L;	switch(dataBase){		case 3:			return SearchDensityKeyJC( logic, totalFound);		break;		case 4:			sprintf(aText,"CRYSTAL.S05");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}		break;		default:		return 0L;	}	theErr = GetEOF(refNum,&curEOF);//	if(densityMeasured > 1)	compare = densityMeasured * 100;//	else					compare = density * 100;	sizeOfBlock = sizeof(KeyDensityNBS) * number ;	theSets 		= 	(KeyDensityNBS*)D_NewPtr(sizeOfBlock);	dataLength 		= 	500;	theValues 		= 	(DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;			D_HLock			((Handle)theValues);	compareL			=	theSearchObj->logicFields.densityLow * 100;	compareH			=	theSearchObj->logicFields.densityHigh * 100;	do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyDensityNBS);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			double aValue;						aValue =  (double)ConvertToMac(theSets[i].density);			if(compareL <= aValue && aValue <= compareH ){//InRange(aValue,compare,.2,0)){				DataBaseLoc *theValue;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys + 1,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[foundCrys].offSet = ConvertToMac(theSets[i].offSet);				theValue[foundCrys].size = ConvertToMac(theSets[i].size);				foundCrys++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchSubFileKey		(short logic,long *totalFound,short dataBase){	KeySubFileNBS *theSets,*theSet;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum,l,testLength = 1;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	switch(dataBase){		case 3:			return SearchSubFileKeyJC( logic, totalFound);		break;		case 4:			sprintf(aText,"CRYSTAL.S06");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}					break;		default:		return 0L;	}	theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeySubFileNBS) * number ;	theSet = theSets 		= 	(KeySubFileNBS*)D_NewPtr(sizeOfBlock);	dataLength 		= 	500;	theValues 		= 	(DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;			D_HLock			((Handle)theValues);	ConvertToCaps	(theSearchObj->logicFields.subFile,1);	do{		m++;			theSet = theSets;		posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeySubFileNBS);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++,theSet++)		{			if(theSet->subFile[0] == theSearchObj->logicFields.subFile[0]){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSet->offSet);				theValue[l].size = ConvertToMac(theSet->size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchPearsonKey		(short logic,long *totalFound,short dataBase){	KeyPearsonNBS *theSets,*theSet;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		*theText,*cpText;	short		refNum,vRefNum,l,testLength = 6;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	switch(dataBase){		case 3:			return 0L;		break;		case 4:			sprintf(aText,"CRYSTAL.S08");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}					break;		default:		return 0L;	}	theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyPearsonNBS) * number ;	theSets 		= 	(KeyPearsonNBS*)D_NewPtr(sizeOfBlock);	dataLength 		= 	500;	theValues 		= 	(DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		theText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText[testLength] 		= 0;	theText[testLength] 	= 0;		strncpy			(theText,theSearchObj->logicFields.pearsonSym,testLength);	ConvertToCaps	(theText,testLength);	D_HLock			((Handle)theValues);		do{		m++;		theSet = theSets;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyPearsonNBS);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++,theSet++)		{						strncpy(cpText,theSet->name,testLength);			if(!strcmp(cpText,theText)){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSet->offSet);				theValue[l].size = ConvertToMac(theSet->size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	KillPtr((Ptr)theText);	KillPtr((Ptr)cpText);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchUnitCellKey		(short logic,long *totalFound,short dataBase){	KeyUnitCellNBS *theSets,*theSet;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	double		compareL[3],compareH[3];	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum;	DataBaseLoc	**theValues;	DataBaseLoc *theValue;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	switch(dataBase){		case 3:			return SearchUnitCellKeyJC( logic, totalFound);		break;		case 4:			sprintf(aText,"CRYSTAL.S09");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}		break;		default:		return 0L;	}	theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyUnitCellNBS);	sizeOfBlock	*= number;	theSets 		= 	(KeyUnitCellNBS*)D_NewPtr(sizeOfBlock);	dataLength 		= 	500;	theValues 		= 	(DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	foundCrys =		 0;	for(i = 0; i < 3;i++)compareL[i]		=		theSearchObj->logicFields.crysLow[i] * 100;	for(i = 0; i < 3;i++)compareH[i]		=		theSearchObj->logicFields.crysHigh[i] * 100;	D_HLock			((Handle)theValues);	theValue = *theValues;	do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyUnitCellNBS);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));		theSet = theSets;		for(i = 0; i < number;i++,theSet++)		{				double num;			num = (double)ConvertToMac(theSet->a);			if(compareL[0] <= num && compareH[0] >= num){//InRange(num, compare,.1,0)){				num = (double)ConvertToMac(theSet->b);				if(compareL[1] <= num && compareH[1] >= num){//InRange(num, compareB,.1,0)){					num = (double)ConvertToMac(theSet->c);					if(compareL[2] <= num && compareH[2] >= num){//InRange(num, compareC,.1,0)){																		if(dataLength <= foundCrys){							if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys + 1,sizeof(DataBaseLoc)))continue;							theValue = &((*theValues)[foundCrys]);						}						foundCrys++;						theValue->offSet = ConvertToMac(theSet->offSet);						theValue->size = ConvertToMac(theSet->size);						theValue++;					}				}			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchCDIDKey			(short logic,long *totalFound,short dataBase){	KeyCDIDNBS *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		*theText,*cpText;	short		refNum,vRefNum,l,testLength = 7;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	switch(dataBase){		case 3:			return 0L;		break;		case 4:			sprintf(aText,"CRYSTAL.S10");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}		break;		default:		return 0L;	}	theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyCDIDNBS) * number ;	theSets 		= 	(KeyCDIDNBS*)D_NewPtr(sizeOfBlock);	dataLength 		= 	500;	theValues 		= 	(DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		theText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText[7] 		= 0;	theText[7] 		= 0;		strncpy			(theText,"testValue",testLength);	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyCDIDNBS);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			strncpy(cpText,theSets[i].cDID,testLength);			if(!strcmp(cpText,theText)){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	KillPtr((Ptr)theText);	KillPtr((Ptr)cpText);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchOrganicClassKey	(short logic,long *totalFound,short dataBase){	KeyOrgClassNBS *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum,l;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	int			orgClass = 0;	char		aText[255];	if(!logic)return 0L;	switch(dataBase){		case 3:			return 0L;		break;		case 4:			sprintf(aText,"CRYSTAL.S11");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}		break;		default:		return 0L;	}	theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyOrgClassNBS) * number ;	theSets 		= 	(KeyOrgClassNBS*)D_NewPtr(sizeOfBlock);	dataLength 		= 	500;	theValues 		= 	(DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;			D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyOrgClassNBS);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			if(orgClass == theSets[i].orgClass){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);		D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchYearKey			(short logic,long *totalFound,short dataBase){	KeyYearNBS *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum,l;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	switch(dataBase){		case 3:			return SearchYearKeyJC( logic, totalFound);		break;		case 4:			sprintf(aText,"CRYSTAL.S12");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}		break;		default:		return 0L;	}	theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyYearNBS) * number ;	theSets 		= 	(KeyYearNBS*)D_NewPtr(sizeOfBlock);	dataLength 		= 	500;	theValues 		= 	(DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyYearNBS);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			int	aValue;			aValue = (int)ConvertToMac((long int) theSets[i].year);			if(year == (short)aValue){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchElementOrgKey	(short logic,long *totalFound,short dataBase){		if(!logic)return 0L;	switch(dataBase){		case 3:			return  SearchElementOrgKeyJC ( logic, totalFound);		break;		case 4:			return 0L;		break;		default:		return 0L;	}}/*Handle	JCPDFCrystal::SearchAxialRatiosKey	(short logic,long *totalFound,short dataBase){		if(!logic)return 0L;	return 0L;	}*/Handle	JCPDFCrystal::SearchAuthorKey			(short logic,long *totalFound,short dataBase){	KeyAuthorNBS *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		*theText,*cpText;	short		refNum,vRefNum,l,testLength = 20;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic || author == 0L)return 0L;	switch(dataBase){		case 3:			return SearchAuthorKeyJC( logic, totalFound);		break;		case 4:			sprintf(aText,"CRYSTAL.S15");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}		break;		default:		return 0L;	}	theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyAuthorNBS) * number ;	theSets 		= 	(KeyAuthorNBS*)D_NewPtr(sizeOfBlock);	dataLength 		= 	500;	theValues 		= 	(DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		theText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText[40] 		= 0;	theText[40] 	= 0;		strncpy			(theText,author,testLength);	ConvertToCaps	(theText,testLength);	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyAuthorNBS);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			strncpy(cpText,theSets[i].author,testLength);			if(!strcmp(cpText,theText)){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr		(theSets);	KillPtr		((Ptr)theText);	KillPtr		((Ptr)cpText);	D_HUnlock	((Handle)theValues);	theErr 	= 	FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchCASKey			(short logic,long *totalFound,short dataBase){	if(!logic)return 0L;	switch(dataBase){		case 3:			return SearchCASKeyJC( logic, totalFound);		break;		case 4:			return 0L;		break;		default:		return 0L;	}		return (Handle)0L;	}Handle	JCPDFCrystal::SearchNameKey(short logic,long *totalFound,short dataBase){	KeyMineralNameNBS *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		*theText,*cpText;	short		refNum,vRefNum,l,testLength = 40;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	switch(dataBase){		case 3:			return SearchMinNameKeyJC( logic, totalFound);		break;		case 4:			sprintf(aText,"CRYSTAL.S07");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}		break;		default:		return 0L;	}	theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyMineralNameNBS) * number ;	theSets 		= 	(KeyMineralNameNBS*)D_NewPtr(sizeOfBlock);	dataLength 		= 	500;	theValues 		= 	(DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		theText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText[testLength] 		= 0;	theText[testLength] 	= 0;		strcpy			(theText,theSearchObj->logicFields.mineralName);	testLength	=	strlen(theText);	ConvertToCaps	(theText,testLength);	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyMineralNameNBS);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			strncpy(cpText,theSets[i].name,testLength);			if(!strncmp(cpText,theText,testLength)){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	KillPtr((Ptr)theText);	KillPtr((Ptr)cpText);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchMinNameKeyJC(short logic,long *totalFound){	KeyMineralNameJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		*theText,*cpText;	short		refNum,vRefNum,l,testLength = 40;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	sprintf(aText,"PDF2.S04");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyMineralNameJC) * number ;	theSets = (KeyMineralNameJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		theText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText[testLength] 		= 0;	theText[testLength] 	= 0;		strncpy			(theText,crystalName,testLength);	ConvertToCaps	(theText,testLength);	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyMineralNameJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			strncpy(cpText,theSets[i].name,testLength);			if(!strcmp(cpText,theText)){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	KillPtr((Ptr)theText);	KillPtr((Ptr)cpText);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchSubFileKeyJC		(short logic,long *totalFound){	KeySubFileJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum,l,testLength = 3;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	sprintf(aText,"PDF2.S02");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeySubFileJC) * number ;	theSets = (KeySubFileJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		ConvertToCaps	(theSearchObj->logicFields.subFile,1);	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeySubFileJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			if(theSets[i].subFile[0] == theSearchObj->logicFields.subFile[0]){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchInorNameKeyJC		(short logic,long *totalFound){	KeyInOrgNameJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		*theText,*cpText;	short		refNum,vRefNum,l,testLength = 100;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	sprintf(aText,"PDF2.S03");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyInOrgNameJC) * number ;	theSets = (KeyInOrgNameJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		theText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText[testLength] 		= 0;	theText[testLength] 	= 0;		strncpy			(theText,crystalName,testLength);	ConvertToCaps	(theText,testLength);	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyInOrgNameJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			strncpy(cpText,theSets[i].name,testLength);			if(!strcmp(cpText,theText)){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	KillPtr((Ptr)theText);	KillPtr((Ptr)cpText);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchElementOrgKeyJC	(short logic,long *totalFound){	KeyInorgChemFragJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		*theText,*cpText;	short		refNum,vRefNum,l,testLength = 5;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	sprintf(aText,"PDF2.S05");	if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}	theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyInorgChemFragJC) * number ;	theSets 		= 	(KeyInorgChemFragJC*)D_NewPtr(sizeOfBlock);	dataLength 		= 	500;	theValues 		= 	(DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		theText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText[testLength] 		= 0;	theText[testLength] 	= 0;		GetAtomicSymbol(elementList[0],theText);	ConvertToCaps	(theText,testLength);	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyInorgChemFragJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			strncpy(cpText,theSets[i].element,testLength);			if(!strcmp(cpText,theText)){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	KillPtr((Ptr)theText);	KillPtr((Ptr)cpText);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;		}Handle	JCPDFCrystal::SearchCASKeyJC			(short logic,long *totalFound){	KeyCASJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	long		cASKeyTest;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum,l;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	sprintf(aText,"PDF2.S08");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyCASJC) * number ;	theSets = (KeyCASJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		cASKeyTest		=		1000;	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyCASJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			int aValue;			aValue = ConvertToMac(theSets[i].cASnum);			if(cASKeyTest == aValue){				DataBaseLoc *theValue;				foundCrys++;				if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchOrgNameKeyJC		(short logic,long *totalFound){	KeyOrgChemNameJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		*theText,*cpText;	short		refNum,vRefNum,l,testLength = 100;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	sprintf(aText,"PDF2.S09");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyOrgChemNameJC) * number ;	theSets = (KeyOrgChemNameJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		theText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText[testLength] 		= 0;	theText[testLength] 	= 0;		strncpy			(theText,crystalName,testLength);	ConvertToCaps	(theText,testLength);	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyOrgChemNameJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			strncpy(cpText,theSets[i].name,testLength);			if(!strcmp(cpText,theText)){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	KillPtr((Ptr)theText);	KillPtr((Ptr)cpText);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchInorgChemFragKeyJC(short logic,long *totalFound){	KeyInorgChemFragJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		*theText,*cpText;	short		refNum,vRefNum,l,testLength = 20;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	sprintf(aText,"PDF2.S10");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyInorgChemFragJC) * number ;	theSets = (KeyInorgChemFragJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		theText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText[testLength] 		= 0;	theText[testLength] 	= 0;		GetAtomicSymbol(elementList[0],theText);	ConvertToCaps	(theText,testLength);	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyInorgChemFragJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			strncpy(cpText,theSets[i].element,testLength);			if(!strcmp(cpText,theText)){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	KillPtr((Ptr)theText);	KillPtr((Ptr)cpText);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchMinCodesKeyJC		(short logic,long *totalFound){	KeyMinCodesJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		*theText,*cpText;	short		refNum,vRefNum,l,testLength = 6;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	sprintf(aText,"PDF2.S11");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyMinCodesJC) * number ;	theSets = (KeyMinCodesJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		theText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText[testLength] 		= 0;	theText[testLength] 	= 0;		strncpy			(theText,crystalName,testLength);	ConvertToCaps	(theText,testLength);	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyMinCodesJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			strncpy(cpText,theSets[i].minCode,testLength);			if(!strcmp(cpText,theText)){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	KillPtr((Ptr)theText);	KillPtr((Ptr)cpText);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchUnitCellKeyJC		(short logic,long *totalFound){	KeyUnitCellJC *theSets,*theSet;	long 		posOff = 0,				m = -1,				i,				sizeOfBlock,				curEOF;	Boolean		flag = true;		OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum,l;	long		dataLength;	long		foundCrys;	double		compareL[3],compareH[3];	DataBaseLoc	**theValues,*theValue;	char		aText[255];	if(!logic)return 0L;	sprintf(aText,"PDF2.S12");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyUnitCellJC) * number ;	theSets = (KeyUnitCellJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;	for(i = 0; i < 3;i++)compareL[i]		=		theSearchObj->logicFields.crysLow[i] * 100;	for(i = 0; i < 3;i++)compareH[i]		=		theSearchObj->logicFields.crysHigh[i] * 100;	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyUnitCellJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));		theSet = theSets;		for(i = 0; i < number;i++,theSet++)		{				double num;			num = (double)ConvertToMac(theSet->a);			if(compareL[0] <= num && compareH[0] >= num){//InRange(num, compare,.1,0)){				num = (double)ConvertToMac(theSet->b);				if(compareL[1] <= num && compareH[1] >= num){//InRange(num, compareB,.1,0)){					num = (double)ConvertToMac(theSet->c);					if(compareL[2] <= num && compareH[2] >= num){//InRange(num, compareC,.1,0)){																		if(dataLength <= foundCrys){							if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys + 1,sizeof(DataBaseLoc)))continue;							theValue = &((*theValues)[foundCrys]);						}						foundCrys++;						theValue->offSet = ConvertToMac(theSet->offSet);						theValue->size = ConvertToMac(theSet->size);						theValue++;					}				}			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchAuthorKeyJC		(short logic,long *totalFound){	KeyAuthorJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		*theText,*cpText;	short		refNum,vRefNum,l,testLength = 20;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];		if(!logic || author == 0L)return 0L;	sprintf(aText,"PDF2.S13");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyAuthorJC) * number ;	theSets = (KeyAuthorJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		theText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText[testLength] 		= 0;	theText[testLength] 	= 0;		strncpy			(theText,author,testLength);	ConvertToCaps	(theText,testLength);	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyAuthorJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)theSets);				for(i = 0; i < number;i++)		{			theSets[i].author[testLength - 1] = 0;			if(!StringCompare(theSets[i].author,theText)){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	KillPtr((Ptr)theText);	KillPtr((Ptr)cpText);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchYearKeyJC			(short logic,long *totalFound){	KeyYearJC 	*theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum,l;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	sprintf(aText,"PDF2.S14");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyYearJC) * number ;	theSets = (KeyYearJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyYearJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			int	aValue;			aValue = 1900 + (int)theSets[i].year;			if(year == (short)aValue){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchCODENKey		(short logic,long *totalFound,short dataBase){	KeyCODENNBS *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		*theText,*cpText;	short		refNum,vRefNum,l,testLength = 6;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];		long		length;	length = strlen(theSearchObj->logicFields.CODEN);	if(!logic || length == 0L)return 0L;	if(cODEN)KillPtr((Ptr)cODEN);	cODEN = (char*)D_NewPtr(length + 1);	strcpy(cODEN,theSearchObj->logicFields.CODEN);	if(length > 6)ConvertJournalToCODEN();	switch(dataBase){		case 3:			return SearchCODENKeyJC( logic, totalFound);		break;		case 4:			sprintf(aText,"CRYSTAL.S03");			if(OpenNamedFileEM(SEARCH_NBS_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}		break;		default:		return 0L;	}	theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyCODENNBS) * number ;	theSets 		= 	(KeyCODENNBS*)D_NewPtr(sizeOfBlock);	dataLength 		= 	500;	theValues 		= 	(DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		theText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText[testLength] 		= 0;	theText[testLength] 	= 0;	p2cstr((unsigned char*)theSearchObj->logicFields.CODEN);	strncpy			(theText,theSearchObj->logicFields.CODEN,testLength);	c2pstr(theSearchObj->logicFields.CODEN);	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyCODENNBS);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			strncpy(cpText,theSets[i].cODEN,testLength);			if(!strcmp(cpText,theText)){				DataBaseLoc *theValue;				foundCrys++;				if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr		(theSets);	KillPtr		((Ptr)theText);	KillPtr		((Ptr)cpText);	D_HUnlock	((Handle)theValues);	theErr 	= 	FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchCODENKeyJC		(short logic,long *totalFound){	KeyCODENJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	char		*theText,*cpText;	short		refNum,vRefNum,l,testLength = 6;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic || cODEN == 0L)return 0L;	sprintf(aText,"PDF2.S15");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyCODENJC) * number ;	theSets = (KeyCODENJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		theText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	cpText			= (char*)D_NewPtr(sizeof(char) * (testLength + 1));	theText[testLength] 	= 0;	cpText[testLength] 		= 0;		strncpy			(theText,cODEN,testLength);	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyCODENJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			strncpy(cpText,theSets[i].cODEN,testLength);			if(!strcmp(cpText,theText)){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	KillPtr((Ptr)theText);	KillPtr((Ptr)cpText);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchColorKeyJC		(short logic,long *totalFound){	KeyColorJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum,l;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	short		testColor = 0;	char		aText[255];	if(!logic)return 0L;	sprintf(aText,"PDF2.S16");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyColorJC) * number ;	theSets = (KeyColorJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;		D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyColorJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			short aNumber;			aNumber	= ConvertToMac(theSets[i].color[0]);			if(aNumber == testColor){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchDensityKeyJC		(short logic,long *totalFound){	KeyDensityJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	double		compareL,compareH;//avgAtWt,avgZ;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic)return 0L;	sprintf(aText,"PDF2.S17");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);//	if(densityMeasured > 1)	compare = densityMeasured * 100;//	else					compare = CrystalDensity(&avgAtWt,&avgZ) * 100;	sizeOfBlock = sizeof(KeyDensityJC) * number ;	theSets = (KeyDensityJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	foundCrys =		 0;		D_HLock			((Handle)theValues);	compareL			=	theSearchObj->logicFields.densityLow * 100;	compareH			=	theSearchObj->logicFields.densityHigh * 100;	do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyDensityJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			double aValue;						aValue =  (double)ConvertToMac(theSets[i].density);			if(compareL <= aValue && aValue <= compareH ){//if(InRange(aValue,compare,.2,0)){				DataBaseLoc *theValue;												if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys + 1,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[foundCrys].offSet = ConvertToMac(theSets[i].offSet);				theValue[foundCrys].size = ConvertToMac(theSets[i].size);				foundCrys++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchVolumeKeyJC		(short logic,long *totalFound){	KeyVolumeJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	double		compareH,compareL;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum,l;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	char		aText[255];	if(!logic || volume < 1)return 0L;	sprintf(aText,"PDF2.S18");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyVolumeJC) * number ;	theSets = (KeyVolumeJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;	D_HLock			((Handle)theValues);	compareL			=	theSearchObj->logicFields.volumeLow * 100;	compareH			=	theSearchObj->logicFields.volumeHigh * 100;	do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyVolumeJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			double aValue;			aValue = (double)ConvertToMac(theSets[i].volume);			if(compareL <= aValue && aValue <= compareH){				DataBaseLoc *theValue;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys + 1,sizeof(DataBaseLoc))){					D_HUnlock((Handle)theValues);					continue;				}				theValue = *theValues;				theValue[foundCrys].offSet = ConvertToMac(theSets[i].offSet);				theValue[foundCrys].size = ConvertToMac(theSets[i].size);				foundCrys++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}Handle	JCPDFCrystal::SearchLinesKeyJC		(short logic,long *totalFound){	KeyLinesJC *theSets;	long 		posOff = 0,m = -1,i,sizeOfBlock,curEOF;	Boolean		flag = true;	OSErr 		theErr;	short		number = 10000;	short		refNum,vRefNum,l;	DataBaseLoc	**theValues;	long		dataLength;	long		foundCrys;	double		compare;	char		aText[255];	if(!logic)return 0L;	sprintf(aText,"PDF2.S07");	if(OpenNamedFileEM(SEARCH_JCPDF_INDEX,aText,&vRefNum,&refNum)){Message(SEARCH_ALERT);return 0L;}			theErr = GetEOF(refNum,&curEOF);		sizeOfBlock = sizeof(KeyLinesJC) * number ;	theSets = (KeyLinesJC*) D_NewPtr(sizeOfBlock);	dataLength 		= 500;	theValues = (DataBaseLoc**) D_NewHandle(dataLength * sizeof(DataBaseLoc));	l = 0;	foundCrys =		 0;	if(numExpLines > 1){		qsort((Ptr)expDspacings,(long)(numExpLines),sizeof(SpotInfo/*SpotInfoCrys*/),(_compare_function/*__cmp_func_Cmpfun**/)JimsStructFactCompare);		compare = dspacings[0].x * 100;	}else{		qsort((Ptr)dspacings,(long)(numExpLines),sizeof(SpotInfo/*SpotInfoCrys*/),(_compare_function/*__cmp_func_Cmpfun**/)JimsStructFactCompare);		compare = dspacings[0].x * 100;	}	D_HLock			((Handle)theValues);		do{		m++;			posOff = (m * sizeOfBlock);		if(curEOF < posOff + sizeOfBlock){			flag = false;			sizeOfBlock = curEOF - posOff;			number = sizeOfBlock / sizeof(KeyLinesJC);		}				SetFPos		(refNum,fsFromStart,posOff);		theErr = 	FSRead(refNum,&sizeOfBlock,(Ptr)(theSets));				for(i = 0; i < number;i++)		{			double number;			number = (double)ConvertToMac(theSets[i].line);			if(InRange(number, compare,.1,0)){				DataBaseLoc *theValue;				foundCrys++;								if(!CheckHandleSize((Handle)theValues,&dataLength,foundCrys,sizeof(DataBaseLoc)))continue;				theValue = *theValues;				theValue[l].offSet = ConvertToMac(theSets[i].offSet);				theValue[l].size = ConvertToMac(theSets[i].size);				l++;			}		}	}while(flag && !Quit());	*totalFound = foundCrys;	KillPtr(theSets);	D_HUnlock((Handle)theValues);	theErr = FSClose(refNum);		return (Handle)theValues;	}typedef struct	ElementKeyComplet{  // PDF2.S018	unsigned int 		offSet;	unsigned int		size;	unsigned short		theCSReq[6];}ElementKeyComplet;short	IndexCompare(ElementKeyComplet* x,ElementKeyComplet* y);short   OffsetCompare(ElementKeyComplet* x,ElementKeyComplet* y);short	AlphabetSortENBS(KeyElementNBS *x,KeyElementNBS *y){	return strncmp(x->element,y->element,2);}short 	AlphabeticSort(ElementCode* x,ElementCode* y){		return strncmp(x->element,y->element,2);}short OffsetCompareENBS(KeyElementNBS *x,KeyElementNBS *y){	double z1 = 0,z2 = 0;	z1 = y->offSet;	z2 = x->offSet;		return((short)((z1 > z2) ? -1 : ((z1 == z2) ? 0 : 1)));}short   OffsetCompareDB(DataBaseLoc* x,DataBaseLoc* y){	double z1 = 0,z2 = 0;	z1 = y->offSet;	z2 = x->offSet;		return((short)((z1 > z2) ? -1 : ((z1 == z2) ? 0 : 1)));}short   OffsetCompare(ElementKeyComplet* x,ElementKeyComplet* y){	double z1 = 0,z2 = 0;	z1 = y->offSet;	z2 = x->offSet;		return((short)((z1 > z2) ? -1 : ((z1 == z2) ? 0 : 1)));}short	IndexCompare(ElementKeyComplet* x,ElementKeyComplet* y){	unsigned short z1 = 0,z2 = 0,*xPtr,*yPtr;	int i = 0;	Boolean flag = true;	xPtr = x->theCSReq;	yPtr = y->theCSReq;	while(i < 6 && flag){		z1 = *xPtr;		z2 = *yPtr;		if(z1 != z2) flag = false;		i++;		xPtr++;yPtr++;	}		return((short)((z1 > z2) ? -1 : ((z1 == z2) ? 0 : 1)));}void JCPDFCrystal::EliminateBadCrys(DataBaseLoc *crys1,DataBaseLoc *crysNew,long *foundCrys){	long i,k = 0;	DataBaseLoc *value,*compare;	value = crys1;	compare = crysNew;	for(i = 0;i < *foundCrys;i++,value++)	{		if(value->offSet != -1)		{			k++;			compare->offSet = value->offSet;			compare->size 	= value->size;			compare++;		}	}	*foundCrys = k;}short AddAndDraw(char* theText,char* aText,short hor,short ver,short plus);PicHandle	JCPDFCrystal::DisplayCrystal(Rect	*theRect,short horiz,short vert){	PicHandle basePic = 0L;	char			aText[250],cText[250];	short							fontSize = 12;	short			vertStart;	Handle 		theHandle;	theRect = theRect;	short 		theID;	ResType 	theType;	//basePic = inherited::DisplayCrystal(theRect, horiz, vert);	TextFont(geneva);TextSize(9);	sprintf((char*)cText, "PDF ID# OR Crystal Data ID: ");	strcat(cText,pdfNorID);	sprintf((char*)aText, "   MINERAL NAME:"); 	strcat(aText,(char*)crystalName);	vert =  AddAndDraw(cText,aText,horiz,vert,fontSize);		sprintf((char*)cText, "CRYSTAL SYSTEM: ");		switch(lattice_Type){		case	CUBIC:			sprintf(aText," Cubic");			if(spaceGrpNm) theHandle = GetResource('Cubc',spaceGrpNm);			break;		case	TETRAGONAL:			sprintf(aText," Tetragonal");			if(spaceGrpNm) theHandle = GetResource('Tetr',spaceGrpNm);			break;		case	ORTHORHOMBIC:			sprintf(aText," Orthorhombic");			if(spaceGrpNm) theHandle = GetResource('Orth',spaceGrpNm);			break;		case	TRIGONAL:			sprintf(aText," Trigonal");			if(spaceGrpNm) theHandle = GetResource('Trig',spaceGrpNm);			break;		case	TRIGHEX:			sprintf(aText," Rhombohedra");			if(spaceGrpNm) theHandle = GetResource('Trhx',spaceGrpNm);			break;		case	HEXAGONAL:			sprintf(aText," Hexagonal");			if(spaceGrpNm) theHandle = GetResource('Hexa',spaceGrpNm);			break;		case	MONOCLINIC:			sprintf(aText," Monoclinic");			if(spaceGrpNm) theHandle = GetResource('Mono',spaceGrpNm);			break;		case	TRICLINIC:			if(spaceGrpNm) theHandle = GetResource('Tric',spaceGrpNm);			sprintf(aText," Triclinic");			break;		default:			sprintf(aText," ????");			break;	}	strcat(cText,aText);	sprintf((char*)aText,"  SPACE GROUP: ");	strcat(cText,aText);			if(spaceGrpNm){		GetResInfo(theHandle,&theID,&theType,(unsigned char*)aText);		p2cstr((unsigned char*)aText);	}else{		sprintf(aText,"Not Given");	}	if(theHandle)ReleaseResource(theHandle);	strcat(cText,aText);	sprintf((char*)aText,"  PEARSON SYMBOL: ");	strcat(cText,aText);	strncat(cText,pearsonSym,2);	sprintf(aText,"%5.2f",pearsonNum);	vert =  AddAndDraw(cText,aText,horiz,vert,fontSize);	sprintf((char*)cText, "DENSITY CALC:  %6.3fgm/cm3   DENSITY MEAS: %6.3f gm/cm3 ",density,densityMeasured);	vert =  AddAndDraw(cText,0L,horiz,vert,fontSize);	sprintf((char*)cText, "VOLUME:  %6.3f 3   VOLUME REDUCED:  %6.3f 3",volume,volumeReduced);	vert =  AddAndDraw(cText,0L,horiz,vert,fontSize);		sprintf((char*)cText, "UNIT CELL:  ",theUnitCell.a,theUnitCell.alpha);		vert =  AddAndDraw(cText,0L,horiz,vert,fontSize);	switch(editorialCode){		case ' ':		case 0:			sprintf(cText,"Given by Author, Normal Temp. & Pressure");			break;		case 'E':			sprintf(cText, "Cell Inserted by Editor");			break;		case 'C':			sprintf(cText,"Crystal Data Cell Input ( processing of old data)");			break;		case 'T':			sprintf(cText,"Cell data at high or low Temp");			break;		case 'P':			sprintf(cText,"High Pressure Measurements");			break;	}	sprintf(aText," LEAST SQUARES:  ");	strcat(cText,aText);	if(leastSquares[0] == 'L'){		switch(leastSquares[1])		{			case ' ':			case 0:					sprintf(aText,"Entry Prior to Data Flag");			break;		case 'N':			sprintf(aText, "No large Systematic");			break;		case 'S':			sprintf(aText,"Systematic may be reduced by LS refinement");			break;		case 'X':			sprintf(aText,"Systematic not reduced by LS refine.");			break;		case 'M':			sprintf(aText,"Systematic Error Check Omitted, low quality/deleted PDF pattern");			break;		}	}else{		sprintf(aText,"No Systematic Error Check");	}	vert =  AddAndDraw(cText,aText,horiz,vert,fontSize);	sprintf(cText," RADIATION: ");	switch(radiation){		case ' ':		case 0:			sprintf(aText,"Not Specified");			break;		case 'E':			sprintf(aText, "Electrons");			break;		case 'X':			sprintf(aText,"X-rays");			break;		case 'N':			sprintf(aText,"Nuetrons");			break;		case 'G':			sprintf(aText,"Gamma");			break;	}	vert =  AddAndDraw(cText,aText,horiz,vert,fontSize);	sprintf(cText,"SAMPLE TYPE: ");	switch(source){		case ' ':		case 0:			sprintf(aText,"Not Specified");			break;		case 'S':			sprintf(aText,"Single Crystal");			break;		case 'E':			sprintf(aText,"Electron");			break;		case 'P':			sprintf(aText,"Powder Diffraction");			break;		case 'R':			sprintf(aText,"Rietveld or Profile");			break;		default:			sprintf(aText,"Not Specified  ");			break;	}	sprintf(aText,"STRUCTURE INFO QUALITY: ");	strcat(cText,aText);	switch(structureCode){		case ' ':		case 0:			sprintf(aText,"Not Specified");			break;		case 'N':			sprintf(aText, "No Structure info.");			break;		case 'L':			sprintf(aText,"Limited Qualitative");			break;		case 'T':			sprintf(aText,"Total Qualitative (excluding H)");			break;	}	vert =  AddAndDraw(cText,aText,horiz,vert,fontSize);	vertStart = vert;	vert += 12;	sprintf((char*)cText, "a = %6.3f ,  alpha %6.3f  ",theUnitCell.a,theUnitCell.alpha);	vert =  AddAndDraw(cText,0L,horiz,vert,fontSize);	sprintf((char*)cText, "b = %6.3f     beta %6.3f ",theUnitCell.b,theUnitCell.beta);	vert =  AddAndDraw(cText,0L,horiz,vert,fontSize);	sprintf((char*)cText, "c = %6.3f    gamma %6.3f ",theUnitCell.c,theUnitCell.gamma);	vert =  AddAndDraw(cText,0L,horiz,vert,fontSize);	if(standardDev.a != 0L || standardDev.alpha != 0){		sprintf(cText,"Standard Deviations");		vert = vertStart;		horiz += 200;		vert =  AddAndDraw(cText,0L,horiz,vert,fontSize);		sprintf((char*)cText, "asigma = %6.3f ,  alphasisgma %6.3f  ",standardDev.a,standardDev.alpha);		vert =  AddAndDraw(cText,0L,horiz,vert,fontSize);		sprintf((char*)cText, "bsigma = %6.3f     betasigma   %6.3f ",standardDev.b,standardDev.beta);		vert =  AddAndDraw(cText,0L,horiz,vert,fontSize);		sprintf((char*)cText, "csigma = %6.3f    gammasigma %6.3f ",standardDev.c,standardDev.gamma);		vert =  AddAndDraw(cText,0L,horiz,vert,fontSize);		horiz -= 200;	}	if(edCodeAveErr == 'E'){				sprintf(cText,"Editorial Errors Assigned: Avg Error =  ");		switch(qualityIndex)		{			case 'A ':				sprintf(aText,"A Rating: 0-1 parts in 10 to the 5");				break;			case 'A-':				sprintf(aText,"A- Rating: 2-5 parts in 10 to the 5");				break;			case 'B':				sprintf(aText,"B Rating: 6-10 parts in 10 to the 5");				break;			case 'B-':				sprintf(aText,"B- Rating: 11-50 parts in 10 to the 5");				break;			case 'C':				sprintf(aText,"C Rating: 51-100 parts in 10 to the 5");				break;			case 'C-':				sprintf(aText,"C- Rating: 101-500 parts in 10 to the 5");				break;			case 'D':				sprintf(aText,"D Rating: 501-1000 parts in 10 to the 5");				break;			case 'D-':				sprintf(aText,"D- Rating: 1001-5000 parts in 10 to the 5");				break;			case 'F ':				sprintf(aText,"F Rating: 5001-9999 parts in 10 to the 5");				break;			default:				aText[0] = 0;			break;		}	}else	{		if(edCodeAveErr){			sprintf(cText,"Average Error Assigned: %8.5f", edCodeAveErr);			aText[0] = 0;		}	}	vert =  AddAndDraw(cText,aText,horiz,vert,fontSize);	sprintf(cText,"AUTHOR: ");	strcat(cText,author);	sprintf(aText," JOURNAL: ");	strcat(aText,cODEN);	strcat(cText,aText);	sprintf(aText," YEAR: %d VOLUME/PAGE NUMBER: ",year);	strcat(cText,aText);	vert =  AddAndDraw(cText,reference,horiz,vert,fontSize);	sprintf(cText,"CHEMICAL FORMULA: ");	vert =  AddAndDraw(cText,formulaText,horiz,vert,fontSize);		sprintf(cText,"EMPIRICAL FORMULA: ");	vert =  AddAndDraw(cText,empiricalText,horiz,vert,fontSize);	sprintf(cText,"COMMENTS:");	strcat(cText,comments);	vert =  AddAndDraw(cText,0L,horiz,vert,fontSize);	TextFont(0);TextSize(12);		return basePic;}short AddAndDraw(char* theText,char* aText,short hor,short ver,short plus){	char bText[90];	short i = 0,length;	MoveTo(hor,ver);	if(aText != 0L)		strcat(theText,aText);	length = 	strlen(theText);	if(length > 80){		while(i < length){			strncpy(bText,&theText[i],80);			c2pstr(bText);				MoveTo(hor,ver);					DrawDiffractString((unsigned char*)bText);			i += 80;			ver += plus;		}		return ver;	}			c2pstr(theText);				DrawDiffractString((unsigned char*)theText);	ver += plus;	return ver;}