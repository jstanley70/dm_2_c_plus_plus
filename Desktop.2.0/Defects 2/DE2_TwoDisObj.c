//Macintosh HD:CodeWarriorª DR/3 Gold Ä:Metrowerks  C/C++ Ä:Projects:D.M. v2.0:Sources.Jim:Desktop.2.0:Defects 2:DE2_TwoDisObj.c#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include 	"OneDisObj.h"#include 	"TwoDisObj.h"double  fault_Proj_X[3][3];double	XXX,YYY;short	iType[4];double	pos[2][4];double 	normalFaultP[3][3];double 	fault_Shear_X[3][3];double 	fault_Proj[3];double 	b_Vect2_Proj[3];double 	b_Vector_Cart_2[3];	double	adjusted_FINISH;void	GetTextForStackingFault(char *theText,Index *fault,Index *shear);void	TwoDisObj::DoClose(void){	stackingFault_1->DoClose();	stackingFault_2->DoClose();	stackingFault_3->DoClose();	fault_Shear_1->DoClose();	fault_Shear_2->DoClose();	fault_Shear_3->DoClose();	burgersVector_2->DoClose();		stackingFault_1s->CloseAll();	stackingFault_2s->CloseAll();	stackingFault_3s->CloseAll();	burgersVector_2s->CloseAll();	fault_Shear_1s->CloseAll();	fault_Shear_2s->CloseAll();	fault_Shear_3s->CloseAll();		stackingFault_1s->DoClose();	stackingFault_2s->DoClose();	stackingFault_3s->DoClose();	burgersVector_2s->DoClose();	fault_Shear_1s->DoClose();	fault_Shear_2s->DoClose();	fault_Shear_3s->DoClose();		inherited::DoClose();}void	TwoDisObj::SetObjectWindowTitle(void){	short i;	stackingFault_1 = (Index*)(Index*)D_new(Index);	stackingFault_1->DoInit(false,theCrystal[0]);	stackingFault_1->intensity = 1;		stackingFault_2 = (Index*)D_new(Index);	stackingFault_2->DoInit(false,theCrystal[0]);	stackingFault_2->intensity = 1;		stackingFault_3 = (Index*)D_new(Index);	stackingFault_3->DoInit(false,theCrystal[0]);	stackingFault_3->intensity = 1;		burgersVector_2 = (Index*)D_new(Index);	burgersVector_2->DoInit(false,theCrystal[0]);	burgersVector_2->intensity = 1;		distanceToNextDis_E = 3;	distanceToNextDis  = 500;		fault_Shear_1 = (Index*)D_new(Index);	fault_Shear_1->DoInit(true,theCrystal[0]);	fault_Shear_1->h = fault_Shear_1->k = fault_Shear_1->l = 1/3;	fault_Shear_1->intensity = 1;		fault_Shear_2 = (Index*)D_new(Index);	fault_Shear_2->DoInit(true,theCrystal[0]);	fault_Shear_2->intensity = 1;		fault_Shear_3 = (Index*)D_new(Index);	fault_Shear_3->DoInit(true,theCrystal[0]);	fault_Shear_3->intensity = 1;		stackingFault_1s = (DislocIndex*)D_new(DislocIndex);	stackingFault_1s->DoInit(false,theCrystal[0]);		stackingFault_2s = (DislocIndex*)D_new(DislocIndex);	stackingFault_2s->DoInit(false,theCrystal[0]);		stackingFault_3s = (DislocIndex*)D_new(DislocIndex);	stackingFault_3s->DoInit(false,theCrystal[0]);		burgersVector_2s = (DislocIndex*)D_new(DislocIndex);	burgersVector_2s->DoInit(false,theCrystal[0]);		fault_Shear_1s = (DislocIndex*)D_new(DislocIndex);	fault_Shear_1s->DoInit(true,theCrystal[0]);		fault_Shear_2s = (DislocIndex*)D_new(DislocIndex);	fault_Shear_2s->DoInit(true,theCrystal[0]);		fault_Shear_3s = (DislocIndex*)D_new(DislocIndex);	fault_Shear_3s->DoInit(true,theCrystal[0]);	for(i = 0; i <= 3;i++)defectFlags[i] = false;			inherited::SetObjectWindowTitle();}Boolean	TwoDisObj::ResetDefects(short i){	short k;	if(!burgersVectors->CopyNth(burgersVector,i))		return false;	lineDirections->CopyNth(lineDirection,i);	stackingFault_1s->CopyNth(stackingFault_1,i);	stackingFault_2s->CopyNth(stackingFault_2,i);	stackingFault_3s->CopyNth(stackingFault_3,i);	burgersVector_2s->CopyNth(burgersVector_2,i);	fault_Shear_1s->CopyNth(fault_Shear_1,i);	fault_Shear_2s->CopyNth(fault_Shear_2,i);	fault_Shear_3s->CopyNth(fault_Shear_3,i);	distanceToNextDis = distanceToNextDiss[i - 1];	distanceToNextDis_E = distanceToNextDis_Es[i - 1];		for(k = 0; k <= 3; k++){		defectFlags[k] = defectFlagsSet[i - 1][k];	}		return true;}void	TwoDisObj::AddDefects(DialogPtr theDialog,Boolean theFlag){	short i = 3;	double	extDist;	double	electronMassRation;	if(!theFlag){		burgersVectors->SubtractIndex() ;		lineDirections->SubtractIndex() ;		return;	}	stackingFault_1s->AddItemIndex(theDialog,i++) ;	fault_Shear_1s->AddItemIndex(theDialog,i++) ;	fault_Shear_1s->AddIntensity(GetItemValue( theDialog,i++));		burgersVectors->AddItemIndex(theDialog,i++);	burgersVectors->AddIntensity(GetItemValue( theDialog,i++));	lineDirections->AddItemIndex(theDialog,i++) ;		stackingFault_2s->AddItemIndex(theDialog,i++) ;	fault_Shear_2s->AddItemIndex(theDialog,i++) ;	fault_Shear_2s->AddIntensity(GetItemValue( theDialog,i++));		distanceToNextDiss[numberDefect_Sets] = GetItemValue( theDialog,i++);	electronMassRation 	= 	1. + ( (double)energy / 511.);	extDist 			= 	g_Vector->TheExtinctionDist(1./ wavelength,1,theBeamFlag);	distanceToNextDis_Es[numberDefect_Sets] = distanceToNextDiss[numberDefect_Sets] * extDist;				burgersVector_2s->AddItemIndex(theDialog,i++) ;	burgersVector_2s->AddIntensity(GetItemValue( theDialog,i++));			stackingFault_3s->AddItemIndex(theDialog,i++) ;			fault_Shear_3s->AddItemIndex(theDialog,i++) ;	fault_Shear_3s->AddIntensity(GetItemValue( theDialog,i++));				}void TwoDisObj::GetCurrentDefectValues(DialogPtr theDialog){	short i = _3_;	if(stackingFault_1->GetIndex(theDialog,i++))changedFlag = true ;	if(fault_Shear_1->GetIndex(theDialog,i++))changedFlag = true ;	if(fabs(fault_Shear_1->intensity - GetItemValue( theDialog,i)) > .01)changedFlag = true ;	fault_Shear_1->intensity = GetItemValue( theDialog,i++);		if(burgersVector->GetIndex(theDialog,i++))changedFlag = true;		if(fabs(burgersVector->intensity - GetItemValue( theDialog,i)))changedFlag = true;	burgersVector->intensity  = GetItemValue( theDialog,i++);		if(lineDirection->GetIndex(theDialog,i++))changedFlag = true;	if(stackingFault_2->GetIndex(theDialog,i++))changedFlag = true;	if(fault_Shear_2->GetIndex(theDialog,i++))changedFlag = true ;		if(fabs(fault_Shear_2->intensity - GetItemValue( theDialog,i)) > .01)changedFlag = true;	fault_Shear_2->intensity = GetItemValue( theDialog,i++);		if(distanceToNextDis != GetItemValue( theDialog,i))changedFlag = true;	distanceToNextDis = GetItemValue( theDialog,i++);	//else distanceToNextDis_E = GetItemValue( theDialog,i++);				if(burgersVector_2->GetIndex(theDialog,i++))changedFlag = true ;		if(	fabs(burgersVector_2->intensity - GetItemValue( theDialog,i)) > .01)changedFlag = true;	burgersVector_2->intensity  = GetItemValue( theDialog,i++);			if(stackingFault_3->GetIndex(theDialog,i++))changedFlag = true ;			if(fault_Shear_3->GetIndex(theDialog,i++))changedFlag = true ;		if(fabs(fault_Shear_3->intensity - GetItemValue( theDialog,i)) > .01)changedFlag = true;	fault_Shear_3->intensity = GetItemValue( theDialog,i++);		stackingFault_1->theCrystal = theZoneAxis->theCrystal;	stackingFault_2->theCrystal = theZoneAxis->theCrystal;	stackingFault_3->theCrystal = theZoneAxis->theCrystal;		burgersVector->theCrystal = theZoneAxis->theCrystal;	lineDirection->theCrystal 	= theZoneAxis->theCrystal;	burgersVector_2->theCrystal = theZoneAxis->theCrystal;		fault_Shear_1->theCrystal = theZoneAxis->theCrystal;	fault_Shear_2->theCrystal = theZoneAxis->theCrystal;	fault_Shear_3->theCrystal = theZoneAxis->theCrystal;	for(i = 0; i <= 3;i++){		GetDItem(theDialog,_18_ + i,&gType,&gTheHandle,&gTheRect);		 if(GetCtlValue((ControlHandle)gTheHandle)){		 	if(!defectFlags[i])changedFlag = true;			defectFlags[i] = true;		}else{			if(defectFlags[i])changedFlag = true;			defectFlags[i] = false;		}	}		}void TwoDisObj::DoDefectSetUp(DialogPtr theDialog){	short i = _3_,k,j;		stackingFault_1->SetIndex(theDialog,i++) ;			fault_Shear_1->SetIndex(theDialog,i++) ;	GetDItem(theDialog,i++,&gType,&gTheHandle,&gTheRect);	sprintf(gTheText,"%6.3f",fault_Shear_1->intensity);	SetIText(gTheHandle,c2pstr(gTheText));		burgersVector->SetIndex(theDialog,i++);	GetDItem(theDialog,i++,&gType,&gTheHandle,&gTheRect);	sprintf(gTheText,"%6.3f",burgersVector->intensity);	SetIText(gTheHandle,c2pstr(gTheText));		lineDirection->SetIndex(theDialog,i++);			stackingFault_2->SetIndex(theDialog,i++) ;			fault_Shear_2->SetIndex(theDialog,i++) ;	GetDItem(theDialog,i++,&gType,&gTheHandle,&gTheRect);	sprintf(gTheText,"%6.3f",fault_Shear_2->intensity);	SetIText(gTheHandle,c2pstr(gTheText));			GetDItem(theDialog,i++,&gType,&gTheHandle,&gTheRect);		sprintf(gTheText,"%6.3f",distanceToNextDis);			SetIText(gTheHandle,c2pstr(gTheText));				burgersVector_2->SetIndex(theDialog,i++) ;	GetDItem(theDialog,i++,&gType,&gTheHandle,&gTheRect);	sprintf(gTheText,"%6.3f",burgersVector_2->intensity);	SetIText(gTheHandle,c2pstr(gTheText));	stackingFault_3->SetIndex(theDialog,i++) ;			fault_Shear_3->SetIndex(theDialog,i++) ;	GetDItem(theDialog,i++,&gType,&gTheHandle,&gTheRect);	sprintf(gTheText,"%6.3f",fault_Shear_3->intensity);	SetIText(gTheHandle,c2pstr(gTheText));		for(i = _3_; i <= _5_;i++){		if(!defectFlags[0])	HideDItem( theDialog,i);		else ShowDItem(theDialog,i);	}		i = _9_;	for(j = 1;j <= 3;j++){		for(k = 0; k <= 2;k++){			if(!defectFlags[j])HideDItem( theDialog,i++);			else ShowDItem(theDialog,i++);		}		}		sprintf(gTheText,"%d",numberDefect_Sets);	GetDItem(theDialog,_24_,&gType,&gTheHandle,&gTheRect);	SetIText(gTheHandle,c2pstr(gTheText));	for(i = 0; i <= 3;i++){		GetDItem(theDialog,_18_ + i,&gType,&gTheHandle,&gTheRect);		SetCtlValue((ControlHandle)gTheHandle,defectFlags[i]);	}			}Boolean TwoDisObj::GetVectors(void){	double crystalXForm[3][3], a,value;	double extDist,electronMassRation;	Boolean flag;	flag = inherited::GetVectors();		if(flag == 0)return false;		a = theZoneAxis->theCrystal->theUnitCell.a;	theZoneAxis->theCrystal->Get001XForm(crystalXForm);	ConverttoReciprocal		(crystalXForm,(double)theZoneAxis->theCrystal->volume,true);		stackingFault_1	->	GetXYZ(crystalXForm);		stackingFault_2	->	GetXYZ(crystalXForm);		stackingFault_3	->	GetXYZ(crystalXForm);		theZoneAxis->theCrystal->Get001XForm(crystalXForm);	if(defectFlags[1]){		burgersVector_2	->intensity /= a;	}else{		value = burgersVector_2	->intensity;		burgersVector_2	->intensity = 0;	}	if(defectFlags[1] && burgersVector_2->intensity == 0) return false;		burgersVector_2->GetXYZAndMultByIntensity(crystalXForm);	burgersVector_2	->intensity *= a;	if(!defectFlags[1])burgersVector_2	->intensity = value;		fault_Shear_1	->	GetXYZ(crystalXForm);	fault_Shear_2	->	GetXYZ(crystalXForm);	fault_Shear_3	->	GetXYZ(crystalXForm);		electronMassRation 	= 	1. + ( (double)energy / 511.);	extDist 			= 	g_Vector->TheExtinctionDist(1./ wavelength,electronMassRation,theBeamFlag);		distanceToNextDis_E	=  distanceToNextDis / extDist;		if(defectFlags[0]) value = 1; else value = 0;	normalFaultP[0][0]  =  stackingFault_1	->x  * a * value;	normalFaultP[0][1]  =  stackingFault_1	->y  * a * value;	normalFaultP[0][2]  =  stackingFault_1	->z  * a * value;		if(defectFlags[2]) value = 1; else value = 0;	normalFaultP[1][0]  =  stackingFault_2	->x  * a * value;	normalFaultP[1][1]  =  stackingFault_2	->y  * a * value;	normalFaultP[1][2]  =  stackingFault_2	->z  * a * value;		if(defectFlags[3]) value = 1; else value = 0;	normalFaultP[2][0]  =  stackingFault_3	->x  * a * value;	normalFaultP[2][1]  =  stackingFault_3	->y  * a * value;	normalFaultP[2][2]  =  stackingFault_3	->z  * a * value;		b_Vector_Cart_2[0] = burgersVector_2->x;	b_Vector_Cart_2[1] = burgersVector_2->y;	b_Vector_Cart_2[2] = burgersVector_2->z;	if(defectFlags[0]) value = 1; else value = 0;		fault_Shear_X[0][0]  =  value * fault_Shear_1	->x	 / a;	fault_Shear_X[0][1]  =  value * fault_Shear_1	->y  / a;	fault_Shear_X[0][2]  =  value * fault_Shear_1	->z  / a;		if(defectFlags[2]) value = 1; else value = 0;		fault_Shear_X[1][0]  =  value * fault_Shear_2	->x  / a;	fault_Shear_X[1][1]  =  value * fault_Shear_2	->y  / a;	fault_Shear_X[1][2]  =  value * fault_Shear_2	->z  / a;		if(defectFlags[3]) value = 1; else value = 0;		fault_Shear_X[2][0]  =  value * fault_Shear_3	->x  / a;	fault_Shear_X[2][1]  =  value * fault_Shear_3	->y  / a;	fault_Shear_X[2][2]  =  value * fault_Shear_3	->z  / a;	return true;}void TwoDisObj::InsertCurrentDefects(void){	short i;		burgersVectors->CopyToNth(burgersVector, numberDefect_Sets);	lineDirections->CopyToNth(lineDirection,numberDefect_Sets);	burgersVector_2s->CopyToNth(burgersVector_2, numberDefect_Sets);	stackingFault_1s->CopyToNth(stackingFault_1, numberDefect_Sets);	stackingFault_2s->CopyToNth(stackingFault_2, numberDefect_Sets);	stackingFault_3s->CopyToNth(stackingFault_3, numberDefect_Sets);	fault_Shear_1s->CopyToNth(fault_Shear_1, numberDefect_Sets);	fault_Shear_2s->CopyToNth(fault_Shear_2, numberDefect_Sets);	fault_Shear_3s->CopyToNth(fault_Shear_3, numberDefect_Sets);	distanceToNextDiss[numberDefect_Sets - 1] = distanceToNextDis;	distanceToNextDis_Es[numberDefect_Sets - 1] = distanceToNextDis_E;	for(i = 0; i <= 3; i++){		defectFlagsSet[numberDefect_Sets - 1][i] = defectFlags[i];	}}void TwoDisObj::AdditionMatrixMults(double DCX[3][3]){	short i;	for(i = 0; i <= 2;i++)MatrixVectorMultiply(DCX,	normalFaultP[i],fault_Proj_X[i]);	MatrixVectorMultiply(cos_Cry_Dis,	normalFaultP[1],fault_Proj);	MatrixVectorMultiply(cos_Cry_Dis,b_Vector_Cart_2,b_Vect2_Proj);}void TwoDisObj::DoAddTwoDisCN(double VR[3][3],double UR[3][3],short j){	CN[j + 20] = VectorDotProduct(&VR[j][0],b_Vect2_Proj,3);	CN[j + 23] = VectorDotProduct(&UR[j][0],b_Vect2_Proj,3);}void  TwoDisObj::StackingFaultShifts(void){	double value,Z,M;	short i,theValue;	for(i = 0;i <= 2;i++){		Z = M = gVector_Cart[0] * fault_Shear_X[i][0] + gVector_Cart[1] * fault_Shear_X[i][1]			+ gVector_Cart[2] * fault_Shear_X[i][2];		switch(i){			case 0:				value =  fault_Shear_1->intensity;				break;			case 1:				value =  fault_Shear_2->intensity;				break;			case 2:				value =  fault_Shear_3->intensity;				break;		}		if(value == 0){			phaseShiftSF[i] = 0.0;			sinShiftSF[i] = sin(phaseShiftSF[i]);			cosShiftSF[i] = cos(phaseShiftSF[i]);			continue;		}		M = Z *= value;		theValue = (short)Z;		value = M - (double)theValue;		phaseShiftSF[i] = 2 * PI * value;		sinShiftSF[i] = sin(phaseShiftSF[i]);		cosShiftSF[i] = cos(phaseShiftSF[i]);	}}void TwoDisObj::CalcShift(double *shift,double delta_Y_Dir_Extinct,double EXTRA,double DIVISOR,double dotProd_Foil_N_Beam){	DIVISOR = 0;	if(defectFlags[1] == 0){		*shift = 0;	}else{		*shift = delta_Y_Dir_Extinct / 2;		if(*shift - .01 > 0)*shift = .01;	}	adjusted_FINISH = PI * ((EXTRA / 2.0) - ((normalized_Thickness / dotProd_Foil_N_Beam) + EXTRA) * FINISH / normalized_Thickness);}void TwoDisObj::ADDCN(double *EXTRA,double *DIVISOR){	double Z,PT,SL;	if(defectFlags[1] == 0){		*ptrCN16 = 0;		*ptrCN17 = 0;		*ptrCN30 = 0;		*EXTRA	= 0;		*DIVISOR	= 1;		return;	}	Z = sqrt(fault_Proj[0] * fault_Proj[0] + fault_Proj[1] * fault_Proj[1]);	if(Z == 0){		Z = 1;		fault_Proj_X[1][0] = 1.0;	}	PT = distanceToNextDis_E * fault_Proj[1] / Z;	SL = - distanceToNextDis_E * fault_Proj[0] / (Z * proj_Beam[1]);	*ptrCN16 = PI * PT / 2;	*ptrCN17 = PI * SL / 2;	*ptrCN30 = *ptrCN16 / proj_Beam[1];	*EXTRA	= fabs(SL + PT * proj_Foil_Norm_X[0] / proj_Foil_Norm_X[1]);	*DIVISOR	= proj_Beam[2] / proj_Beam[1] - proj_Foil_Norm_X[2] / proj_Foil_Norm_X[1];		}void TwoDisObj::HowieWhelanDeriv(void){	double  Z,R,R2,RCN7,RCN8,RCN9,R2CN7,R2CN8,R2CN9;	double	X11,X22;	if(Quit()){		return;	}		if(!SKIP){		X11 = X - *ptrCN17;		if(X11 == 0.)			X11 = 0.0000000001;		R = (*ptrCN29 - *ptrCN30) / X11;		X22 = X + *ptrCN17;		if(X22 == 0)			X22 = .00000001;		R2 = (*ptrCN29 - *ptrCN30)/ X22;		RCN7 = R + *ptrCN7;		RCN8 = R + *ptrCN8;		RCN9 = R + *ptrCN9;		R2CN7 = R2 + *ptrCN7;		R2CN8 = R2 + *ptrCN8;		R2CN9 = R2 + *ptrCN9;		displacement_Norm = *ptrCN14 	+ ((R * *ptrCN1 + *ptrCN4) / (RCN7 * RCN7 + *ptrCN10)							+  (R * *ptrCN2 + *ptrCN5) / (RCN8 * RCN8 + *ptrCN11)							+  (R * *ptrCN3 + *ptrCN6) / (RCN9 * RCN9 + *ptrCN12)) / X11						 	+ ((R2 * *ptrCN21 + *ptrCN24) / (R2CN7 * R2CN7 + *ptrCN10)							+  (R2 * *ptrCN22 + *ptrCN25) / (R2CN8 * R2CN8 + *ptrCN11)							+  (R2 * *ptrCN23 + *ptrCN26) / (R2CN9 * R2CN9 + *ptrCN12)) / X22;	}			Z 		= anomAbsorbCoeff * (*ptrY1 + *ptrY3);	*ptrD1 	= Z - *ptrY4;	*ptrD3 	= -displacement_Norm * *ptrY4 + Z - *ptrY2;	Z 		= anomAbsorbCoeff * (*ptrY2 + *ptrY4);	*ptrD2 	= Z + *ptrY3;	*ptrD4 	= displacement_Norm * *ptrY3 + Z + *ptrY1;	Z 		= anomAbsorbCoeff * (*ptrY5 + *ptrY7);	*ptrD5 	= Z - *ptrY8;	*ptrD7 	= -displacement_Norm * *ptrY8 + Z - *ptrY6;	Z 		= anomAbsorbCoeff * (*ptrY6 + *ptrY8);	*ptrD6 	= Z + *ptrY7;	*ptrD8 	= displacement_Norm * *ptrY7 + Z + *ptrY5;}void TwoDisObj::CalculateMove(double *MOVE,double shift){	double Z;	*MOVE = 0;	Z = *ptrCN15 - *ptrCN16;	if(shift - fabs(Z) > 0) 	{		*ptrCN15 = *ptrCN16 + shift;		if(Z < 0){			*ptrCN15 = *ptrCN16 - shift;		}		*MOVE = 1;			}else{		Z = *ptrCN15 + *ptrCN16;		if(shift - fabs(Z) > 0) {			*ptrCN15 = -*ptrCN16 + shift;			if(Z < 0){				*ptrCN15 = -*ptrCN16 - shift;						 	}		 	*MOVE = 1;		}else{			*MOVE = 0;		}	}	}void TwoDisObj::AdditionalStartAndPositionValues(double EXTRA){	short i,iStore,j,luck,k,iSwitch ;	double Z;	EXTRA = 0;	XXX = *ptrCN15 + *ptrCN16;	YYY = *ptrCN15 - *ptrCN16;	for(i = 0; i <= 3; i++){		pos[0][i] = -10000;		iType[i] = i;		pos[1][i] = -10050.0;	}	if(YYY > 0){		if(phaseShiftSF[0] * fault_Proj_X[0][1] != 0){			pos[0][0] = *ptrCN17 - (*ptrCN15 - *ptrCN16) * fault_Proj_X[0][0] / fault_Proj_X[0][1];		}	}	if(XXX * YYY < 0){		if(phaseShiftSF[1] * fault_Proj_X[1][1] != 0){			pos[0][1] = - *ptrCN15 * fault_Proj_X[1][0] / fault_Proj_X[1][1];		}	}	if(XXX < 0){		if(phaseShiftSF[2] * fault_Proj_X[2][1] != 0){			pos[0][2] = -*ptrCN17 - (*ptrCN15 + *ptrCN16) * fault_Proj_X[2][0] / fault_Proj_X[2][1];		}	}	STARTA = adjusted_FINISH - (*ptrCN15 * proj_Foil_Norm_X[0] / proj_Foil_Norm_X[1]);				X = STARTA;	SURFAC = X + true_Foil_Thick_Extinct;		pos[0][3] = SURFAC;	j = 0;		while(j <= 2 || luck != 0){		luck = 0;		for(k = 0; k <= 2; k++){			if(pos[0][k] - pos[0][k + 1] > 0){				Z = pos[0][k+1];				pos[0][k+1] = pos[0][k];				pos[0][k] = Z;				iStore = iType[k+1];				iType[k + 1] = iType[k];				iType[k] = iStore;				luck = -1;			}		}		j++;	}	iSwitch = 0;	for(j = 0; j <= 3;j++){		if(iType[j] - 3 != 0){			if(iSwitch != 0){				pos[1][j] = pos[0][j];			}else{				pos[1][j] = -10050.0;			}		}else{			iSwitch = -1;			pos[1][j] = -10050.0;		}	}	}void TwoDisObj:: AddedOneDisCalc(void){}void TwoDisObj::AddedOneDis3(void){		AdditionalIterations();	return;}void  TwoDisObj::AddedOneDis2(void){	double XX1;	return;	if(X1 >= SURFAC && iFlag == 0){				XX1 = X1;		X1 = SURFAC;		iFlag = 1;		RungeKuttaIntegration8Eq();		BlockMove(howie_Whelan_Eq,TEMPY,eightElements);		X1 = XX1;				XX1 = X1;	}	return;}void TwoDisObj::AdditionalIterations(void){	short IP;	double Z,ZZ,XX1;		L1390: if(KOUNTF > 3){		return;	}	if(Quit()){		return;	}		if(X1 - pos[N][KOUNTF] < 0) return;	if(X - pos[N][KOUNTF] > 0) {		KOUNTF++;		goto L1390;	}	XX1 = X1;	X1 = pos[N][KOUNTF];	RungeKuttaIntegration8Eq();	IP = iType[KOUNTF];	if(IP == 3){		iFlag = 1;		X1 = XX1;		BlockMove(howie_Whelan_Eq,TEMPY,eightElements);		pos[N][KOUNTF] = -9000.0;		KOUNTF++;		goto L1390;	}		Z = *ptrY3;	ZZ = *ptrY7;	*ptrY3 = *ptrY3 * cosShiftSF[IP] - *ptrY4 * sinShiftSF[IP];	*ptrY7 = *ptrY7 * cosShiftSF[IP] - *ptrY8 * sinShiftSF[IP];	*ptrY4 = *ptrY4 * cosShiftSF[IP] +  Z * sinShiftSF[IP];	*ptrY8 = *ptrY8 * cosShiftSF[IP] - ZZ * sinShiftSF[IP];	X1 = XX1;	pos[N][KOUNTF] = -9000.0;	KOUNTF++;	goto L1390;}void TwoDisObj::DoAuxRead(void){	stackingFault_1->ReadIndex(theCrystal);	stackingFault_2->ReadIndex(theCrystal);	stackingFault_3->ReadIndex(theCrystal);	burgersVector_2->ReadIndex(theCrystal);	fault_Shear_1->ReadIndex(theCrystal);	fault_Shear_2->ReadIndex(theCrystal);	fault_Shear_3->ReadIndex(theCrystal);	distanceToNextDis 		= gTheFile->ReadFloat();	distanceToNextDis_E 	= gTheFile->ReadFloat();			inherited::DoAuxRead();}void TwoDisObj::DoAuxWrite(void){	stackingFault_1->WriteIndex();	stackingFault_2->WriteIndex();	stackingFault_3->WriteIndex();	burgersVector_2->WriteIndex();	fault_Shear_1->WriteIndex();	fault_Shear_2->WriteIndex();	fault_Shear_3->WriteIndex();	gTheFile->WriteFloat(distanceToNextDis);	gTheFile->WriteFloat(distanceToNextDis_E);			inherited::DoAuxWrite();}void	TwoDisObj::DrawFrameText(Point thePoint){	char theText[30];	short bottom,left,i;	inherited::DrawFrameText(thePoint);	bottom = thePictRect.bottom + 30;	left	=	thePictRect.left;	TextFont	(geneva);	TextSize	(7);		gTheText[0] = 0;	i = 0;	if(defectFlags[0]){		i++;		GetTextForStackingFault(gTheText,stackingFault_1,fault_Shear_1);			}	if(defectFlags[1]){		i++;		GetTextForStackingFault(theText,stackingFault_2,fault_Shear_2);		strcat(gTheText, theText);		if(i >= 2){			MoveTo(left,bottom);			DrawDiffractString(c2pstr(gTheText));			bottom += 10;			i = 0;			gTheText[0] = 0;		}	}		if(defectFlags[3]){		GetTextForStackingFault(theText,stackingFault_3,fault_Shear_3);		strcat(gTheText,theText);		i++;	}	if(i){		MoveTo(left,bottom);		DrawDiffractString(c2pstr(gTheText));		bottom += 10;		gTheText[0] = 0;	}	if(defectFlags[2]){		sprintf(gTheText,"b2 %4.2f(",burgersVector_2->intensity);		burgersVector_2->IndexToStraightText(theText);		strcat(gTheText,theText);		sprintf(theText,") b1->b2%4.2f",distanceToNextDis);		strcat(gTheText,theText);		MoveTo(left,bottom);		DrawDiffractString(c2pstr(gTheText));	}}double  TwoDisObj::DrawDislocationSchematic(Rect theRect,Index *lineDir,Index *burgerV,Boolean erase) //Override{	short hor,ver;	double	magnification;		magnification = inherited::DrawDislocationSchematic( theRect,lineDir,burgerV,true);	if(defectFlags[2]){			DislocationShift( magnification,&hor,&ver);			erase = false;			OffsetRect(&theRect,hor,ver);			inherited::DrawDislocationSchematic(theRect,lineDir,burgersVector_2,erase);	}/*	if(defectFlags[0]){			DrawStackingFaultSchematic(fault_Shear_1,stackingFault_1);	}	if(defectFlags[2]){			DrawStackingFaultSchematic(fault_Shear_2,stackingFault_2);	}	if(defectFlags[3]){			inherited::DrawDislocationSchematic(theRect,lineDir,burgersVector_2,false);	}	if(defectFlags[4]){			DrawStackingFaultSchematic(fault_Shear_3,stackingFault_3);	}*/	return magnification;}void  TwoDisObj::DislocationShift(double magnification,short *hor,short *ver){					*hor = lineDirection	->x  * distanceToNextDis * magnification;	*ver = lineDirection	->y * distanceToNextDis * magnification;}#pragma segment Mainvoid TwoDisObj::SetORToNewBase(short newCrystal)//Override{	inherited::SetORToNewBase(newCrystal);	stackingFault_1->theCrystal = theZoneAxis->theCrystal;	stackingFault_2->theCrystal = theZoneAxis->theCrystal;	stackingFault_3->theCrystal = theZoneAxis->theCrystal;		burgersVector->theCrystal = theZoneAxis->theCrystal;	lineDirection->theCrystal 	= theZoneAxis->theCrystal;	burgersVector_2->theCrystal = theZoneAxis->theCrystal;		fault_Shear_1->theCrystal = theZoneAxis->theCrystal;	fault_Shear_2->theCrystal = theZoneAxis->theCrystal;	fault_Shear_3->theCrystal = theZoneAxis->theCrystal;}void	GetTextForStackingFault(char *theText,Index *fault,Index *shear){	char aText[20];	sprintf(theText,"S.F.(");	fault->IndexToStraightText(aText);	strcat(theText,aText);	sprintf(aText,")shear %4.2f[",shear->intensity);	strcat(theText,aText);	shear->IndexToStraightText(aText);	strcat(theText,aText);	sprintf(aText,"]");		strcat(theText,aText);}