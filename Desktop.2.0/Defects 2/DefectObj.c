//Macintosh HD:CodeWarriorª DR/3 Gold Ä:Metrowerks  C/C++ Ä:Projects:D.M. v2.0:Sources.Jim:Desktop.2.0:Defects 2:DefectObj.c#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include 	"OneDisObj.h" #include 	"DefectObj.h" void			DefectObj::Draw(void){	}void			DefectObj::Move(void){}void			DefectObj::CalculateDisplacement(double *x,double *y,double *z){	double theXForm[3][3];	double	zR[3],zI[3];	double	x1[3],u,length;	short i,j;	gCurrentObj->CopyAxesIntoMatrix(theXForm);	InvertMatrix(theXForm);	TransFormVector(x,y,z,theXForm);	TransFormVector(x,y,z,cos_Cry_Dis);	length = displacement->GetLength();		if(sqrt((*x * *x) + (*y * *y)) <= length)	{		if(*x >= 0 && *y >= 0){			*x += displacement->x;			*y += displacement->y;			*z += displacement->z;		}		InvertMatrix(cos_Cry_Dis);		TransFormVector(x,y,z,cos_Cry_Dis);		InvertMatrix(cos_Cry_Dis);		InvertMatrix(theXForm);		TransFormVector(x,y,z,theXForm);		return;	}	for(i = 0; i <= 2; i++){		double a,b;		a = log(fabs(*x + (p_Real[i] * *y))) ;		b = log(fabs(*x - (p_Image[i] * *y)));				zR[i] = a;		zI[i] = b;	}	x1[0] = *x;	x1[1] = *y;	x1[2] = *z;	for(i = 0; i <= 2; i ++){		u = 0;		for(j = 0; j <= 2; j++){			u += AR[i][j] * zR[j] * summedMHbReal[i][j];			u -= AI[i][j] * zI[j] * summedMHbImage[i][j];		}		x1[i] +=  u / (4 * PI);	}	*x  = x1[0];	*y  = x1[1];	*z  = x1[2];	InvertMatrix(cos_Cry_Dis);	TransFormVector(x,y,z,cos_Cry_Dis);	InvertMatrix(cos_Cry_Dis);	InvertMatrix(theXForm);	TransFormVector(x,y,z,theXForm);}void	DefectObj::Init(Crystal *aCrystal){	theCrystal = aCrystal;	xCount	=	yCount	= 64;	displacement = (DislocIndex*)D_new(DislocIndex);	displacement->DoInit(true,aCrystal);	displacement->intensity = 1;		direction = (DislocIndex*)D_new(DislocIndex);	direction->DoInit(true,aCrystal);	locationStart.x = 0;locationStart.y = 0;locationStart.z = 0;	locationEnd.x = 0;locationEnd.y = 0;locationEnd.z = 0;	energy = 0;	nEW = 6;	NP[0] 	= 1;NP[1] 	= 2;NP[2] 	= 0;	NQ[0] 	= 2;NQ[1] 	= 0;NQ[2] 	= 1;	MM[0] 	= 0;MM[1] 	= 5;MM[2] 	= 4;	NN[0] 	= 5;NN[1] 	= 1;NN[2] 	= 3;	L1[0] 	= 0;L1[1] 	= 1;L1[2] 	= 2;L1[3] 	= 1;L1[4] 	= 2;L1[5] 	= 0;	L2[6] 	= 0;L2[1] 	= 1;L2[2] 	= 2;L2[3] 	= 2;L2[4] 	= 0;L2[5] 	= 1;	L3[0][0] = 0;L3[0][1] = 5;L3[0][2] = 4;	L3[1][0] = 5;L3[1][1] = 1;L3[1][2] = 3;	L3[2][0] = 4;L3[2][1] = 3;L3[2][2] = 2;}void	DefectObj::Kill(void){	displacement->CloseAll();	direction->CloseAll();	D_delete(this);}void	DefectObj::CalculateElasticConstantsForDislocation(void){		short 	ja = 0,jb = 0,i = 0,j = 0,k = 0,l = 0,m = 0,n = 0,lp = 0,lq = 0,			lt = 0,kp = 0,kq = 0,kr = 0,ks = 0,kt = 0,nj = 0,nl = 0,ml = 0,			j1 = 0,j2 = 0,i1 = 0,i2 = 0,k1 = 0;	double  	elastic_Const[6][6];		double 	C11 = 0,C12 = 0;	double		x = 0,y= 0,tempValue= 0,Z= 0,PRK= 0,PIK= 0,SQR= 0,SQI= 0;	double  	XR = 0,XI = 0,YR = 0,YI = 0,				DEL = 0,DELI = 0,DELR = 0,AUMR = 0,AUMI = 0,C44;	float		*elastic21;	double		crystalXForm[3][3];		theCrystal		->	Get001XForm(crystalXForm);	Identity_Matrix(cos_Cry_Dis);	FIND_CENTER_XFORM(direction	->x,direction	->y,direction	->z,cos_Cry_Dis);	MatrixMultiply(crystalXForm,cos_Cry_Dis,crystalXForm);	direction	->	GetXYZ(crystalXForm);	displacement->GetXYZAndMultByIntensity(crystalXForm);		for(i = 0; i < 6;i++){		for(j = 0; j < 6;j++){elastic_Const[i][j] = 0;}}	C44 = (double)theCrystal->elasticConstants[15];	elastic21 = 	theCrystal->elasticConstants;	m = 0;	for(ja = 0 ; ja < 6 ; ja++){		for(jb = ja ; jb < 6 ; jb++){			elastic_Const[jb][ja] = elastic_Const[ja][jb] = (double)elastic21[m] / C44;			m++;		}	}		for( m = 0 ; m <= 5 ; m++){		i = L1[m];		j = L2[m];		for(n = 0 ; n <= m ; n++){			k = L1[n];			l = L2[n];			x = 0.0;			for(lp = 0 ; lp <= 2 ; lp++){				y = 0.0;				for(lq = 0 ; lq <= 2 ; lq++){					lt = L3[lp][lq];					y = y + cos_Cry_Dis[j][lq] *						(cos_Cry_Dis[k][0] * (cos_Cry_Dis[l][0] * elastic_Const[lt][0] + cos_Cry_Dis[l][1] * elastic_Const[lt][5] + cos_Cry_Dis[l][2] * elastic_Const[lt][4]) +						 cos_Cry_Dis[k][1] * (cos_Cry_Dis[l][0] * elastic_Const[lt][5] + cos_Cry_Dis[l][1] * elastic_Const[lt][1] + cos_Cry_Dis[l][2] * elastic_Const[lt][3]) +						 cos_Cry_Dis[k][2] * (cos_Cry_Dis[l][0] * elastic_Const[lt][4] + cos_Cry_Dis[l][1] * elastic_Const[lt][3] + cos_Cry_Dis[l][2] * elastic_Const[lt][2]));				}				x += (cos_Cry_Dis[i][lp] * y);			}			dis_Elastic_Const[n][m] = dis_Elastic_Const[m][n] = x;		}	}}void DefectObj::CalculateBandH_Matrix(void){	double	ELR[3][3],ELI[3][3];	double	B[3][3]; 	double  QImage[7],QReal[7];		short 	ja = 0,jb = 0,i = 0,j = 0,k = 0,l = 0,m = 0,n = 0,lp = 0,lq = 0,			lt = 0,kp = 0,kq = 0,kr = 0,ks = 0,kt = 0,nj = 0,nl = 0,ml = 0,			j1 = 0,j2 = 0,i1 = 0,i2 = 0,k1 = 0,k2;		double	DR[3][3];	double	DI[3][3];		double	G[9];	double 	EE[9],C11 = 0,C12 = 0;	double	x = 0,y= 0,tempValue= 0,Z= 0,PRK= 0,PIK= 0,SQR= 0,SQI= 0;	double  XR = 0,XI = 0,YR = 0,YI = 0,			DEL = 0,DELI = 0,DELR = 0,AUMR = 0,AUMI = 0;			Identity_Matrix(DI);	Identity_Matrix(DR);	Identity_Matrix(ELI);	Identity_Matrix(ELR);	Identity_Matrix(B);	for(i = 0; i <= 8 ; i++)G[i] = 0;	for(i = 0; i <= 6; i++){QImage[i] = 0;QReal[i] = 0;}	for(i = 0;  i <= 8; i++)	EE[i] = 0;		G[0] = dis_Elastic_Const[4][4];	G[1] = dis_Elastic_Const[3][4] * 2.0;	G[2] = dis_Elastic_Const[3][3];	G[3] = dis_Elastic_Const[5][5];	G[4] = dis_Elastic_Const[1][5] * 2.0;	G[5] = dis_Elastic_Const[1][1];	G[6] = dis_Elastic_Const[0][0];	G[7] = dis_Elastic_Const[0][5] * 2.0;	G[8] = dis_Elastic_Const[5][5];		EE[0] = dis_Elastic_Const[4][5];	EE[1] = dis_Elastic_Const[1][4] + dis_Elastic_Const[3][5];	EE[2] = dis_Elastic_Const[1][3];	EE[3] = dis_Elastic_Const[0][4];	EE[4] = dis_Elastic_Const[4][5] + dis_Elastic_Const[0][3];	EE[5] = dis_Elastic_Const[3][5];	EE[6] = dis_Elastic_Const[0][5];	EE[7] = dis_Elastic_Const[5][5] + dis_Elastic_Const[0][1];	EE[8] = dis_Elastic_Const[1][5];	{ /* Determinanent to Solve for the Sextic Equation of Stroh's Theory */				for(kp = 0 ; kp <= 6 ; kp++){			QImage[kp] = QReal[kp] = 0.0;		}		for(kq = 0 ; kq <= 2 ; kq++){			for(kr = 0 ; kr <= 2 ; kr++){				for(ks = 0 ; ks <= 2 ; ks++){					kt = kq + kr + ks;					QReal[kt] = 	QReal[kt] +																	G[kq] * G[kr + 3] * G[ks + 6] +								2.0 * EE[kq] * EE[kr + 3] * EE[ks + 6] -								EE[kq] * EE[kr] * G[ks + 6] - 								EE[kq + 3] * EE[kr + 3] * G[ks + 3] -								EE[kq + 6] * EE[kr + 6] * G[ks];				}			}		}			for(kp = 0 ; kp <= 6 ; kp++)			QReal[kp] /=  QReal[6];	}	KRASH = 0;	nEW = 6;	ZR = 0.1;	ZI = 1.0;	RootOfPolyUsingNewtonMethod(QReal,QImage);	if(KRASH == 0){L61:	p_Real[0] = ZR;		p_Image[0] = fabs(ZI);		ZI = -ZI;		RootOfPolyUsingNewtonMethod(QReal,QImage);		if(KRASH == 0){L62:		ZR = 0.5;			ZI = 0.9;			RootOfPolyUsingNewtonMethod(QReal,QImage);			if(KRASH == 0){L63:			p_Real[1] = ZR;				p_Image[1] = fabs(ZI);				ZI = -ZI;				RootOfPolyUsingNewtonMethod(QReal,QImage);					if(KRASH == 0){L64:				ZR = -ZR;					RootOfPolyUsingNewtonMethod(QReal,QImage);					if(KRASH == 0){L65:					p_Real[2] = ZR;						p_Image[2] = fabs(ZI);						ZR = -dis_Elastic_Const[3][4] / dis_Elastic_Const[3][3];						ZI = sqrt(fabs(dis_Elastic_Const[3][3] * dis_Elastic_Const[4][4] - pow(dis_Elastic_Const[3][4],2.0))) / dis_Elastic_Const[3][3];						for(n = 0 ; n <= 1 ; n++){							tempValue = 	pow((ZR - p_Real[n]),2.0) +											pow((ZI - p_Image[n]),2.0) -											pow((ZR - p_Real[n + 1]),2.0) -											pow((ZI - p_Image[n +1]),2.0);							if(tempValue < 0){L66:							Z = p_Real[n];								p_Real[n] = p_Real[n + 1];								p_Real[n + 1] = Z;								Z = p_Image[n];								p_Image[n] = p_Image[n + 1];								p_Image[n + 1] = Z;							}						}					}				}			}		}	} 		if(KRASH > 0){		Message(NOT_CONVERGE);		return;	} else if (KRASH < 0){		Message(NOT_CONVERGE);		return;	}		for(k = 0 ; k <= 2 ; k++){		i = NP[k];		l = NQ[k];		PRK = p_Real[k];		PIK = p_Image[k];		SQR = PRK * PRK - PIK * PIK;		SQI = 2.0 * PIK * PRK;				DR[0][0] = dis_Elastic_Const[0][0] + PRK * 2.0 * dis_Elastic_Const[0][5] + SQR * dis_Elastic_Const[5][5];		DR[1][1] = dis_Elastic_Const[5][5] + PRK * 2.0 * dis_Elastic_Const[1][5] + SQR * dis_Elastic_Const[1][1];		DR[2][2] = dis_Elastic_Const[4][4] + PRK * 2.0 * dis_Elastic_Const[3][4] + SQR * dis_Elastic_Const[3][3];		DR[1][0] = DR[0][1] = dis_Elastic_Const[0][5] + PRK * (dis_Elastic_Const[0][1] + dis_Elastic_Const[5][5]) + SQR * dis_Elastic_Const[1][5];		DR[2][1] = DR[1][2] = dis_Elastic_Const[4][5] + PRK * (dis_Elastic_Const[3][5] + dis_Elastic_Const[1][4]) + SQR * dis_Elastic_Const[1][3];		DR[0][2] = DR[2][0] = dis_Elastic_Const[0][4] + PRK * (dis_Elastic_Const[0][3] + dis_Elastic_Const[4][5]) + SQR * dis_Elastic_Const[3][5];				DI[0][0] = PIK * 2.0 * dis_Elastic_Const[0][5] + SQI * dis_Elastic_Const[5][5];		DI[1][1] = PIK * 2.0 * dis_Elastic_Const[1][5] + SQI * dis_Elastic_Const[1][1];		DI[2][2] = PIK * 2.0 * dis_Elastic_Const[3][4] + SQI * dis_Elastic_Const[3][3];		DI[1][0] = DI[0][1] = PIK * (dis_Elastic_Const[0][1] + dis_Elastic_Const[5][5]) + SQI * dis_Elastic_Const[1][5];		DI[2][1] = DI[1][2] = PIK * (dis_Elastic_Const[3][5] + dis_Elastic_Const[1][4]) + SQI * dis_Elastic_Const[1][3];		DI[0][2] = DI[2][0] = PIK * (dis_Elastic_Const[0][3] + dis_Elastic_Const[4][5]) + SQI * dis_Elastic_Const[3][5];				for(j = 0 ; j <= 2 ; j++){			m = NP[j];			n = NQ[j];			AR[j][k] = 	DR[i][m] * DR[l][n] - DI[i][m] * DI[l][n] - DR[i][n] * DR[l][m] + DI[i][n] * DI[l][m];L80:		AI[j][k] = 	DR[i][m] * DI[l][n] + DI[i][m] * DR[l][n] - DR[i][n] * DI[l][m] - DI[i][n] * DR[l][m];		}	}								for(j = 0 ; j <= 2 ; j++){		nj = NN[j];			for(k = 0 ; k <= 2 ; k++){			XR = XI = 0.0;			for(l = 0 ; l <= 2 ; l++){				nl = NN[l];				ml = MM[l];				YR = dis_Elastic_Const[nj][ml] + dis_Elastic_Const[nj][nl] * p_Real[k];				YI = dis_Elastic_Const[nj][nl] * p_Image[k];				XR += (YR * AR[l][k] - YI * AI[l][k]);L81:			XI += (YI * AR[l][k] + YR * AI[l][k]);			}			ELR[j][k] = XR;L82:		ELI[j][k] = XI;		}	}			for(j = 0 ; j <= 2 ; j++){		j1 = NP[j];		j2 = NQ[j];		for(k = 0 ; k <= 2 ; k++){			k1 = NP[k];			k2 = NQ[k];			eMReal[k][j] =	ELR[j1][k1] * ELR[j2][k2] - ELI[j1][k1] * ELI[j2][k2] -							ELR[j1][k2] * ELR[j2][k1] + ELI[j1][k2] * ELI[j2][k1];						eMImage[k][j] =	ELR[j1][k1] * ELI[j2][k2] + ELI[j1][k1] * ELR[j2][k2] -							ELR[j1][k2] * ELI[j2][k1] - ELI[j1][k2] * ELR[j2][k1];		}	}		DELI = DELR = 0.0;	for(j = 0 ; j <= 2 ; j++){		DELR += (ELR[2][j] * eMReal[j][2] - ELI[2][j] * eMImage[j][2]);		DELI += (ELR[2][j] * eMImage[j][2] + ELI[2][j] * eMReal[j][2]);	}		AUMR = DELR / (DELR * DELR + DELI * DELI);	AUMI = -DELI / (DELR * DELR + DELI * DELI);	for(j = 0 ; j <= 2 ; j++){		for(k = 0 ; k <= 2 ; k++){			x = eMReal[j][k] * AUMR - eMImage[j][k] * AUMI;			eMImage[j][k] = eMReal[j][k] * AUMI + eMImage[j][k] * AUMR;			eMReal[j][k] = x;		}	}		for(i = 0 ; i <= 2 ; i++){		for(j = 0 ; j <= 2 ; j++){			B[i][j] = 0.0;			for(k = 0 ; k <= 2 ; k++){L86:			B[i][j] += (-AR[i][k] * eMImage[k][j] - AI[i][k] * eMReal[k][j]);			}		}	}		for(i = 0 ; i<= 2 ; i++){		i1 = NP[i];		i2 = NQ[i];		for(j = 0 ; j <= 2 ; j++){			j1 = NP[j];			j2 = NQ[j];L87:		H[i][j] = B[i1][j1] * B[i2][j2] - B[i1][j2] * B[i2][j1];		}	}		DEL = B[2][0] * H[2][0]  + B[2][1] * H[2][1] + B[2][2] * H[2][2];	for(i = 0 ; i<= 2 ; i++){		for(j = 0 ; j <= 2 ; j++){			H[i][j] /= DEL;		}	}		}void	DefectObj::DislocationEnergy(void){	double x[3],constant,radiusOuter,radiusInner;	short i,j;		x[0] = displacement->x;	x[1] = displacement->y;	x[2] = displacement->z;	energy = 0;	radiusOuter = 100;	radiusInner = displacement->GetLength();	constant = (double)theCrystal->elasticConstants[15] * log(radiusOuter/radiusInner) / (4 * PI);	for(i = 0;i <= 2;i++){		for(j = 0;j <= 2;j++){			energy += H[i][j] * x[i] * x[j];		}	}	energy *= constant;}void	DefectObj::CalculateSummedMHb(void){		double x[3];	short	a,j,i;		x[0] = displacement->x;	x[1] = displacement->y;	x[2] = displacement->z;		for(a = 0; a <= 2; a++){		for(j = 0; j <= 2;j++){			summedMHbReal[a][j] = 0;			summedMHbImage[a][j] = 0;			for(i = 0; i <= 2; i++){				summedMHbReal[a][j] += eMReal[a][j] * H[i][j] * x[i];				summedMHbImage[a][j] += eMImage[a][j] * H[i][j] * x[i];			}		}	}}void DefectObj::DoDefine(void){	DialogPtr 		theDialog;	short			theSelect;	Boolean			quit,calculateFlag;		theDialog	= DM_GetNewDialog(331,NUL,IN_FRONT);	calculateFlag = quit = false;			DoDefectSetUp(theDialog);				while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case -1:			case 2:				quit = true;				break;			case 1:				calculateFlag = true;					quit = true;				break;			case ML_UPDATE_EVT:						BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			default:				break;		}	}			if(calculateFlag){		GetCurrentDefectValues(theDialog);		DM_DisposDialog(&theDialog);			} else{		DM_DisposDialog(&theDialog);			}	return;}void	DefectObj::DoDefectSetUp(DialogPtr theDialog){		GetDItem(theDialog,5,&gType,&gTheHandle,&gTheRect);		sprintf(gTheText,"%6.2f",displacement->intensity);		SetIText(gTheHandle,c2pstr(gTheText));		displacement->SetIndex(theDialog,3);		direction->SetIndex(theDialog,4);				}void  DefectObj::GetCurrentDefectValues(DialogPtr theDialog){	displacement->GetIndex(theDialog,3);	direction->GetIndex(theDialog,4);	displacement->intensity 	=  (float)GetItemValue( theDialog,5);		CalculateElasticConstantsForDislocation();	CalculateBandH_Matrix();	CalculateSummedMHb();	DislocationEnergy();}void DefectObj::RootOfPolyUsingNewtonMethod(double QReal[7],double QImage[7]){	double  xr,xi,yr,yi,tr,ti,f;	short count,j,converge = 0,m = 0;	for(count = 1 ; count <= 70 ; count++){		xr = xi = yr = yi = 0.0;		for(j = 0 ; j <= nEW; j++){			tr = ZR * yr - ZI * yi + xr;			yi = ZR * yi + ZI * yr + xi;			yr = tr;			m = nEW - j;			tr = ZR * xr - ZI * xi + QReal[m];			ti = ZR * xi + ZI * xr + QImage[m];			if(converge != 0){L1:				QReal[m] = xr;				QImage[m] = xi;			}L2:			xr = tr;L3:			xi = ti;		}				if(converge != 0){L7:			if(fabs(ZR) > 100000.0 * fabs(ZI))L8:				KRASH = nEW;L9:			nEW--;L10:		return;		}		L4:		f = 1.0 / (yr * yr + yi * yi);		tr = f * (xr * yr + xi * yi);		ti = f * (xi * yr - xr * yi);		ZR -= tr;		ZI -= ti;			if(((tr * tr + ti * ti) / (ZR * ZR + ZI * ZI)) <= .000000000001)L5:			converge = 1;	}	KRASH = -70;	return;}void DefectObj::InitCalcImage(void){/*	short i,j;	KRASH = 0;	eRROR = 0;Q = 0;ANO = 0;ZR = 0 ;ZI = 0;	C44 = 0;	for(i = 0; i <= 5;i++)	{		for(j = 0; j <= 5;j++)			rot_Elastic_Const[i][j] = 0;	}	for(i = 0; i <= 8;i++)D[i] = 0;  	for(i = 0; i <= 2;i++){	p_Real[i] = 0;p_Image[i] = 0;}	  	dotProd_Foil_N_Beam = 0;	delta_X_Dir_Extinct = 0;	nEW = 6;	Identity_Matrix(H);	Identity_Matrix(eMReal);	Identity_Matrix(eMImage);	Identity_Matrix(AI);	Identity_Matrix(AR);	max_Deluge = 0;; 	 Q1	=	0; 	 Q2	=	0; 	 Q3	=	0; 	 Q4	=	0;Q6 = 0; 	 Q15	=	0;highError = 0;loError = 0; 	lastX 	= 0; 	lastY	=	0;	for(i = 0; i <= 7;i++){		YT[i] = 0;		for(j = 0; j <= 2;j++)		{			DT[i][j] = 0;		}	} 	lastGray = 0; 	 	 			maxIntensity	=	0 ;	minIntensity 	= 0;	grayGain 		= 0;	grayOffset 		= 0;		Identity_Matrix(cos_Cry_Dis);	for(i = 0; i <= 2;i++)	{		gVector_Cart[i] = 0;		proj_Beam[i] = 0;		proj_Foil_Norm_X[i] = 0;	} 	KOUNTF = 0; 	N = luck = 0; 	X = X1 = 0; 	MW = 0;	MR = 0;	iFlag = 0;  	STARTA = 0;	for(i = 0; i <= 30;i++)CN[i] = 0;	SURFAC = 0;	for(i = 0; i <= 8;i++)TEMPY[i] = 0;	FINISH = 0;			 SKIP = 0;	displacement_Norm = 0;		for(i = 0; i <= 7;i++)howie_Whelan_Eq[i] = 0;	eightElements = 0;	theSlice = 0;	*/}void DefectObj::CalcIntensities(void){/*	double 			proj_G_Vect[3],			proj_Foil_Norm[3];								double	DCX[3][3],d_Real[3],d_Image[3],UR[3][3],UI[3][3],VR[3][3],VI[3][3];		double  b_Vector_Cart[3],			line_Dir_Cart[3],			beam_Cart[3],			foil_Norm_Cart[3],proj_b_Vector[3];				double	W = 0,TT = 0;		double	EXTRA = 0,DIVISOR = 0,shift = 0,MOVE = 0,			delta_Y_Dir_Extinct = 0,			BACK = 0,DNR = 0,DNI = 0,DNN = 0,part1 = 0,part2 = 0;	double  z = 0,sum = 0,x = 0,tempValue = 0,pixelsWide = 0;	double  totalX = 0,black = 0,white = 0,span = 0;	short 	hRes = 0,vRes = 0;	short 	j = 0,k = 0,l = 0,ja = 0,jk = 0,jc = 0,jt = 0,jm = 0,jz = 0,			ival = 0,theValue = 0;				double	m1[3][3],m2[3][3];	float	*theData;	long	longValue = 0;		long	max_Data_Count = 0,max_FX = 0;	Boolean	testFlag;		Identity_Matrix(m1);	Identity_Matrix(m2);	InitCalc();	SetResolution();		redraw = true;	if(delugeFlag){		longValue = ((5 * xCount * yCount) + 21 + xCount) * (long)sizeof(float );		TB = (float*)D_NewPtr((long)longValue );		if(MemError() != 0){			KillPtr(TB);			StopAlert(609,0L);			redraw = false;			delugeFlag = false;			return;		}		longValue = ((xCount * yCount) + 1) * (long)sizeof(float );		FY1 = (float*)D_NewPtr((long)longValue);		if(MemError() != 0){			KillPtr(TB);			StopAlert(609,0L);			redraw = false;			delugeFlag = false;			return;		}		FY2 = (float*)D_NewPtr((long)longValue);		if(MemError() != 0){			KillPtr((Ptr)TB);			KillPtr((Ptr)FY1);			StopAlert(609,0L);			redraw = false;			delugeFlag = false;			return;		}		FY3 = (float*)D_NewPtr((long)longValue);		if(MemError() != 0){			KillPtr((Ptr)TB);			KillPtr((Ptr)FY1);			KillPtr((Ptr)FY2);			StopAlert(609,0L);			redraw = false;			delugeFlag = false;			return;		}		FY4 = (float*)D_NewPtr((long)longValue);		if(MemError() != 0){			KillPtr((Ptr)TB);			KillPtr((Ptr)FY1);			KillPtr((Ptr)FY2);			KillPtr((Ptr)FY3);			StopAlert(609,0L);			redraw = false;			delugeFlag = false;			return;		}	}else{		longValue = (6 * xCount + 21) * (long)sizeof(float );		TB = (float*)D_NewPtr((long)longValue );		if(MemError() != 0){			StopAlert(609,0L);			redraw = false;			delugeFlag = false;			return;		}	}	max_Deluge 	= -1;	max_FX		= -1;		if(delugeFlag){		theValue  = (pixelsWide) + 4;		FX1 = &TB[theValue];		theValue = (short)(xCount * yCount) + 4;		FX2 = &FX1[theValue];		FX3 = &FX2[theValue];		FX4 = &FX3[theValue];	}else{		theValue = (short)pixelsWide + 4;		FX1 =  &TB[theValue];		theValue = (short)xCount + 4;		FX2 = &FX1[theValue];		FX3 = &FX2[theValue];		FX4 = &FX3[theValue];	}	eightElements = 8 * sizeof(double );	D_MFTempHLock(theDataHandle);		theData = (float*)*theDataHandle;		SetupPointers();	GetVectors();		if(anomFlag)		AnomalGuess();	if(anomAbsorbCoeff == 0.0){		anomAbsorbCoeff = -.1;	}else if(anomAbsorbCoeff > 0.0){		anomAbsorbCoeff *= -1.0;	}	FINISH 	= normalized_Thickness;		*ptrCN14 = 2.0 * w_Off_Bragg;		b_Vector_Cart[0] = burgersVector->x;	b_Vector_Cart[1] = burgersVector->y;	b_Vector_Cart[2] = burgersVector->z;		line_Dir_Cart[0] = cos_Cry_Dis[2][0] = lineDirection->x;					line_Dir_Cart[1] = cos_Cry_Dis[2][1] = lineDirection->y;	line_Dir_Cart[2] = cos_Cry_Dis[2][2] = lineDirection->z;		gVector_Cart[0] = g_Vector->x;	gVector_Cart[1] = g_Vector->y;	gVector_Cart[2] = g_Vector->z;		beam_Cart[0] = theZoneAxis->x;						beam_Cart[1] = theZoneAxis->y;	beam_Cart[2] = theZoneAxis->z;		foil_Norm_Cart[0] = theFoilNormal->x; 	foil_Norm_Cart[1] = theFoilNormal->y; 	foil_Norm_Cart[2] = theFoilNormal->z; 	for(j = 0; j < 3;j++){		gVector_Cart[j] *= theCrystal[baseCrystal]->theUnitCell.a;		b_Vector_Cart[j] /= theCrystal[baseCrystal]->theUnitCell.a;	}			VectorCrossProduct(beam_Cart,line_Dir_Cart,cos_Cry_Dis[0]);	VectorCrossProduct(cos_Cry_Dis[2],cos_Cry_Dis[0],cos_Cry_Dis[1]);			NormalizeMatrixRows(cos_Cry_Dis); 	SetVector1EqualTo2(DCX[0],cos_Cry_Dis[0],3,true);	SetVector1EqualTo2(DCX[1],beam_Cart,3,true);	VectorCrossProduct(DCX[0],DCX[1],DCX[2]);		NormalizeMatrixRows(DCX);	MatrixVectorMultiply(cos_Cry_Dis,	b_Vector_Cart	,proj_b_Vector);	MatrixVectorMultiply(cos_Cry_Dis,	beam_Cart		,proj_Beam);	MatrixVectorMultiply(cos_Cry_Dis,	foil_Norm_Cart	,proj_Foil_Norm);	MatrixVectorMultiply(DCX,			foil_Norm_Cart	,proj_Foil_Norm_X);	MatrixVectorMultiply(cos_Cry_Dis,	gVector_Cart	,proj_G_Vect);		AdditionMatrixMults(DCX);		NormalizeVector				(&proj_Beam[0],&proj_Beam[1],&proj_Beam[2]);	NormalizeVector				(&proj_Foil_Norm[0],&proj_Foil_Norm[1],&proj_Foil_Norm[2]);	dotProd_Foil_N_Beam		=  	VectorDotProduct(proj_Beam,proj_Foil_Norm,3);	true_Foil_Thick_Extinct = 	PI * normalized_Thickness / dotProd_Foil_N_Beam;			testFlag = false;	if(fabs(theZoneAxis->GetTheXYZAngle(g_Vector)) < 1.22 && Question(BEAM_G_NOT_90)){		testFlag = true;	}	if(fabs(theZoneAxis->GetTheXYZAngle(lineDirection)) > 1.396 && Question(BEAM_LINE_GT_80)){		testFlag = true;	}	if(fabs(theZoneAxis->GetTheXYZAngle(theFoilNormal)) > .69813 && Question(BEAM_FOIL_NOT_0)){		testFlag = true;	}	if(burgersVector->intensity  < .1 && Question(DISLOC_SHORT)){		testFlag = true;	}	if(w_Off_Bragg > 10 && Question(NOT_CONVERGE)){		testFlag = true;	}	if(testFlag){		KillPtr(TB);		D_MFTempHUnlock(theDataHandle);		if(delugeFlag){			KillPtr((Ptr)FY1);			KillPtr((Ptr)FY2);			KillPtr((Ptr)FY3);			KillPtr((Ptr)FY4);		}			redraw = false;		delugeFlag = false;		return;	}			data_Count = 0;			StackingFaultShifts();			ElasticField();			if(KRASH != 0){		Message(NOT_CONVERGE);		KillPtr(TB);		D_MFTempHUnlock(theDataHandle);		if(delugeFlag){			KillPtr((Ptr)FY1);			KillPtr((Ptr)FY2);			KillPtr((Ptr)FY3);			KillPtr((Ptr)FY4);		}				redraw = false;		delugeFlag = false;		return;	}	SetVectorToOrigin(d_Real,3);	SetVectorToOrigin(d_Image,3);								for(j = 0; j <= 2 ; j++){						for(k = 0; k <= 2 ; k++){			d_Real[j] += (proj_G_Vect[k] * AR[k][j]);			d_Image[j] += (proj_G_Vect[k] * AI[k][j]);		}	}			for(j = 0; j <= 2 ; j++){		z = d_Real[j];		d_Real[j] = z * p_Real[j] - d_Image[j] * p_Image[j];		d_Image[j] = z * p_Image[j] + d_Image[j] * p_Real[j];	}		for(ja = 0; ja <= 2 ; ja++){		for(l = 0; l <= 2 ; l++){			UR[ja][l] = UI[ja][l] = 0.0;			for(j = 0; j <= 2 ; j++){				UR[ja][l] += (eMReal[ja][j] * H[j][l]);				UI[ja][l] += (eMImage[ja][j] * H[j][l]);			}		}	}	for(ja = 0; ja <= 2 ; ja++){		for(l = 0; l <= 2 ; l++){			VR[ja][l] = d_Real[ja] * UR[ja][l] - d_Image[ja] * UI[ja][l];			VI[ja][l] = d_Real[ja] * UI[ja][l] + d_Image[ja] * UR[ja][l];		}	}		for(ja = 0; ja <= 2 ; ja++){		for(l = 0; l <= 2 ; l++){			UR[ja][l] = VR[ja][l] * p_Real[ja] + VI[ja][l] * p_Image[ja];		}	}		for(j = 0; j <= 2 ; j++){		CN[j + 9] = p_Image[j] * p_Image[j];		CN[j + 6] = p_Real[j];		CN[j] 	= 	VectorDotProduct(&VR[j][0],proj_b_Vector,3);		CN[j + 3] = VectorDotProduct(&UR[j][0],proj_b_Vector,3);		DoAddTwoDisCN(VR,UR,j);	}				ADDCN(&EXTRA,&DIVISOR);	delta_Y_Dir_Extinct = delta_X_Dir_Extinct =  (true_Foil_Thick_Extinct + EXTRA) / (xCount + 1);				{		double WL = 0,WW = 0;		WL = (normalized_Thickness * proj_Beam[1] / proj_Foil_Norm[2]) + (EXTRA / DIVISOR);				WW = WL * yCount / pixelsWide;						delta_Y_Dir_Extinct = PI * WW / yCount;	}	CalcShift(&shift, delta_Y_Dir_Extinct,EXTRA,DIVISOR,dotProd_Foil_N_Beam);			*ptrCN29 = 1000.0;	X = Q = 0.0;	eRROR = 0.0001;		for(jk = 0 ; jk <= 7 ; jk++)howie_Whelan_Eq[jk] = 0.0;				*ptrY1 = 1.0;		X1 = delta_X_Dir_Extinct;	RungeKuttaIntegration8Eq();	X1 = true_Foil_Thick_Extinct;	RungeKuttaIntegration8Eq();	if(darkFieldFlag){		BACK = *ptrY3 * *ptrY3 + *ptrY4 * *ptrY4;	} else {		BACK = *ptrY1 * *ptrY1 + *ptrY2 * *ptrY2;	}		if(fabs(proj_Foil_Norm_X[1]) < .00000001){		D_MFTempHUnlock(theDataHandle);		KillPtr(TB);		if(delugeFlag){				KillPtr((Ptr)FY1);				KillPtr((Ptr)FY2);				KillPtr((Ptr)FY3);				KillPtr((Ptr)FY4);		}			delugeFlag = false;		return;	}	redraw = true;	for(jc = 0 ; jc < (yCount) ; jc++){								AllowBackground();		SetupPointers();		if(Quit()){			D_MFTempHUnlock(theDataHandle);			KillPtr(TB);			if(delugeFlag){				KillPtr((Ptr)FY1);				KillPtr((Ptr)FY2);				KillPtr((Ptr)FY3);				KillPtr((Ptr)FY4);			}				delugeFlag = false;			return;		}		*ptrCN15 = ((float )jc  -.5 - (yCount + 1.)/ 2.0) * delta_Y_Dir_Extinct;								CalculateMove(&MOVE, shift);				*ptrCN29 = *ptrCN15 / proj_Beam[1] ;											AdditionalStartAndPositionValues( EXTRA);		AddedOneDisCalc();		X1 = X;				iFlag = 0;						for(jk = 0 ; jk <= 7 ; jk++) howie_Whelan_Eq[jk] = 0.0;					*ptrY1 = *ptrY7 = 1.0;				KOUNTF = 0;		N = 0;		for(jt = 0 ; jt < xCount ; jt++){						X1 += delta_X_Dir_Extinct;						AddedOneDis2();			AdditionalIterations();			RungeKuttaIntegration8Eq();			DNR = *ptrY1 * *ptrY7 - *ptrY2 * *ptrY8 - *ptrY3 * *ptrY5 + *ptrY4 * *ptrY6;			DNI = *ptrY1 * *ptrY8 + *ptrY2 * *ptrY7 - *ptrY3 * *ptrY6 - *ptrY4 * *ptrY5;						DNN = 1.0 / (DNR * DNR + DNI * DNI);			if(delugeFlag){				max_FX++;			}else{				max_FX = jt;			}			FX1[max_FX] = DNN * (*ptrY7 * DNR + *ptrY8 * DNI);			FX2[max_FX] = DNN * (*ptrY8 * DNR - *ptrY7 * DNI);			FX3[max_FX] = -DNN * (*ptrY3 * DNR + *ptrY4 * DNI);			FX4[max_FX] = DNN * (*ptrY3 * DNI - *ptrY4 * DNR);		}				if(iFlag == 0){			X1 = SURFAC;			AddedOneDis3();					}				X = SURFAC;		X1 = X;				BlockMove(TEMPY,howie_Whelan_Eq,eightElements);						KOUNTF = 0;		N = 1;		max_FX -= xCount;		if(Quit()){			D_MFTempHUnlock(theDataHandle);			KillPtr(TB);			if(delugeFlag){				KillPtr((Ptr)FY1);				KillPtr((Ptr)FY2);				KillPtr((Ptr)FY3);				KillPtr((Ptr)FY4);			}			delugeFlag = false;				return;		}				for(jm = 0 ; jm < xCount ; jm++){			max_FX++;			if(delugeFlag){				max_Deluge++;				if(darkFieldFlag){					FY1[max_Deluge] = *ptrY3;					FY2[max_Deluge] = *ptrY4;					FY3[max_Deluge] = *ptrY7;					FY4[max_Deluge] = *ptrY8;				}else{					FY1[max_Deluge] = *ptrY1;					FY2[max_Deluge] = *ptrY2;					FY3[max_Deluge] = *ptrY5;					FY4[max_Deluge] = *ptrY6;				}			}			X1 += delta_X_Dir_Extinct;			AdditionalIterations();			RungeKuttaIntegration8Eq();			if(darkFieldFlag){				part1 = FX1[max_FX] * *ptrY3 - FX2[max_FX] * *ptrY4 + FX3[max_FX] * *ptrY7 - FX4[max_FX] * *ptrY8;				part2 = FX1[max_FX] * *ptrY4 + FX2[max_FX] * *ptrY3 + FX3[max_FX] * *ptrY8 + FX4[max_FX] * *ptrY7;			} else {				part1 = FX1[max_FX] * *ptrY1 - FX2[max_FX] * *ptrY2 + FX3[max_FX] * *ptrY5 - FX4[max_FX] * *ptrY6;				part2 = FX1[max_FX] * *ptrY2 + FX2[max_FX] * *ptrY1 + FX3[max_FX] * *ptrY6 + FX4[max_FX] * *ptrY5;			}			TT = part1 * part1 + part2 * part2;						TB[2 * jm] = TT / BACK;					}						if(darkFieldFlag){			TB[0] = (TEMPY[2] * TEMPY[2] + TEMPY[3] * TEMPY[3]) / BACK;		} else {			TB[0] = (TEMPY[0] * TEMPY[0] + TEMPY[1] * TEMPY[1]) / BACK;		}		for(jz = 1 ; jz < (2 * xCount) - 1; jz += 2){			TB[jz] = .5 * (TB[jz - 1] + TB[jz + 1]);					}		theData = (float*)*theDataHandle;		for(jz = 0; jz < (2 * xCount); jz++){			if(max_Data_Count < data_Count) continue;			theData[data_Count++] = TB[jz];		}					MoveTo(100,100);		{			double value1 = 0,value2 = 0;			value1 = (double)jc + 1;			value2 = (double)yCount;			sprintf(gTheText,"per. comp. = %6.4f",((double)100 * value1)/((double)value2));		}		SetRect(&gTheRect,80,80,280,110);		dm_EraseRect(&gTheRect);		DrawDiffractString(c2pstr(gTheText));					}		D_MFTempHUnlock(theDataHandle);	if(!delugeFlag)KillPtr(TB);	data_Count--;	redraw = true;		return;		*/}void DefectObj::SetResolution(void){		/*	if((yCount % 2) == 0)		yCount++;	KillTempHandle(&theDataHandle);	data_Size = max_Data_Count =  2 * xCount * yCount;	data_Count = 0;	data_Size++;	data_Length = sizeof(float);	theDataHandle		= 	D_TempNewHandle((long)(data_Length * data_Size),&gTheOSError);	if(MemError() != 0 || gTheOSError != 0){		StopAlert(609,0L);		redraw = false;		delugeFlag = false;		return;	}		pixelsWide = 2.0 * xCount;	theSlice = 0.0;	*/}