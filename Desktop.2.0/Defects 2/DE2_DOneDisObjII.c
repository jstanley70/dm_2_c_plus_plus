//Macintosh HD:CodeWarriorª DR/3 Gold Ä:Metrowerks  C/C++ Ä:Projects:D.M. v2.0:Sources.Jim:Desktop.2.0:Defects 2:DE2_DOneDisObjII.c#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include 	"OneDisObj.h"  void OneDisObj::RootOfPolyUsingNewtonMethod(double QReal[7],double QImage[7]){	double  xr,xi,yr,yi,tr,ti,f;	short count,j,converge = 0,m = 0;	for(count = 1 ; count <= 70 ; count++){		xr = xi = yr = yi = 0.0;		for(j = 0 ; j <= nEW; j++){			tr = ZR * yr - ZI * yi + xr;			yi = ZR * yi + ZI * yr + xi;			yr = tr;			m = nEW - j;			tr = ZR * xr - ZI * xi + QReal[m];			ti = ZR * xi + ZI * xr + QImage[m];			if(converge != 0){L1:				QReal[m] = xr;				QImage[m] = xi;			}L2:			xr = tr;L3:			xi = ti;		}				if(converge != 0){L7:			if(fabs(ZR) > 100000.0 * fabs(ZI))L8:				KRASH = nEW;L9:			nEW--;L10:		return;		}		L4:		f = 1.0 / (yr * yr + yi * yi);		tr = f * (xr * yr + xi * yi);		ti = f * (xi * yr - xr * yi);		ZR -= tr;		ZI -= ti;			if(((tr * tr + ti * ti) / (ZR * ZR + ZI * ZI)) <= .000000000001)L5:			converge = 1;	}	KRASH = -70;	return;}void OneDisObj::ElasticField(void){	double	ELR[3][3],ELI[3][3];	double	B[3][3]; 	double  QImage[7],QReal[7];		short 	ja = 0,jb = 0,i = 0,j = 0,k = 0,l = 0,m = 0,n = 0,lp = 0,lq = 0,			lt = 0,kp = 0,kq = 0,kr = 0,ks = 0,kt = 0,nj = 0,nl = 0,ml = 0,			j1 = 0,j2 = 0,i1 = 0,i2 = 0,k1 = 0,k2;	double  elastic_Const[6][6];		double	DR[3][3];	double	DI[3][3];		double	G[9];	double 	EE[9],C11 = 0,C12 = 0;	double	x = 0,y= 0,tempValue= 0,Z= 0,PRK= 0,PIK= 0,SQR= 0,SQI= 0;	double  XR = 0,XI = 0,YR = 0,YI = 0,			DEL = 0,DELI = 0,DELR = 0,AUMR = 0,AUMI = 0;	float	*elastic21;	Identity_Matrix(DI);	Identity_Matrix(DR);	Identity_Matrix(ELI);	Identity_Matrix(ELR);	Identity_Matrix(B);	for(i = 0; i <= 8 ; i++)G[i] = 0;	for(i = 0; i <= 6; i++){QImage[i] = 0;QReal[i] = 0;}	for(i = 0;  i <= 8; i++)	EE[i] = 0;	for(i = 0; i < 6;i++){		for(j = 0; j < 6;j++){elastic_Const[i][j] = 0;}}	C44 = (double)theZoneAxis->theCrystal->elasticConstants[15];	elastic21 = 	theZoneAxis->theCrystal->elasticConstants;	m = 0;	for(ja = 0 ; ja < 6 ; ja++){		for(jb = ja ; jb < 6 ; jb++){			elastic_Const[jb][ja] = elastic_Const[ja][jb] = (double)elastic21[m] / C44;			m++;		}	}					for( m = 0 ; m <= 5 ; m++){		i = L1[m];		j = L2[m];		for(n = 0 ; n <= m ; n++){			k = L1[n];			l = L2[n];			x = 0.0;			for(lp = 0 ; lp <= 2 ; lp++){				y = 0.0;				for(lq = 0 ; lq <= 2 ; lq++){					lt = L3[lp][lq];					y += cos_Cry_Dis[j][lq] *						(cos_Cry_Dis[k][0] * (cos_Cry_Dis[l][0] * elastic_Const[lt][0] + cos_Cry_Dis[l][1] * elastic_Const[lt][5] + cos_Cry_Dis[l][2] * elastic_Const[lt][4]) +						 cos_Cry_Dis[k][1] * (cos_Cry_Dis[l][0] * elastic_Const[lt][5] + cos_Cry_Dis[l][1] * elastic_Const[lt][1] + cos_Cry_Dis[l][2] * elastic_Const[lt][3]) +						 cos_Cry_Dis[k][2] * (cos_Cry_Dis[l][0] * elastic_Const[lt][4] + cos_Cry_Dis[l][1] * elastic_Const[lt][3] + cos_Cry_Dis[l][2] * elastic_Const[lt][2]));				}				x += (cos_Cry_Dis[i][lp] * y);			}			rot_Elastic_Const[n][m] = rot_Elastic_Const[m][n] = x;		}	}	G[0] = rot_Elastic_Const[4][4];	G[1] = rot_Elastic_Const[3][4] * 2.0;	G[2] = rot_Elastic_Const[3][3];	G[3] = rot_Elastic_Const[5][5];	G[4] = rot_Elastic_Const[1][5] * 2.0;	G[5] = rot_Elastic_Const[1][1];	G[6] = rot_Elastic_Const[0][0];	G[7] = rot_Elastic_Const[0][5] * 2.0;	G[8] = rot_Elastic_Const[5][5];		EE[0] = rot_Elastic_Const[4][5];	EE[1] = rot_Elastic_Const[1][4] + rot_Elastic_Const[3][5];	EE[2] = rot_Elastic_Const[1][3];	EE[3] = rot_Elastic_Const[0][4];	EE[4] = rot_Elastic_Const[4][5] + rot_Elastic_Const[0][3];	EE[5] = rot_Elastic_Const[3][5];	EE[6] = rot_Elastic_Const[0][5];	EE[7] = rot_Elastic_Const[5][5] + rot_Elastic_Const[0][1];	EE[8] = rot_Elastic_Const[1][5];	{ /* Determinanent to Solve for the Sextic Equation of Stroh's Theory */				for(kp = 0 ; kp <= 6 ; kp++){			QImage[kp] = QReal[kp] = 0.0;		}		for(kq = 0 ; kq <= 2 ; kq++){			for(kr = 0 ; kr <= 2 ; kr++){				for(ks = 0 ; ks <= 2 ; ks++){					kt = kq + kr + ks;					QReal[kt] = 	QReal[kt] +																	G[kq] * G[kr + 3] * G[ks + 6] +								2.0 * EE[kq] * EE[kr + 3] * EE[ks + 6] -								EE[kq] * EE[kr] * G[ks + 6] - 								EE[kq + 3] * EE[kr + 3] * G[ks + 3] -								EE[kq + 6] * EE[kr + 6] * G[ks];				}			}		}			for(kp = 0 ; kp <= 6 ; kp++)			QReal[kp] /=  QReal[6];	}	KRASH = 0;	nEW = 6;	ZR = 0.1;	ZI = 1.0;	RootOfPolyUsingNewtonMethod(QReal,QImage);	if(KRASH == 0){L61:	p_Real[0] = ZR;		p_Image[0] = fabs(ZI);		ZI = -ZI;		RootOfPolyUsingNewtonMethod(QReal,QImage);		if(KRASH == 0){L62:		ZR = 0.5;			ZI = 0.9;			RootOfPolyUsingNewtonMethod(QReal,QImage);			if(KRASH == 0){L63:			p_Real[1] = ZR;				p_Image[1] = fabs(ZI);				ZI = -ZI;				RootOfPolyUsingNewtonMethod(QReal,QImage);					if(KRASH == 0){L64:				ZR = -ZR;					RootOfPolyUsingNewtonMethod(QReal,QImage);					if(KRASH == 0){L65:					p_Real[2] = ZR;						p_Image[2] = fabs(ZI);						ZR = -rot_Elastic_Const[3][4] / rot_Elastic_Const[3][3];						ZI = sqrt(fabs(rot_Elastic_Const[3][3] * rot_Elastic_Const[4][4] - pow(rot_Elastic_Const[3][4],2.0))) / rot_Elastic_Const[3][3];						for(n = 0 ; n <= 1 ; n++){							tempValue = 	pow((ZR - p_Real[n]),2.0) +											pow((ZI - p_Image[n]),2.0) -											pow((ZR - p_Real[n + 1]),2.0) -											pow((ZI - p_Image[n +1]),2.0);							if(tempValue < 0){L66:							Z = p_Real[n];								p_Real[n] = p_Real[n + 1];								p_Real[n + 1] = Z;								Z = p_Image[n];								p_Image[n] = p_Image[n + 1];								p_Image[n + 1] = Z;							}						}					}				}			}		}	} 		if(KRASH > 0){		Message(NOT_CONVERGE);		return;	} else if (KRASH < 0){		Message(NOT_CONVERGE);		return;	}		for(k = 0 ; k <= 2 ; k++){		i = NP[k];		l = NQ[k];		PRK = p_Real[k];		PIK = p_Image[k];		SQR = PRK * PRK - PIK * PIK;		SQI = 2.0 * PIK * PRK;				DR[0][0] = rot_Elastic_Const[0][0] + PRK * 2.0 * rot_Elastic_Const[0][5] + SQR * rot_Elastic_Const[5][5];		DR[1][1] = rot_Elastic_Const[5][5] + PRK * 2.0 * rot_Elastic_Const[1][5] + SQR * rot_Elastic_Const[1][1];		DR[2][2] = rot_Elastic_Const[4][4] + PRK * 2.0 * rot_Elastic_Const[3][4] + SQR * rot_Elastic_Const[3][3];		DR[1][0] = DR[0][1] = rot_Elastic_Const[0][5] + PRK * (rot_Elastic_Const[0][1] + rot_Elastic_Const[5][5]) + SQR * rot_Elastic_Const[1][5];		DR[2][1] = DR[1][2] = rot_Elastic_Const[4][5] + PRK * (rot_Elastic_Const[3][5] + rot_Elastic_Const[1][4]) + SQR * rot_Elastic_Const[1][3];		DR[0][2] = DR[2][0] = rot_Elastic_Const[0][4] + PRK * (rot_Elastic_Const[0][3] + rot_Elastic_Const[4][5]) + SQR * rot_Elastic_Const[3][5];				DI[0][0] = PIK * 2.0 * rot_Elastic_Const[0][5] + SQI * rot_Elastic_Const[5][5];		DI[1][1] = PIK * 2.0 * rot_Elastic_Const[1][5] + SQI * rot_Elastic_Const[1][1];		DI[2][2] = PIK * 2.0 * rot_Elastic_Const[3][4] + SQI * rot_Elastic_Const[3][3];		DI[1][0] = DI[0][1] = PIK * (rot_Elastic_Const[0][1] + rot_Elastic_Const[5][5]) + SQI * rot_Elastic_Const[1][5];		DI[2][1] = DI[1][2] = PIK * (rot_Elastic_Const[3][5] + rot_Elastic_Const[1][4]) + SQI * rot_Elastic_Const[1][3];		DI[0][2] = DI[2][0] = PIK * (rot_Elastic_Const[0][3] + rot_Elastic_Const[4][5]) + SQI * rot_Elastic_Const[3][5];				for(j = 0 ; j <= 2 ; j++){			m = NP[j];			n = NQ[j];			AR[j][k] = 	DR[i][m] * DR[l][n] - DI[i][m] * DI[l][n] - DR[i][n] * DR[l][m] + DI[i][n] * DI[l][m];L80:		AI[j][k] = 	DR[i][m] * DI[l][n] + DI[i][m] * DR[l][n] - DR[i][n] * DI[l][m] - DI[i][n] * DR[l][m];		}	}								for(j = 0 ; j <= 2 ; j++){		nj = NN[j];			for(k = 0 ; k <= 2 ; k++){			XR = XI = 0.0;			for(l = 0 ; l <= 2 ; l++){				nl = NN[l];				ml = MM[l];				YR = rot_Elastic_Const[nj][ml] + rot_Elastic_Const[nj][nl] * p_Real[k];				YI = rot_Elastic_Const[nj][nl] * p_Image[k];				XR += (YR * AR[l][k] - YI * AI[l][k]);L81:			XI += (YI * AR[l][k] + YR * AI[l][k]);			}			ELR[j][k] = XR;L82:		ELI[j][k] = XI;		}	}			for(j = 0 ; j <= 2 ; j++){		j1 = NP[j];		j2 = NQ[j];		for(k = 0 ; k <= 2 ; k++){			k1 = NP[k];			k2 = NQ[k];			eMReal[k][j] =		ELR[j1][k1] * ELR[j2][k2] - ELI[j1][k1] * ELI[j2][k2] -							ELR[j1][k2] * ELR[j2][k1] + ELI[j1][k2] * ELI[j2][k1];						eMImage[k][j] =		ELR[j1][k1] * ELI[j2][k2] + ELI[j1][k1] * ELR[j2][k2] -							ELR[j1][k2] * ELI[j2][k1] - ELI[j1][k2] * ELR[j2][k1];		}	}		DELI = DELR = 0.0;	for(j = 0 ; j <= 2 ; j++){		DELR += (ELR[2][j] * eMReal[j][2] - ELI[2][j] * eMImage[j][2]);		DELI += (ELR[2][j] * eMImage[j][2] + ELI[2][j] * eMReal[j][2]);	}		AUMR = DELR / (DELR * DELR + DELI * DELI);	AUMI = -DELI / (DELR * DELR + DELI * DELI);	for(j = 0 ; j <= 2 ; j++){		for(k = 0 ; k <= 2 ; k++){			x = eMReal[j][k] * AUMR - eMImage[j][k] * AUMI;			eMImage[j][k] = eMReal[j][k] * AUMI + eMImage[j][k] * AUMR;			eMReal[j][k] = x;		}	}		for(i = 0 ; i <= 2 ; i++){		for(j = 0 ; j <= 2 ; j++){			B[i][j] = 0.0;			for(k = 0 ; k <= 2 ; k++){L86:			B[i][j] += (-AR[i][k] * eMImage[k][j] - AI[i][k] * eMReal[k][j]);			}		}	}		for(i = 0 ; i<= 2 ; i++){		i1 = NP[i];		i2 = NQ[i];		for(j = 0 ; j <= 2 ; j++){			j1 = NP[j];			j2 = NQ[j];L87:		H[i][j] = B[i1][j1] * B[i2][j2] - B[i1][j2] * B[i2][j1];		}	}		DEL = B[2][0] * H[2][0]  + B[2][1] * H[2][1] + B[2][2] * H[2][2];	for(i = 0 ; i<= 2 ; i++){		for(j = 0 ; j <= 2 ; j++){			H[i][j] /= DEL;		}	}}void OneDisObj::RungeKuttaIntegration8Eq(void){	double  doubler = 0,test = 0,XT = 0;	short 	last = 0,m = 0;	double	*thePtr,*thePtrD,*thePtrY;	last = 0;	if(Q == 0){L1:		Q = X1 - X;		SKIP = false;		Q15 = 0.0;		highError = eRROR * 5.0;		loError = highError * 0.03125;L2:		last = 1;		Q1 = Q;		Q = X1 - X;L3:		XT = X;		if(Quit())return;		BlockMove(howie_Whelan_Eq,YT,eightElements);		if((Q * 1.5) < Q15 + .0000001 &&  (Q * 1.5) > Q15 - .0000001)/* used to be equal to*/			goto L7;			L6:		Q2 	= Q / 2.0;if(Quit())return;		Q3 	= Q / 3.0;		Q4 	= 4.0 * Q3;		Q6 	= Q / 6.0;		Q15 = Q * 1.5;L7:		HowieWhelanDeriv();		thePtr = howie_Whelan_Eq;		thePtrD = D,		thePtrY = YT;		for(m = 0 ; m<= 7 ; m++,thePtrY++,thePtr++,thePtrD++){			DT[m][0] = Q3 * *thePtrD;			*thePtr = DT[m][0] + *thePtrY;		}				X += Q3;		HowieWhelanDeriv();		thePtrY = YT;		thePtrD = D,		*ptrY1 = Q6 * *thePtrD + 0.5 * DT[0][0] + *thePtrY;		thePtrD++;thePtrY++;		*ptrY2 = Q6 * *thePtrD + 0.5 * DT[1][0] + *thePtrY;		thePtrD++;thePtrY++;		*ptrY3 = Q6 * *thePtrD + 0.5 * DT[2][0] + *thePtrY;		thePtrD++;thePtrY++;		*ptrY4 = Q6 * *thePtrD + 0.5 * DT[3][0] + *thePtrY;		thePtrD++;thePtrY++;		*ptrY5 = Q6 * *thePtrD + 0.5 * DT[4][0] + *thePtrY;		thePtrD++;thePtrY++;		*ptrY6 = Q6 * *thePtrD + 0.5 * DT[5][0] + *thePtrY;		thePtrD++;thePtrY++;		*ptrY7 = Q6 * *thePtrD + 0.5 * DT[6][0] + *thePtrY;		thePtrD++;thePtrY++;		*ptrY8 = Q6 * *thePtrD++ + 0.5 * DT[7][0] + *thePtrY;		thePtrD++;thePtrY++;								SKIP = true;		HowieWhelanDeriv();		SKIP = false;		if(Quit())return;		thePtr = howie_Whelan_Eq;		thePtrD = D,		thePtrY = YT;		for(m = 0 ; m<= 7 ; m++,thePtr++,thePtrD++,thePtrY++){			DT[m][1] = Q15 * *thePtrD;L10:		*thePtr = .375 * DT[m][0] + 0.25 * DT[m][1] + *thePtrY;		}				X = XT + Q2;		HowieWhelanDeriv();		thePtr = howie_Whelan_Eq;		thePtrD = D,		thePtrY = YT;		for(m = 0 ; m<=7 ; m++,thePtr++,thePtrD++,thePtrY++){			DT[m][0] = Q4 * *thePtrD + DT[m][0];L11:	*thePtr = 1.5 * DT[m][0] - DT[m][1] + *thePtrY;		}				X = XT + Q;			/* was Q2  */		HowieWhelanDeriv();		doubler = 2.0;		thePtrD = D;		for(m = 0 ; m < 8 ; m++,thePtrD++){			DT[m][2] = Q6 * *thePtrD;			test = fabs(DT[m][0] - DT[m][1] - DT[m][2]);			if(fabs(test) > 10e100)goto L15;			if(test > highError)				goto L18;L12:		if(test >= loError)L13:			doubler = 1.0;		}		thePtr = howie_Whelan_Eq;		thePtrY = YT;				for(m = 0 ; m<= 7 ; m++,thePtrY++,thePtr++)		*thePtr = .5 * DT[m][0] + DT[m][2] + *thePtrY;		Q *= doubler ; 		/*|| (fabs(Q1)  < .0000001 || fabs(Q) < .0000001) interesting addition*/		if(last != 0 || (fabs(Q1)  < .0000001 || fabs(Q) < .0000001)){			if(1.0 > (Q / Q1))Q = Q1;L15:			return;		}	}L16:	if(1.0 >= ((X1 - X) / Q))goto L2;			goto L3;L18:	Q /= 2.0;		last = 0;	L19:	BlockMove(YT,howie_Whelan_Eq,eightElements);			X = XT;	goto L6;}void OneDisObj::HowieWhelanDeriv(void){	double  Z = 0,R = 0,RCN7 = 0,RCN8 = 0,RCN9 = 0;			if(!SKIP){		if(X == 0.)			X = 0.0000000001;		R = *ptrCN29 / X;		RCN7 = R + *ptrCN7;		RCN8 = R + *ptrCN8;		RCN9 = R + *ptrCN9;		displacement_Norm = *ptrCN14 	+ ((R * *ptrCN1 + *ptrCN4) / (RCN7 * RCN7 + *ptrCN10)							+  (R * *ptrCN2 + *ptrCN5) / (RCN8 * RCN8 + *ptrCN11)							+  (R * *ptrCN3 + *ptrCN6) / (RCN9 * RCN9 + *ptrCN12)) / X;	}			Z = anomAbsorbCoeff * (*ptrY1 + *ptrY3);	*ptrD1 = Z - *ptrY4;	*ptrD3 = -displacement_Norm * *ptrY4 + Z - *ptrY2;	Z = anomAbsorbCoeff * (*ptrY2 + *ptrY4);	*ptrD2 = Z + *ptrY3;	*ptrD4 = displacement_Norm * *ptrY3 + Z + *ptrY1;	Z = anomAbsorbCoeff * (*ptrY5 + *ptrY7);	*ptrD5 = Z - *ptrY8;	*ptrD7 = -displacement_Norm * *ptrY8 + Z - *ptrY6;	Z = anomAbsorbCoeff * (*ptrY6 + *ptrY8);	*ptrD6 = Z + *ptrY7;	*ptrD8 = displacement_Norm * *ptrY7 + Z + *ptrY5;}void OneDisObj::GrayScale(short theX,short theY,double intensity){	short theGray;		double theValue;		theValue 	= (grayGain * (intensity)) + 15;	theGray 	= Round(theValue);	if(theGray < 15 )		theGray = 15;	if(theGray > 255)		theGray = 255;	if(theGray != lastGray || theY != lastY){		if(g_Monitor)			DMForeColor((short)lastGray);		else{			short patID = 0;			PatHandle hPat;			patID = 10 - theGray;			patID += 300;			PenNormal();			DMForeColor(BLACK);			hPat = GetPattern(patID);			PenPat(*hPat); 			ReleaseResource((Handle)hPat);		}		LineTo(lastX,lastY);		lastGray = theGray;		if(theY != lastY)			MoveTo(theX,theY);	} 	lastX = theX;	lastY = theY;}void OneDisObj::SetupPointers(void){	ptrCN1 = &CN[0];	ptrCN2 = &CN[1];	ptrCN3 = &CN[2];	ptrCN4 = &CN[3];	ptrCN5 = &CN[4];	ptrCN6 = &CN[5];	ptrCN7 = &CN[6];	ptrCN8 = &CN[7];	ptrCN9 = &CN[8];	ptrCN10 = &CN[9];	ptrCN11 = &CN[10];	ptrCN12 = &CN[11];	ptrCN13 = &CN[12];	ptrCN14 = &CN[13];	ptrCN15 = &CN[14];	ptrCN16 = &CN[15];	ptrCN17 = &CN[16];		ptrCN21 = &CN[20];	ptrCN22 = &CN[21];	ptrCN23 = &CN[22];	ptrCN24 = &CN[23];	ptrCN25 = &CN[24];	ptrCN26 = &CN[25];	ptrCN29 = &CN[28];	ptrCN30 = &CN[29];			ptrD1 = &D[0];	ptrD2 = &D[1];	ptrD3 = &D[2];	ptrD4 = &D[3];	ptrD5 = &D[4];	ptrD6 = &D[5];	ptrD7 = &D[6];	ptrD8 = &D[7];	ptrY1 = &howie_Whelan_Eq[0];	ptrY2 = &howie_Whelan_Eq[1];	ptrY3 = &howie_Whelan_Eq[2];	ptrY4 = &howie_Whelan_Eq[3];	ptrY5 = &howie_Whelan_Eq[4];	ptrY6 = &howie_Whelan_Eq[5];	ptrY7 = &howie_Whelan_Eq[6];	ptrY8 = &howie_Whelan_Eq[7];}void OneDisObj::SetImageParameters(double *k_D,double *I_D,short *lastX,long *twoXCount,long *twoYCount){	double testCountX;	short	hRes,vRes;		ScreenRes(&hRes, &vRes);		lastGray = -100;	*twoYCount		=	yCount;	testCountX 		= ((double)negWidth / 50.8) * (double)hRes;	*k_D			= testCountX / (double)(xCount);	testCountX 		= ((double)negHeight / 25.4) * (double)vRes;	*I_D			= testCountX / (double)yCount;			SetIntensities();	SetGrayConstants();	*lastX 	= 0;//centerX - ((double)negWidth / 50.8) * (double)hRes;	lastY 	= 0;centerY - ((double)negHeight / 50.8) * (double)vRes;	MoveTo	(*lastX,lastY);	lastGray = -100;	*twoXCount = xCount * 2;}void OneDisObj::DoPictDraw(void){	short 	i,jz,j;	float 	*theData;	short 	theX,			theY,			startX;	double  testCountX = 0;	long	twoXCount = 0,totalCounts,twoYCount;	double 	k_D = 0,			l_D = 0,			theY_D = 0,			theX_D = 0;		SetDrawEnviron();	if(data_Count < 10 || !redraw){		dm_FrameRect(&thePictRect);		return;	}		totalCounts = GetHandleSize(theDataHandle) / sizeof(float);	theData = (float*)*theDataHandle;	SetImageParameters(&k_D, &l_D, &lastX,&twoXCount,&twoYCount);	jz = 0;	startX 	= theX = lastX;	theY_D 	= lastY;	for(i = 0 ; i < twoYCount && i < totalCounts; i++){		if(jz > data_Count)continue;		theY = Round(theY_D);		for(theX_D = (double)startX, j = 0;j < twoXCount - 2  && j < totalCounts;j++ ,theX_D += k_D,theData++){			double doubVal;			theX = Round(theX_D);			doubVal = *theData;			GrayScale(theX,theY,(double)(doubVal - minIntensity));			jz++;		}		theY_D += l_D;	}	ClearDrawEnviron();}void	OneDisObj::ThicknessMacro(void){	float	*theData;	long	k,i = 0,nX,nY,nCalc,nInt,jz,baseCount,startX,oldValue;	double 	part1,part2,extInterval;	double  BACK,TT;	short 	hRes,vRes,theInterval;	Boolean	newRow;		if((numberOfSteps * interval) <= 0){		/*MFTemp*/D_HUnlock(theDataHandle);		KillPtr(TB);		KillPtr(FY1);		KillPtr(FY2);		KillPtr(FY3);		KillPtr(FY4);		 return;	}	/*MFTemp*/D_HLock(theDataHandle);	ScreenRes(&hRes, &vRes);	theData = (float*)*theDataHandle;	newRow = false;	extInterval						=			PI * interval;	extInterval 			/= 	(g_Vector->TheExtinctionDist(1./ wavelength,1. + ( (double)energy / 511.),theBeamFlag) * delta_X_Dir_Extinct);		for(i = 1; i <= numberOfSteps;i++){		float *TB_P;		theInterval			=	extInterval * i;		theSlice = theInterval * delta_X_Dir_Extinct;		X1 = true_Foil_Thick_Extinct - theSlice;		data_Count = 0;		if(X1 <= 0){			/*MFTemp*/D_HUnlock(theDataHandle);			KillPtr(TB);			KillPtr(FY1);			KillPtr(FY2);			KillPtr(FY3);			KillPtr(FY4);			return;		}		X = 0.0;		*ptrCN29 = 1000.;		for(k = 0; k <= 7; k++) howie_Whelan_Eq[k] = 0.0;		howie_Whelan_Eq[0] = 1.0;		SetupPointers();		RungeKuttaIntegration8Eq();		if(darkFieldFlag){			BACK = *ptrY3 * *ptrY3 + *ptrY4 * *ptrY4;		} else {			BACK = *ptrY1 * *ptrY1 + *ptrY2 * *ptrY2;		}			nCalc = xCount - theInterval * i;		nInt = (2 * nCalc) - 2;		if(nCalc <= 0){			/*MFTemp*/D_HUnlock(theDataHandle);			KillPtr(TB);			KillPtr(FY1);			KillPtr(FY2);			KillPtr(FY3);			KillPtr(FY4);			return;		}		baseCount = xCount;		startX 	= 0;		for(k = 0; k < yCount;k++){			short j;			float *FY1_P,*FY2_P,*FY3_P,*FY4_P;			j = 0;			FY1_P = &FY1[startX];			FY2_P = &FY2[startX];			FY3_P = &FY3[startX];			FY4_P = &FY4[startX];			TB_P = TB;			for(nY = startX; nY < nCalc;nY++,j++,FY1_P++,FY2_P++,FY3_P++,FY4_P++,TB_P += 2){				nX = nY - nCalc + baseCount;				part1 = (FX1[nX] * *FY1_P - 	 FX2[nX] * *FY2_P					+  FX3[nX] * *FY3_P - FX4[nX] * *FY4_P);								part2 = FX1[nX] * *FY2_P +  FX2[nX] *  *FY1_P					+ FX3[nX] * *FY4_P + FX4[nX] * *FY3_P;								TT =  part1 * part1 + part2 * part2;				*TB_P = TT/ BACK;			}			baseCount += xCount;			startX		+= xCount;			nCalc			+= xCount;			TB_P = &TB[1];			for(jz = 1,j = 0; j < nInt ;jz += 2,j++,TB_P += 2){				*TB_P = .5 * (TB_P[-1] + TB_P[1]);			}			TB_P = TB;			theData = (float*)*theDataHandle;			for(jz = 0; jz < nInt; jz++,TB_P++){				if(data_Size < data_Count) continue;				theData[data_Count++] = *TB_P;			}		}				/*MFTemp*/D_HUnlock(theDataHandle);		redraw = true;		oldValue = xCount;		xCount = (nInt/2) + 1;		pictID->AddThickness(i);		SetPictFrame(false);		SetPict(false);		xCount = oldValue;		/*MFTemp*/D_HLock(theDataHandle);	}	/*MFTemp*/D_HUnlock(theDataHandle);	KillPtr(TB);	KillPtr(FY1);	KillPtr(FY2);	KillPtr(FY3);	KillPtr(FY4);	return;}void OneDisObj::InitCalc(void){	short i,j;	KRASH = 0;	eRROR = 0;Q = 0;ANO = 0;ZR = 0 ;ZI = 0;	C44 = 0;	for(i = 0; i <= 5;i++)	{		for(j = 0; j <= 5;j++)			rot_Elastic_Const[i][j] = 0;	}	for(i = 0; i <= 8;i++)D[i] = 0;  	for(i = 0; i <= 2;i++){	p_Real[i] = 0;p_Image[i] = 0;}	  	dotProd_Foil_N_Beam = 0;	delta_X_Dir_Extinct = 0;	nEW = 6;	Identity_Matrix(H);	Identity_Matrix(eMReal);	Identity_Matrix(eMImage);	Identity_Matrix(AI);	Identity_Matrix(AR);	max_Deluge = 0;; 	 Q1	=	0; 	 Q2	=	0; 	 Q3	=	0; 	 Q4	=	0;Q6 = 0; 	 Q15	=	0;highError = 0;loError = 0; 	lastX 	= 0; 	lastY	=	0;	for(i = 0; i <= 7;i++){		YT[i] = 0;		for(j = 0; j <= 2;j++)		{			DT[i][j] = 0;		}	} 	lastGray = 0; 	 	 			maxIntensity	=	0 ;	minIntensity 	= 0;	grayGain 		= 0;	grayOffset 		= 0;		Identity_Matrix(cos_Cry_Dis);	for(i = 0; i <= 2;i++)	{		gVector_Cart[i] = 0;		proj_Beam[i] = 0;		proj_Foil_Norm_X[i] = 0;	} 	KOUNTF = 0; 	N = luck = 0; 	X = X1 = 0; 	MW = 0;	MR = 0;	iFlag = 0;  	STARTA = 0;	for(i = 0; i <= 30;i++)CN[i] = 0;	SURFAC = 0;	for(i = 0; i <= 8;i++)TEMPY[i] = 0;	FINISH = 0;			 SKIP = 0;	displacement_Norm = 0;		for(i = 0; i <= 7;i++)howie_Whelan_Eq[i] = 0;	eightElements = 0;	theSlice = 0;	}void OneDisObj::CalculateThickness(void){	double		extDist;	double 	electronMassRation;	electronMassRation 	= 	1. + ( (double)energy / 511.);	extDist 			= 	theFoilBragg->TheExtinctionDist(1./ wavelength,electronMassRation,theBeamFlag);	normalized_Thickness = 10 * theFoilThickness / extDist;}void OneDisObj::CheckBeamsMem(short n){	short p;	switch(n)	{		case -1:		KillHandle((Handle*)&anomAbsorbCoeffs);		KillHandle((Handle*)&rotationAngles);		KillHandle((Handle*)&offLaueDistances);		KillHandle((Handle*)&orTypes);		break;		case 0:		anomAbsorbCoeffs 	=	(float**)D_NewHandle(sizeof(float) * 7);		rotationAngles		=	(float**)D_NewHandle(sizeof(float) * 7);		offLaueDistances	=	(float**)D_NewHandle(sizeof(float) * 7);		orTypes				=	(short**)D_NewHandle(sizeof(short) * 7);		break;		case 1:		p = GetHandleSize((Handle)anomAbsorbCoeffs) / sizeof(float);		if(p > number_Beams){			SetHandleSize((Handle)anomAbsorbCoeffs,sizeof(float) * (number_Beams + 5));			SetHandleSize((Handle)rotationAngles,sizeof(float) * (number_Beams + 5));			SetHandleSize((Handle)offLaueDistances,sizeof(float) * (number_Beams + 5));			SetHandleSize((Handle)orTypes,sizeof(short) * (number_Beams + 5));		}		break;	}}	double 			OneDisObj::DrawDislocationSchematic(Rect theRect,Index *lineDir,Index *burgerV,Boolean erase){ 		short 		midHor,midVer,hor,ver;		double			length,x;		Crystal 	*thisCrystal;		double		magnification,dspacing;		double		xFormMatrix[3][3],xForm[3][3],angle,angle2,angle3;		short			orNum = 0;		RgnHandle theRgn;		Rect			aRect;		GetClip(gTheRgn);		theRgn = D_NewRgn();		RectRgn(theRgn,&theRect);				D_SetClip(theRgn);		if(erase)dm_EraseRect(&theRect);		if(erase)dm_FrameRect(&theRect);		lineDir->x = lineDir->h;		lineDir->y = lineDir->k;		lineDir->z = lineDir->l;		angle					=	AngleBetFoilAndBeam(lineDir,theFoilBragg,theFNRotationAxis,0,0,0,1);		angle2				=	AngleBetFoilAndBeam(burgerV,theFoilBragg,theFNRotationAxis,theFNRotationAngle,theFNOffLaueDistance,0,2);		angle3				=	lineDir->GetTheAngle(burgerV);		magnification = fabs(cos(angle));		angle  *= 180 / PI;		angle2 *= 180 / PI;		if(magnification < .001){				length = (theRect.right - theRect.left) * 2;		}else{				x = trueThickness / magnification;				length = sqrt(x * x -   (trueThickness * trueThickness));		}		if(length < 1){			length = 2;			magnification = 1.5;		}else			magnification = (theRect.right - theRect.left)/length;		midHor				=	(theRect.right + theRect.left)/2;		midVer				=	(theRect.bottom + theRect.top)/2;		thisCrystal 	= theZoneAxis->theCrystal;		GetOrientation(xFormMatrix);		GetPPTXFormMatrixBase		(xForm,thisCrystal,orNum);		MatrixMultiply		(xForm,xFormMatrix,xForm); 								lineDirection	->	GetXYZ(xForm); /* Transforms to Cartesian coordinates & rotates */		dspacing 			=	lineDirection	->GetLength();		lineDirection	->x /= dspacing;		lineDirection	->y /= dspacing;		lineDirection	->z /= dspacing;				burgerV->GetXYZAndMultByIntensity(xForm);				hor = lineDirection	->y * length * magnification;		ver = lineDirection	->x * length * magnification;		MoveTo(midHor - hor/2,midVer - ver/2);		LineTo(midHor + hor/2,midVer + ver/2);		SetRect(&aRect,midHor - 2 + hor/2 ,midVer  - 2 + ver/2,midHor + 2 + hor/2 ,midVer  + 2 + ver/2);		dm_FrameOval(&aRect);		hor = burgerV	->y * 50 * magnification;		ver = burgerV	->x * 50 * magnification;				PenSize(2,2);		MoveTo(midHor,midVer);		LineTo(midHor + hor,midVer + ver);		PenSize(1,1);		ScreenRes(&hor,&ver);		D_SetClip				(gTheRgn);		D_DisposeRgn		(&theRgn);		if(!erase)return magnification;						sprintf				(gTheText,"%6.2f  ",hor/ (magnification * 1.27));		SetRect				(&theRect,theRect.left - 40,theRect.bottom + 1,theRect.right + 52,theRect.bottom + 52);		dm_EraseRect			(&theRect);		MoveTo				(theRect.left + 42,theRect.bottom - 48);		LineTo				(theRect.left + 42 + (hor / 1.27),theRect.bottom - 48);		MoveTo				(theRect.left + 42,theRect.bottom - 36);		c2pstr				(gTheText);		TextSize			(9);			TextFont			(geneva);		DrawString		(pTheText);		MoveTo				(theRect.left,theRect.bottom - 24);		sprintf				(gTheText,"angle bet. line & Beam = %5.1f ¡",angle);		c2pstr				(gTheText);		DrawString		(pTheText);				MoveTo				(theRect.left,theRect.bottom - 12);		sprintf				(gTheText,"angle bet. burger & Beam = %5.1f ¡",angle2);		c2pstr				(gTheText);		DrawString		(pTheText);				MoveTo				(theRect.left,theRect.bottom);		sprintf				(gTheText,"angle bet. line & burgers = %5.1f ¡",angle3);		c2pstr				(gTheText);		DrawString		(pTheText);				TextFont			(0);		TextSize			(0);		return magnification;}#pragma segment Mainvoid  OneDisObj::DrawDislocation(void){	CTabHandle		destCTab;	GWorldPtr 		currPort;    // Saves the current port prior to setting up offscreen world	GDHandle 			currDev;       // Saves the current device prior to setting up offscreen world	short 				err;                    //  error returned from Pointer to OffScreen Graphics World	PaletteHandle	thisPalette;	GWorldPtr			gW1;	PictObj			*thePictObj;	Rect					theRect;	RgnHandle			theClipRgn;		theClipRgn = D_NewRgn();	thisPalette = GetPalette(theWindow);	destCTab = GetCTable(2100);	Palette2CTab(thisPalette,destCTab);//	CTabChanged(destCTab);	//DisposePalette(thisPalette);	GetGWorld(&currPort,&currDev);	theRect = thePictRect;	OffsetRect(&theRect,-thePictRect.left,-thePictRect.top);	//err = NewGWorld(&gW1, 8, &theRect,destCTab, nil, 0);// Create Offscreen Graphics world.	err = NewGWorld(&gW1, (*(currPort->portPixMap))->pixelSize,&theRect,destCTab, nil, 0);// Create Offscreen Graphics world.	if(err){gW1 = 0L;return;}	if (!err) {		LockPixels (gW1->portPixMap);		// Setup drawing area to be our offscreen graphics world		SetGWorld (gW1, nil);		BackColor (whiteColor);		DMBackColor		(BACKGROUND_COLOR);		ForeColor (blackColor);		BackColor (whiteColor);		DoResetOrigin();		DoSetOrigin();		RectRgn(theClipRgn,&theRect);		D_SetClip(theClipRgn);		dm_EraseRect (&theRect);						SetObjectDrawTransferMode();			PenMode(gMode);		DoPictDraw();				SetGWorld (currPort, currDev);// Done drawing, now reset Port etc.				ForeColor (blackColor);		BackColor (whiteColor);		RectRgn(theClipRgn,&theRect);		D_SetClip(theClipRgn);		dm_EraseRect (&theRect);		screenPict = OpenPicture(&theRect);			CopyBits ( (BitMap *) (*(gW1->portPixMap)),						&((GrafPtr)theWindow)->portBits, &theRect, &theRect, gMode, nil);//srcCopy		ClosePicture();				UnlockPixels (gW1->portPixMap);		DMBackColor		(BACKGROUND_COLOR);			}	DisposeGWorld(gW1);	DisposCTable(destCTab);	RectRgn(theClipRgn,&theRect);	D_SetClip(theClipRgn);	thePictObj = 	(PictObj*)D_new(PictObj);	thePictObj->	DoInit((Handle)this);	thePictObj->	AddPictObj(screenPict,&thePictRect);	pictID->			SetPict(thePictObj);	D_DisposeRgn(&theClipRgn);}void OneDisObj::FastPictDraw(void)//Override{//	pictID->DrawDisPicture();	inherited::FastPictDraw();}Boolean OneDisObj::GetFoilPtrs(Boolean *thePtr1,short *thePtr2,short *thePtr3){	*thePtr1 = delugeFlag;	*thePtr2 = numberOfSteps;	*thePtr3 = interval;	return true;}	void OneDisObj::SetFoilPtrs(Boolean thePtr1,short thePtr2,short thePtr3){	delugeFlag = thePtr1;	numberOfSteps = thePtr2;	interval = thePtr3;}#pragma segment Mainvoid OneDisObj::SetORToNewBase(short newCrystal)//Override{	inherited::SetORToNewBase(newCrystal);	burgersVector->theCrystal = theCrystal[newCrystal];	lineDirection->theCrystal = theCrystal[newCrystal];}