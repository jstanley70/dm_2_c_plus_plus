//Macintosh HD:CodeWarriorª DR/3 Gold Ä:Metrowerks  C/C++ Ä:Projects:D.M. v2.0:Sources.Jim:Desktop.2.0:Defects 2:DE2_OneDisObj2.c#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include 	"OneDisObj.h" #define MICRODEFINE 326#define ADDDEFECT 327void OneDisObj::ADDCN(double *EXTRA,double *DIVISOR){	*EXTRA = 0;	*DIVISOR = 1;}void OneDisObj::ColorTest(void){	Rect theRect;	short x,k = 10;		/*for(x = 0 ; x <= 638 ; x++){		SetRect(&theRect,x,400,x + 2,440);		k = (x * 255) / 638;		DMForeColor(k);		dm_PaintRect(&theRect);	}*/	for(x = 50 ; x <= 498 ; x += 2,k++){		SetRect(&theRect,x,360,x + 3,440);		DMForeColor(k);		dm_PaintRect(&theRect);	}}void OneDisObj::DrawALine(double *m,short h,short v){		DMForeColor(0);	sprintf(gTheText,"%8.5f    %8.5f     %8.5f",m[0],m[1],m[2]);	MoveTo(h,v);	DrawDiffractString(c2pstr(gTheText));}void OneDisObj::SetIntensities(void){	long jz;	float	*theData;	theData = (float*)*theDataHandle;	maxIntensity	= -1957;	minIntensity	= 1957;	for(jz = 0 ; jz < data_Count -2 ;jz++, theData++){		if(*theData > maxIntensity){			maxIntensity = *theData;		}		if(*theData < minIntensity /*&& *theData/minIntensity > .1*/){			minIntensity = *theData;		}	}}void OneDisObj::SetGrayConstants(void){	double  span;		span = (maxIntensity - minIntensity);		if(span == 0){		grayGain = 1;		return;	}	if(g_Monitor){		grayGain = 240. / span;	}else{		grayGain = 10/span;	}}Boolean OneDisObj::GetVectors(void){	double  u,v,w;	double	crystalXForm[3][3],matrix[3][3];	double	dspacing;	double  sZ,sL;		theZoneAxis->theCrystal->Get001XForm(crystalXForm);	ConverttoReciprocal		(crystalXForm,(double)theZoneAxis->theCrystal->volume,true);		g_Vector	->	GetXYZ(crystalXForm);			theZoneAxis->theCrystal->Get001XForm(crystalXForm);		IrrationalZoneAxis(theFoilNormal,theFNRotationAxis,theFoilBragg,theFNRotationAngle,theFNOffLaueDistance,totalRot,beamAzimuth,calcFoil,&u,&v,&w,matrix); 		TRANSFORM_VECTOR	(u,v,w,crystalXForm); /* Transforms to Cartesian coordinates */	NormalizeVector		(&u,&v,&w);	theFoilNormal->x = u;	theFoilNormal->y = v;	theFoilNormal->z = w;		IrrationalZoneAxis(theZoneAxis,theRotationAxis,g_Vector,rotationAngle,offLaueDistance,totalRot,beamAzimuth,calcIrrational,&u,&v,&w,matrix); 			TRANSFORM_VECTOR(u,v,w,crystalXForm); /* Transforms to Cartesian coordinates */	NormalizeVector(&u,&v,&w);	theZoneAxis->x = u;	theZoneAxis->y = v;	theZoneAxis->z = w;		lineDirection	->	GetXYZ(crystalXForm); /* Transforms to Cartesian coordinates */	dspacing 			=	lineDirection	->GetLength();	lineDirection	->x /= dspacing;	lineDirection	->y /= dspacing;	lineDirection	->z /= dspacing;		burgersVector->GetXYZAndMultByIntensity(crystalXForm);	w_Off_Bragg =  CalculateW_OffBragg(theZoneAxis,theRotationAxis,g_Vector, rotationAngle, offLaueDistance, totalRot, calcIrrational,&sZ,&sL);	CalculateThickness();	return true;}	void	OneDisObj::DoMenu(long theResult){	short theMenu,theItem;				theMenu = HiWord(theResult);	theItem = LoWord(theResult);	switch(theMenu){		case MICRODEFINE:			switch(theItem){				case 1:					//DoDefine();					DoSetUp();					break;				case 2:					DefineFoilNormal();					break;								case 4:					changedFlag = true;										break;				case 5:					redraw = true;					newPictReq = true;					break;						}			break;		case ADDDEFECT:			switch(theItem){				case 1:					DefineDislocation();					break;				default:					break;			}			break;		case PALETTE_MENU_1:			if(!g_Monitor)				break;			{				short 			paletteID,itemCnt,i;								itemCnt = CountMItems(GetMenu(PALETTE_MENU_1));				for(i = 1;i <= itemCnt;i++) CheckItem(GetMenu(PALETTE_MENU_1),i,false);				CheckItem(GetMenu(PALETTE_MENU_1),theItem,true);				if(theItem >= 1 && theItem < 11)				paletteID = theItem + 2100;				else paletteID = 2110;				SetWindowColors(paletteID);								/*DrawPicture(screenPict,&thePictRect);*/				redraw = true;				newPictReq = true;			}			break;	}			inherited::DoMenu(theResult);	switch(theMenu){		short i;		case PARAMETER_MENU:			switch(theItem){				case DEFINE_BEAM_OR:		 			i = number_Beams;					number_Beams = 1;					InsertCurrentBeam();					number_Beams = i;					changedFlag = false;					newPictReq = false;					break;				case DEFINE_FOIL_OR:					changedFlag = false;					newPictReq = false;					break;			}		break;	}					}void OneDisObj::MyCalculate(void){	if(delugeFlag || macroFlag){		short hRes,vRes,theValue;		ScreenRes(&hRes, &vRes);		theValue = ((double)negWidth / 50.8) * (double)hRes + 10;			if(theValue < 145)				theValue = 145;		centerX 	= 	theValue;		centerX 	= 	((double)negWidth / 50.8) * (double)hRes + 10;		centerY		= 	((double)negHeight / 50.8) * (double)hRes + 60;	}else{		centerX = ( theWindow->portRect.right +  theWindow->portRect.left) / 2;		centerY = ( theWindow->portRect.bottom +  theWindow->portRect.top) / 2;	}		picObjList = pictID->CleanImages(picObjList);	pictID			->	KillAll();	pictID			=	(DislocImageCond*)D_new(DislocImageCond);	pictID			->	DoInit(0L);	if(macroFlag){	short hRes,vRes,theValue;	ScreenRes(&hRes, &vRes);	theValue = ((double)negWidth / 50.6) * (double)hRes + 1;			centerX 	= 	-theValue;	centerY		= 	((double)negHeight / 50.8) * (double)vRes + 60;		DoMacros();		}else{	picObjList = pictID->CleanImages(picObjList);	pictID			->	KillAll();	pictID			=	(DislocImageCond*)D_new(DislocImageCond);	pictID			->	DoInit(0L);	isCalculating = true;	CalculateIntensityMap();	isCalculating = false;	pictID->Add(1,1);	if(delugeFlag){		redraw = true;		SetPictFrame(false);		SetPict(false);		ThicknessMacro();	}	}}Boolean OneDisObj::SetPlotParameters(void){	short 			itemCnt,i,theItem,markChar;		if(inherited::SetPlotParameters()){		if(g_Monitor){ 				EnableItem(GetMenu(PALETTE_MENU_1),0);			itemCnt = CountMItems(GetMenu(PALETTE_MENU_1));			for(i = 1;i <= itemCnt;i++){				GetItemMark(GetMenu(PALETTE_MENU_1),i,&markChar);				if(markChar) theItem = i;			} 			SetWindowColors(2100 + theItem);			CheckItem(GetMenu(PALETTE_MENU_1),theItem,true);		}else {			DisableItem(GetMenu(PALETTE_MENU_1),0);			SetWindowColors(1001);		}				DrawPicture(screenPict,&thePictRect);		DrawMenuBar();	}	return true;}void OneDisObj::SetPict(Boolean eraseFlag){	short 			theLeft,theTop,hRes,vRes,theRight,theBottom;	OpenCPicParams	thePicParms;	RgnHandle		theNewClip;	if(isCalculating)		return;	if(!redraw) return;	SetTheCursor(WAIT_CURSOR);			ScreenRes(&hRes, &vRes);	theLeft 	= 	centerX - ((double)negWidth / 50.8) * (double)hRes;	theTop		= 	centerY - ((double)negHeight / 50.8) * (double)hRes;	theRight 	= 	centerX + ((double)negWidth / 50.8) * (double)hRes;	theBottom 	= 	centerY + ((double)negHeight / 50.8) * (double)hRes;	theBottom++;	SetRect			(&thePictRect,theLeft,theTop,theRight,theBottom);	if(screenPict != NUL){		KillPicture(screenPict);	}	screenPict = 0L;	thePicParms.srcRect = thePictRect;	thePicParms.hRes = hRes;	thePicParms.vRes = vRes;	thePicParms.version = -2;	theNewClip = SetClipToPort(theWindow,0,0,15,15);	screenPict = 0L;	DrawDislocation();	redraw = false;	RestoreTheCursor();	D_DisposeRgn(&theNewClip);	inherited::SetPict(eraseFlag);}void OneDisObj::AdditionMatrixMults(double DCX[3][3]){	DCX[0][0] = 0;}void  OneDisObj::GetCurrentDefectValues(DialogPtr theDialog){	if(burgersVector->GetIndex(theDialog,_3_))changedFlag = true;	if(lineDirection->GetIndex(theDialog,_4_))changedFlag = true;	if(fabs(burgersVector->intensity 	-  (float)GetItemValue( theDialog,_5_)) > .01)changedFlag = true;	burgersVector->intensity 	=  (float)GetItemValue( theDialog,_5_);}void  OneDisObj::DoAuxRead(void){	burgersVector	->ReadIndex(theCrystal);	lineDirection	->ReadIndex(theCrystal);	g_Vector		->ReadIndex(theCrystal);	theFNRotationAxis->ReadIndex(theCrystal);			w_Off_Bragg 			= (float)gTheFile->ReadFloat();	normalized_Thickness 	= (float)gTheFile->ReadFloat();	anomAbsorbCoeff 		= (float)gTheFile->ReadFloat();	theFNRotationAngle 		= (float)gTheFile->ReadFloat();	theFNOffLaueDistance 	= (float)gTheFile->ReadFloat();	true_Foil_Thick_Extinct = (float)gTheFile->ReadFloat();			xCount	 				= gTheFile->ReadLong();	yCount	 				= gTheFile->ReadLong();		numberOfSteps	 		= gTheFile->ReadShort();	interval	 			= gTheFile->ReadShort();		anomFlag		 		= gTheFile->ReadBoolean();	darkFieldFlag	 		= gTheFile->ReadBoolean();	delugeFlag		 		= gTheFile->ReadBoolean();		number_Beams			=	gTheFile->ReadShort();	numberDefect_Sets		=	gTheFile->ReadShort();	burgersVectors			-> 	ReadIndex(theCrystal);	lineDirections			-> 	ReadIndex(theCrystal);	g_Vectors				-> 	ReadIndex(theCrystal);	theZoneAxes				-> 	ReadIndex(theCrystal);	theRotationAxes			-> 	ReadIndex(theCrystal);	gTheFile				->	ReadHandle((Handle)anomAbsorbCoeffs);	gTheFile				->	ReadHandle((Handle)rotationAngles);	gTheFile				->	ReadHandle((Handle)offLaueDistances);	gTheFile				->	ReadHandle((Handle)orTypes);	pictID					->	ReadImage	(picObjList);	inherited::DoAuxRead();}void  OneDisObj::DoAuxWrite(void){	burgersVector	->WriteIndex();	lineDirection	->WriteIndex();	g_Vector		->WriteIndex();	theFNRotationAxis->WriteIndex();		gTheFile->WriteFloat((float)w_Off_Bragg);	gTheFile->WriteFloat((float)normalized_Thickness);	gTheFile->WriteFloat((float)anomAbsorbCoeff);	gTheFile->WriteFloat((float)theFNRotationAngle);	gTheFile->WriteFloat((float)theFNOffLaueDistance);	gTheFile->WriteFloat((float)true_Foil_Thick_Extinct);		gTheFile->WriteLong(xCount);	gTheFile->WriteLong(yCount);		gTheFile->WriteShort(numberOfSteps);	gTheFile->WriteShort(interval);		gTheFile->WriteBoolean(anomFlag);	gTheFile->WriteBoolean(darkFieldFlag);	gTheFile->WriteBoolean(delugeFlag);	gTheFile->WriteShort(number_Beams);	gTheFile->WriteShort(numberDefect_Sets);	burgersVectors			-> 	WriteIndex();	lineDirections			-> 	WriteIndex();	g_Vectors				-> 	WriteIndex();	theZoneAxes				-> 	WriteIndex();	theRotationAxes			-> 	WriteIndex();	gTheFile				->	WriteHandle((Handle)anomAbsorbCoeffs);	gTheFile				->	WriteHandle((Handle)rotationAngles);	gTheFile				->	WriteHandle((Handle)offLaueDistances);	gTheFile				->	WriteHandle((Handle)orTypes);	pictID					->	WriteImage	();	inherited::DoAuxWrite();}void	OneDisObj::RationalizeData(void){	if(screenPict == NULL && picObjList != NULL){		inherited::SetPict(true);	}	return;}void	OneDisObj::DoDefectSetUp(DialogPtr theDialog){		GetDItem(theDialog,_5_,&gType,&gTheHandle,&gTheRect);		sprintf(gTheText,"%6.2f",burgersVector->intensity);		SetIText(gTheHandle,c2pstr(gTheText));		burgersVector->SetIndex(theDialog,_3_);		lineDirection->SetIndex(theDialog,_4_);				sprintf(gTheText,"%d",numberDefect_Sets);		GetDItem(theDialog,_6_,&gType,&gTheHandle,&gTheRect);		SetIText(gTheHandle,c2pstr(gTheText));}Boolean	OneDisObj::ResetDefects(short i){	if(!burgersVectors->CopyNth(burgersVector,i))		return false;	lineDirections->CopyNth(lineDirection,i);		return true;}void	OneDisObj::AddDefects(DialogPtr theDialog,Boolean theFlag){	if(!theFlag){		burgersVectors->SubtractIndex() ;		lineDirections->SubtractIndex() ;		return;	}		burgersVectors->AddItemIndex(theDialog,3) ;	lineDirections->AddItemIndex(theDialog,4);	burgersVectors->AddIntensity(GetItemValue( theDialog,5));	}Boolean	OneDisObj::ResetBeam(short i){	short k,*theShort;	float		*thePtr;	double	sZ,sL;	if(!g_Vectors->CopyNth(g_Vector,i))		return false;	theZoneAxes->CopyNth(theZoneAxis,i);	theRotationAxes->CopyNth(theRotationAxis,i);	k = i - 1;	thePtr				=	 ((float*)(*anomAbsorbCoeffs));	anomAbsorbCoeff 	= 	thePtr[k];	thePtr				=	 ((float*)(*rotationAngles));	rotationAngle 		= 	thePtr[k];	thePtr				=	 ((float*)(*offLaueDistances));	offLaueDistance 	= 	thePtr[k];	theShort				=	 ((short*)(*orTypes));	calcIrrational		=	theShort[k];	w_Off_Bragg =  CalculateW_OffBragg(theZoneAxis,theRotationAxis,g_Vector, rotationAngle, offLaueDistance, totalRot, calcIrrational,&sZ,&sL);	return true;}void	OneDisObj::DoImagePopUp(PictObj *thePicture){	PopUpPicture	*thePopUpPict;	PicHandle		aPicture;	short			i,j,l;	GrafPtr			oldPort;	Rect			theRect;	Point			objPoint;	double			extDist;	double			extInterval;	short				theInterval;	GetPort			(&oldPort);	if(thePicture == 0L || !pictID			->	GetSettings(&j,&i,&l,thePicture))		return;			PenMode(gMode);		thePopUpPict 	= 	(PopUpPicture*)D_new(PopUpPicture);	thePopUpPict	->	DoInit((Ptr)(gCurrentObj));	ResetBeam(i);	ResetDefects(j);	/*electronMassRation 	= 	1. + ( (double)energy / 511.);	extDist 			= 	theFoilBragg->TheExtinctionDist(1./ wavelength,electronMassRation,theBeamFlag);	theSlice 			= 	interval * l * ((delta_X_Dir_Extinct));	FINISH 				= 	(normalized_Thickness - theSlice ) * extDist / 10;	*/	extInterval						=			PI * interval;	extDist = 	(g_Vector->TheExtinctionDist(1./ wavelength,1. + ( (double)energy / 511.),theBeamFlag) );	extInterval 			/= (extDist *  delta_X_Dir_Extinct);	theInterval			=	extInterval * l;	theSlice = theInterval * delta_X_Dir_Extinct;	FINISH = (true_Foil_Thick_Extinct - theSlice) * extDist / (PI * 10) ;							GetMouse(&objPoint);	LocalToObj		(&objPoint);	aPicture = DisplayDefectPict	(&theRect,objPoint.h,objPoint.v);	/*D_HLock				((Handle)aPicture);*/	thePopUpPict	->	SetPopUpPict(aPicture);	thePopUpPict	->	DrawPopUpPict(objPoint.h,objPoint.v,true);	SetPort				(oldPort);	/*D_HUnlock			((Handle)aPicture);*/	thePopUpPict->DoClose();	ResetBeam(1);	ResetDefects(1);}PicHandle OneDisObj::DisplayDefectPict(Rect *theRect,short horiz,short vert){	short 		width;	PicHandle	thePict;	Rect		frameRect;	Point		thePoint;		TextFont		(geneva);	TextSize		(10);	PenNormal		();	sprintf			(gTheText,"Log Dynamic Range = %d X %d ",dyRange);	c2pstr			(gTheText);	width 		= 	StringWidth((unsigned char*)gTheText);	SetRect			(theRect,2,2,width + 30,180);	OffsetRect		(theRect,horiz,vert);	frameRect 	= 	*theRect;	InsetRect		(&frameRect,-2,-2);	thePict 	= 	OpenPicture(theRect);	ForeColor(BLACK);	BackColor(WHITE);	dm_EraseRect(theRect);	InsetRect(theRect,2,2);	PenSize(2,2);	dm_FrameRect(theRect);	PenSize(1,1);	thePoint.h	=	horiz + 3;	thePoint.v	=	vert + 10;	DrawFrameText(thePoint);		PenSize(2,2);	dm_FrameRect(&frameRect);	PenNormal();	ClosePicture();	return(thePict);}void	OneDisObj::DoMacros(void){	short i,k;	Boolean	newRow = false;		for(i = 1; i <= number_Beams;i++){		ResetBeam( i);				for(k = 1; k <= numberDefect_Sets;k++){			if(!ResetDefects(k))continue;			pictID->Add(k,i);			isCalculating = true;			CalculateIntensityMap();			isCalculating = false;			SetPictFrame(newRow);			newRow = false;			SetPict(false);			if(delugeFlag){				ThicknessMacro();			}		}		newRow = true;	}	ZoomWindow(theWindow,inZoomOut,true);	DoResize();	newPictReq = true;	}void OneDisObj::SetPictFrame(Boolean newRow){	short 		hRes,vRes,theValue;	double		pixelLength,pixelHeight;	short		wide, high,shVal;		ScreenRes(&hRes, &vRes);	pixelLength = (double)(negWidth * hRes) / 25.4;	pixelHeight = (double)(negHeight * vRes) / 25.4;	wide	=	theWindow->portRect.right - theWindow->portRect.left;	high	=	theWindow->portRect.bottom - theWindow->portRect.top;	if(!newRow){			shVal =	centerX + ((double)pixelLength * 1.5 ) + 15;			if(shVal >  theWindow->portRect.right){				SizeWindow(theWindow,wide + ((short)pixelLength) + 15,high,false);				reSizeFlag = true;			}			centerX 	+= 	pixelLength + 2;				}else{		shVal =	centerY	+ 	(pixelHeight * 1.5) + 12;		if(shVal > theWindow->portRect.bottom){			SizeWindow(theWindow,wide,high + ((short)pixelHeight) + 12,false);			reSizeFlag = true;		}		theValue = ((double)pixelLength / 2) + 2;		centerX 	= 	theValue;		centerY		+= 	 pixelHeight + 2;	}}void OneDisObj::InsertCurrentDefects(void){	burgersVectors->CopyToNth(burgersVector, numberDefect_Sets);	lineDirections->CopyToNth(lineDirection,numberDefect_Sets);}	void OneDisObj::InsertCurrentBeam(void){	theZoneAxes->CopyToNth(theZoneAxis, number_Beams);	g_Vectors->CopyToNth(g_Vector,number_Beams);	theRotationAxes ->	CopyToNth(theRotationAxis,number_Beams);		(*rotationAngles)[number_Beams - 1] 	=  	rotationAngle;	(*offLaueDistances)[number_Beams - 1] 	= 	offLaueDistance;	(*anomAbsorbCoeffs)[number_Beams - 1] 	= 	anomAbsorbCoeff;	(*orTypes)[number_Beams - 1] 	= 	calcIrrational;}void	OneDisObj::DrawFrameText(Point thePoint){	char theText[255];	short	h,v;		h = thePoint.h + 5;	v = thePoint.v + 10;		PenNormal();	TextSize(10);	TextFont(geneva);		sprintf			(gTheText,"b vector =  %4.2f ",burgersVector->intensity);	burgersVector->IndexToIndecies(theText);	strcat			(gTheText,p2cstr((unsigned char*)theText));			MoveTo(h,v);	DrawDiffractString(c2pstr(gTheText));		sprintf			(gTheText,"line direction u = ");	lineDirection->IndexToIndecies(theText);	strcat(gTheText,p2cstr((unsigned char*)theText));	v += 15;	MoveTo(h,v);	DrawDiffractString(c2pstr(gTheText));			sprintf(gTheText,"Beam Dir. B = ");	theZoneAxis->IndexToIndecies(theText); 	strcat(gTheText,p2cstr((unsigned char*)theText));		v += 15;	MoveTo(h,v);	DrawDiffractString(c2pstr(gTheText));		sprintf(gTheText,"g vector = ");	g_Vector->IndexToIndecies(theText); strcat(gTheText,p2cstr((unsigned char*)theText));	v += 15;	MoveTo(h,v);	DrawDiffractString(c2pstr(gTheText));			sprintf(gTheText,"Foil Normal FN = ");	theFoilNormal->IndexToIndecies(theText); 	strcat(gTheText,p2cstr((unsigned char*)theText));	v += 15;	MoveTo(h,v);	DrawDiffractString(c2pstr(gTheText));			sprintf(gTheText,"Thickness in nm %4.2f ",FINISH );	v += 15;	MoveTo(h,v);	DrawDiffractString(c2pstr(gTheText));	sprintf(gTheText,"deviation from Bragg =  %4.2f ",w_Off_Bragg);		v += 15;	MoveTo(h,v);	DrawDiffractString(c2pstr(gTheText));	sprintf(gTheText,"anomal. absorp. = %4.2f ",anomAbsorbCoeff);	v += 15;	MoveTo(h,v);	DrawDiffractString(c2pstr(gTheText));	TextSize(0);	TextFont(0);	}Boolean		OneDisObj::DoContent(Point thePoint)			/*	Object Content method			*/{	Point		objPoint;	objPoint 	= thePoint;	LocalToObj		(&objPoint);		if(picObjList != (PictObj*)NUL && (gTheEvent.modifiers & shiftKey)){		DoImagePopUp(picObjList->DoSelect(objPoint));	}	return inherited::DoContent(thePoint);}