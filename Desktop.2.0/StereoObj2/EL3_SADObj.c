#include	"Diffract_INCs.h"#include	"PCVNumerical.h"#include	"RulerButton.h"#include	"AtomicScatter.h"#include	"SF_MathLib.h"#include 	"TextTableObj.h"  #include 	"mathRecipies.h"#include 	"nrutil.h"#include "UextBoxFree.h"#include "PoleBox.h"#include "SADObj.h"#include	"StereoObject.h"void SADObj::SetBeamORToPole(void){	PolePosition thePole;	double x,y,z,length;	Crystal *aCrystal;	double theXForm[3][3],matrix[3][3];	CopyAxesIntoMatrix(theXForm);	SetMatrixAEqB(matrix,theXForm);	ZoneAxisFromMatrix (false,matrix,&calcIrrational,theZoneAxis,theRotationAxis,g_Vector,&rotationAngle,&offLaueDistance,&totalRot,&beamAzimuth);/*determine z.a.*/	SetOrientation(theXForm);	if(!SetPoleDefinition())return;		aCrystal 		= 	theCrystal[baseCrystal];	thePole.zoneAxis.h = theZoneAxis->h;	thePole.zoneAxis.k = theZoneAxis->k;	thePole.zoneAxis.l = theZoneAxis->l;	theZoneAxis->direction = true;	theZoneAxis->theCrystal = aCrystal;	thePole.zoneAxis.direction = true;	thePole.zoneAxis.intensity = 1;	thePole.zoneAxis.theCrystal = aCrystal;	CopyAxesIntoMatrix(theXForm);	theZoneAxis->GetXYZFromHKL(theXForm);	x = theZoneAxis->x;	y = theZoneAxis->y;	z = theZoneAxis->z;	stage->CancelMatrixRotation		(&x,&y,&z,true);	//if(stereoObj)stereoObj->stage->NewMatrixRotation(&x,&y,&z,true);	length = sqrt(x * x + y * y + z * z);	thePole.zoneAxis.x = x/length;	thePole.zoneAxis.y = y/length;	thePole.zoneAxis.z = z/length;		thePole.gvector.flags = g_Vector->flags;	CopyAxesIntoMatrix(theXForm);	g_Vector->GetXYZFromHKL(theXForm);	thePole.gvector.h = g_Vector->h;	thePole.gvector.k = g_Vector->k;	thePole.gvector.l = g_Vector->l;	thePole.gvector.direction = false;	thePole.gvector.theCrystal = aCrystal;	if((thePole.gvector.h * thePole.zoneAxis.h + 		thePole.gvector.k * thePole.zoneAxis.k + 		thePole.gvector.l * thePole.zoneAxis.l) != 0){			Message(G_ZONE_NOT_ORTHO);	}	x = g_Vector->x;	y = g_Vector->y;	z = -g_Vector->z;	stage->CancelMatrixRotation		(&x,&y,&z,true);	//if(stereoObj)stereoObj->stage->NewMatrixRotation(&x,&y,&z,true);	length = sqrt(x * x + y * y + z * z);	thePole.gvector.x = x/length;	thePole.gvector.y = y/length;	thePole.gvector.z = z/length;	thePole.zoneAxis.flags = baseCrystal;	thePole.gvector.flags = baseCrystal;	if(stereoObj){		stereoObj->AddPoleObject(thePole,false);		stereoObj->newPictReq = true;		stereoObj->DoIdle();	}else{		this->CopyObjTo((DiffractObject*)gDefault,true);		stereoObj = (StereoObject*)AllocStereoObject();		if(!IsValidObj(stereoObj)){			stereoObj = 0L;		 	return;		}		stereoObj->poleObject = (SADObj*)this;				CopyObjTo((DiffractObject*)stereoObj,true);		stereoObj->stage->SetStageToNewTilts(0,0);				stereoObj->changedFlag = false; 		stereoObj->newPictReq = true;		stereoObj->AddPoleObject(thePole,true);		//stereoObj->DoPoleObjectMenu(8);		stereoObj->planeBounds[0] = 0;		stereoObj->DoIdle();			}}Boolean	SADObj::SetPoleDefinition(void){	DialogPtr	theDialog;	short		theSelect;	short		i,j;	PopUpMenu 	*theMenu;	WindowPeek	theWindow;	StereoObject		*aObj;	Boolean	quit = false,saveData = false;		theDialog = DM_GetNewDialog(362,NUL,IN_FRONT);	theMenu = (PopUpMenu*)D_new(PopUpMenu);	theMenu->Init(theDialog,8,135,1);	theWindow = (WindowPeek)FrontWindow();	if(stereoObj){		GetWTitle(stereoObj->theWindow,pTheText);		theMenu->P_AppendMenu(gTheText);		j = CountMItems(gTheWindowMenu);						for(i = 1; i <= j;i++){						GetItem(gTheWindowMenu,i,pTheText);			theMenu->P_AppendMenu(gTheText);			theWindow = theWindow->nextWindow;			aObj = (StereoObject*)((WindowPeek)theWindow)->refCon;			if(((SADObj*)aObj)->objectType != STEREO_OBJ ) {					DisableItem(theMenu->theMenu,i + 1);			}					}			}else{		sprintf(gTheText,"New Stereogram");		c2pstr(gTheText);		theMenu->P_AppendMenu(gTheText);		j = CountMItems(gTheWindowMenu);		for(i = 1; i <= j;i++){			GetItem(gTheWindowMenu,i,pTheText);			theMenu->P_AppendMenu(gTheText);			theWindow = theWindow->nextWindow;			aObj = (StereoObject*)((WindowPeek)theWindow)->refCon;			if(((SADObj*)aObj)->objectType != STEREO_OBJ ) {					DisableItem(theMenu->theMenu,i + 1);			}		}	}	SetPort(theDialog);	ShowWindow(theDialog);	DrawDialog(theDialog);	theZoneAxis	->SetIndex(theDialog,4);	g_Vector	->SetIndex(theDialog,5);	theMenu->SetPopUp();	while(!quit){		ModalDialog(TheFilterUPP/*SmallFilterUPP*/,&theSelect);				switch(theSelect){			case DLOG_ENTER_OR_CR:			case 1:				quit = true;				saveData = 1;				break;			case 2:				quit = true;				saveData = 0;				break;			case 3:				quit = true;				saveData = 2;				break;			case	8:				theMenu->DoPopUp();			break;			default:			break;			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;		}				}		if(saveData){		theZoneAxis	->GetIndex(theDialog,4);		g_Vector	->GetIndex(theDialog,5);		theMenu->DoClose();		DM_DisposDialog(&theDialog);		i = 1;		if(theMenu->lastResult != 1){			theWindow = (WindowPeek)FrontWindow();			while(i < theMenu->lastResult){theWindow = theWindow->nextWindow;i++;}			aObj = (StereoObject*)((WindowPeek)theWindow)->refCon;			if(((SADObj*)aObj)->objectType == STEREO_OBJ ) {				stereoObj = aObj;				((StereoObject*)aObj)->poleObject = ((SADObj*)this);			}		}	}else{		theMenu->DoClose();		DM_DisposDialog(&theDialog);	}		if(saveData == 2) return true;		return false;}