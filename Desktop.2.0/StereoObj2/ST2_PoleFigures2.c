#include	"Diffract_INCs.h"#include	"StereoObject.h"//rces.Jim:Stereographic:ST_StereoObject.c#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"SF_MathLib.h"#include	"EV2_Handle.h"#include 	"UextBoxFree.h"void StereoObject::CalculatePoleStereogram(Point thePoint){	double oldAxes[3][3];	double theYForm[3][3];	short i;	PolePosition *thePoles;	SpotInfo theSpot;	thePoint.h = 0;	theSpot = THE_CURRENT_SPOT;	if(!poleHandle || !(theSpot.flags & POLE_FIGURE)){				SysBeep(30);		theRuler->SetHelp("Spot MUST BE AN Experimental Pole.");				return;	}		D_HLock((Handle)poleHandle);	thePoles = (*poleHandle);	HilightDataPoint(&THE_CURRENT_SPOT);	if(theSpot.flags & POLE_FIGURE){		i = Round(theSpot.angle);		GetORFromPole_SpotObject(&THE_CURRENT_SPOT,theYForm);		//GetORFromPoleObject(&(thePoles[i]), theYForm);		CopyAxesIntoMatrix(oldAxes);		CopyMatrixIntoAxes(theYForm);		CalculatePoles(true);		newPictReq = true;		CopyMatrixIntoAxes(oldAxes);	}	D_HUnlock((Handle)poleHandle);			}void StereoObject::DisplayORMatrices(void){	double oldAxes[3][3];	double theYForm[3][3];	short i;	PolePosition *thePoles;	Crystal			*oldCrystal;	SpotInfo theSpot;	theSpot = THE_CURRENT_SPOT;	if(!poleHandle || !(theSpot.flags & POLE_FIGURE)){				SysBeep(30);		theRuler->SetHelp("Spot MUST BE AN Experimental Pole.");		return;	}		D_HLock((Handle)poleHandle);	thePoles = (*poleHandle);	HilightDataPoint(&THE_CURRENT_SPOT);	if(theSpot.flags & POLE_FIGURE){		i = Round(theSpot.angle);		//GetORFromPoleObject(&(thePoles[i]), theYForm);		GetORFromPole_SpotObject(&THE_CURRENT_SPOT,theYForm);		oldCrystal = theCrystal[baseCrystal];		theCrystal[baseCrystal] = thePoles[i].zoneAxis.theCrystal;		CopyAxesIntoMatrix(oldAxes);		CopyMatrixIntoAxes(theYForm);		OrientationMatrixDialogBox();				theCrystal[baseCrystal] = oldCrystal;		CopyMatrixIntoAxes(oldAxes);	}			HilightDataPoint(&THE_CURRENT_SPOT);	D_HUnlock((Handle)poleHandle);}void StereoObject::SetMatrixToORExp(void){	double theYForm[3][3];	short i;	PolePosition *thePoles;	SpotInfo theSpot;	theSpot = THE_CURRENT_SPOT;	if(!poleHandle || !(theSpot.flags & POLE_FIGURE)){				SysBeep(30);		theRuler->SetHelp("Spot MUST BE AN Experimental Pole.");		return;	}		D_HLock((Handle)poleHandle);	thePoles = (*poleHandle);	HilightDataPoint(&THE_CURRENT_SPOT);	if(theSpot.flags & POLE_FIGURE){		i = Round(theSpot.angle);		GetORFromPole_SpotObject(&THE_CURRENT_SPOT,theYForm);		//GetORFromPoleObject(&(thePoles[i]), theYForm);		thePoles[i].zoneAxis.theCrystal->CopyCrystal(theCrystal[baseCrystal]);		theCrystal[baseCrystal]->idNum = 0;		CopyMatrixIntoAxes(theYForm);		ZoneAxisFromMatrix (false,theYForm,&calcIrrational,theZoneAxis,theRotationAxis,g_Vector,&rotationAngle,&offLaueDistance,&totalRot,&beamAzimuth);/*determine z.a.*/		changedFlag = true;	}			D_HUnlock((Handle)poleHandle);}void StereoObject::DeterminePoleFigureOR(Point thePoint){	static	short	loc1,loc2,width;	static	double	x1,y1,z1;	static	char	label1[10];		Point	where;	long	when;	thePoint.h = 0;			if(funcInit){		funcInit = false;		loc1 = -10;		loc2 = -10;		fixPicFlag = true;	}	if(spotLoc < 0) 		return;/*dec 1992*/	if(!poleHandle || !(THE_CURRENT_SPOT.flags & POLE_FIGURE)){				SysBeep(30);		theRuler->SetHelp("Spot MUST BE AN Experimental Pole.");		return;	}	if((THE_CURRENT_SPOT.flags & ANGLE_FLAG) != 0){		if(gShifted && spotLoc == loc2){			loc2 = loc1;			loc1 = spotLoc;			x1 = THE_CURRENT_SPOT.x;			y1 = THE_CURRENT_SPOT.y;			z1 = THE_CURRENT_SPOT.z;			obj_Index->IndexToIndecies(label1);			p2cstr((unsigned char*)label1);		}		where.h = where.v = -100;		FindSpot(where);		return;	}			if(gShifted){		theRuler->ClearHelp();		theRuler->SetHelp("Click Additional Exp. Pole to set second point. Spot MUST BE AN Experimental Pole.");		D_HLock(theDataHandle);		if(loc1 >= 0 && loc1 < data_Count){			if((((SpotInfoPtr)*theDataHandle)[loc1].flags & ANGLE_FLAG) != 0){				((SpotInfoPtr)*theDataHandle)[loc1].flags ^= ANGLE_FLAG;				HilightDataPoint(&(((SpotInfoPtr)*theDataHandle)[loc1]));			}		}		loc1 = spotLoc;		THE_CURRENT_SPOT.flags |= ANGLE_FLAG;		HilightDataPoint(&(((SpotInfoPtr)*theDataHandle)[loc1]));		x1 = THE_CURRENT_SPOT.x;		y1 = THE_CURRENT_SPOT.y;		z1 = THE_CURRENT_SPOT.z;				obj_Index->IndexToIndecies(label1);		p2cstr((unsigned char*)label1);		when = TickCount();		where.h = where.v = -100;		D_HUnlock(theDataHandle);		FindSpot(where);		return;	}		when = TickCount();	if(loc1 >= 0 && loc1 < data_Count){		D_HLock(theDataHandle);		if(loc2 >= 0 && loc2 < data_Count){			if((((SpotInfoPtr)*theDataHandle)[loc2].flags & ANGLE_FLAG) != 0){				((SpotInfoPtr)*theDataHandle)[loc2].flags ^= ANGLE_FLAG;				HilightDataPoint(&(((SpotInfoPtr)*theDataHandle)[loc2]));			}		}		loc2 = spotLoc;		THE_CURRENT_SPOT.flags |= ANGLE_FLAG;		HilightDataPoint(&(((SpotInfoPtr)*theDataHandle)[loc2]));		HilightDataPoint(&(((SpotInfoPtr)*theDataHandle)[loc1]));		D_HUnlock(theDataHandle);		DialogBoxForPoleOR(loc1,loc2);		theRuler->ClearHelp();		D_HLock(theDataHandle);		theRuler->SetHelp("Shift-Click to set first point.  Old values are erased. Spot MUST BE AN Experimental Pole.");		((SpotInfoPtr)*theDataHandle)[loc1].flags ^= ANGLE_FLAG;		((SpotInfoPtr)*theDataHandle)[loc2].flags ^= ANGLE_FLAG;		D_HUnlock(theDataHandle);		spotLoc = loc1 = loc2 = -1;		{			Point aPoint;			aPoint.h = aPoint.v = 0;			FindSpot( aPoint);			inherited::FindSpot( aPoint);			where.h = where.v = -100;			FindSpot(where);		}		//newPictEnable = true;	}	else if(!funcInit){				theRuler->SetHelp("Shift-Click to set first point. Spot MUST BE AN Experimental Pole.");	}	where.h = where.v = -100;	FindSpot(where);	return;}void StereoObject::DoPoleObjectMenu(short theItem){	switch(theItem)	{		case 1:			PlotPolePositions();			newPictReq = true;			break;		case 5:			functionID = SELECT_POLE_FIGURE;			theRuler->SetHelp("Click on pole to generate a Stereogram For This Pole, if you have rotated the crystal since adding poles, will not work.Spot MUST BE AN Experimental Pole.");			theRuler->SetPrompt("Stereogram Around Pole");			SetTheCursor(TARGET_CURSOR);			break;		case 6:			functionID = FIND_POLE_ORIENTATION;			theRuler->SetHelp("Click on two poles DM will try to find an OR,shift-click to select first crystal.Spot MUST BE AN Experimental Pole.");			theRuler->SetPrompt("Pole Figure Orientation Relationships");			SetTheCursor(TARGET_CURSOR);			break;		case 2:			functionID = RUN_POLE_STATISTICS;			AddPoleDialog();			break;		case 7:			functionID = SHOW_POLE_OR_MATRIX;			theRuler->SetHelp("Click on an Experimental pole, DM will set Matrix to this OR and Crystal.Spot MUST BE AN Experimental Pole.");			theRuler->SetPrompt("New Matrix Crystal Orientation");			SetTheCursor(TARGET_CURSOR);			break;		case 8:			functionID = SET_MATRIX_TO_EXP;			theRuler->SetHelp("Click on an Experimental pole DM will bring up the Orientation Matrix for that Crystal at 0,0 stage.Spot MUST BE AN Experimental Pole.");			theRuler->SetPrompt("Pole Figure Orientation Matrix");			SetTheCursor(TARGET_CURSOR);			break;		case 10:			if(theDataHandle){				numSpots = data_Count = 0;				//KillHandle((Handle*)&theDataHandle);				//theDataHandle = 0L;				newPictReq = true;			}			break;		case 11:			if(!Question(DELETE_EXP_POLES))break;			if(poleHandle){				totalPoles = 0;				KillHandle((Handle*)&poleHandle);				poleHandle = 0L;				newPictReq = true;			}			break;	}}void StereoObject::RunPoleStatistics(Point thePoint){	thePoint.h = 0;}void StereoObject::DoPoleFigureMenu(short theItem){	obj_Index->direction = false;	baseCrystal = 0;	obj_Index->flags = baseCrystal;	obj_Index->theCrystal = theCrystal[baseCrystal];	switch( theItem){		case 1:			obj_Index->h = 0; obj_Index->k = 0;obj_Index->l = 1;			obj_Index->flags |= POLE_FIGURE;			obj_Index->flags |= POLE_001;			break;		case 2:			obj_Index->h = 0; obj_Index->k = 1;obj_Index->l = 1;			obj_Index->flags |= POLE_FIGURE;			obj_Index->flags |= POLE_110;			break;		case 3:			obj_Index->h = 1; obj_Index->k = 1;obj_Index->l = 1;			obj_Index->flags |= POLE_FIGURE;			obj_Index->flags |= POLE_111;			break;		case 4:			obj_Index->h = 0; obj_Index->k = 1;obj_Index->l = 2;			obj_Index->flags |= POLE_FIGURE;			obj_Index->flags |= POLE_012;			break;		case 5:			obj_Index->h = 1; obj_Index->k = 1;obj_Index->l = 2;			obj_Index->flags |= POLE_FIGURE;			obj_Index->flags |= POLE_112;			break;		case 6:			if(!DefinePoleFigure()) return;			baseCrystal = 0;			obj_Index->flags = baseCrystal;			obj_Index->theCrystal = theCrystal[baseCrystal];			obj_Index->flags |= POLE_FIGURE;			obj_Index->flags |= POLE_USER;			break;	}	PlotPoleSet();	newPictReq = true;}Boolean StereoObject::DefinePoleFigure(void){	DialogPtr	theDialog;	short		theSelect;	short		oldSelect,i;	Boolean		theFlag,quit = false,saveData = false;		theDialog = DM_GetNewDialog(361,NUL,IN_FRONT);		SetPort(theDialog);		ShowWindow(theDialog);		obj_Index->SetIndex(theDialog,8);	SelIText(theDialog,8,0,100);	DrawDialog(theDialog);	theFlag = SwitchBoolean(theDialog,7,false);	SwitchBoolean(theDialog,baseCrystal + 3,false);	while(!quit){		ModalDialog(TheFilterUPP/*SmallFilterUPP*/,&theSelect);				switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;			case DLOG_ENTER_OR_CR:			case 1:				obj_Index->GetIndex(theDialog,8);				quit = true;				saveData = true;				obj_Index->direction = theFlag;				obj_Index->flags = oldSelect;				baseCrystal = oldSelect;				obj_Index->theCrystal = theCrystal[baseCrystal];				break;			case 2:				quit = true;				saveData = false;				break;			case 3:			case 4:			case 5:			case 6:				for(i = 3; i < 7;i++)SwitchBoolean(theDialog,i,true);				SwitchBoolean(theDialog,theSelect,false);				oldSelect = theSelect;				break;			case 7:				theFlag = SwitchBoolean(theDialog,theSelect,theFlag);				break;			default:			break;		}				}	DM_DisposDialog(&theDialog);	return saveData;		}void	StereoObject::AddPoleDialog(void){	DialogPtr 	theDialog;	double 		lambda,mu,x,y,z,angle,angle2;	short 			theSelect=0;	Point		thePoint,lastPoint;	PopUpMenu	*menu;	PolePosition thePole;	Index		*theI;		theDialog = DM_GetNewDialog(364,NUL,IN_FRONT);	theI	= (Index*)D_new(Index);	ShowWindow(theDialog);		menu 	= (PopUpMenu*)D_new(PopUpMenu);	menu	->	Init(theDialog,3,14,1);	menu	->	SetPopUp();		obj_Index->h = 0;obj_Index->k = 0;obj_Index->l = 1;	obj_Index->SetIndex(theDialog,4);	obj_Index->h = 1;obj_Index->k = 0;obj_Index->l = 0;	obj_Index->SetIndex(theDialog,5);	SetItemValue(theDialog,6,0,2);	SetItemValue(theDialog,7,0,2);	SetItemValue(theDialog,8,0,2);	SetItemValue(theDialog,9,90,2);			while(true){		GetMouse(&thePoint);		if(PtInRect(thePoint,&(theDialog->portRect))|| !Button()){			ModalDialog(TheFilterUPP,&theSelect);			switch(theSelect){				case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;				case 2:					menu->DoClose();					theI->DoClose();					DM_DisposDialog(&theDialog);					FlushEvents(everyEvent,0);					return;					break;				case 1:					obj_Index->theCrystal = theCrystal[menu->lastResult - 1];					obj_Index->flags = menu->lastResult - 1;					obj_Index->direction = true;					obj_Index->reduceFlag = true;					obj_Index->GetIndex(theDialog,4);										lambda = PI * GetItemValue(theDialog,6) / 180;					mu = PI * GetItemValue(theDialog,7) / 180;					ConvertMuLambdaToXYZ(&x,&y,&z,mu,lambda);					obj_Index->CopyIndexToPtr((Ptr)&thePole.zoneAxis);					thePole.zoneAxis.x = x;					thePole.zoneAxis.y = y;					thePole.zoneAxis.z = z;					obj_Index->DoCopy(theI);										obj_Index->direction = false;					obj_Index->reduceFlag = false;										obj_Index->GetIndex(theDialog,5);					obj_Index->CopyIndexToPtr((Ptr)&thePole.gvector);										lambda = PI * GetItemValue(theDialog,8) / 180;					mu = PI * GetItemValue(theDialog,9) / 180;					ConvertMuLambdaToXYZ(&x,&y,&z,mu,lambda);					thePole.gvector.x = x;					thePole.gvector.y = y;					thePole.gvector.z = z;					angle = 180 * acos( x * thePole.zoneAxis.x + y * thePole.zoneAxis.y + z * thePole.zoneAxis.z) / PI;					angle2 = obj_Index->GetTheAngle(theI);					if(fabs(fabs(angle) - fabs(angle2)) > 1){						double theXForm2[3][3],theXForm1[3][3],theXForm3[3][3];						angle = PI * (angle2 - angle)/180;//angular difference between allowed and actual.						x = thePole.zoneAxis.x;						y = thePole.zoneAxis.y;						z = thePole.zoneAxis.z;						FIND_CENTER_XFORM(x,y,z,theXForm1);						x = thePole.gvector.x;						y = thePole.gvector.y;						z = thePole.gvector.z;						TransFormVector(&x,&y,&z,theXForm1);						FIND_VERT_XFORM(x,y,theXForm2);						TransFormVector(&x,&y,&z,theXForm2);						//FindXAxisXform(sin(angle), cos(angle),theXForm3);												RotatateMatrixAxis(theXForm3,angle,1);						TransFormVector(&x,&y,&z,theXForm3);												InvertMatrix(theXForm2);						InvertMatrix(theXForm1);						TransFormVector(&x,&y,&z,theXForm2);						TransFormVector(&x,&y,&z,theXForm1);																		GetMuLambdaFromXYZ(x,y,z,&mu,&lambda);						SetItemValue(theDialog,8,lambda,2);						SetItemValue(theDialog,9,mu,2);						thePole.gvector.x = x;						thePole.gvector.y = y;						thePole.gvector.z = z;					}					SetPort(theWindow);					D_SetClip(drawRgn);										AddPoleObject(thePole,true);					SetPort(theDialog);					newPictReq = true;					break;				case 3:					menu->DoPopUp();					break;			}		} else if(Button()){			while(Button()){				GetMouse(&thePoint);				if(!EqualPt(thePoint,lastPoint)){					lastPoint = thePoint;					LocalToGlobal(&thePoint);					SetPort(theWindow);					GlobalToLocal(&thePoint);					SetPort(theDialog);					onScreen = true;					LocalToObj(&thePoint);					GetMuLambda( thePoint,&mu,&lambda,false);					SetItemValue(theDialog,6,lambda,2);					SetItemValue(theDialog,7,mu,2);									}			}		}	}}