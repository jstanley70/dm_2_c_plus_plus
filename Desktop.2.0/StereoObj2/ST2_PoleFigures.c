#include	"Diffract_INCs.h"#include	"StereoObject.h"//rces.Jim:Stereographic:ST_StereoObject.c#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"SF_MathLib.h"#include	"EV2_Handle.h"#include 	"UextBoxFree.h"typedef struct ORSet{	long spot1a;	long spot1b;	double angle1;	long spot2a;	long spot2b;	double angle2;}ORSet;void	StereoObject::AddPoleObject(PolePosition thePole,Boolean newStereo){	PolePosition *thePoles;	short			theIdent;	double x,y,z;	newStereo = newStereo;	if(!poleHandle){		totalPoles = 0;		add_N_Pole = 50;		maxPoles = 50;		poleHandle = (PolePosition**)D_NewHandle(sizeof(PolePosition) * maxPoles);	}else	if(totalPoles >= maxPoles)		D_ExpandMemory((Handle*)&poleHandle,&totalPoles,&maxPoles,sizeof(PolePosition),add_N_Pole);	/*  Object memory expansion			*/	D_HLock((Handle)poleHandle);	thePoles = &((*poleHandle)[totalPoles]);	totalPoles++;	*thePoles = thePole;	theIdent = thePoles->zoneAxis.flags & CRYSTAL_MASK;	thePoles->zoneAxis.theCrystal =  theCrystal[theIdent];	thePoles->gvector.theCrystal =  theCrystal[theIdent];	x = thePoles->zoneAxis.x;	y = thePoles->zoneAxis.y;	z = thePoles->zoneAxis.z;	//if(!newStereo)stage->NewMatrixRotation(&x,&y,&z,true);	thePoles->zoneAxis.x = x;	thePoles->zoneAxis.y = y;	thePoles->zoneAxis.z = z;	x = thePoles->gvector.x;	y = thePoles->gvector.y;	z = thePoles->gvector.z;	//if(!newStereo)stage->NewMatrixRotation(&x,&y,&z,true);	thePoles->gvector.x = x;	thePoles->gvector.y = y;	thePoles->gvector.z = z;		PlotPoleObject(thePoles,totalPoles - 1);	D_HUnlock((Handle)poleHandle);}void StereoObject::PlotPoleObject(PolePosition *thePoles,long poleNum){	double	x,y,z;	double	xx,yy,zz;	long i;	char	handleState;	Boolean lockedFlag = false;	SpotInfoPtr theSpot,thisSpot;	GrafPtr oldPort;	GetPort(&oldPort);		SetPort(theWindow);			handleState = HGetState((Handle)theDataHandle);	if((handleState & 0x80)){		lockedFlag = true;	}else D_HLock((Handle)theDataHandle);	thisSpot = (SpotInfoPtr)*theDataHandle;	theSpot = &thisSpot[data_Count - 1];	i = data_Count;	while((theSpot->flags & POLE_FIGURE) && i > 0){		if(fabs(theSpot->angle) == poleNum && theSpot->direction){			D_HUnlock((Handle)theDataHandle);			goto nextPoint;		}		theSpot--;		i--;			}	D_HUnlock((Handle)theDataHandle);	x = thePoles->zoneAxis.x;	y = thePoles->zoneAxis.y;	z = thePoles->zoneAxis.z;	//stage->CancelMatrixRotation(&x,&y,&z,false);	stage->NewMatrixRotation(&x,&y,&z,true);	obj_Index->CopyPtrToIndex((Ptr)&thePoles->zoneAxis);		AddThisSpot(x,y,z);		THE_CURRENT_SPOT.intensity = 1;	THE_CURRENT_SPOT.angle = poleNum;	THE_CURRENT_SPOT.flags |= POLE_FIGURE;	xx = thePoles->gvector.x;	yy = thePoles->gvector.y;	zz = thePoles->gvector.z;	nextPoint:	D_HLock((Handle)theDataHandle);	thisSpot = (SpotInfoPtr)*theDataHandle;	theSpot = &thisSpot[data_Count - 1];	i = data_Count;	while((theSpot->flags & POLE_FIGURE) && i > 0){		if(theSpot->angle == poleNum && !theSpot->direction){			if(!lockedFlag)D_HUnlock((Handle)theDataHandle);			return;		}		theSpot--;		i--;			}	D_HUnlock((Handle)theDataHandle);	NormalizeVector(&xx,&yy,&zz);	//stage->CancelMatrixRotation(&xx,&yy,&zz,false);	stage->NewMatrixRotation(&xx,&yy,&zz,true);	obj_Index->CopyPtrToIndex((Ptr)&thePoles->gvector);	AddThisSpot(xx,yy,zz);	THE_CURRENT_SPOT.intensity = 1;	THE_CURRENT_SPOT.angle = poleNum;	THE_CURRENT_SPOT.flags |= POLE_FIGURE;	SetPort(oldPort);	if(lockedFlag)D_HLock((Handle)theDataHandle);}double GetTrueAngle(double xg,double yg,double u,double v);void StereoObject::GetORFromPoleObject(PolePosition *thePole,double theYForm[][3]){	double u,v,w,x,y,z,xg,yg,zg;	double theCrystalForm[3][3];	double theXForm[3][3];	double theta;	double rotForm[3][3];	Index  *theIndex;	theIndex = (Index*)D_new(Index);	theIndex ->CopyPtrToIndex((Ptr)&thePole->zoneAxis);	u = thePole->zoneAxis.h;	v = thePole->zoneAxis.k;	w = thePole->zoneAxis.l;	thePole->zoneAxis.theCrystal->Get001XForm(theCrystalForm);	TransFormVector(&u,&v,&w,theCrystalForm);	NormalizeVector(&u,&v,&w);	FIND_CENTER_XFORM(u,v,w,theYForm);//finds centerXform for 001	theIndex->h = thePole->gvector.h;	theIndex->k = thePole->gvector.k;	theIndex->l = thePole->gvector.l;	theIndex->direction = false;	theIndex->DirOfPlaneNormal(&u,&v,&w);	TransFormVector(&u,&v,&w,theCrystalForm);	NormalizeVector(&u,&v,&w);//position at standard projection 001	TransFormVector(&u,&v,&w,theYForm);//orients gvector with zoneAxis down zone		x = thePole->zoneAxis.x;	y = thePole->zoneAxis.y;	z = thePole->zoneAxis.z;	//stage->CancelMatrixRotation(&x,&y,&z,false);	FIND_CENTER_XFORM(x,y,z,theXForm);//finds centerXform for experimental or	xg = thePole->gvector.x;	yg = thePole->gvector.y;	zg = thePole->gvector.z;	//stage->CancelMatrixRotation(&xg,&yg,&zg,false);	TransFormVector(&xg,&yg,&zg,theXForm);//takes experimental gvector and rotates so zoneaxis is down zone	NormalizeVector(&xg,&yg,&zg);	theta = GetTrueAngle(xg,yg,u,v);//this gets the non-degnerative angle between two vectors, assuming z = 0;	//theta = acos(DotProductXYZ(xg,yg,zg,u,v,w));//degenerative method	RotatateMatrixAxis(rotForm, theta,2);//calculates the angular difference between the standard method and experimental		InvertMatrix(theXForm);//takes the pole after orientation to down zone and rotates to last or	MatrixMultiply(theYForm,rotForm,theYForm);//adds the rotation around the zone axis to obtain proper gvector or;	MatrixMultiply(theYForm,theXForm,theYForm);	theIndex->DoClose();	//this is the current orientation axis;}void StereoObject::GetORFromPole_SpotObject(SpotInfoPtr theSpot,double theYForm[][3]){	double u,v,w,x,y,z,xg,yg,zg;	double theCrystalForm[3][3];	double theXForm[3][3];	double theta;	double rotForm[3][3];	Index  *theIndex;	SpotInfoPtr gSpot;	theIndex = (Index*)D_new(Index);	if(theSpot->direction != true) theSpot--;	gSpot = &theSpot[1];	theIndex ->CopyPtrToIndex((Ptr)theSpot);	u = theSpot->h;	v = theSpot->k;	w = theSpot->l;	theSpot->theCrystal->Get001XForm(theCrystalForm);	TransFormVector(&u,&v,&w,theCrystalForm);	NormalizeVector(&u,&v,&w);	FIND_CENTER_XFORM(u,v,w,theYForm);//finds centerXform for 001	theIndex->h = gSpot->h;	theIndex->k = gSpot->k;	theIndex->l = gSpot->l;	theIndex->direction = false;	theIndex->DirOfPlaneNormal(&u,&v,&w);	TransFormVector(&u,&v,&w,theCrystalForm);	NormalizeVector(&u,&v,&w);//position at standard projection 001	TransFormVector(&u,&v,&w,theYForm);//orients gvector with zoneAxis down zone		x = theSpot->x;	y = theSpot->y;	z = theSpot->z;	//stage->CancelMatrixRotation(&x,&y,&z,false);	FIND_CENTER_XFORM(x,y,z,theXForm);//finds centerXform for experimental or	xg = gSpot->x;	yg = gSpot->y;	zg = gSpot->z;	//stage->CancelMatrixRotation(&xg,&yg,&zg,false);	TransFormVector(&xg,&yg,&zg,theXForm);//takes experimental gvector and rotates so zoneaxis is down zone	NormalizeVector(&xg,&yg,&zg);	theta = GetTrueAngle(xg,yg,u,v);//this gets the non-degnerative angle between two vectors, assuming z = 0;	//theta = acos(DotProductXYZ(xg,yg,zg,u,v,w));//degenerative method	RotatateMatrixAxis(rotForm, theta,2);//calculates the angular difference between the standard method and experimental		InvertMatrix(theXForm);//takes the pole after orientation to down zone and rotates to last or	MatrixMultiply(theYForm,rotForm,theYForm);//adds the rotation around the zone axis to obtain proper gvector or;	MatrixMultiply(theYForm,theXForm,theYForm);	theIndex->DoClose();	//this is the current orientation axis;}double GetTrueAngle(double xg,double yg,double u,double v){	double length;	double x,y;	length = sqrt(xg * xg + yg * yg);	x = atan2(xg/length,yg/length);	length = sqrt(u * u + v * v);	y = atan2(u/length,v/length);	return y - x;	//}void StereoObject::PlotPoleSet(void){	short i;	PolePosition *thePoles;	if(!poleHandle)return;	D_HLock((Handle)poleHandle);	thePoles = (*poleHandle);	for(i = 0; i < totalPoles;i++,thePoles++){		PlotSpotsFromPoleOR(thePoles);	}	D_HUnlock((Handle)poleHandle);}void StereoObject::PlotPolePositions(void){	short i;	GrafPtr oldPort;		PolePosition *thePoles;	if(!poleHandle)return;	GetPort(&oldPort);	SetPort(theWindow);	D_HLock((Handle)poleHandle);	thePoles = (*poleHandle);	for(i = 0; i < totalPoles;i++,thePoles++){		obj_Index->theCrystal = thePoles->zoneAxis.theCrystal;		PlotPoleObject(thePoles,i);	}	SetPort(oldPort);	D_HUnlock((Handle)poleHandle);}void StereoObject::PlotSpotsFromPoleOR(PolePosition *thePole){	double oldAxes[3][3];	double theYForm[3][3];	double theXForm[3][3];	short	i;	double	x,y,z;	double  xx,yy,zz;	CrystalFace 	newFaces[100],theFace;	short			theCount;	short			latticeType;			if( thePole->zoneAxis.flags & CRYSTAL_MASK != obj_Index->flags & CRYSTAL_MASK)return;	GetORFromPoleObject(thePole, theYForm);	CopyAxesIntoMatrix(oldAxes);	CopyMatrixIntoAxes(theYForm);	theRuler->SetPrompt("Adding the type.");	D_SetClip(drawRgn);	theFace.h = obj_Index->h;	theFace.k = obj_Index->k;	theFace.l = obj_Index->l;	theFace.flags = obj_Index->flags;	latticeType 	= 	obj_Index->theCrystal->lattice_Type;	theCount = -1;	CubicPermutate(&theCount,theFace,newFaces,true,latticeType);	for(i = 0; i <= theCount;i++){ 		xx = obj_Index->h = newFaces[i].h;		yy = obj_Index->k = newFaces[i].k;		zz = obj_Index->l = newFaces[i].l;		obj_Index->theCrystal->Get001XForm(theXForm);		TransFormVector(&xx,&yy,&zz,theXForm);		NormalizeVector(&xx,&yy,&zz);				x = xx * x_001.x + yy * y_001.x + zz * z_001.x;		y = xx * x_001.y + yy * y_001.y + zz * z_001.y;		z = xx * x_001.z + yy * y_001.z + zz * z_001.z;		AddThisSpot(x,y,z);	}		CopyMatrixIntoAxes(oldAxes);	theRuler->ClearPrompt();}typedef struct ParallelSpots{	long spot1;	long spot2;	double angle;}ParallelSpots,ParallelSpotsPtr;int	ParallelAngleCompare(const void* spot1,const void* spot2);//short	ParallelAngleCompare(ParallelSpots* spot1,ParallelSpots* spot2);int	ParallelAngleCompare(const void* spot1,const void* spot2){	double z1,z2;		z1 = fabs((double)((ParallelSpots*)spot1)->angle);	z2 = fabs((double)((ParallelSpots*)spot2)->angle);		return((short)((z1 < z2) ? -1 : ((z1 == z2) ? 0 : 1)));}void GetORRotations(SpotInfoPtr theSpots,ORSet *orr,double *theta1,double *theta2,double *theta3);void StereoObject::DialogBoxForPoleOR(short spotLoc1,short spotLoc2){	DialogPtr 		theDialog;	short 			k,i,theItem;	Rect 			rDataBnds,theRect;	Cell			cellSize;	TextBoxFree		*textBox;	PopUpMenu		*menu1,*menu2;	long			start1,start2,end1,end2;	long			old_Data;	Boolean			quit = false;	ParallelSpots 	**parallelHandle;	ORSet **orHandle;	ParallelSpots 	*parallels,*parallel,*par1,*par2;	long 			totalParallel,maxParallel;	SpotInfo 		*theSpots,*spot1,*spot2,*spot1a,*spot2a;	double 			angle,angleDif;	Index*			theIndex;	Cell			theCell;	short			oldBase,oldPValue[4],oldDValue[4],maxHKL;	Boolean			oldFlag;	ORSet 			*ors,*orr;	long 			maxOR,totalOR;	short			id1,id2;	double			theYForm[3][3],theTForm[3][3];	double theta1,theta2,theta3;		orHandle = 0L;	parallelHandle = 0L;	theDialog = DM_GetNewDialog(363, 0L,(WindowPtr)-1L);	textBox				=	(TextBoxFree*)D_new(TextBoxFree);	SetRect(&rDataBnds,0,0,6,25);	GetDItem			(theDialog,4,&gType,&gTheHandle,&gTheRect);	theRect = gTheRect;	theRect.right -= 45;	theRect.bottom -= 45;	cellSize.h = 60;	cellSize.v = 15;	old_Data = data_Count;	menu1 	= (PopUpMenu*)D_new(PopUpMenu);	D_HLock(theDataHandle);	theSpots = (SpotInfoPtr)*theDataHandle;		spot1 = &(theSpots[spotLoc1]);	id1 = spot1->flags & CRYSTAL_MASK;	spot1 = &(theSpots[spotLoc2]);	id2 = spot1->flags & CRYSTAL_MASK;		if(id1 > id2){//id1 should be matrix, for the moment we will just make it the lowest	//will change if it becomes necessary.		id1 = spotLoc1;		spotLoc1 = spotLoc2;		spotLoc2 = id1;		spot1 = &(theSpots[spotLoc1]);		id1 = spot1->flags & CRYSTAL_MASK;		spot1 = &(theSpots[spotLoc2]);		id2 = spot1->flags & CRYSTAL_MASK;	}	totalOR = 0;	menu1	->	Init(theDialog,5,14,id1 + 1);	menu1	->	SetPopUp();		menu2 	= (PopUpMenu*)D_new(PopUpMenu);	menu2	->	Init(theDialog,6,14,id2 + 1);	menu2	->	SetPopUp();		textBox		-> DoInit(&theRect,&rDataBnds,cellSize,0,theDialog,true,false,true,true,false,false,geneva,9,0);	textBox		-> ResetCell();	textBox		-> selected = true;	SetItemValue(theDialog,8,2.5,2);	SetItemValue(theDialog,9,2,0);	textBox->SetDrawFlag(true);	/* DrawDialog(theDialog); */	while(!quit){		Point thePoint;		SystemTask();		ModalDialog(TheFilterUPP,&theItem);		switch(theItem){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;			case 1:			StartWatch();			spotLoc = spotLoc1;			start1 = data_Count;			angleDif = GetItemValue(theDialog,8);			maxHKL = (short)GetItemValue(theDialog,9);			theSpots = (SpotInfoPtr)*theDataHandle;			oldFlag = structFactFlag;//save old calculation values			structFactFlag = false;//make sure DM does not waste time caluclating structure factors			oldBase = baseCrystal;			for(i = 0; i < 4;i++){//save old caluclation falues				oldPValue[i] = planeBounds[i];				planeBounds[i] = -1;				oldDValue[i] = dirBounds[i];				dirBounds[i] = -1;			}			spot1 = &(theSpots[spotLoc]);			baseCrystal = spot1->flags & CRYSTAL_MASK;			setCrystal = theCrystal[baseCrystal];			planeBounds[baseCrystal] = maxHKL;//set plot values large enough to insure an OR			dirBounds[baseCrystal] = maxHKL;			D_HUnlock(theDataHandle);			CalculatePoleStereogram( thePoint);			D_HLock(theDataHandle);			theSpots = (SpotInfoPtr)*theDataHandle;			end1 = data_Count - start1;						planeBounds[baseCrystal] = 0;			dirBounds[baseCrystal] = 0;						spotLoc = spotLoc2;			start2 = data_Count;												spot1 = &(theSpots[spotLoc]);						baseCrystal = spot1->flags & CRYSTAL_MASK;			setCrystal = theCrystal[baseCrystal];						planeBounds[baseCrystal] = maxHKL;			dirBounds[baseCrystal] = maxHKL;			D_HUnlock(theDataHandle);			CalculatePoleStereogram(thePoint);			D_HLock(theDataHandle);			theSpots = (SpotInfoPtr)*theDataHandle;			for(i = 0; i < 3;i++){//restore old values				planeBounds[i] = oldPValue[i];				dirBounds[i] = oldDValue[i];			}			structFactFlag = oldFlag;			baseCrystal   = oldBase;//restore old values			end2 = data_Count - start2;			if(!parallelHandle){				parallelHandle = (ParallelSpots**)D_NewHandle(100 * sizeof( ParallelSpots));				maxParallel = 100;				totalParallel = 0;			}else{				totalParallel = 0;			}			spot1 = &(theSpots[start1]);			D_HLock((Handle)parallelHandle);			parallels = *parallelHandle;			angleDif *= PI / 180;			for(i = 0; i < end1;i++,spot1++){				spot2 = &(theSpots[start2]);				for(k = 0;k < end2;k++,spot2++){					angle = acos(spot1->x * spot2->x + spot1->y * spot2->y + spot1->z * spot2->z);					if(fabs(angle) < angleDif){						if(totalParallel >= maxParallel){							D_ExpandMemory((Handle*)&parallelHandle,&totalParallel,&maxParallel,sizeof(ParallelSpots),100);							parallels = *parallelHandle;						}						parallel = &(parallels[totalParallel++]);						parallel->spot1 = i + start1;						parallel->spot2 = k + start2;						parallel->angle = angle;					}				}			}			D_HUnlock((Handle)parallelHandle);			if(totalParallel){				qHandlesort((Handle)parallelHandle,totalParallel,sizeof(ParallelSpots),/*(_compare_function)*/ParallelAngleCompare);			}else{				StopWatch();				break;			}			D_HLock((Handle)parallelHandle);												if(!orHandle){				orHandle = (ORSet**)D_NewHandle(100 * sizeof(ORSet));				maxOR = 100;				totalOR = 0;			}else{				totalOR = 0;			}			par1 = *parallelHandle;			ors = *orHandle;			D_HLock((Handle)orHandle);			for(i = 0; i < totalParallel;i++,par1++){				short crossProd;				par2 = *parallelHandle;				spot1 =  &(theSpots[par1->spot1]);				spot1a =  &(theSpots[par1->spot2]);				if(Quit())goto FINSIH_EARLY;				if(spot1a->direction != spot1->direction)continue;				for(k = 0; k < totalParallel;k++,par2++){					if(k == i)continue;																				spot2 =  &(theSpots[par2->spot1]);					spot2a =  &(theSpots[par2->spot2]);					if(spot2->direction != spot2a->direction)continue;										if(spot1->direction == spot2->direction)continue;					crossProd = spot1->h * spot2->h + spot1->k * spot2->k + spot1->l * spot2->l;					if(crossProd)continue;															if(spot1a->direction == spot2a->direction)continue;					crossProd = spot1a->h * spot2a->h + spot1a->k * spot2a->k + spot1a->l * spot2a->l;					if(crossProd)continue;					if(totalOR >= maxOR){						D_ExpandMemory((Handle*)&orHandle,&totalOR,&maxOR,sizeof(ORSet),100);						ors = *orHandle;					}					orr = &(ors[totalOR++]);					orr->spot1a = par1->spot1;					orr->spot1b = par1->spot2;					orr->angle1 =  par1->angle;										orr->spot2a = par2->spot1;					orr->spot2b = par2->spot2;					orr->angle2 =  par2->angle;									}			}			FINSIH_EARLY:			//while(IsPressed((unsigned short)47))i = 0;//this is so the dialog does not close on cmd-.			theIndex	 = (Index*)D_new(Index);			orr = *orHandle;			for(i = 0; i < totalOR;i++,orr++){				theCell.v = i;				if(Quit())goto ENOUGH_ALREADY;				for(k = 0; k < 6;k++){					theCell.h = k;					switch(k){						case 0:						spot1 =  &(theSpots[orr->spot1a]);						theIndex->CopyPtrToIndex((Ptr)spot1);						if(theIndex->direction)theIndex->reduceFlag = true;						else						if(theIndex->direction)theIndex->reduceFlag = false;						theIndex->IndexToSimpleText(gTheText);						break;						case 1:						spot2 =  &(theSpots[orr->spot1b]);						theIndex->CopyPtrToIndex((Ptr)spot2);						if(theIndex->direction)theIndex->reduceFlag = true;						else						if(theIndex->direction)theIndex->reduceFlag = false;						theIndex->IndexToSimpleText(gTheText);						break;						case 2:						sprintf(gTheText,"%6.3f",orr->angle1 * 180 / PI);						break;												case 3:						spot1 =  &(theSpots[orr->spot2a]);						theIndex->CopyPtrToIndex((Ptr)spot1);						theIndex->IndexToSimpleText(gTheText);						break;						case 4:						spot2 =  &(theSpots[orr->spot2b]);						theIndex->CopyPtrToIndex((Ptr)spot2);						theIndex->IndexToSimpleText(gTheText);						break;						case 5:						sprintf(gTheText,"%6.3f",orr->angle2 * 180 / PI);						break;					}					textBox->SetListText(gTheText,theCell);				}			}			ENOUGH_ALREADY:			while(IsPressed((unsigned short)47))i = 0;//this is so the dialog does not close on cmd-.			theIndex->DoClose();			StopWatch();			D_HUnlock((Handle)orHandle);			D_HUnlock((Handle)parallelHandle);			textBox->DrawList();			break;						case 2:			case CANCELCLICK:				quit = true;				break;			case 3:				InvalRect(&theDialog->portRect);				if(id1 != 0 && id1 != id2){					if(!Question(CHANGE_CRYSTAL))break;//if id1 is not the matrix we now need to set it to the matrix/this will					//probably mung up the current plot, but we warn the user.					theCrystal[id1]->CopyCrystal(theCrystal[0]);					menu1	->lastResult = 1;					menu1	->SetPopUp();				}else if(id1 == id2){//if id1 == id2 there is no way to establish a relationship				//again this will mung up the current equilbrium but there's nothing we can do				//the user is warned and asked to continue.					if(!Question(CHANGE_CRYSTAL_EQUAL))break;					theCrystal[id1]->CopyCrystal(theCrystal[0]);					theCrystal[0]->CopyCrystal(theCrystal[1]);					id1 = 0;					id2 = 1;					menu1	->lastResult = 1;					menu1	->SetPopUp();					menu2	->lastResult = 2;					menu2	->SetPopUp();				}				if(textBox->currentCell.v < 0 || textBox->currentCell.v >  totalOR)break;				D_HLock((Handle)orHandle);				orr = &(*orHandle)[textBox->currentCell.v];				GetORRotations((SpotInfoPtr)*theDataHandle,orr,&theta1,&theta2,&theta3);				if(MAX_NUM_OR <= the_PPT_Info[id2 - 1]->lastOR + 1){					Message(TOO_MANY_ORS);					break;				}				the_PPT_Info[id2 - 1]->lastOR++;				{					ORel	*theORel;					theORel = (ORel*)D_new(ORel);					if(!theORel->DoInit(theCrystal[id2])){the_PPT_Info[id2 - 1]->lastOR--;break;}										theORel->theMatrix1->CopyPtrToIndex((Ptr)&(theSpots[orr->spot1a]));					theORel->theMatrix1->theCrystal = theCrystal[0];					theORel->thePPT1->CopyPtrToIndex((Ptr)&(theSpots[orr->spot1b]));					theORel->thePPT1->theCrystal = theCrystal[id2];					theORel->rot1 = theta1;//orr->angle2 * 180 / PI;					theORel->theMatrix2->CopyPtrToIndex((Ptr)&(theSpots[orr->spot2a]));					theORel->theMatrix2->theCrystal = theCrystal[0];					theORel->thePPT2->CopyPtrToIndex((Ptr)&(theSpots[orr->spot2b]));					theORel->thePPT2->theCrystal = theCrystal[id2];					theORel->rot2 = theta3;//orr->angle1 * 180 / PI;					theORel->rot1b = theta2;//orr->angle1 * 180 / PI;					the_PPT_Info[id2 - 1]->theORs[the_PPT_Info[id2 - 1]->lastOR] =  theORel;				}				D_HUnlock((Handle)orHandle);				InvalRect(&theDialog->portRect);				break;			case 4:			 default:				GetMouse(&thePoint);				/*if(Button() && DblClick( thePoint)){					textBox->DoDblClick(thePoint);				}				*/				if(Button()){					unsigned char *theText;					long theSize;					if(theCell.v < 0 || theCell.v >=  totalOR)break;					if(!poleHandle || totalOR < 1)break;					theText = (unsigned char*)D_NewPtr(sizeof(char) * 256);					theText[0] = 0;					textBox->DoContent(thePoint);					theCell.v = textBox->currentCell.v;										gTheText[0] = 0;					D_HLock((Handle)orHandle);					orr = &(*orHandle)[textBox->currentCell.v];					GetORRotations((SpotInfoPtr)*theDataHandle,orr,&theta1,&theta2,&theta3);					D_HUnlock((Handle)orHandle);					for(i = 0; i <= 5;i++){						if(i == 2){							sprintf((char*)theText," rotate around pole 2 = %6.3f¡ ",theta1);							strcat(gTheText,(char*)theText);							sprintf((char*)theText," rotate toward pole 2 = %6.3f¡ ",theta2);							strcat(gTheText,(char*)theText);							continue;						}						if(i == 5){							sprintf((char*)theText," rotate around new pole 1 = %6.3f¡ ",theta3);							strcat(gTheText,(char*)theText);							continue;						}						theCell.h = i;						theSize = textBox->GetCell(theCell,(Ptr)theText)/sizeof(char);						theText[theSize] = 0;						strcat(gTheText,(char*)theText);					}					TextSize(9);					TextFont(geneva);					c2pstr(gTheText);					SetItemText(theDialog,7,(unsigned char*)gTheText);					TextSize(0);					TextFont(0);					KillPtr((Ptr)theText);				}				textBox->DoIdle();				break;				case 14:				{					Crystal 	*oldCrystal;					PolePosition *thePoles;					double		oldAxes[3][3];					if(!poleHandle || totalOR < 1)break;					D_HLock((Handle)poleHandle);					thePoles = (*poleHandle);					spot1 		= &(theSpots[spotLoc1]);					i 			= Round(spot1->angle);					GetORFromPoleObject(&(thePoles[i]), theYForm);					spot1 		= &(theSpots[spotLoc2]);					i 			= Round(spot1->angle);					GetORFromPoleObject(&(thePoles[i]), theTForm);					InvertMatrix	(theYForm);					MatrixMultiply	(theYForm,theTForm,theYForm);					oldCrystal 	= theCrystal[baseCrystal];					theCrystal[baseCrystal] = thePoles[i].zoneAxis.theCrystal;					CopyAxesIntoMatrix		(oldAxes);					CopyMatrixIntoAxes		(theYForm);					OrientationMatrixDialogBox	();					DrawDialog(theDialog);					textBox->DrawList();					menu2	->	SetPopUp();					menu1	->	SetPopUp();					theCrystal[baseCrystal] = oldCrystal;					CopyMatrixIntoAxes			(oldAxes);					D_HUnlock((Handle)poleHandle);					}				break;		}	}	if(parallelHandle)KillHandle((Handle*)&parallelHandle);	if(orHandle)KillHandle((Handle*)&orHandle);	menu1 ->DoClose();	menu2 ->DoClose();	textBox->DoClose();		D_HUnlock(theDataHandle);	if(data_Count > old_Data){		data_Count = old_Data;		if(data_Length >  data_Count){			D_RecoverMemory		(theDataHandle,data_Size,(long)data_Count);		}		numSpots = 	data_Length 	= 	data_Count;	}	DM_DisposDialog(&theDialog);	return;}void GetORRotations(SpotInfoPtr theSpots,ORSet *orr,double *theta1,double *theta2,double *theta3){	Vector axis[2][3];	double theXForm[3][3];	short i,j;	double	x,y;	//first get or matrix for experimental set 1	axis[0][0].x = (theSpots[orr->spot1a]).x;	axis[0][0].y = (theSpots[orr->spot1a]).y;	axis[0][0].z = (theSpots[orr->spot1a]).z;	axis[0][1].x = (theSpots[orr->spot2a]).x;	axis[0][1].y = (theSpots[orr->spot2a]).y;	axis[0][1].z = (theSpots[orr->spot2a]).z;		axis[1][0].x = (theSpots[orr->spot1b]).x;	axis[1][0].y = (theSpots[orr->spot1b]).y;	axis[1][0].z = (theSpots[orr->spot1b]).z;	axis[1][1].x = theSpots[orr->spot2b].x;	axis[1][1].y = theSpots[orr->spot2b].y;	axis[1][1].z = theSpots[orr->spot2b].z;	//rotate poles so that axis1 from pole 1 is in the center	FIND_CENTER_XFORM(axis[0][0].x,axis[0][0].y,axis[0][0].z,theXForm);	for(i = 0; i < 2;i++){		for(j = 0; j < 2;j++){		TransFormVector(&axis[i][j].x,&axis[i][j].y,&axis[i][j].z,theXForm);		}	}	//now rotate poles so that  axis2 from pole 1 is vertical	FIND_VERT_XFORM(axis[0][1].x,axis[0][1].y,theXForm);	for(i = 0; i < 2;i++){		for(j = 0; j < 2;j++){		TransFormVector(&axis[i][j].x,&axis[i][j].y,&axis[i][j].z,theXForm);		}	}	//now get the rotations that set axis1 fromi pole 2 to its current position from dead center	GetMuLambdaFromXYZ(axis[1][0].x,axis[1][0].y,axis[1][0].z,theta2,theta1);	//now save current axis2,pole2 orientation.	axis[1][2].x = axis[1][1].x;	axis[1][2].y = axis[1][1].y;	axis[1][2].z = axis[1][1].z;		//rotate poles so that axis1 from pole 2 is in the center	FIND_CENTER_XFORM(axis[1][0].x,axis[1][0].y,axis[1][0].z,theXForm);	for(i = 0; i < 2;i++){		for(j = 0; j < 2;j++){		TransFormVector(&axis[i][j].x,&axis[i][j].y,&axis[i][j].z,theXForm);		}	}	//now rotate poles so that  axis2 from pole 2 is vertical	FIND_VERT_XFORM(axis[1][1].x,axis[1][1].y,theXForm);	for(i = 0; i < 2;i++){		for(j = 0; j < 2;j++){		TransFormVector(&axis[i][j].x,&axis[i][j].y,&axis[i][j].z,theXForm);		}	}	//now apply theta1 and theta2 rotations about y and about x		x = cos(*theta1 * PI / 180);	y = sin(*theta1 * PI / 180);		FindXAxisXform(y,x,theXForm);/*mislabeled subroutines*/	for(i = 0; i < 2;i++){		for(j = 0; j < 2;j++){		TransFormVector(&axis[i][j].x,&axis[i][j].y,&axis[i][j].z,theXForm);		}	}	x = cos(*theta2 * PI / 180);	y = sin(*theta2 * PI / 180);	FindYAxisXform(y,x,theXForm);/*mislabeled subroutines*/	for(i = 0; i < 2;i++){		for(j = 0; j < 2;j++){		TransFormVector(&axis[i][j].x,&axis[i][j].y,&axis[i][j].z,theXForm);		}	}	//we now have the axis2 from pole 2 where we want it, less the final 3rd rotation.	// the quesiton is how to get both the rotation to the final position and the direction of that 	//rotation.	//this may seem a cicuitous method but it should work,we send the axis1 pole2 back to	//the center,with final axis, and the curennt axis two, then send these three poles so that	//the current axis two is vertical, then determine the rotation to the final axis.	FIND_CENTER_XFORM(axis[1][0].x,axis[1][0].y,axis[1][0].z,theXForm);	for(i = 0; i < 2;i++){		for(j = 0; j < 3;j++){		TransFormVector(&axis[i][j].x,&axis[i][j].y,&axis[i][j].z,theXForm);		}	}	//now rotate poles so that  axis2 from pole 2 is vertical	FIND_VERT_XFORM(axis[1][1].x,axis[1][1].y,theXForm);	for(i = 0; i < 2;i++){		for(j = 0; j < 3;j++){		TransFormVector(&axis[i][j].x,&axis[i][j].y,&axis[i][j].z,theXForm);		}	}	*theta3 = -asin(axis[1][2].y) * 180 /  PI;}