#include	"Diffract_INCs.h"#include	"StereoObject.h"Vector** SetSymmetryMatrix(double matrix[][3], short *totalSpots,short *theCrystal,Boolean *direction);//rces.Jim:Desktop.2.0:ST2_MatrixSymmetries.cdouble ConvertShortChar(char theChar);#include "UA2_Text_Box.h"Vector** SetSymmetryMatrix(double matrix[][3], short *totalSpots,short *theCrystal,Boolean *direction){	DialogPtr 	theDialog;	GrafPtr		theOldPort;	PopUpMenu	*popUpMenu,*crystalMenu;	PopUpMenu	*operations;	short		theAxis;	short 		itemType,theSelect=0;	Rect		theRect;	Handle		itemHndl;	double		matrix1[3][3],matrix2[3][3],matrixNew[3][3];	char		**theTextHdn,*theText,*matrixText;	long		lastResult;	Boolean		quit = false,theFlag;	short		i,j;	long		thePositions,oldPosition;	double		a,b,c;	Vector		*thePos,**thePosHdn;	long		maxPos;	Index		*theIndex;	long		aResult;	Rect		rDataBnds;	DA2_Text_Box	*textBox;	Point		cellSize;	thePositions = oldPosition = 0;		GetPort(&theOldPort);	SetMatrixAEqB(matrixNew,matrix);	theTextHdn = (char**)GetResource('info',400);	D_HLock(theTextHdn);	theText = *theTextHdn;	thePosHdn = (Vector**)D_NewHandle(sizeof(Vector) * 50);		maxPos	=	49;	theDialog = DM_GetNewDialog(400,NUL,IN_FRONT);	popUpMenu = (PopUpMenu*)D_new(PopUpMenu);	theAxis = 1;	operations = (PopUpMenu*)D_new(PopUpMenu);	crystalMenu = 	(PopUpMenu*)D_new(PopUpMenu);	popUpMenu->		Init		(theDialog,3,64,1);	operations->	Init		(theDialog,23,65,1);	crystalMenu->	Init		(theDialog,7,14,gCurrentObj->baseCrystal);	theIndex		=	(Index*)D_new(Index);	theIndex->		Init	(false,gCurrentObj->theCrystal[gCurrentObj->baseCrystal]);	textBox		=	(DA2_Text_Box*)D_new(DA2_Text_Box);	GetDItem(theDialog,9,&itemType,&itemHndl,&theRect);	SetRect(&rDataBnds,0,0,2,11);	cellSize.h = 57;	cellSize.v = 20;	textBox		-> DoInit(&theRect,&rDataBnds,cellSize,0,theDialog,true,false,false,true,false,false,geneva,9,0);	thePos		= 	*thePosHdn;	thePos->x = -3;	thePos->y = 19;	thePos->z = 2;	theIndex->h =  -3;	theIndex->k = 19;	theIndex->l =  2;	theIndex->		SetIndex(theDialog,6);	*direction	=	theFlag = true;	theFlag = SwitchBoolean( theDialog, 8, theFlag);	*theCrystal = 	1;		DrawDialog(theDialog);	textBox->ResetCell();	sprintf(gTheText,"(%3.0f %3.0f %3.0f)",thePos->x,thePos->y,thePos->z);	textBox->AddListText(gTheText);	textBox->DrawList();	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){		case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;			case 1:				SetMatrixAEqB(matrix,matrixNew);				*theCrystal = crystalMenu->lastResult;				*direction	=	theFlag;				gCurrentObj->newPictReq = true;			case 2:				quit = true;				if(theSelect == 2) thePositions = -1;				break;			case 3:				lastResult = popUpMenu->DoPopUp();				theAxis = popUpMenu->lastResult;				switch(theAxis)				{					case 1:						operations->DoClose();						operations = (PopUpMenu*)D_new(PopUpMenu);						operations->		Init		(theDialog,23,65,1);						break;					case 3:					case 4:						operations->DoClose();						operations = (PopUpMenu*)D_new(PopUpMenu);						operations->		Init		(theDialog,23,66,1);					break;					case 5:						operations->DoClose();						operations = (PopUpMenu*)D_new(PopUpMenu);						operations->		Init		(theDialog,23,67,1);					break;					case 7:					case 8:					case 9:					case 10:					case 11:					case 12:						operations->DoClose();						operations = (PopUpMenu*)D_new(PopUpMenu);						operations->		Init		(theDialog,23,68,1);					break;					case 14:					case 15:					case 16:					case 17:						operations->DoClose();						operations = (PopUpMenu*)D_new(PopUpMenu);						operations->		Init		(theDialog,23,69,1);					break;					case 19:					case 20:						operations->DoClose();						operations = (PopUpMenu*)D_new(PopUpMenu);						operations->		Init		(theDialog,23,70,1);					break;				}			break;			case 23:				operations->DoPopUp();								Identity_Matrix(matrix1);				if(theAxis == 1 && operations->lastResult == 1){					SetMatrixAEqB(matrixNew,matrix);					oldPosition = thePositions = 0;				}else if(theAxis == 1 && operations->lastResult == 2){					Identity_Matrix(matrixNew);					oldPosition = thePositions = 0;				}else{					short n = 0;					if(theAxis > 1) n += 1;					if(theAxis > 3) n += 8;					if(theAxis > 4) n += 8;					if(theAxis > 5) n += 14;					if(theAxis > 6 && theAxis < 13) n += 2 * (theAxis - 7);					else if(theAxis > 13) n += 12;					if(theAxis > 14 && theAxis < 18) n += 4 * (theAxis - 14);					else if(theAxis > 18) n += 16;					if(theAxis > 19) n += 2;					if(theAxis == 1) n = operations->lastResult - 3;					else n += operations->lastResult;					matrixText = &theText[(n) * 9];					j = 0;					for(i = 0; i <= 2;i++){						short k;						for(k = 0; k <= 2;k++) matrix1[i][k] = (double)ConvertShortChar(matrixText[j++]);					}					MatrixMultiply(matrixNew,matrix1,matrix2);					SetMatrixAEqB(matrixNew,matrix2);				}					thePos = *thePosHdn;				D_HLock((Handle)thePosHdn);				for(i = 0; i <= oldPosition;i++){					Boolean flag;					a = thePos[i].x;					b = thePos[i].y;					c = thePos[i].z;					flag = false;					while(a != thePos[i].x ||						b != thePos[i].y ||						c != thePos[i].z || flag == false){						TransFormVector(&a,&b,&c,matrix1);												CheckHandleSize((Handle)thePosHdn,&maxPos,thePositions + 2,sizeof(Vector));						thePos = *thePosHdn;						thePos[++thePositions].x = a;						thePos[thePositions].y = b;						thePos[thePositions].z = c;						flag = true;					}					thePositions--;				}				oldPosition = thePositions;				D_HUnlock((Handle)thePosHdn);								D_HLock((Handle)thePosHdn);				for(i = 0;i < thePositions;i++){					a = thePos[i].x;					b = thePos[i].y;					c = thePos[i].z;					for(j = i + 1;j <= thePositions;j++){						if(a == thePos[j].x && b == thePos[j].y&& c == thePos[j].z){							short k;							for(k = j; k < thePositions;k++){								thePos[k].x		= thePos[k + 1].x;								thePos[k].y		= thePos[k + 1].y;								thePos[k].z  	= thePos[k + 1].z;							}							thePositions--;							j--;						}					}				}				oldPosition = thePositions;				sprintf(gTheText,"%1.0f %1.0f %1.0f \r%1.0f %1.0f %1.0f \r%1.0f %1.0f %1.0f",matrixNew[0][0],matrixNew[0][1],matrixNew[0][2],matrixNew[1][0],					matrixNew[1][1],matrixNew[1][2],matrixNew[2][0],matrixNew[2][1],matrixNew[2][2]);								GetDItem(theDialog,4,&itemType,&itemHndl,&theRect);				SetIText(itemHndl,(unsigned char*)c2pstr(gTheText));								sprintf(gTheText,"%1.0f %1.0f %1.0f \r%1.0f %1.0f %1.0f \r%1.0f %1.0f %1.0f",matrix1[0][0],matrix1[0][1],matrix1[0][2],matrix1[1][0],					matrix1[1][1],matrix1[1][2],matrix1[2][0],matrix1[2][1],matrix1[2][2]);								GetDItem(theDialog,5,&itemType,&itemHndl,&theRect);				SetIText(itemHndl,(unsigned char*)c2pstr(gTheText));								textBox->ResetCell();				for(i = 0;i <= thePositions;i++){					sprintf(gTheText,"(%3.0f %3.0f %3.0f)",thePos[i].x,thePos[i].y,thePos[i].z);					textBox->AddListText(gTheText);				}				textBox->DrawList();				D_HUnlock((Handle)thePosHdn);				break;			case 7:				aResult = crystalMenu->DoPopUp();				break;			case 8:				theFlag = SwitchBoolean( theDialog, theSelect, theFlag);				break;			case 11:				theIndex->GetIndex(theDialog,6);				thePos		= 	*thePosHdn;				thePos->x = theIndex->h;				thePos->y = theIndex->k;				thePos->z = theIndex->l;				SetMatrixAEqB(matrixNew,matrix);				oldPosition = thePositions = 0;				textBox->ResetCell();				sprintf(gTheText,"(%3.0f %3.0f %3.0f)",thePos->x,thePos->y,thePos->z);				textBox->AddListText(gTheText);				textBox->DrawList();				break;			case 9:			case 10:				{					Point thePoint;					GetMouse(&thePoint);					textBox->DoContent(thePoint);				}			default:				break;					}	}	crystalMenu		->DoClose();	popUpMenu		->DoClose();	operations		->DoClose();	theIndex		->DoClose();	textBox			->DoClose();	D_HUnlock			(theTextHdn);	ReleaseResource		((Handle)theTextHdn);	DM_DisposDialog		(&theDialog);	*totalSpots 	= 	thePositions;	return thePosHdn;}double ConvertShortChar(char theChar){	short charVal;	charVal = (short)theChar;	if(charVal > 47 && charVal < 58)		return (double)(charVal - 48);	switch (theChar){		case (char)'»':			return -9;			break;		case (char)'¥':			return -8;			break;		case (char)'¦':			return -7;			break;		case (char)'¤':			return -6;			break;		case (char)'°':			return -5;			break;		case (char)'¢':			return -4;			break;		case (char)'£':			return -3;			break;		case (char)'ª':			return -2;			break;		case (char)'Á':			return -1;			break;		default:			return 0;			break;	}}void StereoObject::DoSpotAdditionBySymmetry(void){	double			matrix[3][3];	short			totalSpots;	Vector			**thePosHdn,*thePos;	short			i;	Boolean			direction;	Identity_Matrix(matrix);	thePosHdn = SetSymmetryMatrix(matrix,&totalSpots,&i,&direction);	thePos		=	*thePosHdn;	D_HLock((Handle)thePosHdn);	obj_Index->DoInit(direction,theCrystal[i - 1]);	theRuler->SetPrompt("Adding the Spot.");	for(i = 0; i <= totalSpots;i++)	{		double	x,y,z;		obj_Index->h = (short)thePos[i].x;		obj_Index->k = (short)thePos[i].y;		obj_Index->l = (short)thePos[i].z;		SystemTask();		LocatePole(&x,&y,&z);		AddThisSpot(x,y,z);		THE_CURRENT_SPOT.flags |= SYMMETRY_MASK;		LabelSpot();	}	theRuler->ClearPrompt();	D_HUnlock((Handle)thePosHdn);	KillHandle((Handle*)&thePosHdn);}void	StereoObject::AddTA(void){	DialogPtr 	theDialog;	double 		lambda,mu,x,y,z;	short 			theSelect=0,n;	Point		thePoint,lastPoint;		thePoint.h = 0;	n = 500 + '0';	thePoint.v = rulerHeight + 19;	LocalToGlobal(&thePoint);	theDialog = DM_GetNewDialog(ADD_TA_DLOG,NUL,IN_FRONT);		MoveWindow(theDialog,thePoint.h,thePoint.v,true);	ShowWindow(theDialog);			SelIText(theDialog,3,0,255);	while(true){		GetMouse(&thePoint);		if(PtInRect(thePoint,&(theDialog->portRect))|| !Button()){			ModalDialog(TheFilterUPP,&theSelect);			switch(theSelect){				case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;				case 2:					DM_DisposDialog(&theDialog);					FlushEvents(everyEvent,0);					return;					break;				case 1:					GetDItem(theDialog,3, &gType,&gTheHandle,&gTheRect);					GetIText(gTheHandle,pTheText);					p2cstr(pTheText);					 lambda = PI * atof(gTheText) / 180.;					GetDItem(theDialog,4, &gType,&gTheHandle,&gTheRect);					GetIText(gTheHandle,pTheText);					p2cstr(pTheText);					mu = PI * atof(gTheText) / 180.;					ConvertMuLambdaToXYZ(&x,&y,&z,mu,lambda);										SetPort(theWindow);					D_SetClip(drawRgn);					SetXYZValueToHKL(x,y,z,DIRECTION);					AddThisSpot(x,y,z);					SetPort(theDialog);					newPictReq = true;					break;			}		} else if(Button()){			while(Button()){				GetMouse(&thePoint);				if(!EqualPt(thePoint,lastPoint)){					lastPoint = thePoint;					LocalToGlobal(&thePoint);					SetPort(theWindow);					GlobalToLocal(&thePoint);					SetPort(theDialog);					onScreen = true;					LocalToObj(&thePoint);					GetMuLambda( thePoint,&mu,&lambda,false);										sprintf(gTheText,"%5.2f",lambda);					c2pstr(gTheText);					GetDItem(theDialog,3, &gType,&gTheHandle,&gTheRect);					SetIText(gTheHandle,pTheText);					sprintf(gTheText,"%5.2f",mu);					c2pstr(gTheText);					GetDItem(theDialog,4, &gType,&gTheHandle,&gTheRect);					SetIText(gTheHandle,pTheText);				}			}		}	}}void 	StereoObject::ConvertMuLambdaToXYZ(double *x,double *y,double *z,double mu,double lambda){	*x = sin(mu);	*y = cos(mu) * sin(lambda);	*z = cos(mu) * cos(lambda);} void StereoObject::SetScaleFactor(void) {     short hRes,vRes;     ScreenRes(&hRes,&vRes);      projLengthScreen    =   SetRadius();     cameraLength = projLengthScreen *  25.4 / ((double)hRes * magnification);     cameraConstant  =   cameraLength;     switch(theBeamFlag){         case 1:            theEBeam->ReturnCameraConstant(&cameraConstant);             break;         case 2:             theXRay->ReturnCameraConstant(&cameraConstant);             break;        case 3:             theIon->ReturnCameraConstant(&cameraConstant);             break;     }     scaleFactor     =   (double)cameraConstant * (double)hRes * magnification/ 25.4; }