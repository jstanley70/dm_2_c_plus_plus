#include	"a_DiffractObject.h"#include	"Diffract_INCs.h"#include	"Print_Special.h"#include	"crystalFaceObj.h"#include	"elementInfoObj.h"//#include	"a_ImageObject.h"#include	"KikuchiObject.h"#include 	"KosselObj.h"			/* Added by JT. Septemeber */#include	"Pict_Obj.h"#include  "ElasticConstant.h"  	/* Added by JT July 1991 */#include	"MenuDefs.h"			/* Jan 1993 by Eric */#include	"Dir_Paths.h"				/* Jan 1993 by Eric */#include 	"BEKPObj.h"#include 	"WindowMenu.h"#include	"GraphSpots.h"//#include	"Patterson.h"//#include	"HREM.h"#include 	"ML_BeamOrientation.h"#include 	"ML_FoilNormal.h"#include 	"GraphFunction.h"#include 	"UA2_Text_Box.h"#include 	"UextBoxFree.h"#include 	"nrutil.h"#include 	"mathRecipies.h"#include	"EveMacros.h"#include	"VectorLib.h"Boolean		DoHexSet(void);void		DrawProgramName(void);void TestCenterSpot(Index *theIndex,short plotType,short size,doublematrix[3][3]);void DiffractObject::ReadBeamORData(DialogPtr theDialog,Boolean resetBeam,short oldIr,double *x,double *y){	double matrix[3][3],oldMatrix[3][3],oldRot;	Index	*cIndex;	short i,j;		if(!resetBeam){		return;	}		cIndex	=	(Index*)D_new(Index);		GetDialogValues(theDialog,oldIr,theZoneAxis,theRotationAxis,g_Vector,x,y);		oldRot = totalRot;		totalRot = GetItemValue(theDialog,ML_HOR_ROT);		beamAzimuth = 0;		if(fabs(oldRot - totalRot) > .001)changedFlag = true;		if(oldIr < 2){			theZoneAxis->x = theZoneAxis->h;			theZoneAxis->y = theZoneAxis->k;			theZoneAxis->z = theZoneAxis->l;		}		rotationAngle = *x;		offLaueDistance = *y;		calcIrrational = oldIr;		CalculateOrientation(theZoneAxis,theRotationAxis,g_Vector,rotationAngle,offLaueDistance,totalRot,beamAzimuth,calcIrrational,matrix);			if(calcIrrational == 3 || calcIrrational == 4){			if(theZoneAxis->h == theRotationAxis->h &&				theZoneAxis->k == theRotationAxis->k &&				theZoneAxis->l == theRotationAxis->l||				theZoneAxis->h == -theRotationAxis->h &&				theZoneAxis->k == -theRotationAxis->k &&				theZoneAxis->l == -theRotationAxis->l){Message(ROTATE_AXIS_BEAM_SAME);			}		}		if(calcIrrational >= 5 && calcIrrational <= 7){			if(fabs(theZoneAxis->GetTheAngle(g_Vector)) > 95 || fabs(theZoneAxis->GetTheAngle(g_Vector)) < 85){				Message(BEAM_G_NOT_90);			}		}		CopyAxesIntoMatrix(oldMatrix);		for(i = 0; i < 3; i++){			for(j = 0; j < 3; j++){				if(fabs(matrix[i][j] - oldMatrix[i][j]) > .00001)changedFlag = true;			}		}		SetOrientation(matrix);		SetFoundation();/*new 1997*/		cIndex->DoClose();}void DiffractObject::SetFoundation(void){	short i;	CopyAxesIntoMatrix(rockAxes);	theZoneAxis->DoCopy(rockZA);	rockCalcIrr = calcIrrational;	g_Vector->DoCopy(rockGVect),	theRotationAxis->DoCopy(rockRotVec),	rockRotAng 			= rotationAngle;	rockOffLaueD 		=  offLaueDistance;	rockTotalRot		=	totalRot;	rockBeamAximuth = beamAzimuth;	for(i = 0; i < 3;i++){		totalTilts[i] = 0;	}}void DiffractObject::RenormalizeToFoundation(void){	short i;	double degree;	CopyMatrixIntoAxes(rockAxes);	rockZA->DoCopy(theZoneAxis);	calcIrrational = rockCalcIrr;	rockGVect->DoCopy(g_Vector),	rockRotVec->DoCopy(theRotationAxis),	rotationAngle = rockRotAng;	offLaueDistance = rockOffLaueD;	totalRot = rockTotalRot;	beamAzimuth = rockBeamAximuth;	for(i = 0; i < 3;i++){		degree = totalTilts[i];		DoARotation(totalTilts[i],i);		totalTilts[i] -= degree;	}}		void DiffractObject::CopyFoundation(DiffractObject *theObj){	short i;	CopyAxesIntoMatrix(theObj->rockAxes);	rockZA->DoCopy(theObj-> rockZA);	rockGVect->DoCopy(theObj->rockGVect),	rockRotVec->DoCopy(theObj->rockRotVec),	theObj-> rockCalcIrr = rockCalcIrr;	theObj->rockRotAng = rockRotAng;	theObj->rockOffLaueD 		=  rockOffLaueD;	theObj->rockTotalRot		=	rockTotalRot;	theObj->rockBeamAximuth = rockBeamAximuth;	for(i = 0; i < 3;i++){		theObj->totalTilts[i] = totalTilts[i];	}}	Boolean	DoHexSet(void){	GrafPtr 	theOldPort;	DialogPtr 	theDialog;	short 		theSelect,lastSelect;		GetPort(&theOldPort);	theDialog	= DM_GetNewDialog(150,NUL,IN_FRONT);	if(g_Hex_Four)		lastSelect = 3;	else		lastSelect = 4;	GetDItem(theDialog,lastSelect,&gType,&gTheHandle,&gTheRect);	SetCtlValue((ControlHandle)gTheHandle,1);	while(1 != 2){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case -1:			case 2:				DM_DisposDialog(&theDialog);								return g_Hex_Four;			case DLOG_ENTER_OR_CR:			case 1:				DM_DisposDialog(&theDialog);								if(lastSelect == 3)					return true;				return false;			case 3:			case 4:				if(lastSelect != theSelect){					GetDItem(theDialog,theSelect,&gType,&gTheHandle,&gTheRect);					SetCtlValue((ControlHandle)gTheHandle,1);					GetDItem(theDialog,lastSelect,&gType,&gTheHandle,&gTheRect);					SetCtlValue((ControlHandle)gTheHandle,0);					lastSelect = theSelect;				}				break;			default:				break;			case ML_UPDATE_EVT:						BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;		}	}}void		DrawProgramName(void)	/* this is a kludge that fixes the colorenvironment */{	WindowPtr	startupWindow;	PicHandle	startupPict;	unsigned long		time;		startupPict 	= GetPicture(129);	startupWindow 	= GetNewCWindow(129,0L,(WindowPtr)-1L);	SetPort(startupWindow);	DrawPicture(startupPict,&startupWindow->portRect);	KillPicture (startupPict);	Delay(15,&time);	DisposeWindow(startupWindow);}void DiffractObject::IrrationalZoneAxis(Index *zone,Index *about,Index*gvector,double xx,double yy,double rotation,double rotation2,shortmethod,double *u,double *v,double *w,double aMatrix[3][3]){	double 		x1,y1,z1,mu,lambda,x2,y2,z2,radConvert;	double 		xForm[3][3],newMatrix[3][3],vForm[3][3],centerM[3][3];	Crystal 	*thisCrystal;	double		dspace;	Index			*theIndex;	short			j;		/* method 1 is Zone Axis	 					2	is Plane Normal	 					3 is Laue rotate to zone	 					4 is Bragg rotate to zone	 					5 is Laue rotate about g	 					6 is Bragg rotate about g	 					7 g is x-axis, y perpendicular to g	*/		if(baseCrystal <= 0){		baseCrystal = 0;	}		if(!about || !zone || !gvector){		WarnUser(1);		return;	}			thisCrystal = theCrystal[baseCrystal];	gvector->theCrystal = thisCrystal;	zone->theCrystal = thisCrystal;	if(about)	about->theCrystal = thisCrystal;			Identity_Matrix(newMatrix);	radConvert = PI / 180.0;	thisCrystal->Get001XForm(xForm);		if(method <= 2){		zone-> DirOfPlaneNormal(&x1,&y1,&z1);		TransFormVector(&x1,&y1,&z1,xForm);		FIND_CENTER_XFORM(x1,y1,z1,newMatrix);		zone->DirOfPlaneNormal(u,v,w);		if(!(zone->h * gvector->h + zone->k * gvector->k + zone->l * gvector->l)){				gvector->DirOfPlaneNormal(&x2,&y2,&z2);				TRANSFORM_VECTOR(x2,y2,z2,xForm);				TRANSFORM_VECTOR(x2,y2,z2,newMatrix);				FIND_VERT_XFORM(x2,y2,vForm);				MatrixMultiply(newMatrix,vForm,newMatrix);				RotatateMatrixAxis(vForm,rotation * PI / 180,2);				MatrixMultiply(newMatrix,vForm,newMatrix);				RotatateMatrixAxis(vForm,rotation2 * PI / 180,2);				MatrixMultiply(newMatrix,vForm,newMatrix);		}		NormalizeRotationMatrix(newMatrix);		SetMatrixAEqB(aMatrix,newMatrix);		return;	}			zone->DirOfPlaneNormal(&x1,&y1,&z1);	TransFormVector(&x1,&y1,&z1,xForm);	if(method > 2 && method < 5){				about->DirOfPlaneNormal(&x2,&y2,&z2);	}else{		gvector->DirOfPlaneNormal(&x2,&y2,&z2);	}	TRANSFORM_VECTOR(x2,y2,z2,xForm);	FIND_CENTER_XFORM(x1,y1,z1,newMatrix);/*rotate beam center to zone axis*/			if(method == 3 || method == 4){		SetMatrixAEqB(aMatrix,newMatrix);		if(zone->h == about->h &&			zone->k == about->k &&			zone->l == about->l ||(			xx == 0 && yy == 0 && method == 3)){			zone->DirOfPlaneNormal(&x1,&y1,&z1);			TransFormVector(&x1,&y1,&z1,xForm);			FIND_CENTER_XFORM(x1,y1,z1,newMatrix);			zone->DirOfPlaneNormal(u,v,w);			if(!(zone->h * gvector->h + zone->k * gvector->k + zone->l * gvector->l)){				gvector->DirOfPlaneNormal(&x2,&y2,&z2);				TRANSFORM_VECTOR(x2,y2,z2,xForm);				TRANSFORM_VECTOR(x2,y2,z2,newMatrix);				FIND_VERT_XFORM(x2,y2,vForm);				MatrixMultiply(newMatrix,vForm,newMatrix);				RotatateMatrixAxis(vForm,rotation * PI/180,2);				MatrixMultiply(newMatrix,vForm,newMatrix);				RotatateMatrixAxis(vForm,rotation2 * PI / 180,2);				MatrixMultiply(newMatrix,vForm,newMatrix);			}			NormalizeRotationMatrix(newMatrix);			SetMatrixAEqB(aMatrix,newMatrix);			return;		}	}	if(method >= 5 && method <= 7){		double vv;		vv = fabs(zone->GetTheAngle(gvector));		if(vv > 95 || vv < 85){			zone->DirOfPlaneNormal(&x1,&y1,&z1);			TransFormVector(&x1,&y1,&z1,xForm);			FIND_CENTER_XFORM(x1,y1,z1,newMatrix);			zone->DirOfPlaneNormal(u,v,w);			if(!(zone->h * gvector->h + zone->k * gvector->k + zone->l * gvector->l)){				gvector->DirOfPlaneNormal(&x2,&y2,&z2);				TRANSFORM_VECTOR(x2,y2,z2,xForm);				TRANSFORM_VECTOR(x2,y2,z2,newMatrix);				FIND_VERT_XFORM(x2,y2,vForm);				MatrixMultiply(newMatrix,vForm,newMatrix);				RotatateMatrixAxis(vForm,rotation * PI/180,2);				MatrixMultiply(newMatrix,vForm,newMatrix);				NormalizeRotationMatrix(newMatrix);				RotatateMatrixAxis(vForm,rotation2 * PI / 180,2);				MatrixMultiply(newMatrix,vForm,newMatrix);			}			NormalizeRotationMatrix(newMatrix);			SetMatrixAEqB(aMatrix,newMatrix);			return;		}	}	TRANSFORM_VECTOR(x2,y2,z2,newMatrix);/*impose zone axis rotation on vector of interest if vector is perpendicular to										to zone axis it will now be in plane normal to beam*/	SetMatrixAEqB(aMatrix,newMatrix);		FIND_VERT_XFORM(x2,y2,vForm);/*determine rotation neccessary to move this vector to vertical*/		MatrixMultiply(newMatrix,vForm,newMatrix);//make a new matrix which contains the center + vertical rotations	//Now we must calculate the rotations required to get the desired off axis orientation	//essentially xx is a rotation parallel (in the case of rotation to and the Laue Circle	//or about i.e. perpendicular in the case of rotation about g, yy is rotation always perpendicular	//in a rigth handed screw out of the page to the rotational sense of xx	//rotations are given either in mm, ° or w by Bragg orientation or Laue	//convert all to theta and laue	//mm to theta is asin(xx * wavelength/cameraConstant * 2)	//w to mm is (w/extDist) + 1/2*dspacing) * cameraConstant	//convert Bragg to Laue (bragg in mm + ((1/2*dspacing) * cameraConstant);		j = 1;	if(method < 5){		double x3,y3,z3;		gvector->DirOfPlaneNormal(&x3,&y3,&z3);		TRANSFORM_VECTOR(x3,y3,z3,newMatrix);		if(y3 < 0){			j = -1;		}	}else{		j = -1;	}	dspace =   j * -gvector->TheDSpacing();	cameraLength = cameraConstant / wavelength;	switch(method){		double angstroms;		case TO_Z_LAUE_OR:  /*towards horizontal,from laue, in theta,mm*/			mu = radConvert *  -xx;			lambda = asin(( j * yy) / (cameraLength /* * 2.*/));			break;		case TO_Z_BRAG_OR: /*towards horizontal,from bragg,in theta,mm*/			mu = radConvert *  -xx;			angstroms = cameraConstant / dspace;			lambda = asin(( j * yy + angstroms) / (cameraLength /* * 2.*/));			break;		case HOR_LAUE: /*about horizontal, from laue, in theta,mm*/			mu = radConvert *  xx;			lambda = asin((j * yy) / (cameraLength /* * 2.*/));			break;		case HOR_BRAG_OR: /*about horizontal, from Bragg, in theta,mm*/			mu = radConvert *  xx;			//lambda = asin((dspace + ((double)yy * wavelength)) /((double)cameraConstant * 2.));			angstroms = cameraConstant / dspace;			lambda = asin((j * yy + angstroms) / (cameraLength/* * 2.*/));			break;		case LAUE_CIR_OR: /*towards horizontal,from laue,in mm,mm*/			mu 	=  asin( ((double)yy) / ((double)cameraLength));			lambda 	= asin((double)xx / (j * cameraLength));			break;	}	theIndex	=	(Index*)D_new(Index);	zone->DoCopy(theIndex);	SetMatrixAEqB(aMatrix,newMatrix);//takes center + vertical rotations into aMatrix	//Next section rotations matrix by the necessary amounts around x axis, then around y axis	if(method > 4){				RotatateMatrixAxis(xForm,mu,0);			MatrixMultiply(aMatrix,xForm,aMatrix);		RotatateMatrixAxis(xForm,lambda,1);			MatrixMultiply(aMatrix,xForm,aMatrix);				}else if(method > 2)	{		RotatateMatrixAxis(xForm,lambda,0);			MatrixMultiply(aMatrix,xForm,aMatrix);		RotatateMatrixAxis(xForm,mu,1);			MatrixMultiply(aMatrix,xForm,aMatrix);			}	RotatateMatrixAxis(xForm,rotation * PI / 180,2);	MatrixMultiply(aMatrix,xForm,aMatrix);		zone->DirOfPlaneNormal(&x1,&y1,&z1);	zone->theCrystal->Get001XForm(xForm);	TransFormVector		(&x1,&y1,&z1,xForm);	TransFormVector		(&x1,&y1,&z1,aMatrix);	FIND_CENTER_XFORM	(x1,y1,z1,centerM);	RotatateMatrixAxis(vForm,rotation2 * PI/180,2);	MatrixMultiply		(aMatrix,centerM,aMatrix);	MatrixMultiply		(aMatrix,vForm,aMatrix);	InvertMatrix			(centerM);	MatrixMultiply		(aMatrix,centerM,aMatrix);	theIndex->x = 0;	theIndex->y = 0;	theIndex->z = 1;	//TestCenterSpot(zone,0,3,aMatrix);	NormalizeRotationMatrix(aMatrix);	InvertMatrix(aMatrix);	theIndex->GetTheUVWFromXYZ(aMatrix);//converts 001 to new xyz	theIndex->ConvertXYZToHKLReduce();	InvertMatrix(aMatrix);	if(theIndex->direction == false) theIndex->reduceFlag = false;	zone->x = *u = theIndex->x;	zone->y = *v = theIndex->y;	zone->z = *w = theIndex->z;	theIndex->DoClose();	return;}void TestCenterSpot(Index *theIndex,short plotType,short size,doublematrix[3][3]){	short ver,hor;	double cl;	short l,j;	double xForm[3][3];	double x1,y1,z1;	GrafPtr oldPort ;	GetPort(&oldPort);	SetPort(gCurrentObj->theWindow);	theIndex->DirOfPlaneNormal(&x1,&y1,&z1);	theIndex->theCrystal->Get001XForm(xForm);	TransFormVector(&x1,&y1,&z1,xForm);//transform hkl to xyz for g-vector	TransFormVector(&x1,&y1,&z1,matrix);	NormalizeVector(&x1,&y1,&z1);		ScreenRes(&j,&l);	cl 	= 	l * gCurrentObj->cameraConstant/(gCurrentObj->wavelength * 25.4);	ver =  x1 * cl + gCurrentObj->centerY;	hor =  y1 * cl + gCurrentObj->centerX;	SetRect(&gTheRect, -size,-size,size,size);	OffsetRect(&gTheRect,hor,ver);	switch(plotType){		case 0:				FrameRect(&gTheRect);		break;		case 1:			FrameOval(&gTheRect);		break;			}	FrameRect(&gTheRect);	SetPort(oldPort);}Boolean DiffractObject::DefineOrientation(Boolean resetBeam,double*xx,double *yy,double *zz){	DialogPtr 			theDialog;	short						theSelect;	Boolean					quit = false;	Boolean					saveData = false;	ML_BeamORParamsPtr theMLParams;		theDialog	= DM_GetNewDialog(11112,NUL,IN_FRONT);		ML_DoBeamORSetup((Ptr)this, theDialog,(Ptr*)&theMLParams);	theMLParams->resetBeam = resetBeam;	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:						BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}						quit = DoBeamORSwitch(theDialog,theSelect,theMLParams,&saveData);				EndUpdate(theDialog);				break;			default:					quit = DoBeamORSwitch(theDialog,theSelect,theMLParams,&saveData);			break;		}	}		ML_DoBeamORRead((Ptr)this, theDialog,	(Ptr)theMLParams, saveData);	*xx = theZoneAxis->x;	*yy = theZoneAxis->y;	*zz = theZoneAxis->z;	DM_DisposDialog(&theDialog);	return saveData ;}void DiffractObject::GetDialogValues(DialogPtr theDialog,short method,Index *theIndex,Index *aIndex,Index *bIndex,double *x,double *y/*,double *z*/){	theIndex->GetIndex(theDialog,ML_ZONE_AXIS);	aIndex->GetIndex(theDialog,ML_TOWARD);	bIndex->GetIndex(theDialog,ML_GVECTOR);	*x = GetItemValue( theDialog,ML_ROT_ANGLE);	*y = GetItemValue( theDialog,ML_OFF_LAUE);// * 2;	bIndex->reduceFlag = false;	bIndex->direction = false;	theIndex->direction = true;	switch(method){				case 2:			theIndex->direction = false;			break;			default:		theIndex->direction = true;		break;	}}void DiffractObject::SetForZone(DialogPtr theDialog,short method,Index *theIndex,Index *aIndex,Index *bIndex,  double x,double y/*,double z*/){	double aMatrix[3][3];	double angle;	theIndex->SetIndex(theDialog,ML_ZONE_AXIS);	SelIText(theDialog,ML_ZONE_AXIS,0,100);	if(method <= 2){		HideDItem(theDialog,ML_ROT_ANGLE);		HideDItem(theDialog,ML_TOWARD);		HideDItem(theDialog,ML_OFF_LAUE);	}else{		ShowDItem(theDialog,ML_ROT_ANGLE);		ShowDItem(theDialog,ML_TOWARD);		ShowDItem(theDialog,ML_OFF_LAUE);		aIndex->SetIndex(theDialog,ML_TOWARD);		SetItemValue(theDialog,ML_ROT_ANGLE ,x,3);		SetItemValue(theDialog, ML_OFF_LAUE,y /*/2*/,3);	}	//angle = fabs(theIndex->GetTheAngle(bIndex));	if(theIndex->h * bIndex->h + theIndex->k * bIndex->k + theIndex->l *bIndex->l == 0){		GetOrientation(aMatrix);		bIndex->GetXYZFromHKL(aMatrix);		//GetLength()		angle = atan2(bIndex->y,bIndex->x) + PI;		angle *= 180/PI;		while(angle >= 360) angle -= 360;		if(angle > 180 && angle <= 360)angle -= 360;		while(angle <= -360) angle += 360;		SetItemValue(theDialog, ML_HOR_ROT,angle,2);	}else{		SetItemValue(theDialog, ML_HOR_ROT,0,2);	}	SetItemValue(theDialog,ML_EXTINCT_B,(bIndex->TheExtinctionDist(1/wavelength, 1,  theBeamFlag)),1);	bIndex->SetIndex(theDialog,ML_GVECTOR);	DrawControls(theDialog);	sprintf(gTheText,"[%6.5f , %6.5f , %6.5f]",theIndex->x,theIndex->y,theIndex->z);	SetItemText( theDialog, ML_BEAM_IRRATION,c2pstr(gTheText));	switch(method)	{		case 1:			SetItemText( theDialog, ML_BEAM_TEXT,"\pZone Axis  [");			SetItemText( theDialog,ML_BEAM_UNITS,"\p]");			SetItemText( theDialog, ML_GVEC_TEXT,"\pSelected  g    (\r\rExtinction Dist.");			theIndex->x = theIndex->h; theIndex->y = theIndex->k;theIndex->z = theIndex->l;			break;		case 2:			SetItemText( theDialog, ML_BEAM_TEXT,"\pPlane Normal(");			SetItemText( theDialog, ML_BEAM_UNITS,"\p)");			SetItemText( theDialog, ML_GVEC_TEXT,"\pSelected  g    (\r\rExtinction Dist.");			theIndex->x = theIndex->h; theIndex->y = theIndex->k;theIndex->z = theIndex->l;			break;		case 3:			SetItemText( theDialog, ML_BEAM_TEXT,"\pZone Axis  [\r\rRotate\r\rToward [\r\rOff Laue");			SetItemText( theDialog, ML_BEAM_UNITS,"\p]\r\r°\r\r]\r\r(mm)");			SetItemText( theDialog, ML_GVEC_TEXT,"\pSelected  g    (\r\rExtinction Dist.");			break;		case 4:			SetItemText( theDialog, ML_BEAM_TEXT,"\pZone Axis  [\r\rRotate\r\rToward     [\r\rOff Bragg");			SetItemText( theDialog, ML_BEAM_UNITS,"\p]\r\r°\r\r]\r\r(mm)");			SetItemText( theDialog, ML_GVEC_TEXT,"\pSelected  g    (\r\rExtinction Dist.");			bIndex->SetIndex(theDialog,ML_GVECTOR);			break;		case 5:			SetItemText( theDialog, ML_BEAM_TEXT,"\pZone Axis [\r\rRotate\r\r\r\rOff Laue");			SetItemText( theDialog, ML_BEAM_UNITS,"\p]\r\r°\r\r\r\r(mm)");			SetItemText( theDialog, ML_GVEC_TEXT,"\pAround    g    (\r\rExtinction Dist.");			HideDItem(theDialog,ML_TOWARD);			break;		case 6:			SetItemText( theDialog, ML_BEAM_TEXT,"\pZone Axis [\r\rRotate\r\r\r\rOff Bragg");			SetItemText( theDialog, ML_BEAM_UNITS,"\p]\r\r°\r\r\r\r(mm)");			SetItemText( theDialog, ML_GVEC_TEXT,"\pAround    g    (\r\rExtinction Dist.");			HideDItem(theDialog,ML_TOWARD);			break;		case 7:			SetItemText( theDialog, ML_BEAM_TEXT,"\pZone Axis  [\r\rx =\r\r\r\ry = ");			SetItemText( theDialog, ML_BEAM_UNITS,"\p]\r\r(mm)\r\r\r\r(mm)");			SetItemText( theDialog, ML_GVEC_TEXT,"\px axis         (\r\rExtinction Dist.");			HideDItem(theDialog,ML_TOWARD);			break;			}}Boolean DiffractObject::SameObject(DiffractObject *theObj){	short i;	if(!CheckAxes(theObj))return false;	for(i = 0; i < 3;i++){		if(!theCrystal[i]->SameCrystal(theObj->theCrystal[i]))return false;	}	for(i = 0; i < 2;i++){		if(!the_PPT_Info[i]->SameOR(theObj->the_PPT_Info[i]))return false;	}	return true;}Boolean DiffractObject::CheckAxes(DiffractObject *theObj){	if(theObj->x_001.x != x_001.x)return false;	if(theObj->x_001.y != x_001.y)return false;	if(theObj->x_001.z != x_001.z)return false;	if(theObj->y_001.x != y_001.x)return false;	if(theObj->y_001.y != y_001.y)return false;	if(theObj->y_001.z != y_001.z)return false;	if(theObj->z_001.x != z_001.x)return false;	if(theObj->z_001.y != z_001.y)return false;	if(theObj->z_001.z != z_001.z)return false;	return true;}void DiffractObject::DynamicLinking(void){	WindowPeek	aWindow;	DiffractObject *theObj;	GrafPtr	oldPort;	GetPort(&oldPort);		aWindow 	= (WindowPeek)FrontWindow();	if(!aWindow)return;	while(!aWindow->refCon && aWindow->nextWindow)aWindow = aWindow->nextWindow;		while(aWindow != (WindowPeek)NUL){		if(!IsValidObj((DiffractObject*)aWindow->refCon)){			aWindow = aWindow->nextWindow;			if(aWindow == 0L)return;		}		theObj	=	(DiffractObject*)aWindow->refCon;				if(theObj == 0L)return;		if(theObj->linking == 2){			if(!theObj->SameObject(gDefault)){				gDefault->CopyObjTo(theObj,false);				theObj->DoCalculate();				SetPort((WindowPtr)aWindow);				theObj->SetPict(true);				theObj->D_DrawPict();//change				//theObj->FastPictDraw();				theObj->refreshFlag = true;				theObj->DoRefresh();				SetPort(oldPort);			}		}		aWindow = aWindow->nextWindow;		if(aWindow == 0L)return;	}	}Boolean DiffractObject::GetFoilPtrs(Boolean *thePtr1,short *thePtr2,short *thePtr3){	*thePtr1 = 0;	*thePtr2 = 0;	*thePtr3 = 0;	return false;}void DiffractObject::SetFoilPtrs(Boolean thePtr1,short thePtr2,short thePtr3){	thePtr1 = 0;	thePtr2 = 0;	thePtr3 = 0;}#pragma segment Mainvoid DiffractObject::SetORToNewBase(short newCrystal){	double x,y,z;	if(baseCrystal != newCrystal){		double matrix[3][3];		baseCrystal = newCrystal;		changedFlag = true;		setCrystal = theCrystal[baseCrystal];		theZoneAxis->theCrystal = theCrystal[baseCrystal];		theRotationAxis->theCrystal = theCrystal[baseCrystal];		g_Vector->theCrystal = theCrystal[baseCrystal];		IrrationalZoneAxis(theZoneAxis,theRotationAxis,g_Vector,rotationAngle,offLaueDistance,totalRot,beamAzimuth,calcIrrational,&x,&y,&z,matrix);		SetOrientation(matrix);	}}#pragma segment MainBoolean DiffractObject::DoDefineOR(DialogPtr theDialog,Boolean defineFlag,short dlogOffset){	short i,j;	double x,y,z;	Boolean flag = false;	i = 0;	j = 0;	 while(i <= 3 && !GetBoolean(theDialog,i + dlogOffset)){ i++; j = i;flag = true;}	if(j != baseCrystal && i < 4){		changedFlag = true;		SetORToNewBase(j);	}	if(i == 4)baseCrystal = 0;	if(defineFlag)changedFlag = DefineOrientation(true,&x,&y,&z);		return changedFlag;}