//cts:D.M. v2.0:Sources.Jim:Desktop.2.0:Diffract 2:DI2_DiffractObject.c#include	"Diffract_INCs.h"#include	"Dir_Paths.h"#include	"UT_VectorMacros.c"short DiffractObject::SetFileType(void){	short 		picType;	DialogPtr 	theDialog;	short 		theSelect;	PopUpMenu  *fileTypeMenu;	Boolean		quit = false;	long		theResult;			theDialog	= DM_GetNewDialog(109,NUL,IN_FRONT);	fileTypeMenu 	= 	(PopUpMenu*)D_new(PopUpMenu);	picType = 1;	fileTypeMenu	->	Init(theDialog,4,35,picType);		while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case -1:			case 2:				quit = true;				break;			case 1:				picType = fileTypeMenu->lastResult;				quit = true;				break;			case 4:				theResult = fileTypeMenu->DoPopUp();				break;			case ML_UPDATE_EVT:						BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			default:				break;		}	}	fileTypeMenu	->DoClose();	DM_DisposDialog(&theDialog);		return picType;}Boolean	DiffractObject::StageControl(void){	if(!stage		->				SetStageDialogBox(/*projLengthScreen,centerX,centerY*/))return false;		return true;}void	DiffractObject::RotateSpots(double matrix[3][3]){	TransformAxes(matrix);}void	DiffractObject::CalculateScreenThetas(double *x,double *y,double *z,Point thePoint){	double temp,length,x1,y1;	onScreen = true;	LocalToObj(&thePoint);	y1 = thePoint.h - centerX;	x1 = thePoint.v - centerY;	length = sqrt(x1 * x1 + y1 * y1);	if(length < .01){			*x = 0;			*y = 0;			*z = 1;			return;	}	temp = 2.0 * atan2(length,projLengthScreen);	*z = cos(temp);	temp = sin(temp) / length;	x1 *= temp;	y1 *= temp;	*x = x1;	*y = y1;	}void  DiffractObject::TransformAxes(double matrix[3][3]){	TransFormVectorFl(&x_001.x,&x_001.y,&x_001.z,matrix);	TransFormVectorFl(&y_001.x,&y_001.y,&y_001.z,matrix);	TransFormVectorFl(&z_001.x,&z_001.y,&z_001.z,matrix);}double DiffractObject::CalculateW_OffBragg(Index *zone,Index *rotAxis,Index *a_Vector,double x,double y,double z,short method,double *sZ,double *sL){	double electronMassRation,extDist;	double	x1,y1,z1;	double  matrix[3][3],xForm[3][3];	double	w_Off_Bragg;	double	rWave,d;		IrrationalZoneAxis(zone,rotAxis,a_Vector,x,y,z,0,method,&x1,&y1,&z1,matrix);/*Get The Current Orientation*/		zone->theCrystal->Get001XForm(xForm);/*Get The Transformation Matrix For hkl to xyz */	MatrixMultiply			(xForm,matrix,xForm); //multiply these two	ConverttoReciprocal		(xForm,(double)zone->theCrystal->volume,true);// convert to the reciprocal lattice matrix	x1 = a_Vector->h;	y1 = a_Vector->k;	z1 = a_Vector->l;	TransFormVector(&x1,&y1,&z1,xForm);//convert the hkl to xyz	d = x1 * x1 + y1 * y1;	rWave = 1/wavelength;	*sL = sqrt(d + (rWave - z1) * (rWave - z1)) - rWave; //should be exact although depending on implementation of theory might be wrong to use	// determine distance from Ewald Sphere for xy projection	// by convention s is given parallel to beam from end of g to ewald sphere, this is slightly wrong	*sZ = rWave - sqrt((rWave * rWave) - d) - z1;		electronMassRation 	= 	1. + ( (double)energy / 511.);		extDist 			= 	a_Vector->TheExtinctionDist(1./ wavelength,electronMassRation,theBeamFlag);	w_Off_Bragg = *sZ;	return w_Off_Bragg * extDist;}double DiffractObject::AngleBetFoilAndBeam(Index *theIndex,Index *aIndex,Index *bIndex,double x,double y,double z,short method){	double xForm[3][3],matrix[3][3],xFormMatrix[3][3];	double	x1,y1,z1;	double	value;	//if(foilParallel) return 0;	GetOrientation(xFormMatrix);	GetPPTXFormMatrixBase(xForm,theCrystal[baseCrystal],0);	MatrixMultiply(xForm,xFormMatrix,xFormMatrix); 	IrrationalZoneAxis(theIndex,aIndex,bIndex,x,y,0,0,method,&x1,&y1,&z1,matrix);	MatrixMultiply(xForm,matrix,matrix); //	NormalizeMatrixRows(xForm);	x1 = x = 0;	y1 = y = 0;	z1 = z = 1;	InvertMatrix(matrix);	InvertMatrix(xFormMatrix);	TRANSFORM_VECTOR	(x,y,z,matrix);		TRANSFORM_VECTOR	(x1,y1,z1,xFormMatrix);		NormalizeVector(&x,&y,&z);	NormalizeVector(&x1,&y1,&z1);	value	= DotProductXYZ( x, y, z, x1, y1, z1);	if(fabs(value) > 1)value = 1;	value = acos(value);	return  value;}void DiffractObject::PlotMovedPeriod(short hh,short vv){		Rect aOval;	short theSize;	double cameraLength;	double	xFormMatrix[3][3],xForm[3][3];	double	x,y,z,length;	short	h,v,j,l;	double u,vd,w;	Crystal	*thisCrystal;	Index	*theIndex;	Point thePoint;	cameraLength 	= 	cameraConstant/wavelength;	hh =hh;	vv = vv;	GetOrientation(xFormMatrix);	thisCrystal = theCrystal[baseCrystal];	GetPPTXFormMatrixBase		(xForm,thisCrystal,0);	MatrixMultiply			(xForm,xFormMatrix,xForm);	theIndex	=	(Index*)D_new(Index);	theZoneAxis->DoCopy(theIndex);	u 	= theIndex->h;	vd 	= theIndex->k;	w 	= theIndex->l;	while(u > 3 || vd > 3 || w > 3)	{		u 	/= 1.333333;		vd 	/= 1.333333;		w 	/= 1.333333;	}	theIndex->h = Round(u);	theIndex->k = Round(vd);	theIndex->l = Round(w);	theIndex->GetXYZ(xForm);	x = theIndex->x;	y = theIndex->y;	z = theIndex->z;	length = sqrt(x * x + y * y + z * z);	x /= length;	y /= length;	ScreenRes(&j,&l);	x *= l * cameraLength / 25.4;	y *=  j * cameraLength / 25.4;	h = Round(y) + centerX;	v = Round(x)  + centerY;	if(h != centerX ||  v != centerY){		x = centerX - h;		y = centerY - v;		theSize = Round(sqrt(x * x + y * y));		SetRect(&aOval,-theSize,-theSize,theSize,theSize);		OffsetRect(&aOval,(short)h,(short)v);		dm_FrameOval(&aOval);		MoveTo(h,v);		thePoint.h = h;		thePoint.v = v;		//theIndex->ReduceIndex();		//theIndex->DrawIndex(thePoint);	}	theIndex->DoClose();}void  DiffractObject::ConvertToTextTable(void){	}void  DiffractObject::GetMuLambda(Point thePoint,double *mu,double *lambda,Boolean switchAxis){	double x,y,z;	double length;	double temp;	if(switchAxis){		x = thePoint.h - centerX;		y = thePoint.v - centerY;	}else{		y = thePoint.h - centerX;		x = thePoint.v - centerY;	}	length = sqrt(x * x + y * y);	if(length == 0){		*mu 			= 0;		*lambda 	= 0;		return;	}	temp = 2.0 * atan2(length,projLengthScreen);	z = cos(temp);	temp = sin(temp) / length;	x *= temp;	y *= temp;		NormalizeVector(&x,&y,&z);	*mu 		= asin(x);	*lambda 	= asin(y / cos(*mu));	*mu 		*= (180. / PI);	*lambda 	*= (180. / PI);}void 	DiffractObject::SetDrawEnviron(void) {	GetPenState(&oldPenState);		PenPat(&qd.black);	if(g_Monitor && !printing){		DMForeColor(COMPLEMENT_COLOR);		DMBackColor(BACKGROUND_COLOR);	} else {		PenPat(&qd.black);	}	PenMode		(gMode);} Boolean DiffractObject::FindSpot(Point thePoint) { 	thePoint = thePoint; 	return false; }void DiffractObject::ClearDrawEnviron(void){	SetPenState(&oldPenState);		PenNormal();	ShowCursor();	TextFont(0); /* courier */	TextSize(12);}#pragma segment Mainvoid DiffractObject::SetWindowColors(short thePalletteNum){	PaletteHandle	thisPalette;	PaletteHandle	dumbPalette;		RGBColor		compColor;		if(theWindow == 0L)return;				if(thePalletteNum == 0){			thePalette = GetPalette(theWindow);			SetEntryColor(thePalette,10,&(theCrystal[0]->crystalColor));			SetEntryColor(thePalette,11,&(theCrystal[1]->crystalColor));			SetEntryColor(thePalette,12,&(theCrystal[2]->crystalColor));			SetEntryColor(thePalette,13,&(theCrystal[3]->crystalColor));			SetEntryColor(thePalette,14,&backgroundColor);			SetEntryColor(thePalette,15,&compColor);			ActivatePalette(theWindow);			return;		}		dumbPalette 	= GetNewPalette(thePalletteNum);		if(!dumbPalette)return;		if(thePalette){			DetachResource((Handle)thePalette);			DisposePalette(thePalette);					}		thePalette = dumbPalette;		thisPalette = GetPalette(theWindow);		if(thePalette != (PaletteHandle)NUL){			compColor = backgroundColor;			InvertColor(&compColor);											SetEntryColor(thePalette,10,&(theCrystal[0]->crystalColor));			SetEntryColor(thePalette,11,&(theCrystal[1]->crystalColor));			SetEntryColor(thePalette,12,&(theCrystal[2]->crystalColor));			SetEntryColor(thePalette,13,&(theCrystal[3]->crystalColor));			SetEntryColor(thePalette,14,&backgroundColor);			SetEntryColor(thePalette,15,&compColor);			CopyPalette(thePalette, thisPalette,0, 0, 254);			ActivatePalette(theWindow);		}		}void DialogSetTransferMode(void);short  DiffractObject::SetPictMode(short theItem)//bloch{	short i;	for(i = 1;i < 7;i++)	{		CheckItem(g_Hier_Pict_Mode,i,false);	}	CheckItem(g_Hier_Pict_Mode,theItem,true);		switch(theItem)	{		case 1:			pictTransferMode = 2; 			if(picObjList)picObjList->ConvertPictToNewTransferMode();			toggleDraw = true;			gMode = 47;			forceOverlay = false;			break;			case 2:			pictTransferMode = 14; 			if(picObjList)picObjList->ConvertPictToNewTransferMode();			toggleDraw = true;			gMode = 8;			forceOverlay = false;			break;			case 3:			pictTransferMode = 14; 			if(picObjList)picObjList->ConvertPictToNewTransferMode();			toggleDraw = true;			gMode = 10;			forceOverlay = false;			break;			case 5:			pictTransferMode = 0; 			forceOverlay = true;			if(picObjList)picObjList->ConvertPictToNewTransferMode();			toggleDraw = false;			if(gMyOffG){				DisposeGWorld(gMyOffG);				gMyOffG = 0L;				newPictReq = true;			}			gMode = 0;		 break;		 case 6:		 	if(this->theRuler != NUL && this->rulerHeight > 0){ 				functionID = TRANSFER_MODE_F;			};			break;		 case 7:		 	 DialogSetTransferMode();		 break;	}	SetTransferModeText();	if(this->theRuler != NUL && this->rulerHeight > 0){ 		RectRgn(drawRgn,&thePictRect);		newPictReq = true;			dm_EraseRect(&thePictRect);	//bloch		InvalRect(&thePictRect);		}	return 0;}void  DiffractObject::CheckMode(void)//bloch{	short i;	for(i = 1;i < 8;i++)	{		CheckItem(g_Hier_Pict_Mode,i,false);	}		if(pictTransferMode == 2 && toggleDraw == true		&& gMode == 47 && forceOverlay == false){			CheckItem(g_Hier_Pict_Mode,1,true);			return;	}	if(pictTransferMode == 14 && toggleDraw == true		&& gMode == 8 && forceOverlay == false){			CheckItem(g_Hier_Pict_Mode,2,true);			return;	}	if(pictTransferMode == 14 && toggleDraw == true		&& gMode == 10 && forceOverlay == false){			CheckItem(g_Hier_Pict_Mode,3,true);			return;	}	if(pictTransferMode == 0 && toggleDraw == false		&& gMode == 0 && forceOverlay == true){			CheckItem(g_Hier_Pict_Mode,5,true);			return;	}		CheckItem(g_Hier_Pict_Mode,6,true);			return;}#pragma segment Mainvoid DiffractObject::UpdateOR(short theChar){		short n,i;		double degree;	Boolean flag = false;	if(!theWindow)return;	switch(functionID)	{		default:			if(theChar == 28){ n = 0; i = 1;flag = true;}			if(theChar == 29){ n = 0; i = -1;flag = true;}			if(theChar == 30){ n = 1; i = 1;flag = true;}			if(theChar == 31){ n = 1; i = -1;flag = true;}		break;				case ROTATE_AROUND_X:			if(theChar == 28){ n = 1; i = 1;flag = true;}			if(theChar == 29){ n = 1; i = -1;flag = true;}			if(theChar == 30){ n = 0; i = 1;flag = true;}			if(theChar == 31){ n = 0; i = -1;flag = true;}		break;		case ROTATE_AROUND_Y:			if(theChar == 28){ n = 0; i = 1;flag = true;}			if(theChar == 29){ n = 0; i = -1;flag = true;}			if(theChar == 30){ n = 2; i = 1;flag = true;}			if(theChar == 31){ n = 2; i = -1;flag = true;}		break;		case ROTATE_AROUND:			if(theChar == 28){ n = 2; i = 1;flag = true;}			if(theChar == 29){ n = 2; i = -1;flag = true;}			if(theChar == 30){ n = 1; i = 1;flag = true;}			if(theChar == 31){ n = 1; i = -1;flag = true;}		break;			}	if(!flag) return;		degree = (i * delAngle * PI / 180.0);	if(IsPressed(56)) degree *= 5;	if(IsPressed(58) && !IsPressed(56)) degree /= 5;	DoARotation(degree,n);	SetPict(false);	D_DrawPict();	newPictReq = false;	refreshFlag = true;	DoRefresh();	ListOrientation();	if(linking == 2)CopyObjTo(gDefault,false);	if(linking == 2)DynamicLinking();}void DiffractObject::DoARotation(double angle,short axis){	angle = angle;	axis = axis;}void DiffractObject::ListOrientation(void){	Index				*theIndex,*newIndex;	char				theText[256];	double			theXForm[3][3];	if(!theRuler)return;	theIndex = (Index*)D_new(Index);	newIndex = (Index*)D_new(Index);	theIndex->DoInit(true,theCrystal[baseCrystal]);	newIndex->DoInit(false,theCrystal[baseCrystal]);			GetOrientation(theXForm);		theIndex->x = 0;	theIndex->y = 0;	theIndex->z = 1;	newIndex->x = 0;	newIndex->y = 0;	newIndex->z = 1;			InvertMatrix(theXForm);/*Takes the 001 and rotates to true direction*/	theIndex->GetTheUVWFromXYZ(theXForm);	theIndex->ConvertXYZToHKLReduce();	if(theIndex->direction == false) theIndex->reduceFlag = false;	theRuler->SetPrompt("Your new orientation is:");	sprintf(gTheText,"arrow keys rotate by %5.2f¡,with option key by %5.2f¡ with shift key by %5.2f",delAngle,delAngle/5,delAngle * 5);	theRuler->SetHelp(gTheText);	newIndex->GetTheUVWFromXYZ(theXForm);	newIndex->ConvertXYZToHKLReduce();	if(newIndex->direction == false) newIndex->reduceFlag = false;	gTheText[0] = 0;	newIndex	->	IndexToIndecies(gTheText);	p2cstr			(pTheText);	sprintf			(theText," & Direction:");	strcat			(gTheText,theText);	theIndex	->	IndexToIndecies(theText);	p2cstr			((unsigned char*)theText);	strcat			(gTheText,theText);	theRuler	->	SetInfo(gTheText); 	gTheText[0] = 	0;	//flag 		= 	true;	//lastPoint 	= 	thePoint;	theIndex->DoClose();	newIndex->DoClose();	InvertMatrix(theXForm);/*Takes the 001 and rotates to true direction*/}#include "Folders.h"Boolean UpdatePrefResource(AddResourceType resources);Boolean DiffractObject::GetPreferenceFolder(FSSpec *theFSSpec){	OSErr iErr;	iErr = FindFolder(kOnSystemDisk,kPreferencesFolderType,kDontCreateFolder,&theFSSpec->vRefNum,&theFSSpec->parID);	theFSSpec->name[0] = 0;		if(iErr) return false;	return true;}void DiffractObject::GetPreferenceFile(void){	short total = 0,j;	Boolean flag = true;		AddResourceType resources[300];	UseResFile(g_AppResFile);			if(!GetPreferenceFolder(&gTheFile->theFileInfo.sfFile))return;	if(!OpenPreferenceFile(gTheFile->theFileInfo.sfFile)){		SetPreferenceFile(0,0,'    ',0L);		return;	}	objectType = 	gTheFile->ReadShort();	DoFileRead(); 	while(total < 300 && flag)	{		flag = ReadHandleFromPrefFile(&resources[total]);		total++;	}	gTheFile->DoFileClose();	j = 0;	flag = true;	while(j < total && flag)	{		flag = UpdatePrefResource(resources[j]);		j++;	}	UpdateResFile(g_AppResFile);}#include	<Aliases.h>Boolean DiffractObject::ReadHandleFromPrefFile(AddResourceType *resources){			resources->resNum = gTheFile->ReadShort();		if(!resources->resNum)return false;		resources->theRes = gTheFile->ReadResType();		resources->name = (char*)gTheFile->ReadPtr(0L);		resources->theHandle = D_NewHandle(sizeof(char) * 10);		gTheFile->ReadHandle(resources->theHandle);		return true;	}void DiffractObject::SetPreferenceObject(DiffractObject *newStuff){	AddResourceType resources[300];	short total = 0;	short	j = 0;	Boolean flag = true;	UseResFile(g_AppResFile);			if(!GetPreferenceFolder(&gTheFile->theFileInfo.sfFile))return;	if(OpenPreferenceFile(gTheFile->theFileInfo.sfFile)){		objectType = 	gTheFile->ReadShort();		DoFileRead();		while(total < 300 && flag)		{			flag = ReadHandleFromPrefFile(&resources[total]);			if(flag)total++;		}		gTheFile->fileError = SetFPos(gTheFile->pathRefNum,1,0);	}else{		SetPreferenceFile(0,0,'    ',0L);		SetPreferenceObject(newStuff);		return;	}	newStuff->DoFileWrite(); 	while(j < total && resources[j].resNum){			gTheFile->WriteShort(resources[j].resNum); 		gTheFile->WriteResType(resources[j].theRes);		gTheFile->WriteTextPtr(resources[j].name);		gTheFile->WriteHandle(resources[j].theHandle);		KillPtr(resources[j].name);		KillHandle((Handle*)(&resources[j].theHandle));		j++;	}	gTheFile->WriteShort(0);  //termination signal for the resource files.		gTheFile->DoFileClose();}void DiffractObject::SetPreferenceFile(Handle theHandle,short resNum,ResType theType,char* name){	FSSpec theFileSpecs;	AddResourceType resources[300];	OSErr  err;	short p;	short total = 0;	short	j,k;	AliasHandle aHandle;	Boolean flag = true;	Boolean changed;			UseResFile(g_AppResFile);			if(!GetPreferenceFolder(&gTheFile->theFileInfo.sfFile))return;	if(OpenPreferenceFile(gTheFile->theFileInfo.sfFile)){		objectType = 	gTheFile->ReadShort();		objectType = 0;		DoFileRead();		while(total < 300 && flag)		{			flag = ReadHandleFromPrefFile(&resources[total]);			if(flag)total++;		}		gTheFile->fileError = SetFPos(gTheFile->pathRefNum,1,0);	}else{		if(!gTheFile->CreatePref())return;	}	DoFileWrite(); 	j = 0;	p = 0;	while(j < total && resources[j].resNum){			if(resources[j].resNum != resNum){			if(resources[j].theRes == 'DATA' && resources[j].resNum >= ALIAS_BASE && resources[j].resNum < ALIAS_BASE + NUM_FSS_RECS)p++;			gTheFile->WriteShort(resources[j].resNum); 			gTheFile->WriteResType(resources[j].theRes);			gTheFile->WriteTextPtr(resources[j].name);			gTheFile->WriteHandle(resources[j].theHandle);					}else{			if(theType == 'DATA' && resNum >= ALIAS_BASE && resNum < ALIAS_BASE + NUM_FSS_RECS)p++;						gTheFile->WriteShort(resNum); 		  gTheFile->WriteResType(theType);		  		  p2cstr((unsigned char*)name);		  gTheFile->WriteTextPtr((char*)name);		  		  gTheFile->WriteHandle(theHandle);		  		  resources[j].resNum = resNum;		  resources[j].theRes = theType;		  strcpy(resources[j].name,name);//already defined therefore just copy into it		  c2pstr(name);		  KillHandle((Handle*)&(resources[j].theHandle));		  resources[j].theHandle = theHandle; 		  D_HandToHand((Handle*)&(resources[j].theHandle));  //makes a copy since the passed Handle is to be destroyed outside		 //do n resources[j].resNum ot kill the handle and the name since thats to be handled outside the subroutine		  resNum = 0;		}		j++;	}	if(p < NUM_FSS_RECS){//Adds dir paths if there were non-defined		for( k = ALIAS_BASE + p; k < ALIAS_BASE + NUM_FSS_RECS;k++)		{								theFileSpecs.vRefNum 	= 0;				theFileSpecs.parID		= NUL;				theFileSpecs.name[0]		= (char)0;								err = NewAlias(NUL,&theFileSpecs,&aHandle);				err = ResolveAlias(NULL,aHandle,&theFileSpecs,&changed);												gTheFile->WriteShort(k); 				resources[j].theRes = 'DATA';			  gTheFile->WriteResType(resources[j].theRes);			  			  resources[j].name = (char*)D_NewPtr(sizeof(char) * 255);				sprintf((char*)resources[j].name,"Search Path Alias");			  gTheFile->WriteTextPtr(resources[j].name);			  resources[j].theHandle = (Handle)aHandle; 		  	D_HandToHand((Handle*)&(resources[j].theHandle));			  gTheFile->WriteHandle(resources[j].theHandle);			  resources[j].resNum = k;		  			  	DisposHandle((Handle)aHandle);		  	j++;		}	}	if(resNum){		gTheFile->WriteShort(resNum); 		gTheFile->WriteResType(theType);				resources[j].name = (char*)D_NewPtr(sizeof(char) * 255);		p2cstr((unsigned char*)name);		strcpy(resources[j].name,(char*)name);//make a new copy		gTheFile->WriteTextPtr(resources[j].name);				gTheFile->WriteHandle(theHandle);		resources[j].resNum = resNum;		resources[j].theRes = theType;		resources[j].theHandle = theHandle;		D_HandToHand((Handle*)&(resources[j].theHandle));//make a new copy		j++;	}	gTheFile->WriteShort(0);  //termination signal for the resource files.		gTheFile->DoFileClose();	k = 0;	flag = true;	while(k < j && flag)	{		flag = UpdatePrefResource(resources[k]);		k++;	}	}Boolean DiffractObject::OpenPreferenceFile(FSSpec	theFSSpec){ 																	/*EnumerateCatalog */    HFileInfo		myCPB; 	unsigned char	fName[255];	short			index=1;									/* for ioFDirIndex */	OSErr			err;               							/* the usual */	FInfo			aFilesInfo;  Boolean  flag;  	myCPB.ioNamePtr = fName;        do    {			myCPB.ioFDirIndex 	= index;         										myCPB.ioDirID 		= theFSSpec.parID;  										myCPB.ioVRefNum 	= theFSSpec.vRefNum;     										err 				= PBGetCatInfo((CInfoPBPtr)&myCPB,false);						if (err == noErr){        	if (((myCPB.ioFlAttrib>>4) & 0x01) == 1)       	{	       		long oldID;       		oldID = theFSSpec.parID;         	theFSSpec.parID = myCPB.ioDirID;         	flag = OpenPreferenceFile(theFSSpec);	         	if(err || flag){ /* JTS 4/93 */							return flag;						}						theFSSpec.parID = oldID;					} else { 					BlockMove((Ptr)&(myCPB.ioFlFndrInfo),(Ptr)&aFilesInfo,sizeof(FInfo));					if(aFilesInfo.fdType ==  'pref' && aFilesInfo.fdCreator == OWNER){	          gTheFile->fileError = HOpen(myCPB.ioVRefNum,theFSSpec.parID,(unsigned char*)fName,(SignedByte)fsRdWrPerm,&gTheFile->pathRefNum);												if(gTheFile->fileError != 0){							gTheFile->DoFileError();							return false;						}							          gTheFile->file_is_Open = true;	         return true;					}				}	     	    	index += 1;     											/* increment the index for GetCatInfo */	     															/* if (err == noErr) */    	}    } while (err == noErr);    return false;}Boolean UpdatePrefResource(AddResourceType resources){	Handle testH;	short		iErr;	if(!resources.resNum)return false;	UseResFile(g_AppResFile);		testH 	= GetResource(resources.theRes,resources.resNum);	if(testH){//if there is already a corresponding resouce, we need to remove it, release the handle	//and add the new one.			RmveResource((Handle)testH);			DisposHandle(testH);	}	//	if(resources.theRes == 'DATA' && resources.resNum >= ALIAS_BASE && resources.resNum < ALIAS_BASE + NUM_FSS_RECS)	//if the resource is of type data, then it is an alias,  this attempts to check the alias///and correct it if it is incorrect, or al\t least set it to a non-threatening alias.//	{//		theFileSpecs.vRefNum 	= 0;//		theFileSpecs.parID		= NUL;//		theFileSpecs.name[0]		= (char)0;//		err = ResolveAlias(NUL,(AliasHandle)resources.theHandle,&theFileSpecs,&changed);//		if(err != noErr){//			theFileSpecs.vRefNum 	= 0;//			theFileSpecs.parID		= NUL;//			theFileSpecs.name[0]		= (char)0;//			KillHandle((Handle*)&resources.theHandle);//			err = NewAlias(NUL,&theFileSpecs,(AliasHandle*)&(resources.theHandle));//	}//	}		c2pstr(resources.name);	AddResource((Handle)resources.theHandle,resources.theRes,resources.resNum,(unsigned char*)resources.name);	p2cstr((unsigned char*)resources.name);	iErr = ResError();	if(iErr){		AlertUser(7);	}		ChangedResource((Handle)resources.theHandle);	WriteResource((Handle)resources.theHandle);	iErr = ResError();	if(iErr){		AlertUser(7);	}		DetachResource(resources.theHandle);	KillHandle((Handle*)&resources.theHandle);	KillPtr((Ptr)resources.name);		return true;}/* QuickDraw Constants of Possible Importance:enum {    invalColReq = -1,                   invalid color table request transfer modes     srcCopy = 0,                        the 16 transfer modes    srcOr = 1,    srcXor = 2,    srcBic = 3,    notSrcCopy = 4,    notSrcOr = 5,    notSrcXor = 6,    notSrcBic = 7,    patCopy = 8,    patOr = 9,    patXor = 10,    patBic = 11,    notPatCopy = 12,    notPatOr = 13,    notPatXor = 14,    notPatBic = 15, Special Text Transfer Mode         Arithmetic transfer modes    };enum {		blend = 32,    addPin = 33    addOver = 34,    subPin = 35,    transparent = 36,    addMax = 37,    adMax = 37,    subOver = 38,    adMin = 39,    grayishTextOr = 49,    ditherCopy = 64, Transparent mode constant         normalBit = 0,                      normal screen mapping    inverseBit = 1,                     inverse screen mapping    redBit = 4,                         RGB additive mapping    greenBit = 3,    blueBit = 2,    cyanBit = 8,                        CMYBk subtractive mapping    magentaBit = 7,    yellowBit = 6,    blackBit = 5,    blackColor = 33,                    colors expressed in these mappings    whiteColor = 30,    redColor = 205};*/void DialogSetTransferMode(void){	short 			item;	//pascal Boolean 	TheFilter();	DialogPtr 		theDialog;	GrafPtr				thePort;	short					oldGMode,oldPictT;	Boolean				oldTog,oldOver;	PopUpMenu			*theMenu,*theMenu2;		GetPort(&thePort);	theDialog 		= 		DM_GetNewDialog(366, 0L,(WindowPtr)-1L);	oldTog = gCurrentObj->toggleDraw;	oldOver = gCurrentObj->forceOverlay;	oldGMode = gCurrentObj->gMode;	oldPictT = gCurrentObj->pictTransferMode;		theMenu 	= (PopUpMenu*)D_new(PopUpMenu);	theMenu	->	Init(theDialog,8,41,1);	theMenu	->	SetPopUp();		theMenu2 	= (PopUpMenu*)D_new(PopUpMenu);	theMenu2	->	Init(theDialog,9,41,1);	theMenu2	->	SetPopUp();		SetItemValue(theDialog,3,gCurrentObj->gMode,0);	SetItemValue(theDialog,4,gCurrentObj->pictTransferMode,0);	SwitchBoolean(theDialog,5,!gCurrentObj->toggleDraw);	SwitchBoolean(theDialog,6,!gCurrentObj->forceOverlay);		while(1 != 2){		SystemTask();		ModalDialog(TheFilterUPP,&item);		switch(item){			case DLOG_ENTER_OR_CR:			case 	1:			gCurrentObj->gMode = GetItemValue(theDialog,3);			gCurrentObj->pictTransferMode = GetItemValue(theDialog,4);			theMenu2	->DoClose();			theMenu	->DoClose();			DM_DisposDialog(&theDialog);			return;			case 2:			case CANCELCLICK: 				gCurrentObj->toggleDraw 				= oldTog;				gCurrentObj->forceOverlay 			= oldOver;				gCurrentObj->gMode 						= oldGMode;				gCurrentObj->pictTransferMode 	= oldPictT;				theMenu2	->DoClose();				theMenu	->DoClose();				DM_DisposDialog(&theDialog);				return ;			case 3:			case 4:			break;			case 5:			gCurrentObj->toggleDraw =	SwitchBoolean(theDialog,5,gCurrentObj->toggleDraw);			break;			case 6:			gCurrentObj->forceOverlay =	SwitchBoolean(theDialog,6,gCurrentObj->forceOverlay);			break;			case 7:				gCurrentObj->newPictReq = true;				gCurrentObj->gMode 							= GetItemValue(theDialog,3);				gCurrentObj->pictTransferMode 	= GetItemValue(theDialog,4);				SetPort(thePort);				gCurrentObj->DoIdle();				SetPort(theDialog);				break;			case 8:					theMenu->DoPopUp();					theMenu	->	SetPopUp();					if(theMenu->lastResult <= 16){gCurrentObj->gMode = theMenu->lastResult - 1;SetItemValue(theDialog,3,gCurrentObj->gMode,0);break;}					if(theMenu->lastResult <= 24){gCurrentObj->gMode = theMenu->lastResult + 15;SetItemValue(theDialog,3,gCurrentObj->gMode,0);break;}					if(theMenu->lastResult == 25){gCurrentObj->gMode = 49;SetItemValue(theDialog,3,gCurrentObj->gMode,0);break;}					if(theMenu->lastResult == 26){gCurrentObj->gMode = 64;SetItemValue(theDialog,3,gCurrentObj->gMode,0);break;}								break;				case 9:					theMenu2->DoPopUp();					theMenu2	->	SetPopUp();					if(theMenu2->lastResult <= 16){gCurrentObj->pictTransferMode = theMenu2->lastResult - 1;SetItemValue(theDialog,4,gCurrentObj->pictTransferMode,0);break;}					if(theMenu2->lastResult <= 24){gCurrentObj->pictTransferMode = theMenu2->lastResult + 15;SetItemValue(theDialog,4,gCurrentObj->pictTransferMode,0);break;}					if(theMenu2->lastResult == 25){gCurrentObj->pictTransferMode = 49;SetItemValue(theDialog,4,gCurrentObj->pictTransferMode,0);break;}					if(theMenu2->lastResult == 26){gCurrentObj->pictTransferMode = 64;SetItemValue(theDialog,4,gCurrentObj->pictTransferMode,0);break;}			break;					default:				break;			case ML_UPDATE_EVT:				BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			}	}}