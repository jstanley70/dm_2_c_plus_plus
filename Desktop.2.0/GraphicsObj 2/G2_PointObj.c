//ces.Jim:Desktop.2.0:GraphicsObj 2:G2_PointObj.c#include	"Diffract_INCs.h"#include	"PointObj.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"PointObj.h"#include	"MicrographObj.h"void			EraseOvalFrame(Rect*	theRect);short	PointObj::PtInObject(Point thePoint){	RgnHandle theRgn;	Rect theRect;	theRect 	= viewRect;	gCurrentObj->ObjRectToLocal(&theRect);	if(PtInRect(thePoint,&theRect))	{		return 1;	}	theRect 	= ptRect;	gCurrentObj->ObjRectToLocal(&theRect);	theRgn = D_NewRgn();	OpenRgn();		dm_FrameOval(&theRect);	CloseRgn(theRgn);	if(PtInRgn(thePoint,theRgn))return 2;	return 0;}void PointObj::DoCleanUp(void){	//inherited::DoCleanUp();}void  PointObj::SetXToHKLConvertToXY(SpotInfoPtr theSpots,short data_Count,short theType){	short number,i = 0;	double			matrix[3][3];	Boolean flag = false;	if(TestType(theType,&number) && number/100 == 7){		theCrystal = ((DiffractObject*)gCurrentObj)->setCrystal;		((DiffractObject*)gCurrentObj)->CopyAxesIntoMatrix(matrix);		GetXYZFromHKL(matrix);	}	if(nextText != 0L)((PointObj*)nextText)->SetXToHKLConvertToXY(theSpots,data_Count,theType);			}void  PointObj::SetOrigin(float x1,float y1,float hor1,float ver1){	x -= x1;	y -= y1;	hor -= hor1;	ver -= ver1;	if(nextText != 0L) ((PointObj*)nextText)->SetOrigin(x1,y1,hor1,ver1);	return;}Boolean PointObj::RelocateText(Point delPoint){ //InvalRect(&viewRect); //InvalRect(&ptRect);	objPoint.v 	+= delPoint.v;	objPoint.h 	+= delPoint.h;	hor 		+= delPoint.h;	ver 		+= delPoint.v;	dm_EraseRect(&ptRect);	InvalRect(&ptRect);		OffsetRect(&ptRect,delPoint.h,delPoint.v);	return inherited::RelocateText(delPoint);}void	PointObj::InitText(Point thePoint,void* owner,short theType,Boolean dirFlag,Crystal *aCrystal){	RGBColor 	theColor;	short 		theSize;	GetForeColor(&theColor);	theSize = 	(double)gCurrentObj->scaleFactor * (double)gCurrentObj->theEBeam->convergenceAngle;	objPoint = thePoint;	thePoint.v -= 15;	thePoint.h -= 10;	SetRect(&ptRect,objPoint.h - theSize,objPoint.v - theSize,objPoint.h + theSize,objPoint.v + theSize);	hor = objPoint.h;	ver = objPoint.v;	x	=	0;	y	=	0;	z	=	0;	InvalRect(&ptRect);	inherited::InitText( thePoint,owner, theType, dirFlag,aCrystal);	if(textFlag){		if(type == REG_POINT){			SetStyle(geneva,9,1, 0, theColor);			sprintf(gTheText,(char*)"\p ");			SetChars(gTheText);		}else{			SetStyle(geneva,9,1, 0, theColor);			sprintf(gTheText,(char*)"\p%d,%d",objPoint.h,objPoint.v);			SetChars(gTheText);		}	}	return ;}void PointObj::SetType(short aType){	type = aType;}void	PointObj::CalcXYValues(double scaleFactor,PointObj *centerPt){	double hor1,ver1;	float	*values;		if(nextText != 0L)((PointObj*)nextText)->CalcXYValues(scaleFactor,centerPt);	ver1 =  ver  - centerPt->ver;	hor1 =  hor  - centerPt->hor;	x = scaleFactor * hor1;	y = scaleFactor * ver1;	values = GetValues();	if(values[0] > 0){		double l,R,theta;		l = sqrt(x * x + y * y);		R = 1 / gCurrentObj->wavelength;		theta = acos(l / R);		z = R * (1 - sin(theta));		if(z < .1) z = 0;	}else{		z = 0;	}	KillPtr((Ptr)values);}void PointObj::InsertData(SpotInfoPtr theSpots,PointObj* centerPoint,short theType){	Crystal *crystal;	short 	unitMeasure;	theSpots->x 		= 	y;	theSpots->y 		= 	x;	theSpots->z 		= 	(z);	theSpots->h			=	1;	theSpots->k			=	0;	theSpots->l			=	0;	theSpots->direction	=	false;	theSpots->intensity = 	intensity;	theSpots->flags		=	0L;	crystal 			= 	theSpots->theCrystal;	if(nextText != 0L){		if(TestType(theType,&unitMeasure))			theSpots++;		theSpots->theCrystal = crystal;		((PointObj*)nextText)->InsertData(theSpots,centerPoint,theType);	}	return;}PointObj*	PointObj::CountObjects(short *n,PointObj *centerObj,short theType){	short 	unitMeasure;	if(*n == 1 && centerObj == 0L ){		centerObj = this;	}		if(TestType(theType,&unitMeasure)){		*n += 1;		if(centerObj == 0L) centerObj = this;	}	if(nextText != 0L){		return ((PointObj*)nextText)->CountObjects(n,centerObj,theType);	}	return centerObj;}TextObject* PointObj::Add(Point thePoint,void* owner,short theType){	Rect theRect;	RgnHandle theRgn;	theRect = ptRect;	theRgn 	= D_NewRgn	();	OpenRgn			();	dm_FrameOval		(&theRect);	CloseRgn		(theRgn);	if(PtInRgn(thePoint,theRgn)){		D_DisposeRgn(&theRgn);		return 0L;	}	D_DisposeRgn(&theRgn);	if((*hTE)->teLength == 0 && textFlag){		SetText(thePoint);		return (PointObj*)this;	}	if(nextText != 0L){		return nextText->Add( thePoint,owner, theType);	}		nextText = (TextObject*)D_new(PointObj);	nextText->InitText(thePoint, owner,theType,direction,theCrystal);	return nextText;}void	PointObj::EraseObject(void){	Rect theRect;	theRect 	= ptRect;	gCurrentObj->ObjRectToLocal(&theRect);	OpenRgn();		InsetRect(&ptRect,-1,-1);		dm_FrameOval(&ptRect);	CloseRgn(gTheRgn);	InsetRect(&ptRect,1,1);	EraseRgn(gTheRgn);	InvalRgn	(gTheRgn);		if(textFlag)	inherited::EraseObject();}void	PointObj::SetXYToRecipA(void){	short testType;	double	value;		testType = type/100;	if(testType == 1){		if(fabs(x) > 0.0001)x = 1 / x;		if(fabs(y) > 0.0001)y = 1 / y;	}	if(testType == 2){		if(fabs(x) > 0.0001)x = 1 / (x * 10);		if(fabs(y) > 0.0001)y = 1 / (y * 10);	}		if(testType == 3){		if(fabs(x) > 0.0001)x /= ((DiffractObject*)theOwner)->cameraConstant;		if(fabs(y) > 0.0001)y /= -((DiffractObject*)theOwner)->cameraConstant;		value = y;		y = x;		x = value;	}	if(testType == 4){		if(fabs(x) > 0.0001)x *= 10 / ((DiffractObject*)theOwner)->cameraConstant;		if(fabs(y) > 0.0001)y *= 10 / -((DiffractObject*)theOwner)->cameraConstant;		value = y;		y = x;		x = value;	}	if(testType == 5){		if(fabs(x) > 0.0001)x *= 1000 / ((DiffractObject*)theOwner)->cameraConstant;		if(fabs(y) > 0.0001)y *= 1000 / -((DiffractObject*)theOwner)->cameraConstant;		value = y;		y = x;		x = value;	}	if(testType == 0){		short hRes,vRes;		ScreenRes(&hRes,&vRes);		y /= ((DiffractObject*)theOwner)->scaleFactor;		x /= ((DiffractObject*)theOwner)->scaleFactor;		value = y;		y = x;		x = value;	}	z = 0;	if(nextText != 0L)((PointObj*)nextText)->SetXYToRecipA();}short PointObj::SetMatrixValues(short startValue,short max,short n,		float **a,float **b,Boolean flagX,short theType,PointObj *centerPt){		short L;	short unitMeasure;	if(TestType(theType,&unitMeasure)){		if(n >= startValue){			L = n - startValue + 1;			if(flagX == true){				a[L][1]  	= hor - centerPt->hor ;				a[L][2]  	= ver  - centerPt->ver ;				a[L][3]  	= a[L][2] * a[L][1];				b[L][1] 	= x * gCurrentObj->scaleFactor;			}else{				a[L][1]  	= hor - centerPt->hor   ;				a[L][2]  	= ver - centerPt->ver   ;				a[L][3]  	= a[L][2] * a[L][1];				b[L][1] 	= y * gCurrentObj->scaleFactor;			}		}		n++;	}	if(n <= max && nextText != 0){		return ((PointObj*)nextText)->SetMatrixValues(startValue,max,n,a,b,flagX,theType,centerPt);	}	if(n < max)return -100;	return n;}short PointObj::SetInverseMatrixValues(short startValue,short max,short n,		float **a,float **b,Boolean flagX,short theType,PointObj *centerPt){		short L;	short unitMeasure;	if(TestType(theType,&unitMeasure)){		if(n >= startValue){			L = n - startValue + 1;						if(flagX == true){				a[L][1]  	= x;				a[L][2]  	= y;				a[L][3]  	= a[L][2] * a[L][1];				b[L][1] 	= hor - centerPt->hor ;			}else{				a[L][1]  	= x;				a[L][2]  	= y;				a[L][3]  	= a[L][2] * a[L][1];				b[L][1] 	= ver - centerPt->ver ;			}		}		n++;	}	if(n <= max && nextText != 0){		return ((PointObj*)nextText)->SetInverseMatrixValues(startValue,max,n,a,b,flagX,theType,centerPt);	}	if(n < max)return -100;	return n;}void	PointObj::GetAllValues(PointObj *centerPt){	float *q;	short testType;	if(nextText != 0L){		((PointObj*)nextText)->GetAllValues(centerPt);	}	if(textFlag){				q = GetValues();		testType = type/100;		if(testType == 7){x = 0;y = 0;z = 0;KillPtr(q);return;}		x = q[0];		y = q[1];				if(testType == 0 && centerPt){			x -= centerPt->hor;			y -= centerPt->ver;		}		KillPtr(q);	}}void	 PointObj::FrameText(void){	Rect theRect;	if(objPoint.h == 0 && objPoint.v == 0)return;	LocalizeTextRects();	theRect 	= ptRect;	gCurrentObj->DMForeColor(11);	if(active)	gCurrentObj->ObjRectToLocal(&theRect);	gCurrentObj->StdOvalMarquee(&theRect);	PenNormal();	if(textFlag)		inherited::FrameText();}void PointObj::JustifyObject(void){	short hor,ver;	hor = (viewRect.left + viewRect.right) / 2;	ver = (viewRect.top + viewRect.bottom) / 2;	hor -= objPoint.h;	OffsetRect(&viewRect,-hor,0);	inherited::JustifyObject();}void	PointObj::DoDefine(void){	}void			EraseOvalFrame(Rect*	theRect){	Rect 		thisRect;	RgnHandle	rgnA,rgnB;	rgnA 		= D_NewRgn();	rgnB 		= D_NewRgn();	thisRect	= *theRect;	gCurrentObj->ObjRectToLocal(&thisRect);	InsetRect 		(&thisRect,1,1);	OpenRgn();	dm_FrameOval 		(&thisRect);	CloseRgn(rgnA);	InsetRect 		(&thisRect,-2,-2);	OpenRgn();	dm_FrameOval 		(&thisRect);	CloseRgn(rgnB);	DiffRgn 		(rgnB, rgnA, rgnA);	EraseRgn 		(rgnA);	InvalRgn		(rgnA);	D_DisposeRgn	(&rgnA);	D_DisposeRgn	(&rgnB);}void DrawMagRect(Rect aRect);void	PointObj::DrawText(void){	Rect	theRect;		if(objPoint.h == 0 && objPoint.v == 0)return;	theRect = ptRect;	((DiffractObject*)gCurrentObj)->ObjRectToLocal(&theRect);	if(active){		theRect 	= ptRect;		PenPat(0);		PenMode						(patXor);		GetClip(gTheRgn);		ClipRect(&theRect);		dm_FrameOval(&theRect);		D_SetClip(gTheRgn);		DrawMagRect(theRect);		ClipRect(&theRect);		dm_FrameOval(&theRect);		PenMode						(0);				D_SetClip(gTheRgn);		PenNormal();			}else{		PenMode(gCurrentObj->gMode);		PenNormal();		theRect 	= ptRect;		gCurrentObj->ObjRectToLocal(&theRect);		dm_FrameOval(&theRect);	}	if(textFlag)inherited::DrawText();	}void DrawMagRect(Rect theRect){	PixMapHandle	thePixMap;	Point	*thePts;	Rect	tempRect,aRect;	PicHandle selectPict;	RgnHandle theRgn;	short			hor,ver;	gCurrentObj->DMForeColor(1);	gCurrentObj->DMBackColor(0);	tempRect 	= theRect;	InsetRect(&tempRect,-15,-15);	thePixMap = NewPixMap();	gCurrentObj->ObjRectToLocal(&tempRect);		InsetRect(&tempRect,1,1);	thePts = (Point*)&tempRect;	LocalToGlobal(&(thePts[0]));	LocalToGlobal(&(thePts[1]));	theRgn = D_NewRgn();	GetClip		(theRgn);	aRect = gCurrentObj->theWindow->portRect;	thePts = (Point*)&aRect;	LocalToGlobal(&(thePts[0]));	LocalToGlobal(&(thePts[1]));		RectRgn		(gTheRgn,&aRect);	D_SetClip		(gTheRgn);	PenNormal();	selectPict 		= OpenPicture(&tempRect);			CopyBits(	(BitMap*)(*thePixMap),					(BitMap*)(*(((CGrafPtr)gCurrentObj->theWindow)->portPixMap)),					&tempRect,&tempRect,srcCopy,0L);					ClosePicture();	DisposPixMap(thePixMap);	gCurrentObj->DMBackColor(BACKGROUND_COLOR);	D_SetClip(theRgn);	D_DisposeRgn(&theRgn);	hor = (tempRect.right - tempRect.left) * 3;	ver = (tempRect.bottom - tempRect.top) * 3;	SetRect(&tempRect,5,50,hor + 5,ver + 50);	DrawPicture(selectPict,&tempRect);	FrameRect(&tempRect);	KillPicture(selectPict);}void PointObj::CenterPeaks(void){	if(nextText != 0L)		((PointObj*)nextText)->CenterPeaks();	CenterPeak();}void PointObj::CenterPeak(void){	FindPeakCenter();	}void	PointObj::FindPeakCenter(void){		Point 		thePoint;	double 	*peakIntensity,maxIntensity;	Handle		peakIHdn;		if(objPoint.h == 0 && objPoint.v == 0)return;	thePoint.h = 1 ; thePoint.v = 1;		while(thePoint.h != 0 || thePoint.v != 0){		peakIHdn = FindMaxIntensity(&maxIntensity );		if(Quit() || maxIntensity < .06 || peakIHdn == 0){			if(peakIHdn != 0L)KillHandle((Handle*)&peakIHdn);			return;		}		D_HLock(peakIHdn);		peakIntensity = (double*)*peakIHdn;		InsetPointRect		(1,1);		thePoint 		= AdjustCenter(peakIntensity);		D_HUnlock		(peakIHdn);				KillHandle		((Handle*)&peakIHdn);		RelocateText	(thePoint);			}		InsetPointRect(-1,-1);	peakIHdn = FindMaxIntensity(&maxIntensity );	if(Quit() || maxIntensity < .06 || peakIHdn == 0){		if(peakIHdn != 0L)KillHandle((Handle*)&peakIHdn);		return;	}	peakIntensity = (double*)*peakIHdn;	D_HLock(peakIHdn);	thePoint = AdjustCenter(peakIntensity);		D_HUnlock(peakIHdn);	if(peakIHdn != 0L)KillHandle((Handle*)&peakIHdn);	RelocateText(thePoint);		return;}Handle  PointObj::FindMaxIntensity(double *maxIntensity){	short 		horPix,verPix,n;	RgnHandle	theRgn;	short		j;	Handle		peakIHdn = 0L;	double		*peakIntensity,test;	*maxIntensity = 0;	if(objPoint.h == 0 && objPoint.v == 0)return 0;STARTAGAIN:		horPix = ptRect.left;	verPix = ptRect.top;		PenMode(0);	theRgn = D_NewRgn();	OpenRgn();		dm_FrameOval(&ptRect);	CloseRgn(theRgn);	peakIHdn = gCurrentObj->picObjList->IntensityInsideRect(ptRect,maxIntensity);	*maxIntensity /= 256;	if(peakIHdn == 0L || maxIntensity == 0){		if(peakIHdn != 0L)KillHandle((Handle*)&peakIHdn);		D_DisposeRgn(&theRgn);		return 0L;	}	j = 0;	n = 0;	D_HLock(peakIHdn);	peakIntensity = (double*)*peakIHdn;	test = *maxIntensity * .85;	while(verPix <= ptRect.bottom){		horPix = ptRect.left;		while(horPix <= ptRect.right){			Point thePoint;			thePoint.h = horPix;			thePoint.v = verPix;			if(!PtInRgn(thePoint,theRgn)){				*peakIntensity = 0;			}else{				*peakIntensity /= 256;				if(*peakIntensity <  test){					j++;				}			}			horPix += 1;			peakIntensity++;			n++;		}		verPix += 1;	}	D_DisposeRgn(&theRgn);	D_HUnlock(peakIHdn);	if(j == 0 && *maxIntensity < .05){		KillHandle((Handle*)&peakIHdn);		return 0L;	}	if(j * 4 < n){		InsetPointRect(-2,-2);		KillHandle((Handle*)&peakIHdn);		if(Quit())return 0L;		goto STARTAGAIN;	}	return peakIHdn;}void	PointObj::InsetPointRect(short n,short k){	InsetRect(&ptRect,n,k);	OffsetRect(&viewRect,0,k);	OffsetRect(&destRect,0,k);}void	PointObj::SetPointRectDiameters(short theSize){	if(nextText != 0L){		((PointObj*)nextText)->SetPointRectDiameters(theSize);	}	theSize -= ((ptRect.right - ptRect.left) / 2);	InsetPointRect(-theSize,-theSize);}double PointObj::FindPerimeterIntensity(void){	RGBColor	cPixel;	short 		horPix,verPix;	double		maxIntensity = 0;	double		value;	GrafPtr		thePort;	short		maxSize = 500;	double		oldHor,oldVer,theta,delRad,radius;	if(objPoint.h == 0 && objPoint.v == 0)return 0;	GetPort(&thePort);	SetPort(((DiffractObject*)gCurrentObj)->theWindow);	oldHor = ptRect.right - ptRect.left;	radius = oldHor / 2;	oldHor = horPix = ptRect.right - 1;	oldVer = verPix = (ptRect.top + ptRect.bottom) / 2.;		delRad = asin(.5/radius);	theta = 0;	if(Quit())return 0;	if(radius == 0){		GetCPixel((short)objPoint.h,(short)objPoint.v,&cPixel);	}	while(theta < 2 * PI){		GetCPixel((short)horPix,(short)verPix,&cPixel);		value = (double)cPixel.red + (double)cPixel.green + (double)cPixel.blue;		value /= 196605;		maxIntensity += 1 - value;		while(fabs(oldHor - horPix) < 1 && fabs(oldVer - verPix) < 1){			theta += delRad;			horPix = cos(theta) * radius + objPoint.h;			verPix = sin(theta) * radius + objPoint.v;		}				oldHor = horPix;		oldVer = verPix;	}		SetPort(thePort);	return maxIntensity;}short PointObj::FindPerimeterIntensities(Handle *intensities,Handle *thePoints){	RGBColor	cPixel;	short 		horPix,verPix;	long		theSize;	short		maxPoints;	double		maxIntensity = 0;	double		value;	GrafPtr		thePort;	short		maxSize = 500;	double		oldHor,oldVer,theta,delRad,radius;	Point		*thePoint;	double		*intensity;	short		i;	double 		**intenHandle;	Point		**pointHandle;		if(objPoint.h == 0 && objPoint.v == 0)return 0;	GetPort(&thePort);	SetPort(((DiffractObject*)gCurrentObj)->theWindow);	oldHor = ptRect.right - ptRect.left;	radius = oldHor / 2;	oldHor = horPix = ptRect.right - 1;	oldVer = verPix = (ptRect.top + ptRect.bottom) / 2.;		delRad = asin(.05/radius);	theta = 0;	if(Quit())return 0;	if(radius == 0){		GetCPixel((short)objPoint.h,(short)objPoint.v,&cPixel);		return (double)cPixel.red + (double)cPixel.green + (double)cPixel.blue;	}	maxPoints 		= 	2 * PI * (radius + 6);	theSize 		= 	(double)sizeof(double) * maxPoints;	*intensities 	= 	D_NewHandle((long)theSize);	theSize 		= 	(double)sizeof(Point) * maxPoints;	*thePoints 		= 	D_NewHandle((long)theSize);		D_HLock				((Handle)*intensities);	D_HLock				((Handle)*thePoints);	intensity 		= 	(double*)**intensities;	thePoint 		= 	(Point*)**thePoints;	intenHandle = 	(double**)*intensities;	pointHandle = 	(Point**)*thePoints;	i = 0;	while(theta < 2 * PI){		GetCPixel((short)horPix,(short)verPix,&cPixel);		if(maxPoints < i + 1){			maxPoints 	+= 	40;			theSize 	= 	(double)sizeof(double) * maxPoints;			D_SetHandleSize	((intensities),theSize);			theSize 	= 	(double)sizeof(Point) * maxPoints;			D_SetHandleSize	((thePoints),theSize);			intenHandle = 	(double**)*intensities;			pointHandle = 	(Point**)*thePoints;			intensity 	= 	&(*intenHandle)[i];			thePoint 	= 	&(*pointHandle)[i];		}		value = (double)cPixel.red + (double)cPixel.green + (double)cPixel.blue;		value /= 196605;		thePoint->h 	= 	horPix;		thePoint->v 	= 	verPix;		*intensity		=  1 - value;		thePoint++;		intensity++;		i++;		if(Quit()){			D_HUnlock((Handle)*intensities);			D_HUnlock((Handle)*thePoints);			return i;		}		while(fabs(oldHor - horPix) < 1 && fabs(oldVer - verPix) < 1){			theta += delRad;			horPix = cos(theta) * radius + objPoint.h;			verPix  = sin(theta) * radius + objPoint.v;			if(Quit()){				D_HUnlock((Handle)*intensities);				D_HUnlock((Handle)*thePoints);				return i;			}		}		oldHor = horPix;		oldVer = verPix;	}	(*intenHandle)[i] 	= 	(*intenHandle)[0];	(*pointHandle)[i] 	= 	(*pointHandle)[0];	i++;	D_HUnlock((Handle)intenHandle);	D_HUnlock((Handle)pointHandle);	SetPort(thePort);		return i;}Point PointObj::AdjustCenter(double *peakIntensity){	Point thePoint;	double totalIntensity = 0,			horPix,verPix;	double totalX = 0,totalY = 0;			verPix = ptRect.top;		totalX = 0;		totalY = 0;		totalIntensity = 0;		while(verPix <= ptRect.bottom){			horPix = ptRect.left;			while(horPix <= ptRect.right){				if(*peakIntensity > 0){					totalIntensity += *peakIntensity;					totalX += horPix * *peakIntensity;					totalY += verPix * *peakIntensity;				}				horPix += 1;				peakIntensity++;			}						verPix += 1;		}		hor = totalX / totalIntensity;		ver = totalY / totalIntensity;		thePoint.h =  Round(hor) - objPoint.h;		thePoint.v =  Round(ver) - objPoint.v;		return thePoint;}void PointObj::MovePointTo(Point thePoint){	 thePoint.h -= objPoint.h;	 thePoint.v -= objPoint.v;		 MoveBy(thePoint);	 }