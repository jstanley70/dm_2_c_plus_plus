//ces.Jim:Desktop.2.0:GraphicsObj 2:G2_GraphFunction.c#include	"Diffract_INCs.h"#include	"GraphFunction.h"#include "AbsorptionLabels.h"#include	"GraphSpots.h"#include	"Icons.h"#include	"IconObj.h"void four1(double data[], unsigned long nn, int isign);void 	GraphFunction::DoClose			(GraphFunction *theGraph){		if(next != 0L)next->DoClose(theGraph);	if(owner == 0L && titleMenu)titleMenu ->DoClose();	Kill			();}GraphFunction* 	GraphFunction::Kill			(){	Rect resultRect;	if(xData != 0L) KillHandle((Handle*)&xData);	if(owner == 0L && fileMenu)fileMenu	->DoClose();	if(owner == 0L && spectraMenu)spectraMenu	->DoClose();		if(xTitle != 0L) KillHandle((Handle*)&xTitle);	if(yTitle != 0L) KillHandle((Handle*)&yTitle);	if(graphTitle != 0L) KillHandle((Handle*)&graphTitle);	if(owner == 0L){		exIconV->DoClose();		conIconV->DoClose();		resetIconV->DoClose();		resetIcon->DoClose();		exIconH->DoClose();		conIconH->DoClose();		if(gCurrentObj->theWindow){			resultRect = graphRect;			InsetRect(&resultRect,-15,-15);			EraseRect(&resultRect);			InvalRect(&resultRect);		}	}	AdditionalPointers();	D_delete(this);	return 0L;}GraphFunction* 	GraphFunction::CloseOne			(GraphFunction *graph,GraphFunction *newPrev,GraphFunction *home){	GraphFunction *newStart;	GraphFunction	*deadGraph;	short					num = 1;	if(graph == this){		if(newPrev != 0L){			newPrev->next = next;			newStart = home;		}else{			newStart = next;		}				deadGraph = home->FindGraph(graph,&num);				if(titleMenu){			titleMenu->P_DelMenuItem		(titleMenu->P_GetFirstCheckedItem());		}		if(newStart == 0){			owner = 0L;			if(titleMenu)titleMenu ->DoClose();//if newStart == 0 there are no more graphs & title Menu needs to be killed		}else if(!owner)			owner = (GraphFunction*)20L;		Kill			();		return newStart;	}	if(next != 0L) return next->CloseOne(graph,this,home);		return 0L;}void	GraphFunction::AdditionalPointers(void){	if(yData != 0L) KillHandle((Handle*)&yData);}void GraphFunction::SetPlotScales(void){	scaleX 	= (frame.right - frame.left) / (pMaxX - pMinX);	scaleY 	= (frame.bottom - frame.top) / (pMaxY - pMinY);}void	GraphFunction::InitGraphSpace(Rect theRect){	frame.left 		= theRect.left + 40;	frame.right 	= theRect.right - 10;	frame.bottom 	= theRect.bottom - 20;	frame.top 		= theRect.top + 8;	originX 		= frame.left;	originY 		= frame.bottom;	graphRect		=	theRect;	SetRect(&growBox,0,0,0,0);	}void	GraphFunction::MoveFrameBy(Point thePoint){	OffsetRect(&frame,thePoint.h,thePoint.v);	SetFrame(frame);}void	GraphFunction::SetFrame(Rect theRect){	Point thePoint;	frame = theRect;	SetRect	(&graphRect,frame.left - 50,frame.top - 30,frame.right + 10,frame.bottom + 60);	SetRect	(&activityBox,frame.left,graphRect.top,frame.right,graphRect.top + 20);	SetRect	(&killBox,frame.left + 3,graphRect.top + 3,frame.left + 13,graphRect.top + 13);	SetRect		(&resizeBox,frame.right  - 20,graphRect.top + 3,frame.right - 10,graphRect.top + 13);	SetRect(&fileMBox,frame.left + 18,graphRect.top + 3,frame.left + 60,graphRect.top + 23);	SetRect(&growBox,graphRect.right - 10,graphRect.bottom - 10,graphRect.right,graphRect.bottom);	originX = 	frame.left;	originY = 	frame.bottom;	xTLoc.h =  	frame.left + ((frame.right - frame.left) / 2);	xTLoc.v =  	frame.bottom + 20;	xTLoc.h 	-= 20;	yTLoc.v 	=	frame.top + ((frame.bottom - frame.top) / 2);	yTLoc.h 	=	frame.left - 45;	grpTLoc.h	=	((frame.right - frame.left)/2) + frame.left;	grpTLoc.v	=	frame.bottom + 40;		thePoint.h = 	fileMBox.left;	thePoint.v = 	fileMBox.top - 2;		SetRect(&theRect,graphRect.left + 1,graphRect.bottom - 17,graphRect.left + 17,graphRect.bottom - 1);	resetIcon->SetIconRect(theRect);	SetRect(&theRect,graphRect.left + 1,graphRect.bottom - 33,graphRect.left + 17,graphRect.bottom - 17);	resetIconV->SetIconRect(theRect);	SetRect(&theRect,graphRect.left + 1,graphRect.bottom - 49,graphRect.left + 17,graphRect.bottom - 33);	conIconV->SetIconRect(theRect);	SetRect(&theRect,graphRect.left + 1,graphRect.bottom - 65,graphRect.left + 17,graphRect.bottom - 49);	exIconV->SetIconRect(theRect);	SetRect(&theRect,graphRect.left + 17,graphRect.bottom - 17,graphRect.left + 33,graphRect.bottom - 1);	conIconH->SetIconRect(theRect);	SetRect(&theRect,graphRect.left + 33,graphRect.bottom - 17,graphRect.left + 49,graphRect.bottom - 1);	exIconH->SetIconRect(theRect);	if(!fileMenu)return;	fileMenu		->	MoveMenuTo(thePoint);	thePoint.h 	+= 	 fileMenu	->theMenuRect.right - fileMenu	->theMenuRect.left + 2;	spectraMenu	->	MoveMenuTo(thePoint);	thePoint.h 	+= 	 spectraMenu	->theMenuRect.right - spectraMenu	->theMenuRect.left + 2;	titleMenu		->	MoveMenuTo(thePoint);}GraphFunction*	GraphFunction::FindGraphByNum(short num,short i){	i++;	if(i == num){		return this;	}else{		if(next != 0L)			return next->FindGraphByNum( num, i);	}	return 0L;}GraphFunction*	GraphFunction::FindGraph(GraphFunction *compareGraph,short *num){	if(compareGraph == this){		return this;	}else{		if(next != 0L){			(*num)++;			return next->FindGraph(compareGraph,num);		}	}	return 0L;}void	GraphFunction::AllMinMaxY(double *min,double *max){	if(*min > minY)*min = minY;	if(*max < maxY)*max = maxY;	if(next != 0)next->AllMinMaxY(min,max);		return;}typedef	struct PairedData{	double x;	double y;}PairedData;short	PairedCompare(PairedData* x,PairedData* y);short	PairedCompare(PairedData* x,PairedData* y){	double z1,z2;		z1 = x->x;	z2 = y->x;		return((short)((z1 > z2) ? -1 : ((z1 == z2) ? 0 : 1)));}void GraphFunction::PlotXvsY(void){	double 	*data,*xdata;	short		i = 0;	short 	theX,theY;	double	theValue;	PairedData *theData;	RGBForeColor(&color);	D_HLock(yData);	D_HLock(xData);	data = (double*)*yData;	xdata = (double*)*xData;	theData = 	(PairedData*)D_NewPtr(noPtsY * sizeof(PairedData));	for(i = 0 ; i < noPtsY;i++,xdata++,data++)	{		theData[i].x = *xdata;		theData[i].y = *data;	}	qsort(theData,noPtsY,sizeof(PairedData),(_compare_function/*__cmp_func_Cmpfun**/)PairedCompare);	i = 0;	while(i < noPtsY)	{		theX = Round((((double)theData[i].x - pMinX) * scaleX) + originX);		theValue = (theData[i].y - pMinY) * scaleY;		theY = Round((double)originY - theValue);		if(theY > originY)theY = originY;		if(theY < frame.top)theY = frame.top;		if(i == 0)MoveTo(theX,theY);		i++;		data++;		xdata++;		if(theX > frame.right || theX < frame.left)continue;			GraphType(theX,theY);	}	KillPtr((Ptr)theData);	D_HUnlock(xData);	D_HUnlock(yData);}void	GraphFunction::PlotGraph(void){	double 	theLeft;	double 	*data,spacing;	short 	i;	double 	theValue;	short		theX,theY;	double 	theXValue;	short		startNum;	RgnHandle theRgn;	RgnHandle	oldRgn;	RGBColor	colorOld;		GetForeColor(&colorOld);		if(yData == 0L &&& xData == 0L ) {		if(next != 0)next->PlotGraph();		return;	}		oldRgn = D_NewRgn();	GetClip(oldRgn);	SetToOwner		();	SetPlotScales	();	DrawGraphBox	();			if(shrunk){		if(next != 0)next->PlotGraph();		D_SetClip(oldRgn);		D_DisposeRgn(&oldRgn);	 	return;	}	PenNormal();		theRgn 	= D_NewRgn();	RectRgn		(theRgn,&frame);	D_SetClip		(theRgn);	if(xData){		PlotXvsY();		RGBForeColor(&colorOld);		D_DisposeRgn(&theRgn);		D_SetClip(oldRgn);		D_DisposeRgn(&oldRgn);		return;	}			if(noPtsY > 1)	data 	= 	(double*)*yData;	else {		if(next != 0)next->PlotGraph();		return;	}		i = 0;	theLeft = originX;			theValue = (*data - pMinY) * scaleY;	theY = Round((double)originY - theValue);	theX	=	originX;	if(!plotGraph)	{		RGBForeColor(&colorOld);		if( next != 0L){next->PlotGraph();			D_DisposeRgn(&theRgn);			D_SetClip(oldRgn);			D_DisposeRgn(&oldRgn);			return;		}else			D_DisposeRgn(&theRgn);			D_SetClip(oldRgn);			D_DisposeRgn(&oldRgn);			return;	}		//D_HLock(yData);	spacing = (maxX - minX) / ((double)noPtsY);	MoveTo(theX,theY);	startNum	= (pMinX - minX) / spacing; 	if(startNum < 0){		i	=	0;		startNum = 0;		theXValue	=	- spacing * startNum;	}else{			data		=	&data[startNum];		i			=	startNum;		theX	 	=	originX;		theXValue	=	0;	}	MoveTo(theX,theY);	RGBForeColor(&color);	while(i < noPtsY && theXValue < pMaxX - pMinX)	{				theX = Round(((double)theXValue * scaleX) + originX);		theXValue	+= spacing;		theValue = (*data - pMinY) * scaleY;		theY = Round((double)originY - theValue);		if(theY > originY)theY = originY;		if(theY < frame.top)theY = frame.top;				i++;		data++;		if(theX > frame.right || theX < frame.left)continue;		GraphType(theX,theY);	}	//D_HUnlock(yData);	RGBForeColor(&colorOld);	D_DisposeRgn(&theRgn);	D_SetClip(oldRgn);	D_DisposeRgn(&oldRgn);	if(next != 0)next->PlotGraph();}void	GraphFunction::GraphType(short theX,short theY){		Rect theRect;		double theValue;		switch(graphType){			Point thePoint;			case 0:				LineTo(theX,theY);			break;			case 1:				SetRect(&theRect,-2,-2,2,2);				OffsetRect(&theRect,theX,theY);				if(gCurrentObj->greyFlag)theValue = 200;				else theValue = 0;				gCurrentObj->DM_DrawRect(theRect,0,theValue,false);				FrameOval(&theRect);			break;			case 2:				thePoint = DetermineOrigin();				MoveTo(theX,thePoint.v);				LineTo(theX,theY);			break;			default:			break;			}		}	Point	GraphFunction::DetermineOrigin(void){	short theValue;	Point thePoint;	if(pMinY < 0)	{		theValue =  pMinY;		theValue *= scaleY;		thePoint.v = Round((double)originY + theValue);	}else{		thePoint.v = originY;	}	if(pMinX < 0)	{		theValue =  pMinX;		theValue *= scaleX;		thePoint.h = Round((double)originX - theValue);	}else{		thePoint.h = originX;	}	return thePoint;}	void	GraphFunction::DrawFrame(void){	Point thePoint;	if(shrunk){		EraseRect(&activityBox);		return;	}else{		InsetRect(&graphRect,-3,-3);		EraseRect(&graphRect);		InsetRect(&graphRect,3,3);	}	FrameRect(&frame);	if(pMinY < 0)	{		thePoint = DetermineOrigin();		MoveTo(frame.left,thePoint.v);		LineTo(frame.right,thePoint.v);	}}short	GraphFunction::DrawTicksXAxis(short *powerOf10){	double 	X,spacing;	short 	i,theX,j = 0;	short	lengthof = 0;	double	theMin,tenPow;		spacing = (pMaxX - pMinX) / (double)numXTicks;	while(fabs(spacing) >= 10){j++;spacing /= 10;}	tenPow = pow(10,(double)j);	theMin = pMinX/tenPow;	X = 0;	for(i = 0; i <= numXTicks;i++){		short test;		theX 	= 	originX + Round(scaleX * X * tenPow);		MoveTo		(theX,originY);		LineTo		(theX,originY + 5);		sprintf		(gTheText,"%5.2f",X + theMin);		test 	= 	DrawTextAtPointHor(gTheText,theX,originY + 6);		if(lengthof < test)lengthof = test;		X += spacing;	}	*powerOf10 = j;	return lengthof + 7;}short GraphFunction::DrawTicksYAxis(short *powerOf10){	double Y,spacing,tenPow;	short i,theY;	short lengthof = 0,j = 0;	short	tickLength = 5;	double	theMin;	spacing = (pMaxY - pMinY) / (double)numYTicks;	Y = 0;	while(fabs(spacing) >= 10){j++;spacing /= 10;}	tenPow = pow(10,(double)j);	theMin = pMinY / tenPow;	for(i = 0; i <= numYTicks;i++){		short test;		theY = originY - Round(scaleY * Y * tenPow);		MoveTo(originX,theY);		LineTo(originX + tickLength,theY);		sprintf(gTheText,"%5.2f",Y + theMin);		test = DrawTextAtPointVer(gTheText,originX - 8,theY);		if(test > lengthof)lengthof = test;		Y += spacing;	}	*powerOf10 = j;	return lengthof;}short	GraphFunction::DrawTextAtPointVer(char *theText,short theX,short theY){	FontInfo 	theFont;	short 		stringWidth,charW,				charHeight;					TextFont(courier); /* courier */	TextSize(9);	GetFontInfo(&theFont);	charHeight = theFont.ascent + theFont.descent + theFont.leading;	charW	=  theFont.widMax;	stringWidth = StringWidth(c2pstr(theText));	MoveTo(theX - stringWidth,theY);	DrawDiffractString((unsigned char*)theText);	TextFont(0); /* courier */	TextSize(12);	return stringWidth + charW;}void 	GraphFunction::SetTitleY(char *theText){	if(yTitle == 0L)yTitle = D_NewHandle(sizeof(char) * strlen(theText));		SetTitle(theText,(Handle*)&yTitle);	yTLoc.h	=	frame.left - 40;	yTLoc.v	=	((frame.bottom - frame.top) / 2) + frame.top;	}void 	GraphFunction::SetTitleX(char *theText){	if(xTitle == 0L)xTitle = D_NewHandle(sizeof(char) * strlen(theText));	SetTitle(theText,(Handle*)&xTitle);	xTLoc.h	=	((frame.right - frame.left)/2) + frame.left;	xTLoc.v	=	frame.bottom + 20;	}void	GraphFunction::ResetPlotMinMax(void){	if(!owner){		GetMinMax(yData,&minY,&maxY,noPtsY);	}	if(!owner && SeekNegatives(this)){		if(minY < 0 && fabs(minY) > maxY)			maxY = fabs(minY);		else			minY = -fabs(maxY);	}	pMinX = minX;	pMinY = minY;	pMaxX = maxX;	pMaxY = maxY;}Boolean	GraphFunction::SeekNegatives(GraphFunction *test){	if(owner == test){		if(minY < 0)return true;	}	if(next)return next->SeekNegatives(test);	return false;}void 	GraphFunction::SetTitleGraph(char *theText){	if(graphTitle == 0L) 	graphTitle = D_NewHandle(sizeof(char) * strlen(theText));		SetTitle(theText,(Handle*)&graphTitle);	grpTLoc.h	=	((frame.right - frame.left)/2) + frame.left;	grpTLoc.v	=	frame.bottom + 40;}void	GraphFunction::Normalize(Handle theData,double maxValue,short num){	double *data;	short	i;		if(fabs(maxValue) < .0000001) return;	D_HLock(theData);	data 	= 	(double*)*theData;	for(i = 0; i < num;i++,data++)	{		*data /= maxValue; 	}	normalizedBy = maxValue;	D_HUnlock(theData);}void GraphFunction::SetColor(void){	RGBColor thisColor;	Point thePoint;	thePoint.h = thePoint.v = 0;	if(GetColor(thePoint,"\pSelect Graph Color",&color,&thisColor)){		color = thisColor;	}}void	GraphFunction::DoInit(Rect theRect,RGBColor theColor,Boolean addMenu,Boolean doGrow){	Point thePoint;		xData 		= 0L;	yData 		= 0L;	labelOn		=	false;	grow			=	doGrow;	thePoint.h = 	theRect.left;	thePoint.v = 	theRect.top - 2;	printing	=	false;	if(addMenu){		fileMenu 	= 	(PopUpMenu*)D_new(PopUpMenu);		fileMenu	->	InitAtPoint	(thePoint,1,39,true,false);		thePoint.h += 	 fileMenu	->theMenuRect.right - fileMenu	->theMenuRect.left + 2;		spectraMenu 	= 	(PopUpMenu*)D_new(PopUpMenu);		spectraMenu	->	InitAtPoint (thePoint,1,401,true,false);		thePoint.h += 	 spectraMenu	->theMenuRect.right - spectraMenu->theMenuRect.left + 2;		titleMenu 	= 	(PopUpMenu*)D_new(PopUpMenu);		titleMenu	->	InitAtPoint (thePoint,1,62,true,false);		active = true;	}else{		titleMenu = 0L;		fileMenu = 0L;		spectraMenu = 0L;		active = false;	}	exIconV = (IconObj*)D_new(IconObj);	conIconV = (IconObj*)D_new(IconObj);	resetIconV = (IconObj*)D_new(IconObj);	resetIcon = (IconObj*)D_new(IconObj);	exIconH = (IconObj*)D_new(IconObj);	conIconH = (IconObj*)D_new(IconObj);		exIconV->DoInit(theRect,311);	conIconV->DoInit(theRect,312);	resetIconV->DoInit(theRect,314);	resetIcon->DoInit(theRect,313);	exIconH->DoInit(theRect,309);	conIconH->DoInit(theRect,310);	SetFrame		(theRect);	active	=		true;	SetRect(&iconBox,frame.left,graphRect.top,frame.left + 32,graphRect.top + 32);	maxX 		= 	100;	minX 		= 	0;	maxY 		= 	1.0;	normalizedBy	=	1.0;	doubleClick	=	false;	minY 		= 	0;	originX 	= 	frame.left;	originY 	= 	frame.bottom;	noPtsX		=	0;	noPtsY		=	0;	color		=	theColor;	numXTicks 	= 	5;	numYTicks 	= 	10;	xTitle		= 	0L;	yTitle		= 	0L;	graphTitle	=	0L;	next		= 	0L;	owner		=	0L;			ResetPlotMinMax();	SetPlotScales();	graphType	=	0;	objectType = 0;	plotGraph	=	true;	selected	=	false;	shrunk		=	false;	thePoint.v = graphRect.top;	thePoint.h = frame.left;	thePoint.h += 20;	thePoint.v += 2;	}void GraphFunction::SetToOwner(void){	if(next != 0L)next->SetToOwner();	if(owner == 0L) return;		graphRect 	= owner->graphRect;	shrunk	 	= owner->shrunk;	activityBox	= owner->activityBox;	growBox	 	= owner->growBox;	frame	 	= owner->frame;	pMaxX 		= owner->pMaxX;	pMaxY 		= owner->pMaxY;	pMinX 		= owner->pMinX;	pMinY 		= owner->pMinY;	fileMBox	= owner->fileMBox;	iconBox		= owner->iconBox;	killBox	 	= owner->killBox;	printing		= owner->printing;	resizeBox	 	= owner->resizeBox;	if(owner->fileMenu != fileMenu && fileMenu){		fileMenu	->DoClose();		spectraMenu	->DoClose();		titleMenu->DoClose();	}	fileMenu = owner->fileMenu;	spectraMenu = owner->spectraMenu;	titleMenu = owner->titleMenu;	if(exIconV != owner->exIconV && exIconV)	{		exIconV->DoClose();		conIconV->DoClose();		resetIconV->DoClose();		resetIcon->DoClose();		exIconH->DoClose();		conIconH->DoClose();	}	exIconV = owner->exIconV;	conIconV = owner->conIconV;	resetIconV = owner->resetIconV;	resetIcon = owner->resetIcon;	exIconH = owner->exIconH;	conIconH = owner->conIconH;	if(!shrunk){		yTitle 			= 0L;		xTitle 			= 0L;	}	originX 	= owner->originX;	originY 	= owner->originY;	grpTLoc		= owner->grpTLoc;	xTLoc		= owner->xTLoc;	yTLoc		= owner->yTLoc;}GraphFunction*  GraphFunction::GetSelected(void){	if(this->selected)return this;	if(next != 0L){ 		 return next->GetSelected();	}	return 0L;}GraphFunction*  GraphFunction::AddGraph(GraphFunction *theOwner,GraphFunction *nextGraph,Rect theRect){	if(nextGraph == 0L)return 0L;	if(next != 0L){ 		 return next->AddGraph(theOwner,nextGraph,theRect);	}	next = nextGraph;	next->next = 0L;	next->active = false;	gCurrentObj->refreshFlag = true;				if(theOwner == 0L || theOwner->shrunk){		next->owner = 0L;		if(next->graphTitle){			D_HLock		((Handle)next->graphTitle);			strcpy		(gTheText,*next->graphTitle);			D_HUnlock	((Handle)next->graphTitle);		}else{			return next;		}	}else{				next->owner = theOwner;		next->titleMenu = theOwner->titleMenu;		if(!next->graphTitle){			if(next->owner->graphTitle){				D_HLock		((Handle)next->owner->graphTitle);				strcpy		(gTheText,*(next->owner->graphTitle));				D_HUnlock	((Handle)next->owner->graphTitle);			}		}else{			D_HLock		((Handle)next->graphTitle);			strcpy		(gTheText,*next->graphTitle);			D_HUnlock	((Handle)next->graphTitle);		}		next->SetToOwner();	}	if(!next->graphTitle)sprintf(gTheText,"Spectrum");	c2pstr(gTheText);	if(theOwner->titleMenu)theOwner->titleMenu->P_AppendMenu(gTheText);	return next;}void 	GraphFunction::SetTitle(char *theText,Handle *titleHdn){	short l;	char	**titleH;	titleH = (char**)*titleHdn;		l = strlen(theText);		D_SetHandleSize ((Handle*)titleHdn,l);		D_HLock((Handle)titleH);	strcpy(*titleH,theText);	D_HUnlock((Handle)titleH);}void	GraphFunction::DrawGraphBox(void){	short lengthofX,lengthof;	short	j,k;	OSErr	myErr;	Rect	theRect;	RgnHandle theRgn;	RgnHandle	oldRgn;	RGBColor	oldColor;	if(owner != 0L) return;	if(shrunk && printing)return;	if(shrunk){		Handle theSuite;		myErr = GetIconSuite(&theSuite,307,svAllAvailableData);		myErr = PlotIconSuite(&iconBox,0,0,theSuite);		FrameRect(&iconBox);	//	ReleaseResource(theSuite);		myErr = DisposeIconSuite(theSuite,true);		return;	}	GetForeColor(&oldColor);	RGBForeColor(&color);		oldRgn = D_NewRgn();	GetClip(oldRgn);	DrawFrame()	;	theRgn 	= D_NewRgn();	InsetRect(&graphRect,-3,-3);	RectRgn		(theRgn,&graphRect);	D_SetClip		(theRgn);		if(fileMenu && !printing){		fileMenu -> SetPopUp();		spectraMenu	->SetPopUp();		titleMenu	->SetPopUp();	}	GetForeColor(&oldColor);	RGBForeColor(&color);	FrameRect		(&growBox);	theRect = growBox;	OffsetRect		(&theRect,-4,-4);	InsetRect		(&theRect,2,2);	FrameRect		(&theRect);	FrameRect		(&resizeBox);	theRect 	= 	resizeBox;	InsetRect		(&theRect,3,3);	OffsetRect		(&theRect,-2,-2);	FrameRect		(&theRect);if(!printing){	FrameRect	(&killBox);	FrameRect	(&activityBox);	FrameRect	(&growBox);}	//FrameRect(&fileMBox);			lengthofX 	= DrawTicksXAxis(&k);	lengthof 	= DrawTicksYAxis(&j);	DrawTitleX(k);	DrawTitleY(j);	DrawTitleGraph();if(!printing){	exIconV->DoDraw();	conIconV->DoDraw();	resetIconV->DoDraw();	resetIcon->DoDraw();	exIconH->DoDraw();	conIconH->DoDraw();}	FrameRect(&graphRect);	InsetRect(&graphRect,3,3);	FrameRect(&graphRect);		//aRgn =  SetClipToPort(0L,0,0,16,16);	//D_DisposeRgn(&aRgn);	D_DisposeRgn(&theRgn);	D_SetClip(oldRgn);	D_DisposeRgn(&oldRgn);	RGBForeColor(&oldColor);}short 	GraphFunction::DrawTextAtPointHor(char *theText,short theX,short theY){	FontInfo 	theFont;	short 		stringWidth,				charHeight;	if(theText == 0L)return 0;	TextMode(0);	TextFont		(courier); /* courier */	TextSize		(9);	GetFontInfo		(&theFont);	charHeight 	= 	theFont.ascent + theFont.descent + theFont.leading;	stringWidth = 	StringWidth(c2pstr(theText));	MoveTo				(theX - (stringWidth * .5),theY + charHeight);	DrawDiffractString	((unsigned char*)theText);	TextFont			(0); /* courier */	TextSize			(12);	return charHeight;}void 	GraphFunction::DrawTextVertical(char *theText,short theX,short theY){	FontInfo 	theFont;	short 		stringWidth,				charHeight;	unsigned char		sText[2];	short		i;	if(theText == 0L)return;	TextMode(0);	TextFont(courier); /* courier */	TextSize(9);	GetFontInfo(&theFont);	charHeight = theFont.ascent + theFont.descent + theFont.leading;	stringWidth = strlen(theText);	sText[0] = 1;	theY -= charHeight * stringWidth / 2;	for(i = 0; i < stringWidth;i++){		MoveTo(theX,theY);		sText[1] = theText[i];		DrawDiffractString((unsigned char*)sText);		theY += charHeight;	}	TextFont(0); /* courier */	TextSize(12);}void GraphFunction::SetValues(Handle xD,Handle yD){		if(yD != 0L){		if(yData != 0L){			KillHandle((Handle*)&yData);		}		yData = yD;		D_HandToHand(&yData);		noPtsY = GetHandleSize(yData) / sizeof(double);		GetMinMax(yData,&minY,&maxY,noPtsY);	}else{		noPtsY = 0;	}	if(xD != 0L){		if(xData != 0L){			KillHandle((Handle*)&xData);		}		xData = xD;		D_HandToHand(&xData);		noPtsX = GetHandleSize(xData) / sizeof(double);		GetMinMax(xData,&minX,&maxX,noPtsX);	}else{		xData 	= 	0L;		maxX	= 	noPtsY;		minX 	= 	0;		noPtsX 	= 	0;	}	ResetPlotMinMax();}void GraphFunction::GetMinMax(Handle theData,double *minV,double *maxV,short noPts){	double *testData;	short	i;	if(theData == 0L)return;	D_HLock(theData);	*minV = 0;	*maxV = 0;	testData = (double*)(*theData);	if(testData != 0L)	{		for(i = 0; i < noPts;i++,testData++){			if(*testData < *minV)*minV = *testData;			else			if(*testData > *maxV)*maxV = *testData;		}	}//	if(*maxV - *minV < .00001)*maxV = *minV + .1;	D_HUnlock(theData);		}void	 GraphFunction::DrawTitleGraph(void){	if(graphTitle == 0L)return;	strcpy(gTheText,*graphTitle);	 DrawTextAtPointHor(gTheText,grpTLoc.h,grpTLoc.v);}void	 GraphFunction::DrawTitleX(short j){	char theText[255];	if(xTitle == 0L)return;	strcpy(gTheText,*xTitle);	if(j > 0){		sprintf(theText,"(x%d)",(short)pow(10,(double)j));		strcat(gTheText,theText);	}	DrawTextAtPointHor(gTheText,xTLoc.h,xTLoc.v);}void	 GraphFunction::DrawTitleY(short j){	char theText[255];	if(yTitle == 0L)return;	strcpy(gTheText,*yTitle);	if(j > 0){		sprintf(theText,"(x%d)",(short)pow(10,(double)j));		strcat(gTheText,theText);	}	DrawTextVertical(gTheText,yTLoc.h,yTLoc.v);}void	GraphFunction::XYValue(Point thePoint,double *x,double *y){		*x = ((thePoint.h  - originX) / scaleX) + pMinX;		*y = ((originY - thePoint.v) / scaleY) + pMinY;		*y *= normalizedBy;}void	GraphFunction::ZoomPlot(Boolean flag,Point thePoint){	double distance,testMax,testMin;	if(flag){		distance = (pMaxX - pMinX) / 4;		testMax	= ((thePoint.h - originX) / scaleX) + pMinX + distance;		testMin	= ((thePoint.h - originX) / scaleX) + pMinX - distance;		if(testMax > maxX)pMaxX = maxX;		else pMaxX = testMax;		if(testMin < minX)pMinX = minX;		else pMinX = testMin;	}else{		ResetPlotMinMax();	}	SetToOwner();	//gCurrentObj->newPictReq = true;	//gCurrentObj->newPictEnable = true;}Boolean	GraphFunction::OpenFileText(void){	short			j;	short			sizeOfString;	char			*theText;	long			curEOF;	GraphFunction *theGraph;			if(gTheFile->theFileInfo.sfGood)	{		gTheFile->fileError 			= 	GetEOF(gTheFile->pathRefNum,&curEOF);		if(gTheFile->fileError){			gTheFile->DoFileError();			return false;		}		theText			=	D_NewPtr(curEOF);		sizeOfString	=	curEOF / sizeof(char);		gTheFile->fileError 			=	FSRead(gTheFile->pathRefNum,&curEOF,(Ptr)(theText));		if(gTheFile->fileError){			KillPtr((Ptr)theText);			gTheFile->DoFileError();			return false;		}		gTheFile->DoFileClose();		j = 0;		theGraph 	= (GraphFunction*)D_new(GraphFunction);		theGraph	->DoInit(frame,color,true,grow);		p2cstr		(gTheFile->theFileInfo.sfFile.name);		theGraph	->SetTitleGraph((char*)gTheFile->theFileInfo.sfFile.name);		theGraph	->ConvertData((Ptr)theText,sizeOfString);		theGraph 	= AddGraph(this,theGraph,frame);				KillPtr		((Ptr)theText);				theGraph->NormalizeToOwner(this);		//gCurrentObj->newPictReq = true;		return true;	}else{		return false;	}	}void GraphFunction::DrawSingleValue(double lineEV,double intensity){	short	oldGraphType,theX,theY;	PenNormal();	RGBForeColor(&color);	theX = Round(((double)(lineEV - pMinX) * scaleX) + originX);	theY = Round((double)originY - ((intensity - pMinY) * scaleY));	if(theX < frame.left || theX > frame.right){			return;	}	if(theY < frame.top)theY = frame.top;	if(theY > frame.bottom)theY = frame.bottom - 2;	oldGraphType = graphType;	graphType = 1;	GraphType(theX,theY);	graphType = oldGraphType;}Ptr  GraphFunction::ConvertData(Ptr thePtr,long size){	char* 	theText;	char	string[30];	short	k = 0,l = 0;	double *data;	theText = thePtr;	noPtsY	=	0;	if(yData == 0L){		yData 	=	D_NewHandle(size * sizeof(double));	}else		D_SetHandleSize(&yData,size * sizeof(double));	D_HLock(yData);	data 	= 	(double*)*yData;	while(k < size){		l = 0;		while(*theText != 13 && k < size && l < 29){			switch(*theText){				case '-':				case '1':				case '2':				case '3':				case '4':				case '5':				case '6':				case '7':				case '8':				case '9':				case '0':				case '.':				case 'e':				case 'E':				string[l++] = *theText;				break;				default:				break;			}			theText++;			k++;		}		string[l] = 0;		noPtsY++;		*data = atof(string);		data++;				theText++;k++;	}	D_HUnlock(yData);	D_SetHandleSize(&yData,noPtsY * sizeof(double));	noPtsX 	= 	0;		return 0L;}void  GraphFunction::DefinePlot(void){	DialogPtr 	theDialog;	short				theSelect;	Boolean			quit,calculateFlag;	PopUpMenu		*popUpMenu;	theDialog	= DM_GetNewDialog(401,NUL,IN_FRONT);			calculateFlag = quit = false;	SetItemValue( theDialog,3,minX,2);	SetItemValue( theDialog,4,maxX,2);	popUpMenu	=	(PopUpMenu*)D_new(PopUpMenu);	popUpMenu	->	Init(theDialog,6,63,graphType + 1);		while(!quit){		long	theResult;		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case -1:			case 2:				quit = true;				break;			case DLOG_ENTER_OR_CR:			case 1:				minX =  GetItemValue( theDialog,3);					maxX =  GetItemValue( theDialog,4);					graphType = popUpMenu	->lastResult - 1;				quit = true;				break;			case 5:				SetColor();				break;			case 6:				theResult = popUpMenu->DoPopUp();				break;			default:				break;			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			}	}	popUpMenu	->	DoClose();	DM_DisposDialog(&theDialog);}GraphFunction* GraphFunction::GetDerivative(void){	short i,ii;	double	*derivData;	double	**convertData;	double	*dataPtr,spacing;	GraphFunction*	theGraph;	if(objectType == 1){Message(WRONG_GRAPH);return 0L;}	ii = noPtsY;	if(objectType == 2){		ii = (noPtsY + 1)/2;	}	convertData = (double**)D_NewHandle(sizeof(double) * ii);		D_HLock((Handle)convertData);	D_HLock((Handle)yData);	derivData 	= *convertData;	dataPtr 	= (double*)*yData;	spacing 	= (maxX - minX) / ((double)ii);		if(objectType == 2){		for(i = 0; i < ii - 1;i++,dataPtr += 2,derivData++){			*derivData = (dataPtr[2] - *dataPtr) / spacing;		} 	}else{		for(i = 0; i < ii - 1;i++,dataPtr++,derivData++){				*derivData = (dataPtr[1] - *dataPtr) / spacing;		} 	}	*derivData = 0;	D_HUnlock((Handle)convertData);	D_HUnlock((Handle)yData);	theGraph = (GraphFunction*)D_new(GraphFunction);	theGraph	-> 	DoInit(frame,color,false,grow);		theGraph	->	SetValues(0L,(Handle)convertData);	KillHandle((Handle*)&convertData);	theGraph->SetDescendantTitle("deriv");	theGraph	->NormalizeToOwner(this);	theGraph	->ResetPlotMinMax();	return theGraph;}GraphFunction* GraphFunction::GetIntegral(void){	short i,ii;	double	*derivData;	double	**convertData;	double	*dataPtr,spacing;	double	integral;	GraphFunction*	theGraph;	if(objectType == 1){Message(WRONG_GRAPH);return 0L;}	ii = noPtsY;	if(objectType == 2){		ii = (noPtsY + 1)/2;	}	convertData = (double**)D_NewHandle(sizeof(double) * ii);		D_HLock((Handle)convertData);	D_HLock((Handle)yData);	derivData 	= *convertData;	dataPtr 	= (double*)*yData;	spacing 	= (maxX - minX) / ((double)ii);		integral = 0;	*derivData = 0;	derivData++;	if(objectType == 2){		for(i = 0; i < ii - 1;i++,dataPtr += 2,derivData++){			integral	+= (dataPtr[2] + *dataPtr) * .5 * spacing;			*derivData = integral;		} 	}else{		for(i = 0; i < ii - 1;i++,dataPtr++,derivData++){				integral	+= (dataPtr[1] + *dataPtr) * .5 * spacing;				*derivData = integral;		} 	}	D_HUnlock((Handle)convertData);	D_HUnlock((Handle)yData);	theGraph = (GraphFunction*)D_new(GraphFunction);	theGraph	-> 	DoInit(frame,color,false,grow);		theGraph	->	SetValues(0L,(Handle)convertData);	KillHandle((Handle*)&convertData);	theGraph->SetDescendantTitle("integral");	theGraph	->NormalizeToOwner(this);	theGraph	->ResetPlotMinMax();	return theGraph;}void	GraphFunction::NormalizeToOwner(GraphFunction *theOwner){	double	normal;	GetMinMax(yData,&minY,&maxY,noPtsY);	if(fabs(minY) > maxY) normal = fabs(minY);	else	normal = fabs(maxY);	Normalize(yData,normal,noPtsY);	maxX 	=	theOwner->maxX;	minX	=	theOwner->minX;	GetMinMax(yData,&minY,&maxY,noPtsY);	ResetPlotMinMax();}void  GraphFunction::SetUpData(char *theText){	SetTitleGraph(theText);	GetMinMax(yData,&minY,&maxY,noPtsY);	Normalize(yData,maxY,noPtsY);	GetMinMax(yData,&minY,&maxY,noPtsY);			}GraphFunction* GraphFunction::MultiplyGraphs(GraphFunction *theGraph){	short i;	double	**convertData,*one,*two,*three;	dcomplex sf1,sf2,sf3;	GraphFunction *aGraph;	if(objectType == 1){Message(WRONG_GRAPH);return 0L;}	if(theGraph->noPtsY != noPtsY)return 0L;	convertData =(double**) D_NewHandle(sizeof(double) * noPtsY);	D_HLock(yData);	D_HLock(theGraph->yData);	D_HLock(convertData);	one		=	(double*)*yData;	two		=	(double*)*theGraph->yData;	three		=	(double*)*convertData;	for(i = 0; i < noPtsY;i += 2,one++,two++,three++){		sf1.r = *one;one++;		sf1.i = *one;		sf2.r = *two;two++;		sf2.i = *two;		sf3 = Cmul(sf1,sf2);		*three = sf3.r;three++;		*three = sf3.i;	}	D_HUnlock(yData);	D_HUnlock(theGraph->yData);	D_HUnlock(convertData);	aGraph	 = (GraphFunction*)D_new(GraphFunction);	aGraph	-> 	DoInit(frame,color,false,grow);		aGraph	->	SetValues(0L,(Handle)convertData);	KillHandle((Handle*)&convertData);	D_HLock			((Handle)graphTitle);	strcpy			(gTheText,*graphTitle);	strcat			(gTheText,".X.");	D_HUnlock		((Handle)graphTitle);	D_HLock			((Handle)theGraph	->graphTitle);	strcat			(gTheText,*theGraph	->graphTitle);	D_HUnlock		((Handle)theGraph	->graphTitle);	aGraph	->SetTitleGraph(gTheText);//	aGraph	->NormalizeToOwner(this);	return aGraph;}GraphFunction* GraphFunction::DivideGraphs(GraphFunction *theGraph){	short i;	double	**convertData,*one,*two,*three;	dcomplex sf1,sf2,sf3;	GraphFunction *aGraph;	if(theGraph->noPtsY != noPtsY)return 0L;	if(objectType == 1){Message(WRONG_GRAPH);return 0L;}	convertData =(double**) D_NewHandle(sizeof(double) * noPtsY);	D_HLock(yData);	D_HLock(theGraph->yData);	D_HLock(convertData);	one		=	(double*)*yData;	two		=	(double*)*theGraph->yData;	three		=	(double*)*convertData;	for(i = 0; i < noPtsY;i += 2,one++,two++,three++){		sf1.r = *one;*one++;		sf1.i = *one;		sf2.r = *two;*two++;		sf2.i = *two;		sf3 = Cdiv(sf1,sf2);		*three = sf3.r;*three++;		*three = sf3.i;	}	D_HUnlock(yData);	D_HUnlock(theGraph->yData);	D_HUnlock(convertData);	aGraph	 = (GraphFunction*)D_new(GraphFunction);	aGraph	-> 	DoInit(frame,color,false,grow);		aGraph	->	SetValues(0L,(Handle)convertData);	KillHandle((Handle*)&convertData);	D_HLock			((Handle)graphTitle);	strcpy			(gTheText,*graphTitle);	strcat			(gTheText,".div.");	D_HUnlock		((Handle)graphTitle);	D_HLock			((Handle)theGraph	->graphTitle);	strcat			(gTheText,*theGraph	->graphTitle);	D_HUnlock		((Handle)theGraph	->graphTitle);	aGraph	->SetTitleGraph(gTheText);	aGraph	->NormalizeToOwner(this);	return aGraph;}GraphFunction* GraphFunction::MultiplyRGraphs(GraphFunction *theGraph){	short i;	double	**convertData,*one,*two,*three;	GraphFunction *aGraph;	if(theGraph->noPtsY != noPtsY)return 0L;	if(objectType == 1){Message(WRONG_GRAPH);return 0L;}	convertData =(double**) D_NewHandle(sizeof(double) * noPtsY);	D_HLock(yData);	D_HLock(theGraph->yData);	D_HLock(convertData);	one		=	(double*)*yData;	two		=	(double*)*theGraph->yData;	three		=	(double*)*convertData;	for(i = 0; i < noPtsY;i++,one++,two++,three++){		*three = *one * *two;	}	D_HUnlock(yData);	D_HUnlock(theGraph->yData);	D_HUnlock(convertData);	aGraph	 = (GraphFunction*)D_new(GraphFunction);	aGraph	-> 	DoInit(frame,color,false,grow);		aGraph	->	SetValues(0L,(Handle)convertData);	KillHandle((Handle*)&convertData);	D_HLock			((Handle)graphTitle);	strcpy			(gTheText,*graphTitle);	strcat			(gTheText,".X.");	D_HUnlock		((Handle)graphTitle);	D_HLock			((Handle)theGraph	->graphTitle);	strcat			(gTheText,*theGraph	->graphTitle);	D_HUnlock		((Handle)theGraph	->graphTitle);	aGraph	->SetTitleGraph(gTheText);	aGraph	->NormalizeToOwner(this);	return aGraph;}GraphFunction* GraphFunction::DivideRGraphs(GraphFunction *theGraph){	short i;	double	**convertData,*one,*two,*three;	GraphFunction *aGraph;	if(theGraph->noPtsY != noPtsY)return 0L;	if(objectType == 1){Message(WRONG_GRAPH);return 0L;}	convertData =(double**) D_NewHandle(sizeof(double) * noPtsY);	D_HLock(yData);	D_HLock(theGraph->yData);	D_HLock(convertData);	one		=	(double*)*yData;	two		=	(double*)*theGraph->yData;	three		=	(double*)*convertData;	for(i = 0; i < noPtsY;i ++,one++,two++,three++){		if(fabs(*two) < .000001){*three = 0;continue;}		*three = *one/ *two;	}	D_HUnlock(yData);	D_HUnlock(theGraph->yData);	D_HUnlock(convertData);	aGraph	 = (GraphFunction*)D_new(GraphFunction);	aGraph	-> 	DoInit(frame,color,false,grow);		aGraph	->	SetValues(0L,(Handle)convertData);	KillHandle((Handle*)&convertData);	D_HLock			((Handle)graphTitle);	strcpy			(gTheText,*graphTitle);	strcat			(gTheText,".X.");	D_HUnlock		((Handle)graphTitle);	D_HLock			((Handle)theGraph	->graphTitle);	strcat			(gTheText,*theGraph	->graphTitle);	D_HUnlock		((Handle)theGraph	->graphTitle);	aGraph	->SetTitleGraph(gTheText);	aGraph	->NormalizeToOwner(this);	return aGraph;}GraphFunction* GraphFunction::StdFFTGraph(short type){	short i,k;	double	*one;	double	*two,**convertData;	GraphFunction *aGraph;	unsigned long		ptsD2;	if(objectType == 1){Message(WRONG_GRAPH);return 0L;}	/*this subroutine calcs the fft of the current graph*/	k = 2;	while(k < noPtsY) k *= 2;		convertData =(double**) D_NewHandle(sizeof(double) * (k));	D_HLock(yData);	D_HLock(convertData);	one		=	(double*)*yData;	two		=	(double*)*convertData;	for(i = 0; i < noPtsY;i++,one++,two++)*two = (double)*one;		for(i = noPtsY;i < k/*k*/;i++,two++)*two = 0;			ptsD2	=	k / 2;	two		=	(double*)*convertData;	four1(&two[-1],ptsD2,(int)type);		D_HUnlock(yData);	D_HUnlock(convertData);	aGraph	 = (GraphFunction*)D_new(GraphFunction);	aGraph	-> 	DoInit(frame,color,false,grow);	D_SetHandleSize((Handle*)&convertData,sizeof(double) * k);	aGraph	->		SetValues(0L,(Handle)convertData);	KillHandle		((Handle*)&convertData);	aGraph->SetDescendantTitle(".fft");		return aGraph;}GraphFunction* GraphFunction::FFTGraph(short type){	short 			i,k,kHalf;	double			*one;	double			*two,**convertData;	GraphFunction 	*aGraph;	unsigned long	ptsD2;	if(objectType == 1){Message(WRONG_GRAPH);return 0L;}	/*this subroutine takes a 0 to x graph creats a mirror and then calcs the fft*/	k = 2;	ptsD2 = (unsigned long)noPtsY / 2;	while(k < ptsD2) k *= 2;	kHalf 	= 	2 * k;	k 		*= 	4;		convertData =(double**) D_NewHandle(sizeof(double) * (k));	two		=	(double*)*convertData;	*two		=	0;	two[1]	=	0;	D_HLock(yData);	D_HLock(convertData);	one		=	(double*)*yData;	two		=	(double*)&((*convertData)[kHalf]);	*two		=	0;	two[1]	=	0;	for(i = 0; i < noPtsY;i++,one++,two++)*two = (double)*one;		for(i = noPtsY;i < kHalf/*k*/;i++,two++)*two = 0;		two		=	(double*)&((*convertData)[kHalf - 2]);	one		=	(double*)*yData;	for(i = 0; i < noPtsY && i < kHalf - 2;i += 2,one += 2,two -= 2)	{		*two = (double)*one;		two[1] = (double)one[1];	}	for(i = noPtsY;i < kHalf - 2/*k*/;i++,two--)*two = 0;	two		=	(double*)*convertData;	ptsD2	=	k / 2;	*two		=	0;	four1(&two[-1],ptsD2,(int)type);		D_HUnlock(yData);	D_HUnlock(convertData);	aGraph	 = (GraphFunction*)D_new(GraphFunction);	aGraph	-> 	DoInit(frame,color,false,grow);		aGraph	->	SetValues(0L,(Handle)convertData);	KillHandle		((Handle*)&convertData);	D_HLock			((Handle)graphTitle);	sprintf						(gTheText,"graph");	if(type == 1)strcat			(gTheText,".fft");	else	strcat			(gTheText,".ifft");	D_HUnlock		((Handle)graphTitle);	aGraph	->SetTitleGraph(gTheText);	aGraph	->NormalizeToOwner(this);		return aGraph;}GraphFunction* GraphFunction::GetPowerSpectra(void){	short i;	double	*one;	double	*two,**convertData;	GraphFunction *aGraph;	long		ptsD2;	dcomplex	sF;	if(objectType == 1){Message(WRONG_GRAPH);return 0L;}	ptsD2 = noPtsY / 2;	convertData =(double**) D_NewHandle(sizeof(double) * ptsD2 );	D_HLock(yData);	D_HLock(convertData);	two		=	(double*)*yData;	one		=	(double*)*convertData;	for(i = 0;i < ptsD2;i++,two++,one++){		sF.r =  *two;			two++;		sF.i = *two;		*one = Cabs(sF);		*one *= *one;	}	D_HUnlock(yData);	D_HUnlock(convertData);	aGraph	 = (GraphFunction*)D_new(GraphFunction);	aGraph	-> 	DoInit(frame,color,false,grow);		aGraph	->	SetValues(0L,(Handle)convertData);	KillHandle((Handle*)&convertData);	aGraph->SetDescendantTitle(".pfft");	aGraph	->NormalizeToOwner(this);	return aGraph;}Ptr  GraphFunction::ConvertDataLines(Ptr thePtr,long size){	AbsorpLine 	*theLines;	short	k = 0,l = 0;	double *data;	theLines = (AbsorpLine*)thePtr;	noPtsY	=	0;	if(yData == 0L){		yData 	=	D_NewHandle(size * sizeof(double));	}else		D_SetHandleSize(&yData,size * sizeof(double));	D_HLock(yData);	data 	= 	(double*)*yData;	for(k = 0; k < size;k++,data++){		noPtsY++;		*data = (double)theLines->lineEV;	}	D_HUnlock(yData);	D_SetHandleSize(&yData,noPtsY * sizeof(double));	noPtsX 	= 	0;		return 0L;}GraphFunction*  GraphFunction::MakeTopHat(double start/*for complex spectra * 2 	actual value*/,double stop/*for complex spectra * 2 	actual value*/,long noPts,double minimum,double maximum){	double stepSize;	GraphFunction *aGraph,*fin;	double			*one;	short			i,startN,endN;	double			**convertData;	convertData =(double**) D_NewHandle(sizeof(double) * noPts);		D_HLock(convertData);	one			=	*convertData;	for(i = 0; i < noPts;i++,one++)*one = 0;	one			=	*convertData;	stepSize = (maximum - minimum) / noPts;	startN	=  (start - minimum)/ stepSize;	endN	=   (stop - minimum)/ stepSize;	if(endN > noPts)endN = noPts;	if(startN < 0)startN = 0;	if(endN == startN)endN++;	for(i = startN; i < endN;i++,one++)	{		*one = 1;		i++;one++;	}		D_HUnlock(convertData);	aGraph	 = (GraphFunction*)D_new(GraphFunction);	aGraph	-> 	DoInit(frame,color,false,grow);		aGraph	->	SetValues(0L,(Handle)convertData);	strcat			(gTheText,"Top Hat");	KillHandle((Handle*)&convertData);	aGraph	->SetTitleGraph(gTheText);//	aGraph	->NormalizeToOwner(this);	fin = aGraph	->StdFFTGraph(1);	aGraph->DoClose(aGraph);	return fin;}enum	{ 	TRACK_INIT = -1,					TRACK_MOVE,			TRACK_COMPLETE		};void  GraphFunction::DoTrack(Point movement,short command){	static Point lastPoint;	Rect	oldRect;		if(selected){		switch(command){			case	TRACK_INIT:					lastPoint.h = lastPoint.v = 0;				if(shrunk)moveRect = iconBox;				else{ 					moveRect = graphRect;					//InsetRect(&moveRect,-4,-4);				}				break;				case	TRACK_MOVE:				oldRect = moveRect;				gCurrentObj->FrameTheRect(&moveRect);				OffsetRect(&moveRect,movement.h,movement.v);				gCurrentObj->FrameTheRect(&moveRect);				lastPoint.h += movement.h;				lastPoint.v += movement.v;				break;			case	TRACK_COMPLETE:				//gCurrentObj->EraseTheRect(&moveRect);				//gCurrentObj->InvalTheRect(&moveRect);				if(!shrunk){					MoveFrameBy(lastPoint);					//gCurrentObj->newPictReq = true;				}else				OffsetRect(&iconBox,lastPoint.h,lastPoint.v);				//gCurrentObj->newPictReq = true;				//gCurrentObj->InvalTheRect(&moveRect);				break;			default:				break;		}	}	if(next != (GraphFunction*)NUL){		next->DoTrack(movement,command);	}}GraphFunction*  GraphFunction::DoSelect(Point startPoint){	if(selected && !gShifted){		if(!shrunk){			//gCurrentObj->EraseTheFrame(&graphRect);			//gCurrentObj->FrameTheRect(&graphRect);			FrameRect(&graphRect);		}		selected = false;		if(next != (GraphFunction*)NUL){			return(next->DoSelect(startPoint));		}	}	if(shrunk && owner == 0L){		if(PtInRect(startPoint,&iconBox)){			PenMode(srcXor);			//gCurrentObj->FrameTheRect(&iconBox);			FrameRect(&iconBox);			PenNormal();			selected = true;			if(next != (GraphFunction*)NUL){				next->DoSelect(startPoint);			}			//gTheSelection->Reset(NUL);			return this;		}	}else if(owner == 0L){				if(PtInRect(startPoint,&graphRect)){			PenMode(srcXor);			//gCurrentObj->EraseTheFrame(&graphRect);			FrameRect(&graphRect);			PenNormal();			selected = true;						if(next != (GraphFunction*)NUL){				next->DoSelect(startPoint);			}			//gTheSelection->Reset(NUL);			return this;		}	}	if(next != (GraphFunction*)NUL){		return next->DoSelect(startPoint);	}	return 0L;}void  GraphFunction::DoMove(Point startPoint){	Rect theRect;	if(selected){		Point		thisPoint,lastPoint;		Boolean		moved = false;		short		currentCursor;			currentCursor 	= gCurrentObj->theCursorID;		gCurrentObj		->SetTheCursor(0);			gCurrentObj		->ObjToLocal(&startPoint);		DoTrack			(startPoint,TRACK_INIT);		lastPoint 		= startPoint;		gTheRect  		= moveRect;		theRect				= moveRect;		InsetRect(&theRect,-4,-4);		PenMode				(srcXor);		while(StillDown()){			GetMouse(&thisPoint);			if(!EqualPt(thisPoint,lastPoint)){				startPoint = thisPoint;				gTheRect  = moveRect;				SubPt(lastPoint,&thisPoint);				DoTrack(thisPoint,TRACK_MOVE);				lastPoint = startPoint;				moved = true;			}			}		if(moved){			EraseRect(&theRect);			DoTrack(startPoint,TRACK_COMPLETE);						gCurrentObj->refreshFlag = true;			theRect = moveRect;			InsetRect(&theRect,-4,-4);			InvalRect(&theRect);		}		PenNormal();		gCurrentObj->SetTheCursor(currentCursor);	} else if(next != (GraphFunction*)NUL){		next->DoMove(startPoint);	}}void  GraphFunction::DoIdle(void){	static short marqPat = 1;	if(next != (GraphFunction*)NUL){		next->DoIdle();	}	if(selected && !grow){		if(!shrunk){			SetMarqueePattern	(&marqPat);			PenMode						(patXor);			FrameRect					(&graphRect);			Delay							(2,&gLongScratch);			FrameRect					(&graphRect);		}else{			SetMarqueePattern	(&marqPat);			PenMode						(patXor);			FrameRect					(&iconBox);			Delay							(2,&gLongScratch);			FrameRect					(&iconBox);		}		PenNormal					();		PenMode						(0);	}	/*if(selected && !shrunk){		SetMarqueePattern(&patNum);		InsetRect(&graphRect,-1,-1);		gCurrentObj->FrameTheRect(&graphRect);		InsetRect(&graphRect,1,1);		PenNormal();	}	*/}void GraphFunction::ClearSelects(void){			if(next != (GraphFunction*)NUL)		next->ClearSelects();			if(selected){		gCurrentObj->EraseTheFrame(&graphRect);		selected = false;	}}void GraphFunction::CleanOwner(GraphFunction *prevOwner,GraphFunction *newOwner){	if(prevOwner == owner){	 	if(newOwner == 0L){			owner = 0L;			newOwner = this;		}else{			owner = newOwner;		}	}	if(next != 0L) next->CleanOwner(prevOwner,newOwner);}Boolean GraphFunction::DoContent(Point thePoint){	Rect resultRect;	if(next != 0L) next->DoContent  ( thePoint);	if(owner || !selected) return false;	if(shrunk){		if(PtInRect(thePoint,&iconBox)){			DoMove(thePoint);					}		return true;	}	if(PtInRect(thePoint,&resizeBox) && grow){		shrunk = true;		gCurrentObj->refreshFlag = true;		resultRect = graphRect;		InsetRect(&resultRect,-14,-14);		EraseRect(&resultRect);		UnionRect(&iconBox,&resultRect,&resultRect);		InvalRect(&resultRect);		return true;	}	if(exIconV){		if(exIconV->DoHit(thePoint)){						pMaxY *= .9;			PlotGraph();			return true;			//gCurrentObj->newPictReq = true;		}		if(conIconV->DoHit(thePoint)){			pMaxY /= .9;			PlotGraph();			//gCurrentObj->newPictReq = true;			return true;		}		if(exIconH->DoHit(thePoint)){			double distance,testMax,testMin;			distance = (pMaxX - pMinX) / 4;			testMax	= ((thePoint.h - originX) / scaleX) + pMinX + distance;			testMin	= ((thePoint.h - originX) / scaleX) + pMinX - distance;			if(testMax > maxX)pMaxX = maxX;			else pMaxX = testMax;				if(testMin < minX)pMinX = minX;			else pMinX = testMin;			PlotGraph();			return true;			//gCurrentObj->newPictReq = true;		}			if(	conIconH->DoHit(thePoint)){			double distance,testMax,testMin;			distance = (pMaxX - pMinX) * 4;			testMax	= ((thePoint.h - originX) / scaleX) + pMinX + distance;			testMin	= ((thePoint.h - originX) / scaleX) + pMinX - distance;			if(testMax > maxX)pMaxX = maxX;			else pMaxX = testMax;				if(testMin < minX)pMinX = minX;			else pMinX = testMin;			PlotGraph();			return true;			//gCurrentObj->newPictReq = true;		}		if(resetIcon->DoHit(thePoint)){			ResetPlotMinMax();			PlotGraph();			return true;			//gCurrentObj->newPictReq = true;		}		if(resetIconV->DoHit(thePoint)){			pMinY = minY;			pMaxY = maxY;						PlotGraph();			return true;			//gCurrentObj->newPictReq = true;		}	}	if(PtInRect(thePoint,&killBox) && grow){				GraphFunction *test;		gCurrentObj->refreshFlag = true;		test = this;		((SADObj*)gCurrentObj)->graph = ((SADObj*)gCurrentObj)->graph->CloseOne(this,0L,((SADObj*)gCurrentObj)->graph);		if(((SADObj*)gCurrentObj)->graph && ((SADObj*)gCurrentObj)->graph->titleMenu){			ClearMenu(((SADObj*)gCurrentObj)->graph->titleMenu->theMenu);			((SADObj*)gCurrentObj)->graph->titleMenu->P_CheckItem		(2,true);			((SADObj*)gCurrentObj)->graph->CleanOwner(this,0L);		}		return false;	}	if(!shrunk && PtInRect(thePoint,&frame) && !doubleClick && !labelOn){		Boolean flag;		gCurrentObj->theRuler->SetHelp("Expand graph around point by clicking. shift-click to see whole graph.");/*dec 1992*/		flag = IsPressed( (unsigned short )56);		if(flag){ 				ZoomPlot(false, thePoint);		}else			ZoomPlot(true, thePoint);		PlotGraph();		return true;	}	DoMenu(thePoint);	if(PtInRect(thePoint,&activityBox) && grow){DoMove(thePoint);return true;}	if(PtInRect(thePoint,&growBox) && grow){		GrowFrame(thePoint);		return true;	}		return true;}void  GraphFunction::DoDblClick  (Point thePoint){	Rect resultRect;	if(next != 0L) next->DoDblClick  ( thePoint);	if(!selected) return;	if(!shrunk && PtInRect(thePoint,&frame))ZoomPlot(false, thePoint);	if(shrunk && PtInRect(thePoint,&iconBox)){		shrunk = false;		gCurrentObj->refreshFlag = true;		resultRect = graphRect;		InsetRect(&resultRect,-16,-16);		UnionRect(&iconBox,&resultRect,&resultRect);		EraseRect(&resultRect);		InvalRect(&resultRect);	}	doubleClick = false;	}void  GraphFunction::DoPrint(void){	GrafPtr thePort;	WindowPtr	theOldWindow;	PrOpen();						GetPort(&thePort);		printing = true;/* Jim august 1993*/	theOldWindow = FrontWindow();	if(!gPrintRecHandle) gPrintRecHandle = (THPrint)GetResource('PREC',(short)1000);		if(GetHandleSize((Handle)gPrintRecHandle) != sizeof(TPrint)){		SetHandleSize((Handle)gPrintRecHandle,sizeof(TPrint));		ChangedResource((Handle)gPrintRecHandle);		WriteResource((Handle)gPrintRecHandle);	}	if(PrValidate(gPrintRecHandle))		SysBeep(30);	if(PrJobDialog(gPrintRecHandle)){		TPrStatus	theStatus;		TPPrPort	thePrintPort;		Rect		theRect;				WindowPtr theWindow;				PenNormal();						thePrintPort = PrOpenDoc(gPrintRecHandle,NUL,NUL);				SetPort(&thePrintPort->gPort);		theRect = thePrintPort->gPort.portRect;				theWindow = NewCWindow (NUL, &theRect, "\p", false, plainDBox, IN_FRONT, 								 false,GetWRefCon(theOldWindow));		SetPort(theWindow);		PenMode(0);			PrOpenPage(thePrintPort,NUL);			PlotGraph();					PrClosePage(thePrintPort);		PrCloseDoc(thePrintPort);				if((*gPrintRecHandle)->prJob.bJDocLoop == bSpoolLoop){			PrPicFile(gPrintRecHandle,NUL,NUL,NUL,&theStatus);		}				DisposeWindow(theWindow);		theWindow = theOldWindow;		SetPort(theWindow);			}	SetPort(thePort);	printing = false;	/*Jim august 1993*/	PrClose();	return;}void GraphFunction::DoMenu(Point thePoint){	short item;	short	menu;	long	theResult;	GraphFunction *graph;	if(!spectraMenu)return;	theResult = fileMenu	->	HitPopUp	(thePoint);	item = LoWord(theResult);	switch(item)	{		case 1:						gTheFile->ReadFileOpen('TEXT');			OpenFileText();			break;		case 2:			graph = GetActive();			if(!graph)break;			graph->SaveText();			break;		case 3:			graph = GetActive();			if(!graph)break;			graph->DoPrint();			break;		default:			break;	}	theResult = spectraMenu	->	HitPopUp	(thePoint);	item = LoWord(theResult);	menu = HiWord(theResult);	if(theResult)spectraMenu->SetPopUp();	SpectrumMenu( item);	theResult = titleMenu	->HitPopUp	(thePoint);	item = LoWord(theResult);	menu = HiWord(theResult);	if(theResult && item > 1){		short i = 0;		graph = GetActive();		ClearMenu(titleMenu->theMenu);		titleMenu->P_CheckItem(item,true);		if(graph)graph->active = false;		item--;		graph = FindGraphByNum(item, i);		if(graph)graph->active = true;		titleMenu->SetPopUp();	}}void	GraphFunction::SpectrumMenu(short theItem){	GraphFunction *graph;	switch(theItem)	{				case 4:						DoSpectrumDialogBox();			gCurrentObj->newPictReq = true;			break;		case 3:			graph = GetActive();			if(!graph)break;			graph->DefinePlot();			gCurrentObj->newPictReq = true;			break;		case 2:			graph = GetActive();			if(!graph)break;			graph->plotGraph = !graph->plotGraph;			gCurrentObj->newPictReq = true;			break;		case 5:			graph = GetActive();			if(!graph)break;			((SADObj*)gCurrentObj)->graph = CloseOne			(graph,0L,((SADObj*)gCurrentObj)->graph);			gCurrentObj->newPictReq = true;			if(((SADObj*)gCurrentObj)->graph){				graph = GetActive();				if(graph)graph->active = false;				if(((SADObj*)gCurrentObj)->graph->titleMenu)				((SADObj*)gCurrentObj)->graph->active = true;				((SADObj*)gCurrentObj)->graph->CleanOwner(graph,0L);				((SADObj*)gCurrentObj)->graph->ResetPlotMinMax();				ClearMenu(((SADObj*)gCurrentObj)->graph->titleMenu->theMenu);				((SADObj*)gCurrentObj)->graph->titleMenu->P_CheckItem		(2,true);			}			break;		default:			break;	}}Boolean GraphFunction::GrowFrame(Point thePoint){	short h,v;	Rect  theRect,resultRect;		if(shrunk) return true;	h = thePoint.h;	v = thePoint.v;	ResizeARect( growBox,graphRect, &h,&v);	if(!h && !v)return false;	h += frame.right-frame.left;	v += frame.bottom-frame.top;	SetRect(&theRect,frame.left,frame.top,frame.left + h, frame.top + v);	gCurrentObj->refreshFlag = true;	//dm_EraseRect(&graphRect);	resultRect = graphRect;	InsetRect(&resultRect,-15,-15);	SetFrame(theRect);//	dm_EraseRect(&graphRect);		UnionRect(&graphRect,&resultRect,&resultRect);	InsetRect(&resultRect,-5,-5);	EraseRect(&resultRect);	InvalRect(&resultRect);	return true;}GraphFunction* GraphFunction::GetActive(void){	if(active) return this;	if(next != 0L)return next->GetActive();	return 0L;}short GraphFunction::GetDataSize(void){	return (short)(GetHandleSize(yData)/ noPtsY);}void GraphFunction::SetDescendantTitle(char *theText){	gTheText[0] = 0L;	if(owner){		if(owner->graphTitle){			D_HLock			((Handle)owner->graphTitle);			strcpy			(gTheText,*owner->graphTitle);			D_HUnlock		((Handle)owner->graphTitle);		}	}else{		if(graphTitle){			D_HLock			((Handle)graphTitle);			strcpy			(gTheText,*graphTitle);			D_HUnlock		((Handle)graphTitle);		}	}	strcat			(gTheText,theText);		SetTitleGraph(gTheText);}void	GraphFunction::DoSpectrumDialogBox(void){	DialogPtr 		theDialog;	short			theSelect,func,spec1,spec2,i,iItemCnt;	Boolean			quit,calculateFlag,flag = true;	PopUpMenu		*spec1Menu,*spec2Menu,*funcMenu;//	MenuHandle		theMenu;	theDialog	= DM_GetNewDialog(1111,NUL,IN_FRONT);			calculateFlag = quit = false;		//theMenu = g_Graph_Select_Menu;	spec1Menu 	= 	(PopUpMenu*)D_new(PopUpMenu);	spec1Menu	->Init( theDialog, 3, 71, 1);	spec2Menu 	= 	(PopUpMenu*)D_new(PopUpMenu);	spec2Menu	->Init( theDialog, 4, 71, 1);	if(titleMenu){		iItemCnt = titleMenu->P_CountMItems();		for(i = 1; i <= iItemCnt;i++){			titleMenu->P_GetItemText(i,gTheText);			spec2Menu->P_AppendMenu	((char*)pTheText);			spec1Menu->P_AppendMenu	((char*)pTheText);		}	}			funcMenu 	= 	(PopUpMenu*)D_new(PopUpMenu);	funcMenu	->Init( theDialog, 5, SPECTRUM_FUNCTIONS, 1);	flag		=	SwitchBoolean(theDialog,6,flag);	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case -1:			case 2:				quit = true;				break;			case DLOG_ENTER_OR_CR:			case 1:				calculateFlag = true;					quit = true;				break;			case 3:				spec1Menu	->DoPopUp();				break;			case 4:				spec2Menu	->DoPopUp();				break;			case 5:				funcMenu	->DoPopUp();				break;			case 6:				flag		=	SwitchBoolean(theDialog,6,flag);				break;			default:								break;			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			}	}	spec1 	= spec1Menu	->lastResult - 1;	spec2 	= spec2Menu	->lastResult - 1;	func	= funcMenu	->lastResult;	spec2Menu->DoClose();	spec1Menu->DoClose();	funcMenu->DoClose();		DM_DisposDialog(&theDialog);	if(calculateFlag ){		GraphFunction *graph1,*graph2,*graph;		GraphSpots		*spot1;		short		graphNo;		graphNo = 0;		graph1 = 	FindGraphByNum(spec1,graphNo);		graphNo = 0;		graph2 = 	FindGraphByNum(spec2,graphNo);		if(graph1 == 0L)return;		switch(func)		{			case 1:				if(graph1->GetDataSize() != sizeof(SpotInfo)) return;				spot1 = ((GraphSpots*)graph1);				graph = spot1->ConvertToSpectra(2048,graph1->minX,graph1->maxX,((SADObj*)gCurrentObj));				AddGraph(this,graph,frame);				break;			case 2:				if(graph1->GetDataSize() == sizeof(SpotInfo)){Message(WRONG_GRAPH);return;}				AddGraph(this,graph1->GetDerivative(),frame);				break;				case 3:				if(graph1->GetDataSize() == sizeof(SpotInfo)){Message(WRONG_GRAPH);return;}				AddGraph(this,graph1->GetIntegral(),frame);				break;					case 4:				if(graph1->GetDataSize() == sizeof(SpotInfo)){Message(WRONG_GRAPH);return;}				AddGraph(this,graph1->StdFFTGraph(1),frame);				break;			case 5:				if(graph1->GetDataSize() == sizeof(SpotInfo)){Message(WRONG_GRAPH);return;}				AddGraph(this,graph1->StdFFTGraph(-1),frame);				break;				case 6:				if(graph1->GetDataSize() == sizeof(SpotInfo)){Message(WRONG_GRAPH);return;}				AddGraph(this,graph1->GetPowerSpectra(),frame);				break;				case 7:				AddGraph(this,graph1->MakeTopHat(0,1/(2 * asin((double)1/24/*cameraLength*/) * 180/ PI),2048,minX,maxX),					frame);				break;				case 8:				if(graph2 == 0L)return;				if(graph1->GetDataSize() == sizeof(SpotInfo) || graph2->GetDataSize() == sizeof(SpotInfo)){Message(WRONG_GRAPH);return;}								AddGraph(this,graph1->MultiplyGraphs(graph2),frame);				break;				case 9:				if(graph2 == 0L)return;				if(graph1->GetDataSize() == sizeof(SpotInfo) || graph2->GetDataSize() == sizeof(SpotInfo)){Message(WRONG_GRAPH);return;}				AddGraph(this,graph1->DivideGraphs(graph2),frame);				break;				}		((SADObj*)gCurrentObj)->graph->ResetPlotMinMax();		if(flag){			//gCurrentObj->newPictReq = true;			((SADObj*)gCurrentObj)->graph = ((SADObj*)gCurrentObj)->graph->CloseOne(graph1,0L,((SADObj*)gCurrentObj)->graph);					((SADObj*)gCurrentObj)->graph->CleanOwner(graph1,0L);			if(((SADObj*)gCurrentObj)->graph->titleMenu){				ClearMenu(((SADObj*)gCurrentObj)->graph->titleMenu->theMenu);					((SADObj*)gCurrentObj)->graph->titleMenu->P_CheckItem		(2,true);			}			((SADObj*)gCurrentObj)->graph->active = true;			return;		}	}			return;}Boolean	GraphFunction::SaveText(void){	char			*theText;	long			i;	double			*one,theX,spacing;	char			aText[20];	if(graphTitle == 0L)		sprintf((char*)gTheFile->theFileInfo.sfFile.name,"fileName");	else		strcpy((char*)gTheFile->theFileInfo.sfFile.name,*graphTitle);	c2pstr((char*)gTheFile->theFileInfo.sfFile.name);	gTheFile->SaveFileOpen('TEXT');	if(!gTheFile->file_is_Open) return false;	one		=	(double*)*yData;	theText	=	(char*)D_NewPtr((sizeof(char) * 19 * noPtsY) + (1 * sizeof(char)));	spacing = (maxX - minX) / ((double)noPtsY);	theX	=	minX;	for(i = 0; i < noPtsY;i++,one++,theX += spacing)	{		while(theX < pMinX || theX > pMaxX)continue;		sprintf(aText,"%10.3f\r",*one);		strcat(theText,aText);	}		sprintf(aText,"\r");		strcat(theText,aText);	gTheFile->WriteTextPtr((Ptr)theText);	gTheFile->DoFileClose();	KillPtr(theText); 	return false;}void	GraphFunction::DoRead(GraphFunction *startGraph){	char *theTitle;	if(gTheFile->ReadShort()){		if(!xData)			xData = D_NewHandle(sizeof(char) * 10);		gTheFile->ReadHandle(xData);	}	switch(gTheFile->ReadShort())	{		case 0:			break;		case 1:			if(!yData)					yData = D_NewHandle(sizeof(char) * 10);			gTheFile->ReadHandle(yData);			break;		case 2:			yData = gCurrentObj->theDataHandle;		break;		default:		break;	}					gTheFile->ReadRect(&frame);	SetFrame(frame);	SetRect(&iconBox,frame.left,graphRect.top,frame.left + 40,graphRect.top + 40);	graphType 	= gTheFile->ReadShort();	objectType 	= gTheFile->ReadShort();	minX				= gTheFile->ReadFloat();	minY				= gTheFile->ReadFloat();	maxX				= gTheFile->ReadFloat();	maxY				= gTheFile->ReadFloat();	pMinX				= gTheFile->ReadFloat();	pMinY				= gTheFile->ReadFloat();	pMaxX				= gTheFile->ReadFloat();	pMaxY				= gTheFile->ReadFloat();	scaleX			= gTheFile->ReadFloat();	scaleY			= gTheFile->ReadFloat();	normalizedBy = gTheFile->ReadFloat();	noPtsX				= gTheFile->ReadShort();	noPtsY				= gTheFile->ReadShort();	originX				=	gTheFile->ReadShort();	originY			=	gTheFile->ReadShort();	numXTicks		=	gTheFile->ReadShort();	numYTicks		=	gTheFile->ReadShort();	if(gTheFile->ReadShort())		gTheFile->ReadHandle((Handle)xTitle);			if(gTheFile->ReadShort())				gTheFile->ReadHandle((Handle)yTitle);			if(gTheFile->ReadShort())		gTheFile->ReadHandle((Handle)graphTitle);			gTheFile->ReadDataBlock(&color,sizeof(RGBColor));	if(graphTitle){		D_HLock((Handle)graphTitle);		theTitle = *graphTitle;		c2pstr(theTitle);		if(titleMenu)titleMenu->P_AppendMenu	(theTitle);		if(titleMenu)ClearMenu(titleMenu->theMenu);		if(titleMenu)titleMenu->P_CheckItem		(2,true);		p2cstr((unsigned char*)theTitle);		D_HUnlock((Handle)graphTitle);	}else{			if(titleMenu)			 titleMenu->P_AppendMenu	((char*)"\pGraph");	}	//	PopUpMenu 		*fileMenu;	//PopUpMenu 		*spectraMenu;	if(gTheFile->ReadShort()){		owner = startGraph;		SetToOwner();	}		if(gTheFile->ReadShort()){		short type;		type = gTheFile->ReadShort();		switch(type){			case 0:				next = (GraphFunction*)D_new(GraphFunction);			break;			case 1:			next = (GraphFunction*)D_new(GraphSpots);			 break;		}				if(next){			next->DoInit(frame,color,false,grow);			next->DoRead(startGraph);		}	}	}void	GraphFunction::DoWrite(void){			if(xData){		gTheFile->WriteShort(1);		gTheFile->WriteHandle(xData);	}else{		gTheFile->WriteShort(0);	}	if(yData && yData != gCurrentObj->theDataHandle){		gTheFile->WriteShort(1);		gTheFile->WriteHandle(yData);	}else  if(!yData){		gTheFile->WriteShort(0);	}else{		gTheFile->WriteShort(2);	}	gTheFile->WriteRect(frame);	gTheFile->WriteShort(graphType);	gTheFile->WriteShort(objectType);	gTheFile->WriteFloat(minX);	gTheFile->WriteFloat(minY);	gTheFile->WriteFloat(maxX);	gTheFile->WriteFloat(maxY);	gTheFile->WriteFloat(pMinX);	gTheFile->WriteFloat(pMinY);	gTheFile->WriteFloat(pMaxX);	gTheFile->WriteFloat(pMaxY);	gTheFile->WriteFloat(scaleX);	gTheFile->WriteFloat(scaleY);	gTheFile->WriteFloat(normalizedBy);	gTheFile->WriteShort(noPtsX);	gTheFile->WriteShort(noPtsY);	gTheFile->WriteShort(originX);	gTheFile->WriteShort(originY);	gTheFile->WriteShort(numXTicks);	gTheFile->WriteShort(numYTicks);	if(xTitle){		gTheFile->WriteShort(1);		gTheFile->WriteHandle((Handle)xTitle);	}else	{		gTheFile->WriteShort(0);	}		if(yTitle){		gTheFile->WriteShort(1);		gTheFile->WriteHandle((Handle)yTitle);	}else	{		gTheFile->WriteShort(0);	}		if(graphTitle){		gTheFile->WriteShort(1);		gTheFile->WriteHandle((Handle)graphTitle);	}else	{		gTheFile->WriteShort(0);	}		gTheFile->WriteDataBlock(&color,sizeof(RGBColor));			//	PopUpMenu 		*fileMenu;	//PopUpMenu 		*spectraMenu;	if(owner)		gTheFile->WriteShort(1);	else		gTheFile->WriteShort(0);			if(next){		gTheFile->WriteShort(1);		gTheFile->WriteShort(next->objectType);		next->DoWrite();	}else{		gTheFile->WriteShort(0);	}		}