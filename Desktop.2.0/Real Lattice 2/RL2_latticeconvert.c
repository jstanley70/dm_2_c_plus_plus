//m:Desktop.2.0:Real Lattice 2:RL2_latticeconvert.c#include	"Diffract_INCs.h"#include	"a_LatticeObject.h"#include	"UT_VectorMacros.c"#include	"a_Lat_Image_Vector.h"void		LatticeObject::ConvertToUnitCell(short crystalNo){	Index 			*theIndex[3];	double			x = 1000,y = 1000,z = 1000,length[3];	short 			i;	double 		matrixXForm[3][3];	LatticeAtomPtr	thePoints;	AtomPtr			crysAtoms;		KillHandle((Handle*)&theCrystal[crystalNo]->theAtoms);				for(i = 0; i <= 2; i++){		theIndex[i] = (Index*)D_new(Index);		theIndex[i]->DoInit(false,theCrystal[crystalNo]);	}	theImageVectors->GetLowestPoint(&x,&y, &z);	theImageVectors->GetUnitCellVectors( x,y,z,theIndex,0);	theCrystal[crystalNo]->SetCrystalFromBasisSet(theIndex[0],theIndex[1],theIndex[2],true);	theCrystal[crystalNo]->theAtoms	= (AtomHnd)D_NewHandle((data_Count) * sizeof(Atom));	theCrystal[crystalNo]->atom_Count = data_Count - 1;	crysAtoms = *(theCrystal[crystalNo])->theAtoms;	D_HLock((Handle)(theCrystal[crystalNo])->theAtoms);		length[0] = theCrystal[crystalNo]->theUnitCell.a * theCrystal[crystalNo]->theUnitCell.a;	length[1] = theCrystal[crystalNo]->theUnitCell.b * theCrystal[crystalNo]->theUnitCell.b;	length[2] = theCrystal[crystalNo]->theUnitCell.c * theCrystal[crystalNo]->theUnitCell.c;	for(i = 0 ; i < 3;i++){		matrixXForm[i][0] = theIndex[i]->x / length[i];		matrixXForm[i][1] = theIndex[i]->y / length[i];		matrixXForm[i][2] = theIndex[i]->z / length[i];	}	D_HLock((Handle)theAtoms->theLattice);	thePoints = (*(theAtoms->theLattice));	for(i = 0; i < data_Count;i++,crysAtoms++,thePoints++){		x = thePoints->x * thePoints->length;		y = thePoints->y * thePoints->length;		z = thePoints->z * thePoints->length;		TransFormVector(&x,&y,&z,matrixXForm);		crysAtoms->x = x;		crysAtoms->y = y;		crysAtoms->z = z;		crysAtoms->atomicNum = thePoints->atNum;	}	for(i = 0; i < 3; i++){		theIndex[i]->DoClose();	}	D_HUnlock((Handle)theAtoms->theLattice);	D_HUnlock((Handle)(theCrystal[crystalNo])->theAtoms);	(theCrystal[crystalNo])->GetSvals();	(theCrystal[crystalNo])->CellVolume();	(theCrystal[crystalNo])->referenceInfoSet = false;	(theCrystal[crystalNo])->ChemicalFormula();	(theCrystal[crystalNo])->JustifyAtomPos();	(theCrystal[crystalNo])->EliminateDuplicates();	imageType = UNIT_LATTICE;}void LatticeObject::SetAndRotate(double matrix[3][3]){	theImageVectors->DoRotate(matrix);	theAtoms->DoRotate(matrix);		{		double zForm[3][3];		TransformAxes(matrix);		CopyAxesIntoMatrix(zForm);		SetMatrixAEqB(matrix,zForm);		ZoneAxisFromMatrix(false,matrix,&calcIrrational,theZoneAxis,theRotationAxis,g_Vector,&rotationAngle,&offLaueDistance,&totalRot,&beamAzimuth);		SetOrientation(zForm);//this is potential a problem	}	newPictReq = true;}void LatticeObject::DoARotation(double degree,short n){		double theXForm[3][3];		RotatateMatrixAxis(theXForm,degree,n);		SetAndRotate(theXForm);		theAtoms->SortByZ();		theAtoms->SetIntensity();		theAtoms->SetSurface();		totalTilts[n] += degree;		newPictReq = true;}void	ImageVector::GetLowestPoint(double *x, double *y, double *z){	if(x1 * length1 < *x && *y >  y1 * length1 && *z > z1 * length1){		*x = x1 * length1;		*y = y1 * length1;		*z = z1 * length1;	}	if(x2 * length2 < *x && *y >  y2 * length2 && *z > z2 * length2){		*x = x2 * length2;		*y = y2 * length2;		*z = z2 * length2;	}	if(nextObj != (ImageVector*)NUL){		nextObj->GetLowestPoint( x,  y, z);	}}void	ImageVector::GetUnitCellVectors(double x, double y, double z,Index *theIndex[3],short count){	double a,b,c;	if(fabs(x1 * length1 - x) < .0001 && fabs(y -  y1 * length1) < .0001		 && fabs(z - z1 * length1) < .0001		 || abs(x2 * length2 - x) < .0001 && fabs(y -  y2 * length2) < .0001		 && fabs(z - z2 * length2) < .0001){		a = x1 * length1 - x2 * length2;		b = y1 * length1 - y2 * length2;		c = z1 * length1 - z2 * length2;		if(fabs(a) > fabs(b) && fabs(a) > fabs(c)){			theIndex[0]->x = a;			theIndex[0]->y = b;			theIndex[0]->z = c;		}else if(fabs(b) > fabs(c)){			theIndex[1]->x = a;			theIndex[1]->y = b;			theIndex[1]->z = c;		}else{			theIndex[2]->x = a;			theIndex[2]->y = b;			theIndex[2]->z = c;		}		count++;	}	if(count == 3) return;	if(nextObj != (ImageVector*)NUL){		nextObj->GetUnitCellVectors( x,  y, z,theIndex, count);	}}