//Macintosh HD:CodeWarriorª DR/3 Gold Ä:Metrowerks  C/C++ Ä:Projects:D.M. v2.0:Sources.Jim:Desktop.2.0:IMAGE_2:IM2_HREM.c#include	"Diffract_INCs.h"#include	"SF_MathLib.h"#include 	"AtomData.h"#include	"a_D_Space.h"#include	"Patterson.h"#include	"HREM.h"void 		fourn(float data[], unsigned long nn[], int ndim, int isign);short	XCompare(SpotInfo* spot1,SpotInfo* spot2);short	YCompare(SpotInfo* spot1,SpotInfo* spot2);Ptr AllocHREMObj(void){	HREMObject	*theObj;		theObj =  (HREMObject*)D_new(HREMObject);	if(HandleIsOK((Handle)theObj)){		theObj->objectType  = HREM_OBJ;		theObj->DoInit();		return((Ptr)theObj);	} else {		return(NUL_PTR);	}}void	HREMObject::DoInit(void){	short i;	sliceSet = 0;	for(i = 0;i < 20;i++)noOfSlices[i] = 0;phaseGrs[i] = pMaps[i] = 0L;	noOfSlices[0] = 5;	inherited::DoInit();}void	HREMObject::CalcPoleIntensities(void){		long 		i;		double		hmax,kmax,thehMax,thekMax,xForm[3][3],xFormMatrix[3][3];				double 		theD,					electronMassRation,					RofEwaldSph,					delH,delK;				float		*theData;				short		plotCrystal;		Crystal 	*thisCrystal;		Atom  		*theAtoms;		double 		*theUs,*theVs,*theZs;		double 		 dH,dK;		double		chx,chy,ckx,cky;		double		x,y,x2,y2;		long			**theHandle;	data_Length			=	((2 * (xCount + 2) * (yCount + 2))) + 8;	data_Expand			=	50;	data_Count			=	0;	data_Size			=	sizeof(float);	if(theDataHandle != 0L)		KillTempHandle				(&theDataHandle);	theDataHandle		= 	D_TempNewHandle(data_Length * data_Size,&gTheOSError);		D_MFTempHLock(theDataHandle);	theData = (float*)*theDataHandle;	thisCrystal = theCrystal[baseCrystal];	*theData = 0;	theData++;	plotCrystal  = baseCrystal;	plotType	=	3;	CopyAxesIntoMatrix(xFormMatrix);	thisCrystal->Get001XForm(xForm);	MatrixMultiply			(xForm,xFormMatrix,xForm); 	ConverttoReciprocal		(xForm,(double)thisCrystal->volume);		{			short atom_Count;						atom_Count = thisCrystal->atom_Count + 1;		electronMassRation =   1. + ( (double)energy / 511.);		theHandle = thisCrystal->AtomicScatteringSet(electronMassRation,theBeamFlag);		D_HLock((Handle)thisCrystal->theAtoms);		theAtoms = 	*thisCrystal->theAtoms;		theUs = (double*)D_NewPtr(3L * atom_Count * sizeof(double));		if(!PtrIsOK((Ptr)theUs)){			return;		}		theVs = &theUs[atom_Count];		theZs = &theVs[atom_Count];						for(i = 0; i < atom_Count; i++,theAtoms++)		{			theUs[i] = theAtoms->x;			theVs[i] = theAtoms->y;		}		atom_Count--;				D_HUnlock((Handle)thisCrystal->theAtoms);		{			double maxX;						RofEwaldSph = 1 / wavelength;						hmax = xCount / 2;			kmax = yCount / 2;			delH 	=	1;			delK	=	1;						electronMassRation = 1. + ( (double)energy / 511.);						thehMax = -hmax;			thekMax = -kmax;			maxX = 0;			chx = xForm[0][0];			chy = xForm[1][0];			ckx = xForm[0][1];			cky = xForm[1][1];						x = thehMax * chx;			y = thehMax * chy;			for(dH = thehMax ; dH < hmax && gNoBreak ; dH += delH )			{				x2 = x + thekMax * ckx;				y2 = y + thekMax * cky;				for(dK = thekMax; dK < kmax && gNoBreak ; dK += delK,theData += 2)				{					dcomplex	sF;					theD 	= 	x2 * x2 + y2 * y2;					AtomicScatterForDFromSet(theD,theHandle,theZs,atom_Count);					//thisCrystal->AtomicScatteringByD(theBeamFlag,theD,1,theZs);					sF	= StructureFactor_2D(dH,dK,theUs,theVs,atom_Count,theZs,thisCrystal->volume);					if(maxX < Cabs(sF)){						maxX =  Cabs(sF);					}					*theData			=	sF.r;					theData[1]			=	sF.i;					data_Count			++	;					AllowBackground();					x2 += ckx;					y2 += cky;				}				x += chx;				y += chy;			}		}		KillPtr((Ptr)theUs);		thisCrystal->ClearAtomicScatSet((long**)theHandle);	}	D_MFTempHUnlock			((Handle)theDataHandle);	return;}void	HREMObject::CalculateDeviations(float *devParam,double tilts[2]){		double		hmax,kmax,thehMax,thekMax,xForm[3][3],xFormMatrix[3][3];			double 		theD,				RofEwaldSph;		Crystal 	*thisCrystal;	double		chx,chy,chz,ckx,cky,ckz,delH,delK,dH,dK;	double		x,y,z,x2,y2,z2,rAngleOld,lDistOld;				thisCrystal 		= theCrystal[baseCrystal];	rAngleOld 			= rotationAngle;	lDistOld 			= offLaueDistance;	rotationAngle 		+= tilts[0];	offLaueDistance 	+= tilts[1];	GetOrientation(xFormMatrix);	rotationAngle		=	rAngleOld;	offLaueDistance		=	lDistOld;	thisCrystal->Get001XForm(xForm);	MatrixMultiply			(xForm,xFormMatrix,xForm); 	ConverttoReciprocal		(xForm,(double)thisCrystal->volume);	RofEwaldSph = 1 / wavelength;	devParam++;	hmax = xCount / 2;	kmax = yCount / 2;	delH 	=	1;	delK	=	1;		thehMax = -hmax;	thekMax = -kmax;		chx = xForm[0][0];	chy = xForm[1][0];	chz = xForm[2][0];	ckx = xForm[0][1];	cky = xForm[1][1];	ckz = xForm[2][1];		x = thehMax * chx;	y = thehMax * chy;	z = thehMax * chz;	for(dH = thehMax ; dH < hmax; dH += delH )	{		x2 = x + thekMax * ckx;		y2 = y + thekMax * cky;		z2 = z + thekMax * ckz - RofEwaldSph;		for(dK = thekMax; dK < kmax; dK += delK,devParam += 2)		{			theD 			= 	x2 * x2 + y2 * y2;			*devParam		= 	fabs((RofEwaldSph - sqrt(theD + (z2 * z2)))); 			devParam[1]		=	0;			x2 += ckx;			y2 += cky;			z2 += ckz;		}		x += chx;		y += chy;		z += chz;	}		return;}void HREMObject::DoPictDraw(void){	short 		centerXO,centerYO;	short		l,j;			centerXO = centerX;	centerYO = centerY;	centerX -= diskResH / 2;	centerY -= diskResV / 2;	gTheFile->ReadFileOpen(DIF_OBJ);	D_MFTempHUnlock(theDataHandle);	for(j = 0;j <= diskResH;j++,centerX += 1){		for(l = 0;l <= diskResV;l++,centerY += 1){			gTheFile->ReadHandle(theDataHandle);			DrawBeamSet();		}	}	centerX = centerXO;	centerY = centerYO;	gTheFile->DoFileClose();	D_MFTempHLock(theDataHandle);}void HREMObject::DrawBeamSet(void){	short 	i,jz,j,k;	float 	*theData;	short 	theX,			theY;	double  testCountX = 0;	long	twoXCount = 0,twoYCount;		long 	thehMax,thekMax;	long	hmax,kmax;			double 	x,y,			chx,ckx,			chy,cky,			x1,			y1;	double 	xForm[3][3],xFormMatrix[3][3];	Crystal 	*thisCrystal;		PenMode(0);	PenNormal();	if(data_Count < 10 || !redraw){		FrameRect(&thePictRect);		return;	}		if(g_Monitor){		jz = 1;		k = CountMItems(GetMenu(PALETTE_MENU_1));		for(i = 1;i <= k;i++){			GetItemMark(GetMenu(PALETTE_MENU_1),i,&j);			if(j)jz = i;		}		thePalette 		= GetNewPalette(2100 + jz);	}		SetImageParameters(&x, &y, &lastX,&twoXCount,&twoYCount);		thisCrystal = theCrystal[baseCrystal];	theData = (float*)*theDataHandle;					CopyAxesIntoMatrix(xFormMatrix);	thisCrystal->Get001XForm(xForm);	MatrixMultiply			(xForm,xFormMatrix,xForm); 	ConverttoReciprocal		(xForm,(double)thisCrystal->volume);		hmax = xCount / 2;	kmax = yCount / 2;		chx = xForm[0][0];	chy = xForm[1][0];	ckx = xForm[0][1];	cky = xForm[1][1];		thehMax = -hmax;	thekMax = -kmax;	x = thehMax * chx;	y = thehMax * chy;		for(i = 0 ; i <= twoYCount && i < data_Count; i++){		x1 = x + thekMax * ckx;		y1 = y + thekMax * cky;		for(j = 0;j <= twoXCount  && j < data_Count;j++ ,theData++)		{			theX = Round(x1 * scaleFactor) + centerX;			theY = Round(y1 * scaleFactor) + centerY;			GrayScale(theX,theY,(double )(*theData));			x1 += ckx;			y1 += cky;		}		x += chx;		y += chy;	}	DMForeColor((short)COMPLEMENT_COLOR);	DMBackColor((short)BACKGROUND_COLOR);}void HREMObject::GrayScale(short theX,short theY,double intensity){	inherited::GrayScale( theX, theY, intensity);	}void	HREMObject::CalculateSigma(void){	sigma = .020886416 * wavelength * (1.0 + (1.9569341e-3 * energy));}void	HREMObject::SetCalculationParameters(void){	short	totalSlices = 0,i;	inherited::SetCalculationParameters();	CalculateSigma();	for(i = 0; i < sliceSet;i++){		totalSlices += noOfSlices[i];	}	sliceThickness = theFoilThickness / totalSlices;	}short	XCompare(SpotInfo* spot1,SpotInfo* spot2){	double z1,z2;		z1 = fabs((double)spot1->x);	z2 = fabs((double)spot2->x);		return((short)((z1 > z2) ? -1 : ((z1 == z2) ? 0 : 1)));}	short	YCompare(SpotInfo* spot1,SpotInfo* spot2){	double z1,z2;		z1 = fabs((double)spot1->x);	z2 = fabs((double)spot2->x);		return((short)((z1 > z2) ? -1 : ((z1 == z2) ? 0 : 1)));}double	HREMObject::SliceIntensity(void) /*UTEST*/{	float 	valueR,valueI;	double 	valueTotal = 0;	long	i;	float	*theData;		D_HLock((Handle)theDataHandle);	theData = (float*)*theDataHandle;	theData++;	for(i = 0; i < data_Count;i++,theData += 2)	{		valueR = *theData;		valueI = theData[1];		valueTotal += valueR * valueR + valueI * valueI;	}	D_HUnlock(theDataHandle);	return valueTotal;}void	HREMObject::SetPhaseGrating(void) /*PGMAP*/{	float 			valueR,valueI;	long	 		maxCount,i;	float			*theData;	double			temp;	unsigned long	nn[3];		maxCount = xCount * yCount;		OShift();	D_HLock((Handle)theDataHandle);	theData = (float*)*theDataHandle;	theData++;	nn[1] = xCount;	nn[2] = yCount;	fourn(theData,nn,2,-1);	for(i = 1; i < maxCount;i++,theData += 2)	{		valueR = *theData;		valueI = theData[1];		temp = sigma * valueR;		valueI = exp(sigma * valueI);		*theData	=	valueI * cos(temp);		theData[1]	=	valueI * sin(temp);	}	D_HUnlock(theDataHandle);	return;}void	HREMObject::PAD0(void) /*PAD0*/{	long 	i,j;	float 	*theData;		D_HLock((Handle)theDataHandle);	theData = (float*)*theDataHandle;	theData++;	for(i = 0; i < xCount;i++,theData += 2){		*theData	=	0;		theData[1]	=	0;	}	theData = (float*)*theDataHandle;	for(i = 0; i < yCount;i++,theData += 2){		j = ((i - 1) * xCount);		theData[(j * 2) + 1]		=	0;		theData[(j * 2) + 2]		=	0;	}	D_HUnlock((Handle)theDataHandle);}void	HREMObject::PropogationFunction(double deltaZ,double x0,double y0,short sliceType) /*PROPG*/{		float	temp;	long	j;	float	*devParam;	D_HLock((Handle)pMaps[sliceType]);	devParam = (float*)*pMaps[sliceType];	devParam++;	for(j = 0; j < data_Count;j++,devParam += 2){		temp = PI_2 * (*devParam * deltaZ);		*devParam = cos(temp);		devParam[1] = sin(temp);	}	D_HUnlock((Handle)pMaps[sliceType]);	PAD0();	OShift();		return ;}void	HREMObject::MultMaps(float *map2,double constant) /*Mult & MultR*/{	long 		maxCount,i;	dcomplex 	a,b;	float		*theData;	maxCount = xCount * yCount;	theData = (float*)*theDataHandle;	theData++;	map2++;	for(i = 0; i < maxCount;i++,theData += 2,map2 += 2)	{		a.r = *theData	; a.i = theData[1];		b.r = *map2		; b.i = map2[1];		a =  Cmul(a,b);		*theData = a.r * constant;		theData[1] = a.i * constant;	}}void	HREMObject::OShift(void)/*Oshift*/{	long 	mX,mY,j1,i1,i2,j2,stopY,stopX;	double 	temp;	float	*theData,*data1,*data2;		mX = xCount / 2;	mY = yCount / 2;		D_HLock((Handle)theDataHandle);	theData = (float*)*theDataHandle;	stopY = mY * xCount;	for(j1 = 0,j2 = stopY;j1 <= stopY;j1 += xCount,j2 += xCount)	{		stopX = j1 + mX;		for(i1 = j1 + 1,i2 = j2 + 1;i1 < stopX;i1++,i2++){			data1 = &(theData[(i1 * 2) - 1]);			data2 = &(theData[(i2 * 2) - 1]);			temp = *data1;			*data1 = *data2;			*data2 = temp;			temp = data1[1];			data1[1] = data2[1];			data2[1] = temp;		}	}	stopY = yCount * xCount;	for(j1 = (mY + 1) * xCount,j2 = 0;j1 <= stopY;j1 += xCount,j2 += xCount)	{		stopX = j1 + mX;		for(i1 = j1 + 1,i2 = j2 + 1;i1 < stopX;i1++,i2++){			data1 = &theData[(i1 * 2) - 1];			data2 = &theData[(i2 * 2) - 1];			temp = *data1;			*data1 = *data2;			*data2 = temp;						temp = data1[1];			data1[1] = data2[1];			data2[1] = temp;					}	}	D_HUnlock((Handle)theDataHandle);}void	HREMObject::CalculateTiltFromDirection(void){		}void		HREMObject::MyCalculate(void){	short			j,l;		double			startTiltH = 0;	double 			startTiltV = 0;	double			delTiltH,delTiltV;		SetCalculationParameters();	diskResV = 0;	diskResH = 8;	delTiltH = theEBeam->convergenceAngle / (diskResH * cameraConstant / wavelength);	delTiltV = cameraConstant * theEBeam->convergenceAngle / diskResH;	if(diskResH > 2) tilts[0] = theEBeam->convergenceAngle / (cameraConstant / wavelength);	if(diskResV > 2) tilts[1] = theEBeam->convergenceAngle * cameraConstant;		CalcPoleIntensities();	SetPhaseGrating();	if(pMaps[0] != 0L){		KillHandle((Handle*)&(pMaps[0]));	}	pMaps[0] = D_NewHandle(data_Size * data_Length);		phaseGrs[0] = theDataHandle;	HandToHand(&phaseGrs[0]);	gTheFile->SaveFileOpen(DIF_OBJ);		for(j = 0;j <= diskResH;j++,tilts[0] += delTiltH){		for(l = 0;l <= diskResV;l++,tilts[1] += delTiltV){			CalculateBeamSet();			gTheFile->WriteHandle(theDataHandle);		}	}		gTheFile->DoFileClose();			}void		HREMObject::CalculateBeamSet(void){	float	*data,constant,*dataNew;	short	i,k;	unsigned long nn[3];	theDataHandle 	= 	phaseGrs[0];	HandToHand			(&theDataHandle);	D_HLock(pMaps[0]);	CalculateDeviations	((float*)*(pMaps[0]),tilts);	D_HUnlock(pMaps[0]);	PropogationFunction	(sliceThickness,0,0,0);	D_HLock				(pMaps[0]);	D_HLock				(theDataHandle);	data 			= 	(float*)*theDataHandle;	data++;	constant = 1 / (float) data_Count;	for(i = 0; i < data_Count;i++,data++)*data /= constant;	data = (float*)*theDataHandle;	data++;	nn[1] 	= xCount;	nn[2]	= yCount;	for(k = 0; k <= sliceSet;k++){		for(i = 0 ; i < noOfSlices[k];i++){			float *a,*b;			fourn(data,nn,2,1);			a = (float*)*(pMaps[k]);			MultMaps(a,constant);			fourn(data,nn,2,-1);			b = (float*)*(phaseGrs[k]);			MultMaps(b,1);		}	}		data_Length			= data_Count = xCount * yCount;		dataNew = data 	= (float*)(*theDataHandle);	k = 0;	data++;	for(i = 0; i < data_Count;i++,dataNew++,data += 2){		double d1,d2;		d1 = *data;		d2 = data[1];		*dataNew = (float)Cabs(Complex(d1,d2));	}	D_HUnlock(theDataHandle);	D_HUnlock(pMaps[0]);		}