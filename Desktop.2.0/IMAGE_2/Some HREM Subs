void	SADObj::CalcPoleIntensities(void){		long 		j,i,xyz,in;		double	thehMax,thekMax,thelMax,hmax,kmax,lmax;				double 	x,y,z,				chx,ckx,				chy,cky,				chz,ckz,				chxD,ckxD,				chyD,ckyD,				chzD,ckzD,				dx,dy,dz,				x1,x2,				y1,y2,				z1,z2,				theDist,reciprocalLatticeSize,intens,intensity,				zLimit,zLow,				theD,d,				xLimit,yLimit,				electronMassRation,				spikingFactor,spikingFactorSqr,				RofEwaldSph,				H,K,L,delH,delK,delL;		double 		crystalvector[3][3],					xForm[3][3],					xFormMatrix[3][3],					maxIntensity[4];		double 		rotationMatrix[3][3];		PPT_Info 		*pptOR;		short		k = 0;		short		orNumber,orNum;		short		atom_Count;		short		plotCrystal;		Crystal 		*thisCrystal;			Atom  		*theAtoms;		double 		*theUs,*theVs,*theWs,*theZs;		double 		 dH,dK,dL;							for(i = 0; i <= 3; i++) calculateFlags[i] = false;					D_MFTempHLock(theDataHandle);	thisCrystal = theCrystal[baseCrystal];			if(theBeamFlag == 2 && theXRay->polarizedFlag) return;			if(linking){		x_001 = gDefault->x_001;		y_001 = gDefault->y_001;		z_001 = gDefault->z_001;		stage->DoCopy(gDefault->stage);		ZoneAxisFromAxes();			}	CopyAxesIntoMatrix(xFormMatrix);			theIndex->DoInit(false,theCrystal[baseCrystal]);	{		short atom_Count;				calculateFlags[baseCrystal] = true;		theIndex->theCrystal = thisCrystal;				maxIntensity[baseCrystal] = 0.0;			atom_Count = thisCrystal->atom_Count + 1;				D_HLock((Handle)thisCrystal);		D_HLock((Handle)thisCrystal->theAtoms);		theAtoms = 	*thisCrystal->theAtoms;		theUs = (double*)D_NewPtr(3L * atom_Count * sizeof(double));		if(!PtrIsOK((Ptr)theUs)){			return;		}		theVs = &theUs[atom_Count];		theZs = &theWs[atom_Count];						for(i = 0; i < atom_Count; i++,theAtoms++)		{			theUs[i] = theAtoms->x;			theVs[i] = theAtoms->y;			theZs[i] = 1.;		}		D_HUnlock((Handle)thisCrystal);		D_HUnlock((Handle)thisCrystal->theAtoms);							thisCrystal->Get001XForm(xForm);			MatrixMultiply			(xForm,xFormMatrix,xForm); 			ConverttoReciprocal		(xForm,(double)thisCrystal->volume);			RofEwaldSph = 1 / wavelength;			reciprocalLatticeSize = ((double)(negWidth + negHeight) * 0.25)/												(double)cameraConstant;						hmax = SizeofReciprocalLattice(1.,0.,0.,reciprocalLatticeSize,thisCrystal);			kmax = SizeofReciprocalLattice(0.,1.,0.,reciprocalLatticeSize,thisCrystal);			SetDeltas(&delH,&delK,&delL,hmax,kmax,lmax);			electronMassRation = 1. + ( (double)energy / 511.);			xLimit = (double)negWidth * .5 / (double)cameraConstant;			yLimit = (double)negHeight * .5 / (double)cameraConstant;			zLimit = RofEwaldSph * (1 - cos(atan(yLimit / RofEwaldSph))) + .3;			chx = xForm[0][0] ;			chy = xForm[1][0];			chz = xForm[2][0] ;			ckx = xForm[0][1];			cky = xForm[1][1] ;			ckz = xForm[2][1];						theFoilNormal->PlaneNormalOfDir(&H,&K,&L);			x = H * chx + K * ckx + L * clx ;			y = H * chy + K * cky + L * cly;			z1 = H * chz + K * ckz + L * clz;			z = fabs(z1);						z1 = z /sqrt(z * z + x * x + y * y);			chxD = xForm[0][0] *  delH;			chyD =   xForm[1][0] * delH;			chzD =  xForm[2][0] * delH;			ckxD =  xForm[0][1] * delK;			ckyD =   xForm[1][1] * delK;			ckzD =   xForm[2][1] * delK;							spikingFactor = 10. * z1 / (double)theFoilThickness;  			if(spikingFactor < .01)				spikingFactor =  .01;			spikingFactorSqr =  100. * z1 * z1 / ((double)theFoilThickness * theFoilThickness);									zLow = -spikingFactor - RofEwaldSph;			zLimit -= RofEwaldSph;																	thehMax = -hmax;			thekMax = -kmax;			x = thehMax * chx;			y = thehMax * chy;			z = thehMax * chz;			for(H = thehMax ; H <= hmax && gNoBreak ; H += delH)			{				x2 = x + thekMax * ckx;				y2 = y + thekMax * cky;				z2 = z + thekMax * ckz - RofEwaldSph;				for(K = thekMax; K<= kmax && gNoBreak ; K += delK)				{						dcomplex	sF;						if(TestDimension(&theD,&theDist, H, K, L, x2, y2, z2, xLimit, yLimit, zLimit,zLow, RofEwaldSph, spikingFactor))							goto NEWSTART;												thisCrystal->AtomicScatteringByD(theBeamFlag,theDist,theZs);						sF	= StructureFactor(H,K,L,theUs,theVs,theWs,atom_Count,theZs,thisCrystal->volume);						intensity = (double)Cabs(sF);						if(spikingFactorSqr - theDist * theDist < 0){							intens = .01 * intensity;						}else{							intens = (double)(intensity * sqrt(fabs((spikingFactorSqr - theDist * theDist)) / spikingFactorSqr));						}						if(TestIntensity(intens))							goto NEWSTART;						if(data_Count >= data_Length){							ExpandMemory();						}								NEWSTART:	AllowBackground();					x1 += ckxD;					y1 += ckyD;					z1 += ckzD;				}				x += chxD;				y += chyD;				z += chzD;			}		}				KillPtr((Ptr)theUs);	}			D_MFTempHUnlock			((Handle)theDataHandle);		if(data_Length >  data_Count){		D_RecoverMemory		(theDataHandle,data_Size,data_Count);	}	data_Length 	= 	data_Count;	NormalizeIntensity(baseCrystal,maxIntensity);	return;}void	HREMObject::PropogationFunction(double deltaZ,double x0,double y0) /*PROPG*/{	float 	valueR,valueI,*theData;	double 	valueTotal = 0;	long	maxCount;	long 	j,i,j1,i1,mY,mX;	double	temp,sG,twoKR;	double	a1,a2,b1,b2,AdotB;	double	xForm[3][3];	long	h,k;		maxCount = xCount * yCount;	D_HLock((Handle)theDataHandle);	theData = (float*)*theDataHandle;	twoKR = .5 * wavelength;	mX = xCount / 2;	mY = yCount / 2;	theCrystal[baseCrystal]->Get001XForm(xForm);	ConverttoReciprocal		(xForm,(double)theCrystal[baseCrystal]->volume);	a2 = xForm[0][0]  *  xForm[0][0] +  xForm[0][1] *  xForm[0][1];	b2 = xForm[1][1]  *  xForm[1][1] +  xForm[1][0] *  xForm[1][0];		AdotB = xForm[0][0] * xForm[1][0] + xForm[0][1] * xForm[1][1];		for(j = 2; j < yCount;j++){		k = j - mY -1;		j1 = (j - 1 ) * xCount;		for(i = 2; i < xCount;i++){			h = i - mX - 1;			a1 = (2 * tilt[0]) + h;			b1 = (2 * tilt[1]) + k;			sG = twoKR * ((a1 * h * a2) + (k * b1 * b2) + ((a1 * k + b1 * h) * AdotB));			temp = PI_2 * (sG * deltaZ + h * x0 + k * y0);			i1 = j1 + i;			theData[i1] = cos(temp);			theData[i1 + 1] = sin(temp);		}	}	PAD0();	OShift();		return ;}