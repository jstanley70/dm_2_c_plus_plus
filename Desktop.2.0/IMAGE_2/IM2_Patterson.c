#include	"Diffract_INCs.h"#include 	"AtomData.h"//Macintosh HD:CodeWarriorª DR/3 Gold Ä:Metrowerks  C/C++ Ä:Projects:D.M. v2.0:Sources.Jim:Desktop.2.0:IMAGE_2:IM2_Patterson.c#include	"a_D_Space.h"#include	"Patterson.h"#include	"HREM.h"void fourn(float data[], unsigned long nn[], int ndim, int isign);Ptr AllocPattersonObject(void){	PattersonObject	*theObj;		theObj =  (PattersonObject*)D_new(PattersonObject);	if(HandleIsOK((Handle)theObj)){		theObj->objectType  = PATTERSON_OBJ;		theObj->DoInit();		return((Ptr)theObj);	} else {		return(NUL_PTR);	}}void	PattersonObject::SetObjectWindowTitle(void){	inherited::SetObjectWindowTitle();	plotType			=	0;	sprintf(gTheText,"Patterson %d",g_Window_Number);	SetWTitle(theWindow,c2pstr(gTheText));	data_Length			=	100;	data_Expand			=	50;	data_Count			=	0;	data_Size			=	sizeof(SpotInfo);	if(theDataHandle != 0L)		KillTempHandle				(&theDataHandle);	theDataHandle		= 	D_TempNewHandle(data_Length * data_Size,&gTheOSError);	DrawMenuBar();	objectType = PATTERSON_OBJ; 	xCount = 64;	yCount = 64;	theLens				=	(ObjectiveLens*)D_new(ObjectiveLens);	theLens->DoInit(this);		}void		PattersonObject::DoInit(void){			inherited::DoInit();	return;}Boolean PattersonObject::TestDimension(double *theD,double *theDist,double h,double k,double l,double x2,double y2,double z2,double xLimit,				double yLimit,double zLimit,double zLow,double RofEwaldSph,double spikingFactor){		if(fabs(z2 + RofEwaldSph) > 0.0001)		return true;			if(fabs(x2) > xLimit || fabs(y2) > yLimit ) 		return true;	*theD = x2 * x2 + y2 * y2;	*theDist = fabs((RofEwaldSph - sqrt(*theD + (z2 * z2)))); 	return false;}SpotInfoPtr	PattersonObject::InsertData(double H,double K, double L, double intens,double x2,double y2,double z2,double angle,Crystal *theCrystal,short plotCrystal,dcomplex sF,SpotInfoPtr aSpot){	SmallSpotInfoPtr		theSpots,thisSpot;	theSpots			= 	(SmallSpotInfoPtr)*theDataHandle;	thisSpot 			= 	&(theSpots[data_Count++]);	thisSpot->intensity 	= 	(float)/*(short double)*/intens;	thisSpot->x 		=  	(float)/*(short double)*/x2;	thisSpot->y 		= 	(float)/*(short double)*/y2;	thisSpot->sF		=	sF;	return 0L;}void PattersonObject::SetDeltas(double *delH,double *delK,double *delL,double hmax,double kmax,double lmax){	if(plotType < 3){		*delH 	=	2 * hmax / (double)xCount;		*delK	=	2 * kmax / (double)yCount;		*delL	=	2 * lmax / (double)xCount;		 return;	}	*delH 	=	1;	*delK	=	1;	*delL	=	1;}void	PattersonObject::CalcPoleIntensities(void){			inherited::CalcPoleIntensities();}void PattersonObject::DoPictDraw(void){	if(plotType > 2)		inherited::DoPictDraw();	else		OtherPictDraw();	}void PattersonObject::SetImageParameters(double *k_D,double *I_D,short *lastX,long *twoXCount,long *twoYCount ){		lastGray = -100;	*k_D				=  2;	*I_D				=  2;		SetIntensities();		SetGrayConstants();	*lastX = centerX - (xCount / 2);	lastY = centerY  - (yCount / 2);	MoveTo(*lastX,lastY);	*twoXCount = xCount - 1;	*twoYCount = yCount - 1;}void PattersonObject::GrayScale(short theX,short theY,double intensity){	short theGray;		double theValue;	if(plotType > 2){		inherited::GrayScale( theX, theY, intensity);	}		theValue 	= (grayGain * intensity);	theGray 	= Round(theValue);	if(theGray < 0 )		theGray = 0;	if(theGray > 255)		theGray = 255;	{		if(g_Monitor)			DMForeColor((short)theGray);		else{			short patID = 0;			PatHandle hPat;			patID = 10 - theGray;			patID += 300;			PenNormal();			DMForeColor(BLACK);			hPat = GetPattern(patID);			PenPat(*hPat); 			ReleaseResource((Handle)hPat);		}			} 	}void	PattersonObject::OtherPictDraw(void){	short 	i,jz,j,k;	SmallSpotInfoPtr 	theData;	short 	theX,			theY;	double  testCountX = 0;	long	twoXCount = 0,totalCounts;		Rect		oldOval,oval;	PenMode(0);	PenNormal();	if(data_Count < 10 || !redraw){		FrameRect(&thePictRect);		return;	}	if(g_Monitor){		jz = 1;		k = CountMItems(GetMenu(PALETTE_MENU_1));		for(i = 1;i <= k;i++){			GetItemMark(GetMenu(PALETTE_MENU_1),i,&j);			if(j)jz = i;		}		thePalette 		= GetNewPalette(2100 + jz);	}	totalCounts = GetHandleSize(theDataHandle) / sizeof(SmallSpotInfo);	theData = (SmallSpotInfoPtr)*theDataHandle;	SetIntensities();	SetGrayConstants();	SetRect(&oldOval,-1,-1,1,1);	for(i = 0 ; i < data_Count; i++,theData++){		theX = Round(theData->x * scaleFactor) + centerX;		theY = Round(theData->y * scaleFactor) + centerY;		oval = oldOval;		OffsetRect(&oval,theX,theY);		switch(plotType){			case 0:			GrayScale(theX,theY,(double )(theData->intensity - minIntensity));			break;			case 1:			GrayScale(theX,theY,(double )(theData->sF.r - minIntensity));			break;			case 2:			GrayScale(theX,theY,(double )(theData->sF.i - minIntensity));			break;		}		PaintRect(&oval);	}	DMForeColor((short)COMPLEMENT_COLOR);	DMBackColor((short)BACKGROUND_COLOR);}void		PattersonObject::MyCalculate(void){	unsigned long 	nn[3];	short			i,k;	float			*data;	float			*dataNew;			SetCalculationParameters();	data_Length			=	((xCount + 1) * (yCount + 1)) + 8;	data_Expand			=	50;	data_Count			=	0;	data_Size			=	sizeof(SmallSpotInfo);	if(theDataHandle != 0L)		KillTempHandle				(&theDataHandle);	theDataHandle		= 	D_TempNewHandle(data_Length * data_Size,&gTheOSError);	data_Count = 0;	CalcPoleIntensities();	if(plotType < 3) return;	SetUpStrucFactMap();		nn[1] 	= xCount;	nn[2]	= yCount;	D_HLock(theDataHandle);	data = (float*)*theDataHandle;		fourn(&(data[1]), nn,  2, 1);		data_Size			=	sizeof(float);	data_Length			= data_Count = xCount * yCount;	dataNew = data 	= (float*)*theDataHandle;	++data;	k = 0;	for(i = 0; i < data_Count;i++,dataNew++,data += 2){		double d1,d2;		d1 = *data;		d2 = data[1];		*dataNew = (float)Cabs(Complex(d1,d2));	}	D_HUnlock(theDataHandle);	}void	PattersonObject::SetUpStrucFactMap(void){	SmallSpotInfoPtr 	theData;	long	i,k,l;	float	*intenPtr,**intenHdn;	double	maxX,delX,maxXSqr,delY;	long	totalValues;		totalValues = ((2 * xCount * yCount) + 5);	intenHdn = (float**)D_NewHandle(totalValues * sizeof(float));	D_HLock((Handle)intenHdn);		intenPtr = *intenHdn;	for(i = 0; i < totalValues;i++,intenPtr++){		*intenPtr = 0;	}	intenPtr = *intenHdn;	maxX = theLens->apperatureRadius;	delX = (maxX) / (double)xCount;	delY = (maxX) / (double)yCount;	D_HLock((Handle)theDataHandle);	theData = (SmallSpotInfoPtr)*theDataHandle;		maxXSqr = maxX * maxX;	for(i = 0; i < data_Count;i++,theData++){		long place;				 k = Round((theData->x + maxX)/ delX);		 l = Round((theData->y + maxX)/ delY);		 place = ((k * xCount + l) * 2) + 1;		 if(place >= totalValues || place < 1){		 	continue;		 }		 intenPtr[place] = (float)theData->sF.r;		 intenPtr[place + 1] = (float)theData->sF.i;	}	D_HUnlock((Handle)intenHdn);	D_HUnlock((Handle)theDataHandle);	KillTempHandle((Handle*)&theDataHandle);	theDataHandle = (Handle)intenHdn;}void	PattersonObject::DoClose(void){	theLens->DoClose();	inherited::DoClose();}void	PattersonObject::DoMenu(long theResult){	short 	theMenu,theItem;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);			switch(theMenu){				case PARAMETER_MENU:			switch(theItem){				case LENS_CONTROL_DEF:					theLens->DoDefine();					break;					default:					inherited::DoMenu(theResult); 					break;			}			break;		default:			inherited::DoMenu(theResult); 			break;	}		HiliteMenu(0);	return;}void	PattersonObject::CalculateSigma(void){}void	PattersonObject::SetCalculationParameters(void){		redraw = true;	plotFlags[0] 	 = 	1;	negWidth		=	90;	negHeight		=	90;	}Boolean	PattersonObject::TestIntensity(double intensity){		return false;	}void		PattersonObject::NormalizeIntensity(short baseCrystal,double maxIntensity[4]){	short i;	SmallSpotInfoPtr thisSpot;		D_MFTempHLock			((Handle)theDataHandle);	thisSpot		= 	(SmallSpotInfoPtr)*theDataHandle;	for(i = 0;i <  data_Count;thisSpot++,i++){		thisSpot->intensity /= maxIntensity[0];	}	D_MFTempHUnlock			((Handle)theDataHandle);}void PattersonObject::SetIntensities(void){	short jz;	SmallSpotInfoPtr	theData;	if(plotType > 2){		inherited::SetIntensities();		return;	}	theData = (SmallSpotInfoPtr)*theDataHandle;	maxIntensity	= -1957;	minIntensity	= 1957;	if(plotType == 0){		for(jz = 0 ; jz < data_Count ; jz++,theData++){			if(theData->intensity > maxIntensity){				maxIntensity = theData->intensity ;			} else if(theData->intensity  < minIntensity){				minIntensity = theData->intensity;			}		}		return;	}		if(plotType == 1){		for(jz = 0 ; jz < data_Count ; jz++,theData++){			if(theData->sF.r > maxIntensity){				maxIntensity = theData->sF.r ;			} else if(theData->sF.r  < minIntensity){				minIntensity = theData->sF.r;			}		}		return;	}		if(plotType == 2){		for(jz = 0 ; jz < data_Count ; jz++,theData++){			if(theData->sF.i > maxIntensity){				maxIntensity = theData->sF.i ;			} else if(theData->sF.i  < minIntensity){				minIntensity = theData->sF.i;			}		}	}}void PattersonObject::DoDefine(void){	DialogPtr 		theDialog;	short			theSelect,lastSelect;	Boolean			quit,calculateFlag;	PopUpMenu		*theMenu;	double			dValue;		theDialog	= DM_GetNewDialog(307,NUL,IN_FRONT);	GetDItem(theDialog,3 + baseCrystal,&gType,&gTheHandle,&gTheRect);	SetCtlValue((ControlHandle)gTheHandle,true);		theZoneAxis->SetIndex(theDialog,7);	dValue = xCount;	SetItemValue(theDialog,8,dValue,0);		dValue = yCount;	SetItemValue(theDialog,9,dValue,0);	theMenu = (PopUpMenu*)D_new(PopUpMenu);		theMenu->Init( theDialog, 10,36,plotType + 1);	calculateFlag = quit = false;		lastSelect = 3 + baseCrystal;	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case -1:			case 2:				quit = true;				break;			case 1:								calculateFlag = true;					theZoneAxis->GetIndex(theDialog,7) ;				plotType 	= 	theMenu->lastResult - 1;				xCount		=	(short)GetItemValue(theDialog,8);				yCount		=	(short)GetItemValue(theDialog,9);				quit = true;				baseCrystal = lastSelect - 3;				break;			case 3:			case 4:			case 5:			case 6:				GetDItem(theDialog,theSelect,&gType,&gTheHandle,&gTheRect);				if(GetCtlValue((ControlHandle)gTheHandle) == 0){					SetCtlValue((ControlHandle)gTheHandle,1);					GetDItem(theDialog,lastSelect,&gType,&gTheHandle,&gTheRect);					SetCtlValue((ControlHandle)gTheHandle,0);					lastSelect = theSelect;				}				break;						case 10:				theMenu->DoPopUp();				break;			default:				break;		}	}		theMenu->DoClose();	DM_DisposDialog(&theDialog);		if(calculateFlag){		calculateFlag = true;		reSizeFlag = true;		redraw = true;	} 	return;}