//ects:D.M. v2.0:Sources.Jim:X-Ray Diffract:XR_DiffractometerObj.c#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"SF_MathLib.h"#include	"DiffractometerObj.h"#include	"GraphSpots.h"#include 	"PointObj.h"#include	"AbsorptionLabels.h"#include "UA2_Text_Box.h"#include "UextBoxFree.h"void DiffractometerObj::DoInit() {	graph = 0L;	minX =	0;	maxX = 100;	fullSim	= false;	inherited::DoInit();	}void DiffractometerObj::SetObjectMenu(){	theMenuBar = GetNewMBar(DIFFRACT_METER_MB);	SetMenuBar(theMenuBar);	}void	DiffractometerObj::InitializeGraph(void){	SetRect							(&graphBox,80,80,516,350);	if(graph && graph->objectType == 1){		graph->minX = minX;		graph->maxX = maxX;		/*Temp*/KillHandle(&theDataHandle);		theDataHandle = 0L;		return;	}	if(graph)graph->DoClose(graph);	if(theDataHandle)	/*Temp*/KillHandle(&theDataHandle);	theDataHandle = 0L;	currentGraph 	=	graph	= (GraphSpots*)D_new(GraphSpots);	if(!graph)return;	graph->DoInit(graphBox,theCrystal[0]->crystalColor,true,true);	graph->minX = minX;	graph->maxX = maxX;	graph->numXTicks = 10;	sprintf				(gTheText,"2 Theta in Degrees");	graph->SetTitleX	(gTheText);	sprintf				(gTheText,"Intensity as Percentage");	graph->SetTitleY	(gTheText);	sprintf				(gTheText,"Diffractometer");	graph->SetTitleGraph(gTheText);	c2pstr(gTheText);	graph->titleMenu->P_AppendMenu	(gTheText);	graph->titleMenu->P_CheckItem		(2,true);}  void	DiffractometerObj::SetObjectWindowTitle(void){		//	InsertMenu(g_Spectra_Menu,-1);		 /* Added by J.T. April 1995 */	SetRect(&theCourserRect,graphBox.left,graphBox.top,graphBox.left + 2,graphBox.bottom);			theBeamFlag = 2;	energy =  theXRay->energy;	wavelength = theXRay->wavelength;	maxEnergy = energy;	slitSize	=	.01;	stepSize	=	.1;	dwellTime	=	.1;	autoScale	=	true;	theRuler->SetBeamButton(theBeamFlag);		if(gTheFile->file_is_Open){		SetWTitle(theWindow,fileInfo.sfFile.name);		return;	}	sprintf(gTheText,"Diffractometer %d",g_Window_Number);	SetWTitle(theWindow,c2pstr(gTheText));	g_Window_Number++;	}void 	DiffractometerObj::DoClose			(void){	inherited::DoClose();}double DiffractometerObj::SetRecpSize(void){	return 2. * sin(.5 * graph->maxX * PI / 180) / wavelength;}void	DiffractometerObj::MyCalculate(void){		long 		thehMax,thekMax,thelMax,i;		Ptr *theHandle;		long		hmax,kmax,lmax;				double 		theDist,reciprocalLatticeSize,intens;		SpotInfoPtr	theSpots,thisSpot;		short double 		maxIntensity[4];		short			plotCrystal,h,k,l,atom_Count;		Crystal 	*thisCrystal;		double		correction;				double 		*theUs,*theVs,*theWs,							*theZs,*theBs,							inverseVol,inverseVolSqr;							double  	dH,dK,dL,cutOff;		double 		sh2 , sk2 , sl2 , skl , shl , shk,theta;		long		**theValue;		dcomplex	maxSF[4],cAb,sF0;		data_Count = 0;	InitializeGraph();	data_Length			=	100;	data_Expand			=	50;	data_Count			=	0;	data_Size				=	sizeof(SpotInfo);	if(theDataHandle != 0L)/*Temp*/KillHandle				(&theDataHandle);	theDataHandle		= 	/*Temp*/D_NewHandle(data_Length * data_Size);//,&gTheOSError	thisSpot	=	(SpotInfoPtr)*theDataHandle;		autoScale	=	true;	/*MFTemp*/D_HLock(theDataHandle);	theSpots = (SpotInfoPtr)*theDataHandle;		if(graph)graph->hidden = false;	for(i = 0; i <= 3;i++)calculateFlags[i] = false;		thisSpot	= (SpotInfoPtr)*theDataHandle;	data_Count++;	thisSpot->intensity = (short double)0;	thisSpot->x =  0.0;	thisSpot->y = 0.0;	thisSpot->z =  0.0;	thisSpot->angle = 0.0;	thisSpot->h = 0;	thisSpot->k = 0;	thisSpot->l = 0;	thisSpot->direction = true;	thisSpot->theCrystal = theZoneAxis->theCrystal;	thisSpot->flags = baseCrystal;	for(i = 0 ; i <= 3; i++){		maxIntensity[i] = 0;	}		for(plotCrystal  = baseCrystal; plotCrystal <= 3 && gNoBreak ; plotCrystal++){			double sV0,sV1,sV2,sV3,sV4,sV5;		if(!plotFlags[plotCrystal] )			continue;				thisCrystal = 	theCrystal[plotCrystal];				sV0	= thisCrystal->sVals[0];		sV1	= thisCrystal->sVals[1];		sV2	= thisCrystal->sVals[2];		sV3	= thisCrystal->sVals[3];		sV4	= thisCrystal->sVals[4];		sV5	= thisCrystal->sVals[5];				if(!SetScatteringPosAIntensity(thisCrystal,&theUs,&theVs,&theWs,&theZs,&theBs,&atom_Count))goto FINISHDOFF;		theHandle = thisCrystal->AtomicScatteringSet( 1. + ( (double)energy / 511.),theBeamFlag);		if(plotCrystal  == baseCrystal){			startCount[plotCrystal] = 0;			((SpotInfoPtr)(*theDataHandle))->sF	= TotalStructureFactor(0,0,0,theUs,theVs,theWs,atom_Count,theZs,theBs,thisCrystal->volume,10000,thisCrystal,&cAb);			((SpotInfoPtr)(*theDataHandle))->angle = 1;			cutOff = ((SpotInfoPtr)(*theDataHandle))->sF.r * .00001;		}else{				sF0	= TotalStructureFactor(0,0,0,theUs,theVs,theWs,atom_Count,theZs,theBs,thisCrystal->volume,10000,thisCrystal,&cAb);				cutOff = sF0.r * .00001;				startCount[plotCrystal] = data_Count;				thisSpot 			= &(theSpots[data_Count++]);				thisSpot->intensity = (short double)1;				thisSpot->x 		=  (short double)0;				thisSpot->y 		=  (short double)0;				thisSpot->z 		=  (short double)0;				thisSpot->h 		= (short)0;				thisSpot->k 		= (short)0;				thisSpot->l 		= (short)0;				thisSpot->direction = true;				thisSpot->theCrystal = thisCrystal;				thisSpot->angle = 1;				thisSpot->flags = (long)(plotCrystal);					thisSpot->sF			=	sF0;			}				calculateFlags[plotCrystal] = true;					reciprocalLatticeSize = SetRecpSize();		hmax = SizeofReciprocalLattice(1.,0.,0.,reciprocalLatticeSize,thisCrystal);		kmax = SizeofReciprocalLattice(0.,1.,0.,reciprocalLatticeSize,thisCrystal);		lmax = SizeofReciprocalLattice(0.,0.,1.,reciprocalLatticeSize,thisCrystal);				hmax++;		kmax++;		lmax++;		if(lmax > 12){			hmax = 12;			kmax = 12;			lmax = 12;		}						thehMax = -hmax;		thekMax = -kmax;		thelMax = -lmax;		/************** Removed a switch statement from here ***************/				inverseVol = 1. / thisCrystal->volume;		inverseVolSqr = inverseVol * inverseVol;		if(data_Count == 1){	 		thisSpot->sF	=   TotalStructureFactor(0,0,0,theUs,theVs,theWs,atom_Count,theZs,theBs,thisCrystal->volume,1,thisCrystal,&cAb);			thisSpot->intensity 		= 	(double)Cabs(thisSpot->sF);		}		 for(h = thehMax ; h <= hmax && gNoBreak ; h++)		{						sh2 = h *  h * sV0;			for(k = thekMax; k <= kmax && gNoBreak ; k++)			{								sk2 = k * k * sV1;				shk = 2 * k * h * sV3;				for(l =  thelMax; l <= lmax && gNoBreak ; l++)				{					dcomplex sF;					if(h == 0 && k == 0 && l == 0)						continue;					skl = 2 * k * l * sV4;					shl = 2 * h * l * sV5;					sl2 = l  * l * sV2;					theDist = sqrt((sh2 + sk2 + sl2 + skl + shl + shk) * inverseVolSqr);					if(theDist >  reciprocalLatticeSize) continue;																									dH = (double)h;					dK = (double)k;					dL = (double)l;					AllowBackground();					if(!dynamic_Calc){						AtomicScatterForDFromSet(theDist,theHandle,theZs,atom_Count);						sF				= 	TotalStructureFactor(dH,dK,dL,theUs,theVs,theWs,atom_Count,theZs,theBs,thisCrystal->volume,1/theDist,thisCrystal,&cAb);						intens 			= 	(double)Cabs(sF);					}else{						SpotInfoD theSpotsSt[2];						short nout;						dcomplex sFp[2];						theSpotsSt[0].h = 0;theSpotsSt[0].k = 0;theSpotsSt[0].l = 0;						theSpotsSt[0].x = 0;theSpotsSt[0].y = 0;theSpotsSt[0].z = 0;						theSpotsSt[0].theCrystal = thisCrystal;						theSpotsSt[0].sF = sF0;						theSpotsSt[1].h = dH;theSpotsSt[1].k = dK;theSpotsSt[1].l = dL;						theSpotsSt[1].x = theDist;theSpotsSt[1].y = 0;theSpotsSt[1].z = 0;						theSpotsSt[1].theCrystal = thisCrystal;						theSpotsSt[1].sF = sF;						intens = Single2BeamWaveDynamic(&nout,sFp,theSpotsSt);						sF = sFp[1];					}					if(intens < cutOff) continue;					theta = asin(wavelength * theDist * .5);					correction = (1 + cos( 2 * theta) * cos(2 * theta)) / (sin(theta) * sin(theta) * cos(theta));//Lorentz Polarization factor					intens *= correction; 				//	intens *= intens; 					RCmul(correction,sF);										if(OverlapSpotExists(theDist,intens,h,k,l,thisCrystal,sF)) continue;																					if(data_Count >= data_Length){						ExpandMemory();						theSpots = (SpotInfoPtr)*theDataHandle;					}										thisSpot 			= &(theSpots[data_Count++]);					thisSpot->intensity = (short double)intens;					thisSpot->x 		=  (short double)theDist;					thisSpot->y 		=  (short double)(theta * 360./PI);					thisSpot->z 		=  (short double)0;					thisSpot->h 		= (short)h;					thisSpot->k 		= (short)k;					thisSpot->l 		= (short)l;					thisSpot->direction = false;					thisSpot->theCrystal = thisCrystal;					thisSpot->angle = 0.0;					thisSpot->flags = (long)(plotCrystal);						thisSpot->sF			=	sF;														}			}		}		KillPtr((Ptr)theUs);		thisCrystal->ClearAtomicScatSet(theHandle);	}	CreateCompositeSpots();	FINISHDOFF:	/*MFTemp*/D_HUnlock			((Handle)theDataHandle);	if(data_Length >  data_Count){		D_RecoverMemory		(theDataHandle,data_Size,(long)data_Count);	}	data_Length 	= 	data_Count;	thisSpot = (SpotInfoPtr)*theDataHandle;	thisSpot->sF.r = 1;	thisSpot->sF.i = 0;	thisSpot++;	for(i = 1;i < data_Count;thisSpot++,i++){		if(startCount[thisSpot->flags & CRYSTAL_MASK] == i)continue;		if(thisSpot->intensity > maxIntensity[thisSpot->flags]){			 maxIntensity[thisSpot->flags] = thisSpot->intensity;			 maxSF[thisSpot->flags] = thisSpot->sF;		}		}		thisSpot = (SpotInfoPtr)*theDataHandle;	thisSpot->sF.r = 1;	thisSpot->sF.i = 0;	thisSpot++;	for(i = 1;i < data_Count;thisSpot++,i++){		if(thisSpot->flags != baseCrystal){			thisSpot->intensity /= (maxIntensity[thisSpot->flags] / the_PPT_Info[thisSpot->flags - 1]->intensity);			thisSpot->sF = RCmul(1/(maxSF[thisSpot->flags].r / the_PPT_Info[thisSpot->flags - 1]->intensity),thisSpot->sF);		}else{			thisSpot->intensity /= maxIntensity[thisSpot->flags];			thisSpot->sF = RCmul(1/maxSF[thisSpot->flags].r,thisSpot->sF);		}	}			if(graph){		theValue	= (long**)D_NewHandle(sizeof(long) * 2);		numSpots = **theValue = (long)data_Count;		graph->SetValues(theDataHandle,(Handle)theValue);		KillHandle((Handle*)&theValue);	}	if(fullSim){		double hMaxAvg;		hMaxAvg = thehMax + thekMax + thekMax;		CalcFullSimulation(fabs(hMaxAvg)/3);	}}void	DiffractometerObj::CalcFullSimulation(double hMaxAvg){	GraphFunction *fft,*ifft,*spectra,*slot,*mult,*power;	SpotInfoD theSpotsSt[2];	short nout;	SpotInfoPtr		aSpot,centerspot;	double				**theIs,*theI,*theIi;	dcomplex sFp[2];	short 		i,nStart,p,k,nEnd;	double		delX,totDelH,delH,intens,correction,theta;;		centerspot = aSpot = (SpotInfoPtr)*theDataHandle;	theSpotsSt[0].h = 0;theSpotsSt[0].k = 0;theSpotsSt[0].l = 0;	theSpotsSt[0].x = 0;theSpotsSt[0].y = 0;theSpotsSt[0].z = 0;	theIs = (double**)D_NewHandle(sizeof(double) * 2048);	D_HLock((Handle)theIs);	theI = *theIs;	for(i = 0;i < 2048;i++,theI++)*theI = 0;	delH = hMaxAvg /1024;	delX = (graph->maxX - graph->minX)/1024;	theI = *theIs;		for(i = 0; i < data_Count;i++,aSpot++)	{		theSpotsSt[0].theCrystal = aSpot->theCrystal;		theSpotsSt[0].sF = centerspot[startCount[aSpot->flags & CRYSTAL_MASK]].sF;						theSpotsSt[1].h = aSpot->h;theSpotsSt[1].k = aSpot->k;theSpotsSt[1].l = aSpot->l;		theSpotsSt[1].x = aSpot->x;theSpotsSt[1].z = 0;		theSpotsSt[1].theCrystal = aSpot->theCrystal;				nStart = (aSpot->y / delX);		theta = aSpot->y  * PI/360;		if(theta < 0.0001){			correction = 10;		}else{			correction = (1 + cos( 2 * theta) * cos(2 * theta)) / (sin(theta) * sin(theta) * cos(theta));		}		correction *= aSpot->angle;		nEnd = 121;		nStart *= 2;		nStart -= 120;		totDelH = -60 * delH;		theSpotsSt[1].y = -60 * delX;		if(nStart < 0){p = fabs((double)nStart);nStart = 0;totDelH += p * delH;theSpotsSt[1].y = 0;}		if(nStart + 242 >= 2048)nEnd -= (nStart/2) - 903;		if(nEnd < 0)continue;		theIi = &theI[nStart];		theSpotsSt[1].h += totDelH;theSpotsSt[1].k += totDelH;theSpotsSt[1].l += totDelH;		for(k = 0;k < nEnd;k++,theIi++){			intens = Single2BeamWaveDynamic(&nout,sFp,theSpotsSt);			theSpotsSt[1].h += delH;theSpotsSt[1].k += delH;theSpotsSt[1].l += delH;			theSpotsSt[1].y += delX;					*theIi += sFp[1].r * correction;			theIi++;			*theIi += sFp[1].i * correction;		}			}	//	spectra =  ((GraphSpots*)graph)->ConvertToSpectra(2048,graph->minX,graph->maxX,this);	spectra	=	(GraphFunction*)D_new(GraphFunction);		spectra->DoInit(graph->frame, graph->color,false,true);		D_HUnlock((Handle)theIs);	spectra->SetValues(0L,(Handle)theIs);		KillHandle((Handle*)&theIs);		fft		=	spectra->StdFFTGraph(1);		theta = 180 * asin(slitSize/cameraLength)/PI;	slot	=	graph	->	MakeTopHat(0,theta ,fft->noPtsY,graph->minX,graph->maxX);	mult	=	fft->MultiplyGraphs(slot);		ifft 	= 	mult->StdFFTGraph(-1);	//	power = ifft->GetPowerSpectra();//	power->NormalizeToOwner(graph);	power = ifft->GetPowerSpectra();	D_HLock(power->yData);	delX = (graph->maxX - graph->minX)/power->noPtsY;	nStart = theta * .5 / delX;	theI = (double*)*power->yData;	theIi = &(theI[nStart]);	for(i = nStart;i < power->noPtsY;i++,theIi++,theI++){		*theI = *theIi;	}	for(i = 0;i < nStart;i++,theI++){		*theI = 0;	}	D_HUnlock(power->yData);	power->NormalizeToOwner(graph);	currentGraph	=	graph->AddGraph(graph,power,graph->frame);	spectra 	->DoClose(spectra);	fft		->DoClose(fft);	slot	->DoClose(slot);	mult	->DoClose(mult);	ifft 	->DoClose(ifft);		newPictReq = true;}Boolean	DiffractometerObj::OverlapSpotExists(double theDist,double intens,short h,short k,short l,Crystal *aCrystal,dcomplex sF){	short i;	SpotInfoPtr thisSpot;		if(data_Count <= 1) return false;	thisSpot = (SpotInfoPtr)*theDataHandle;	thisSpot++;	for(i = 1; i < data_Count; i++,thisSpot++){		if(fabs((double)theDist - (double)thisSpot->x) < 0.00001){			if(thisSpot->theCrystal != aCrystal)				continue;			obj_Index->CopyPtrToIndex((Ptr)thisSpot);			if(!obj_Index->CompareTo(h,k,l))continue;			thisSpot->intensity += intens;			thisSpot->sF.r += sF.r;			thisSpot->sF.i += sF.i;			if(thisSpot->h + thisSpot->k + thisSpot->l < (short)h + (short)k + (short)l){				thisSpot->h = h;				thisSpot->k = k;				thisSpot->l = l;				thisSpot->angle += 1;			}			return true;		}	}	return false;}void	DiffractometerObj::CreateCompositeSpots(void){	SpotInfoPtr	theSpots,thisSpot,aSpot;	short	i;	double	x;	thisSpot = (SpotInfoPtr)*theDataHandle;	thisSpot->x = .00001;		qsort(*theDataHandle,(short)(data_Count),sizeof(SpotInfo),(_compare_function/*__cmp_func_Cmpfun**/)InverseDSpaceCompare);		thisSpot = (SpotInfoPtr)*theDataHandle;	thisSpot->x = .01;		thisSpot++;	theSpots = (SpotInfoPtr)*theDataHandle;	for(i = 1; i < data_Count;i++,thisSpot++){		x = thisSpot->x;		if(fabs(thisSpot->x - thisSpot[1].x) < .0001){			if(data_Count >= data_Length){				ExpandMemory();				theSpots = (SpotInfoPtr)*theDataHandle;				thisSpot = &(theSpots[i]);			}			aSpot 			= &(theSpots[data_Count++]);			aSpot->intensity = thisSpot->intensity;			aSpot->x = thisSpot->x;			aSpot->y = thisSpot->y;			aSpot->z = thisSpot->z;			aSpot->h = thisSpot->h;			aSpot->k = thisSpot->k;			aSpot->l = thisSpot->l;			aSpot->direction = thisSpot->direction;			aSpot->theCrystal = thisSpot->theCrystal;			aSpot->angle = thisSpot->angle;			aSpot->flags = thisSpot->flags;				thisSpot++;			i++;			while(fabs(thisSpot->x - x) < .0001 && i < data_Count - 1){				aSpot->intensity += thisSpot->intensity;				thisSpot++;				i++;			}			thisSpot--;			i--;		}	}}void	DiffractometerObj::DoPrint(void){	inherited::DoPrint();	ResizeGraphBox();}void	DiffractometerObj::DoPictDraw(void){	double		min,max;	if(graph == 0L || theDataHandle == 0L) return;	SetDrawEnviron();	if(autoScale){		min = 1000;max = -1000;		graph->AllMinMaxY(&min,&max);		graph->pMinY = min;		graph->pMaxY = max;		autoScale	=	false;	}	//graph->PlotGraph();	theDataHandle = graph->yData;		if(!graph->shrunk)theSearchObj->PlotRings(scaleFactor,graph->scaleY,centerX,centerY,graph->pMinX, graph->pMinX);	ClearDrawEnviron();}void	DiffractometerObj::ResizeGraphBox(void){		thePictRect = theWindow->portRect;	objectSize.h = thePictRect.right;	objectSize.v = thePictRect.bottom;	thePictRect.right	-= 15;	thePictRect.left	+= 15;	thePictRect.bottom	-= 15;	thePictRect.top		+= rulerHeight;	hScroll->ReInit();	vScroll->ReInit();	graphBox = thePictRect;	graphBox.top += 80;	graphBox.left += 60;	graphBox.bottom -= 60;	graphBox.right -= 15;	graph->SetFrame(graphBox);	SetRect(&theCourserRect,graphBox.left,graphBox.top,graphBox.left + 2,graphBox.bottom);}PicHandle	DiffractometerObj::SetPrintPicture(void){	PicHandle megaPicture;			megaPicture = OpenPicture(&thePictRect);		if((long)picObjList != NUL){			PenMode(transparent+addPin);			picObjList->DrawThePicts();		}				DrawPicture(screenPict,&thePictRect);	ClosePicture();		return megaPicture;}void		DiffractometerObj::DoDblClick(Point thePoint){		inherited::DoDblClick(thePoint);}Boolean	DiffractometerObj::DoContent(Point thePoint){	//if(graph)graph->DoContent(thePoint);	return inherited::DoContent(thePoint);}void		DiffractometerObj::DoIdle(void){	Point thePoint;		GetMouse(&thePoint);	DoCourser(thePoint);	inherited::DoIdle();		}void		DiffractometerObj::GraphValues(Point thePoint,double *angle,double *dspace,double *intensity){	double 		theValue,thetaSine;	graph->XYValue(thePoint,angle,intensity);		theValue = *angle;	thetaSine = 2 * sin(theValue * PI / 360);	if(thetaSine <= .0005)*dspace = 0.0;	else *dspace = wavelength / thetaSine;		}void		DiffractometerObj::DoCourser(Point thePoint){		static Point 		oldPoint;	double			theValue,dspace,intensity;	GetMouse(&thePoint);	if(!PtInRect(thePoint,&graph->frame) || graph->shrunk)		return;	if(oldPoint.h == thePoint.h)		return;	theRuler->SetPrompt("Cursor Info:"); 	GraphValues(thePoint,&theValue,&dspace,&intensity);	sprintf(gTheText,"2 Theta = %6.2f °,D-Spacing = %7.3f Å Relative Intensity = %5.1f",theValue,dspace,100 * intensity);	theRuler			->SetInfo(gTheText);	oldPoint 		= 	thePoint;}void	DiffractometerObj::OpenGeneral(void){	graph->OpenFileText();}void	DiffractometerObj::DoMenu(long theResult){	short theMenu,theItem;	static Boolean searchFlag = true;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);	switch(theMenu){		case DIFDEFINE:			switch(theItem){				case 1:					//DoDefine();					DoSetUp();					break;				case 2:					DoCalculate();					ResizeGraphBox();					newPictReq = true;					break;			}			break;			case DIFINFO:			switch(theItem){				case CONVERT_TO_TEXT_D:					ConvertToTextTable();				break;				case	LABEL_SPOT_D:					functionID		= LABEL_SPOT_F;					theRuler->SetPrompt("Add Label");					theRuler->SetHelp("Labels toggle on/off with succesive clicks. Hold <shift> for hidden spots.<opt-t> to label crys to 3.<opt-shift-t>to label crys. to max <a instead of t> for all crystals.");/*dec 1992*/					SetTheCursor(TARGET_CURSOR);					graph->labelOn = true;					break;				case	SHOW_INFO_D:					functionID		= SHOW_INFO_F;					theRuler->SetHelp("Click on spot & hold to view info.  Shift-click to view hidden spots.");/*dec 1992*/					theRuler->SetPrompt("Show Info:");					SetTheCursor(TARGET_CURSOR);					graph->labelOn = true;					break;				case ZOOM_FUNCTION:					functionID = ZOOM_PLOT;					graph->labelOn = false;					theRuler->SetPrompt("Zoom In");					theRuler->SetHelp("Zoom-In (x2) each click, Around click point. shift-Click to Zoom Out to original graph.");					SetTheCursor(TARGET_CURSOR);					break;				case RESIZE_GRAPH:					ResizeGraphBox();					//SetPict(true);					newPictReq = true;					break;				default:					break;			}			break;						case DIFEXPINFO:						break;		case 52:			CheckItem(base_Crystal_Menu,referenceCrystal + 1,false);			referenceCrystal = theItem - 1;				CheckItem(base_Crystal_Menu,theItem,true);			break;		case SADSEARCH:			if(theItem > 5){				theSearchObj->wavelength = wavelength;				theSearchObj->requiredFOM = TWO_THETA_SEARCH;				theSearchObj->DoMenu(theResult);			}else					inherited::DoMenu(theResult);			break;				case SELECT_SPECTRA:						UpdateGraph(theItem,0L);			if(!currentGraph->plotGraph){				currentGraph->plotGraph = true;				//SetPict(true);				newPictReq = true;			}			break;		default:			inherited::DoMenu(theResult); 			break;	}		HiliteMenu(0);	return;}void	DiffractometerObj::UpdateGraph(short theItem,GraphFunction *newGraph){	short graphNo;	graphNo = 1;	currentGraph =	graph->FindGraph(newGraph,&graphNo);	graph->titleMenu->P_CheckItem(graphNo,false);	if(newGraph == 0L){		graphNo = 0;		currentGraph	=	graph	->FindGraphByNum(theItem,graphNo);		graph->titleMenu->P_CheckItem(theItem,true);	}else{		graphNo = 1;		currentGraph =	graph->FindGraph(newGraph,&graphNo);		graph->titleMenu->P_CheckItem(graphNo,true);	}	}void	DiffractometerObj::DoAuxRead(void){	gTheFile->ReadDataBlock((Ptr)&graphBox,sizeof(Rect));	gTheFile->ReadDataBlock((Ptr)&theCourserRect,sizeof(Rect));		inherited::DoAuxRead();}void	DiffractometerObj::DoAuxWrite(void){	gTheFile->WriteDataBlock((Ptr)&graphBox,sizeof(Rect));	gTheFile->WriteDataBlock((Ptr)&theCourserRect,sizeof(Rect));		inherited::DoAuxWrite();}void DiffractometerObj::DrawTheText(void)//Override{}void DiffractometerObj::DoARotation(double angle,short axis){	 angle = angle;	 axis = axis;}#pragma segment Mainvoid  DiffractometerObj::ConvertToTextTable(void)//Override{		SpotInfoPtr    theSpot;	Index				*theIndex;	short				i,k;	double electronMassRation;	if(textBox == 0L){		Rect 			rDataBnds,theRect;		Point 		cellSize;		short			hor,ver;		char			text[100];		hor						= (thePictRect.right - thePictRect.left) * .25;		ver						= (thePictRect.bottom - thePictRect.top) * .25;			textBox				=	(TextBoxFree*)D_new(TextBoxFree);		SetRect(&rDataBnds,0,0,5,numSpots - 1);		SetRect(&theRect,thePictRect.left,thePictRect.top + 30,thePictRect.left + hor + 18,thePictRect.top + ver + 48);		cellSize.h = 80;		cellSize.v = 15;		textBox		-> DoInit(&theRect,&rDataBnds,cellSize,0,theWindow,true,true,true,true,true,true,geneva,9,0);		textBox		-> ResetCell();		textBox		->selected = true;		textBox		-> SetColumnWidth(0,80);		textBox		->selected = false;		 TMX_SetOptions(tmBorder,textBox		->theList);		 sprintf(gTheText,"hkl\tdspace\t2Theta°\tRel. Intensity\t");		 switch(g_StructureEV){		 		case 0:					sprintf(text,"S.F. R,Im Fg Å\t Intensity Å-2");					break;				case 1:					sprintf(text,"S.F. R,Im Vg eV\t Intensity eV2");					break;				case 2:					sprintf(text,"S.F. R,Im Ug\t Intensity Ug2");					break;			 }		 strcat(gTheText,text);		 textBox->SetColumnTitle(gTheText,0);		 textBox		->DrawList();	}	theSpot = (SpotInfoPtr)*theDataHandle;	theIndex = (Index*)D_new(Index);	gTheText[0] = 0;	electronMassRation 	= 	1. + ( (double)energy / 511.);	for(i = 0 ; i < numSpots;i++)	{		dcomplex sF;					for(k = 1 ; k < 7;k++){				switch(k){					case 1:						theIndex			->CopyPtrToIndex((Ptr)(&(theSpot[i])));						theIndex			->IndexToSimpleText(gTheText);						break;					case 2:								sprintf					(gTheText,"%6.4f",theSpot[i].x);					break;					case 3:								sprintf					(gTheText,"%6.4f",theSpot[i].y);							break;										case 4:							sprintf						(gTheText,"%6.4f",theSpot[i].intensity);										break;												case 5:							if(!theSpot[i].direction){								theIndex-> IndexStructureFactor(1/theSpot[i].x, electronMassRation,theBeamFlag,&sF);							}else{									theIndex->direction = false;									theIndex->h = theIndex->k = theIndex->l = 0;									theIndex-> IndexStructureFactor(0, electronMassRation,theBeamFlag,&sF);							}							sF = theSpot[i].sF;							sF = ConvertStructureFactor(sF,g_StructureEV,theSpot[i].theCrystal->volume);							sprintf						(gTheText,"%6.4f , %6.4f",sF.r,sF.i);					break;					case 6:							sprintf						(gTheText,"%6.4f",Cabs(sF) * Cabs(sF) );					break;				}					textBox					->AddListText(gTheText);			}	}	theIndex			->DoClose();}PicHandle		DiffractometerObj::SetInfoPict(void){	short		n,vSpace,h,v;	double		value;	Rect		theRect;	PicHandle	thePicture;	Point		thePoint;	RgnHandle	clipRgn;	dcomplex	sF;		if(spotLoc < 0) 		return((PicHandle)NUL);/*dec 1992*/	if(obj_Index->direction){		SetRect(&theRect,0,0,180,180);/*dec 1992*/	} else {		SetRect(&theRect,0,0,180,180);	}	clipRgn = D_NewRgn();	GetClip(gTheRgn);	RectRgn(clipRgn,&theRect);	D_SetClip(clipRgn);	ForeColor (blackColor);	BackColor (whiteColor);	thePicture = OpenPicture(&theRect);		dm_EraseRect(&theRect);	h = 10;	v = 18;	vSpace = 15;		n = sprintf(gTheText,"Spot Index: ");	MoveTo(h,v);	DrawText(gTheText,0,n);	c2pstr(gTheText);	n = StringWidth((unsigned char*)gTheText);	thePoint.h = h + n;	thePoint.v = v;	obj_Index->ShowIndex(thePoint);	v += vSpace;		TextFont(newYork);	TextSize(9);		if(THE_CURRENT_SPOT.theCrystal->idNum == 0){		n = sprintf(gTheText,"Matrix");	} else {		n = sprintf(gTheText,"Crystal #%1d",THE_CURRENT_SPOT.theCrystal->idNum);	}	MoveTo(h,v);	DrawText(gTheText,0,n);	v += vSpace;	if(obj_Index->direction){		obj_Index->h = obj_Index->k = obj_Index->l = 0;		obj_Index->direction = false;	}	{		double electronMassRation;		dcomplex cAb;		value = obj_Index->theCrystal->DSpacing(obj_Index->h,obj_Index->k,obj_Index->l);		n = sprintf(gTheText,"D spacing : %6.4f Å",value);		MoveTo(h,v);		DrawText(gTheText,0,n);		v += vSpace;				value = obj_Index->theCrystal->DSpacing(obj_Index->h,obj_Index->k,obj_Index->l);		n = sprintf(gTheText,"2Theta %6.4f °",THE_CURRENT_SPOT.y);		MoveTo(h,v);		DrawText(gTheText,0,n);		v += vSpace;		electronMassRation = 1. + ( (double)energy / 511.);		if(value < .001)value = 0;		else{			value = 1/value;		}		value  = obj_Index->IndexStructureFactor(value,electronMassRation,theBeamFlag,&cAb);	 sF.r = value;	 sF.i = 0;	 sF = ConvertStructureFactor(sF,g_StructureEV,obj_Index->theCrystal->volume);		 		switch(g_StructureEV)		{			case 0:				n = sprintf(gTheText,"S. F. : %6.1f Å (Fg)",sF.r);				break;			case 1:				n = sprintf(gTheText,"S.F. : %6.1f eV (Vg)",sF.r);			break;			case 2:				n = sprintf(gTheText,"S.F. : %6.1f Å2 (Ug)",sF.r);				break;		}		MoveTo(h,v);		DrawText(gTheText,0,n);		v += vSpace;				switch(g_StructureEV)		{			case 0:				n = sprintf(gTheText,"S.F. Used In Plot : %6.1f, %6.1f Å (Fg)",THE_CURRENT_SPOT.sF.r,THE_CURRENT_SPOT.sF.i);			break;			case 1:				n = sprintf(gTheText,"S.F. Used In Plot : %6.1f, %6.1f eV (Vg)",THE_CURRENT_SPOT.sF.r,THE_CURRENT_SPOT.sF.i);			break;			case 2:				n = sprintf(gTheText,"S.F. Used In Plot : %6.1f, %6.1f Å2 (Ug)",THE_CURRENT_SPOT.sF.r,THE_CURRENT_SPOT.sF.i);			break;		}				MoveTo(h,v);		DrawText(gTheText,0,n);		v += vSpace;				n = sprintf(gTheText,"Rel. Intensity : %6.1f",100 *THE_CURRENT_SPOT.intensity);		MoveTo(h,v);		DrawText(gTheText,0,n);		v += vSpace;						if(value > .5){			value = obj_Index->TheExtinctionDist(1/wavelength,electronMassRation,theBeamFlag);			n = sprintf(gTheText,"Extinction Dist. : %6.0f Å",value);		}else{			n = sprintf(gTheText,"Extinction Dist. : Not Given");		}		MoveTo(h,v);		DrawText(gTheText,0,n);		v += vSpace;	}	InsetRect(&theRect,2,2);	PenSize(2,2);	dm_FrameRect(&theRect);	PenNormal();	TextFont(0);	TextSize(12);	ClosePicture();	D_DisposeRgn(&clipRgn);	DMBackColor(BACKGROUND_COLOR);	return(thePicture);}