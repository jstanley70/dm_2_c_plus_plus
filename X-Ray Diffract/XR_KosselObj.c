//ects:D.M. v2.0:Sources.Jim:X-Ray Diffract:XR_KosselObj.c#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"SF_MathLib.h"#include	"StereoObject.h"#include	"KikuchiObject.h"#include	"KosselObj.h"void KosselObj::SetObjectMenu(void){	theMenuBar = 		GetNewMBar(KOSSEL_OBJECT_MB);	ClearMenuBar();/* July 1992 */	SetMenuBar			(theMenuBar);}void	KosselObj::FinishSetUp(void){	inherited::FinishSetUp();	theBeamFlag = 2;	energy =  theXRay->energy;	wavelength = theXRay->wavelength;	maxEnergy = energy;	if(gTheFile->file_is_Open){		return;	}	sprintf(gTheText,"Kossel %d",g_Window_Number - 1);	SetWTitle(theWindow,c2pstr(gTheText));	centerX = (theWindow->portRect.right + theWindow->portRect.left) / 2;	centerY = (theWindow->portRect.bottom + theWindow->portRect.top) / 2;	} void KosselObj::SetScaleFactor(void) {    short hRes,vRes;	ScreenRes(&hRes,&vRes);	switch(theBeamFlag){		case 1:			cameraConstant = cameraLength 	= theEBeam->cameraConstant;			theEBeam->ReturnCameraLength(&cameraLength);			break;		case 2:			cameraConstant = cameraLength 	= theXRay->cameraConstant;			theXRay->ReturnCameraLength(&cameraLength);			break;		case 3:			cameraConstant = cameraLength 	= theIon->cameraConstant;			theIon->ReturnCameraLength(&cameraLength);			break;	}	scaleFactor 	= (double)cameraConstant * (double)hRes * magnification/ 25.4;	projLengthScreen = cameraLength * (double)hRes * magnification/ 25.4; }PicHandle	KosselObj::SetPrintPicture(void){	PicHandle megaPicture;			megaPicture = OpenPicture(&thePictRect);		if((long)picObjList != NUL){			PenMode(transparent+addPin);			picObjList->DrawThePicts();		}		DrawPicture(screenPict,&thePictRect);	ClosePicture();		return megaPicture;}void	KosselObj::DoPictDraw(void){	double 			factor;	Rect 				theOval,oldOval,newRect;	long 				theX,theY,count=0,drawMask,flagMask;	SpotInfoPtr thisSpot;	short 			theIdent,i,theValue;		SetScaleFactor();		radius = scaleFactor / wavelength;			SetDrawEnviron();	thisSpot = (SpotInfoPtr)*theDataHandle;	SetRect(&oldOval,-2,-2,2,2);	theValue = theIdent = thisSpot->flags & CRYSTAL_MASK;	SetRect(&newRect,centerX - 4,centerY - 4, centerX + 4,centerY + 4);	if(greyFlag && !thisSpot->direction){//plot a center spot		theValue = 220;		theValue += 15;	}	DM_DrawRect(newRect,theIdent,theValue,thisSpot->direction);	for(i = 1 ; i <= data_Count ; i++,thisSpot++){		double length;		flagMask = FLAG_MASK & thisSpot->flags;		drawMask = DRAW_MASK & thisSpot->flags;					if(!thisSpot->direction){			thisSpot->spotRect = oldOval;			DRAW_SMALL_CIRCLE(thisSpot);			continue;		}		if(thisSpot->z < -.05){thisSpot->spotRect = oldOval;continue;}		length = sqrt(thisSpot->y * thisSpot->y + thisSpot->x * thisSpot->x);				if(length > .000001 ){ 			factor	= radius * tan(acos(thisSpot->z));			theX	= centerX + Round((double)factor * thisSpot->y / length);			theY	= centerY + Round((double)factor * thisSpot->x / length);			theOval = oldOval;			thisSpot->spotRect = oldOval;			if(fabs((double)theX) > 1000 || fabs((double)theY) > 1000) continue;					}else{ 			theX	= centerX;			theY	= centerY;			theOval = oldOval;		}				OffsetRect(&theOval,(short)theX,(short)theY);		theIdent = thisSpot->flags & CRYSTAL_MASK;		thisSpot->spotRect = theOval;		theValue = theIdent;		if(plotZoneAxes && thisSpot->direction)DM_DrawRect(theOval,theIdent,theValue,thisSpot->direction);						if(thisSpot->flags & XTAL_ROT){			newRect = theOval;			InsetRect(&newRect,-1,-1);			dm_FrameRect(&newRect); 			DM_DrawRect(newRect,theIdent,theValue,thisSpot->direction);		}		if(flagMask){			if(drawMask){				DRAW_PLANE_TRACE(thisSpot);				DRAW_SMALL_CIRCLE(thisSpot);			}			if(thisSpot->flags & MARK_MASK){				DRAW_BEAM_SPOT(thisSpot,theX,theY);				DRAW_LINE_SPOT(thisSpot,theX,theY);				DRAW_DEFECT_SPOT(thisSpot,theX,theY);				DRAW_HABIT_PLANE(thisSpot);				DRAW_PIN_MARK(thisSpot,theX,theY);				DRAW_PRIME_MARK(thisSpot,theX,theY);				PenNormal();			}		}	}	ClearDrawEnviron();}void	KosselObj::DrawSmallCircle(SpotInfo *thisPole,Boolean erase){	double		alpha,P;	double		x,y,z;	short		hRes,vRes;	double		theXForm[3][3];	double		length,zz;	double		factor,L;	short		theX,theY,theXOld,theYOld;	double	theXForm00,value,						theXForm10,						theXForm20,						theXForm01,						theXForm11,						theXForm21,						theXForm02,						theXForm12,						theXForm22;	double			theta,distance,inelasticCal;	RgnHandle  	newClip;	double 			x1,y1,z1,xp,yp,zp;		alpha		= thisPole->angle;	if(thisPole->h == 0 && thisPole->k == 2 && thisPole->l == 0){		x1 = 0;	}	if(fabs(alpha) < .000001)return;//the pole has no angle the cone radius is therefore infinite	distance   = CalcExtinctionDistance(thisPole,1/wavelength);//1/ (thisPole->sF.r * wavelength);// /	SetScaleFactor();	//this sets camera length and camera length in pixels.	//inelasticCal = (1 -  exp(-.4 * trueThickness / distance));	inelasticCal = kLineMult * (1.23 -  exp(-1.5 * trueThickness / distance));	inelasticCal *= pow((double)(thisPole->intensity),1/dyRange);	if(inelasticCal < .1)return;		if(erase){		DMForeColor(BACKGROUND_COLOR);	} else {		RGBColor	aColor;		if(g_Monitor)			if(greyFlag){				long theValue;				theValue = 210 * inelasticCal;				DMForeColor(theValue + 15);			}else{				thisPole->theCrystal->SetColor();				GetForeColor(&aColor);				InvertColor	(&aColor);				RGBForeColor(&aColor);			}		else{			DMForeColor(BLACK);		}				}	PenNormal();	PenPat(&qd.black);	SetRect			(&thisPole->spotRect,-2,-2,2,2);	newClip 	= 	D_NewRgn();	RectRgn			(newClip,&thePictRect);	D_SetClip			(newClip);	D_DisposeRgn		(&newClip);				length = sqrt(thisPole->x * thisPole->x + thisPole->y * thisPole->y + thisPole->z * thisPole->z);	x = thisPole->x/length;	y = thisPole->y/length;	z = thisPole->z/length;		FIND_CENTER_XFORM(x,y,z,theXForm);	InvertMatrix(theXForm);		ScreenRes(&hRes,&vRes);	theXForm00 = theXForm[0][0];	theXForm10 = theXForm[1][0];	theXForm20 = theXForm[2][0];	theXForm01 = theXForm[0][1];	theXForm11 = theXForm[1][1];	theXForm21 = theXForm[2][1];	theXForm02 = theXForm[0][2];	theXForm12 = theXForm[1][2];	theXForm22 = theXForm[2][2];	L = sin(alpha);	zz = z = cos(alpha);	theta = 0;	x = L;	y = 0;	TransFormVector(&x,&y,&z,theXForm);	NormalizeVector(&x,&y,&z);	//angle = acos(z);	length		= sqrt(x * x + y * y);	factor = projLengthScreen * length / z;		value = Round((double)factor * y/length);	if(value > 32000) value = 31000;	else if(value < -32000) value = -31000;	theXOld	= centerX + value;			value = Round((double)factor * x/length);	if(value > 31000) value = 32000;	else if(value < -31000) value = -32000;	theYOld	= centerY + value;	MoveTo(theXOld,theYOld);	x1 = zz * theXForm02;	y1 = zz * theXForm12;	z1 = zz * theXForm22;	P = PI/90;	for(theta =  0; theta <= PI_2;theta += P){		x = L * cos(theta);		y = L * sin(theta);		//z = zz;		xp = x * theXForm00 + y * theXForm01 + x1;		yp = x * theXForm10 + y * theXForm11 + y1;		zp = x * theXForm20 + y * theXForm21 + z1;		//TransFormVector(&x,&y,&z,theXForm);		//NormalizeVector(&x,&y,&z);				length		= sqrt(xp * xp + yp * yp);		factor	= projLengthScreen * length / zp;		value = Round((double)factor * yp/length);				if(value > 32000) value = 32000;		else if(value < -32000) value = -32000;		theX	= centerX + value;								value = Round((double)factor * xp/length);		if(value > 32000) value = 32000;		else if(value < -32000) value = -32000;		theY	= centerY + value;		if(zp < 0){			theXOld = theX;			theYOld = theY;			continue;		}		if(fabs((double)theX) > 3000 || fabs((double)theY) > 3000){			theXOld = theX;			theYOld = theY;			MoveTo(theXOld,theYOld);			continue;		}		LineTo(theX,theY);		theXOld = theX;		theYOld = theY;	}	}Boolean KosselObj::ConvertPointToXYZCart(Point thePoint,double *x,double *y,double *z){	static Point	lastPoint;	double rad,u,v;	if(IRRATIONAL_DIR_F != functionID) return false;	if(EqualPt(thePoint,lastPoint) || !PtInRgn(thePoint,drawRgn))		return false;		radius = scaleFactor / wavelength;		lastPoint = thePoint;		onScreen = true;	LocalToObj(&thePoint);	v = thePoint.h - centerX;	u = thePoint.v - centerY;	rad = sqrt(u * u + v * v + radius * radius);	if(rad == 0){		*x = 0.0;		*y = 0.0;		*z = 1.0;	} else {		*x = u / rad;		*y = v / rad;		*z = radius / rad;	}	return true;}Boolean	KosselObj::FindTrace(Point thePoint,short n){	short 			i;	SpotInfo		*theSpot;	double			minError = 100.9;	double 			error;	LineObj			*theLine;	Index				*aIndex;	unsigned long				time= 0L;	double			alpha;		SetScaleFactor();//	radius = scaleFactor / wavelength;	theLine = (LineObj*)D_new(LineObj);	theLine->DoInit(false,theCrystal[0],false,0L,thePoint,thePoint);		GetMouse(&thePoint);		aIndex = (Index*)D_new(Index);	/*MFTemp*/D_HLock			(theDataHandle);	theSpot 	= 	(SpotInfoPtr)*theDataHandle;	obj_Index->DoInit(false,theSpot->theCrystal);	LocalToObj(&thePoint);		for(i = n , theSpot = &(((SpotInfoPtr)*theDataHandle)[n - 1])  ; i <= data_Count ; i++,theSpot++){		double	P;		double	x,y,z;		double	theXForm[3][3];		double	length,zz;		double	factor,L;		short		theX,theY;		double	theXForm00,value,						theXForm10,						theXForm20,						theXForm01,						theXForm11,						theXForm21,						theXForm02,						theXForm12,						theXForm22;		double	theta;		double	x1,y1,z1,xp,yp,zp,inelasticCal,distance;		Point		aPoint;		if(theSpot->direction)continue;		distance   = 1/ (theSpot->sF.r * wavelength);// /CalcExtinctionDistance(thisPole,1/wavelength);		SetScaleFactor();	//this sets camera length and camera length in pixels.		//inelasticCal = exp(-PI * distance/trueThickness);		//inelasticCal *= pow((double)(theSpot->intensity),1/dyRange);		inelasticCal = kLineMult * (1.23 -  exp(-1.5 * trueThickness / distance));		inelasticCal *= pow((double)(theSpot->intensity),1/dyRange);		if(inelasticCal < .1)continue;		alpha		= theSpot->angle;		length = sqrt(theSpot->x * theSpot->x + theSpot->y * theSpot->y + theSpot->z * theSpot->z);		x = theSpot->x/length;		y = theSpot->y/length;		z = theSpot->z/length;					FIND_CENTER_XFORM(x,y,z,theXForm);		InvertMatrix(theXForm);		theXForm00 = theXForm[0][0];		theXForm10 = theXForm[1][0];		theXForm20 = theXForm[2][0];		theXForm01 = theXForm[0][1];		theXForm11 = theXForm[1][1];		theXForm21 = theXForm[2][1];		theXForm02 = theXForm[0][2];		theXForm12 = theXForm[1][2];		theXForm22 = theXForm[2][2];			L = sin(alpha);		zz = z = cos(alpha);		theta = 0;		x = L;		y = 0;		TransFormVector(&x,&y,&z,theXForm);		NormalizeVector(&x,&y,&z);		length		= sqrt(x * x + y * y);		factor = projLengthScreen * length / z;				value = Round((double)factor * y / length);		if(value > 32000) value = 31000;		else if(value < -32000) value = -31000;				theLine->hor1	= centerX + value;					value = Round((double)factor * x / length);		if(value > 31000) value = 32000;		else if(value < -31000) value = -32000;				theLine->ver1	= centerY + value;				x1 = zz * theXForm02;		y1 = zz * theXForm12;		z1 = zz * theXForm22;						P = PI/90;		for(theta =  0; theta <= PI_2;theta += P){			x = L * cos(theta);			y = L * sin(theta);			xp = x * theXForm00 + y * theXForm01 + x1;			yp = x * theXForm10 + y * theXForm11 + y1;			zp = x * theXForm20 + y * theXForm21 + z1;						length		= sqrt(xp * xp + yp * yp);			factor	= projLengthScreen * length / zp;			value = Round((double)factor * yp/length);						if(fabs(value) > 4000){				theLine->hor2 = theLine->hor1 = 4000 * value/(fabs(value));				continue;			}			theX	= centerX + value;									value = Round((double)factor * xp/length);			if(fabs(value) > 4000){				theLine->ver2 = theLine->ver1 = 4000 * value/(fabs(value));				 continue;			}			theY	= centerY + value;			if(zp < 0){				theLine->hor2 = theLine->hor1 = theX;				theLine->ver2 = theLine->ver1 = theY;				continue;			}			aPoint.h = theLine->hor2	= theX;			aPoint.v = theLine->ver2	= theY;			if(theLine->PointOnLine(thePoint)){					theLine->DoClose();					aIndex->DoClose();					spotLoc = i - 1;					/*MFTemp*/D_HUnlock(theDataHandle);					goto END;			}						SubPt(thePoint,&aPoint);			x = aPoint.h;			y = aPoint.v;			error = sqrt((double)(x * x) + (double)(y * y));			if(error < 8){				theLine->DoClose();				aIndex->DoClose();				/*MFTemp*/D_HUnlock(theDataHandle);				spotLoc = i - 1;				goto END;			}			theLine->hor1	= theLine->hor2;			theLine->ver1	= theLine->ver2;		}	}	theLine->DoClose();	aIndex->DoClose();	spotLoc = -1;		/*MFTemp*/D_HUnlock(theDataHandle);	if(n != 1){		SysBeep(30);	} else {		FlashMenuBar(0);		Delay(6L,&time);		FlashMenuBar(0);	}	return false;END:	obj_Index->theCrystal	= 	THE_CURRENT_SPOT.theCrystal;	obj_Index->h 			= 	THE_CURRENT_SPOT.h;	obj_Index->k 			= 	THE_CURRENT_SPOT.k;	obj_Index->l 			= 	THE_CURRENT_SPOT.l;	obj_Index->direction 	= 	THE_CURRENT_SPOT.direction;	if(THE_CURRENT_SPOT.flags & TOO_BIG){//THE_CURRENT_SPOT.spotRect.top == -2 && THE_CURRENT_SPOT.spotRect.bottom == 2		//|| THE_CURRENT_SPOT.spotRect.right == THE_CURRENT_SPOT.spotRect.left && 		//THE_CURRENT_SPOT.spotRect.top == THE_CURRENT_SPOT.spotRect.bottom){			THE_CURRENT_SPOT.spotRect.right = THE_CURRENT_SPOT.spotRect.left = thePoint.h;		THE_CURRENT_SPOT.spotRect.top = THE_CURRENT_SPOT.spotRect.bottom = thePoint.v;	}	return 						true;			}void	KosselObj::ZoomIn(Point thePoint){	Point	thisPoint,startPoint;	Rect	lastRect;	unsigned long	theResult;	double	theValue,magX,magY,theMag;	PenMode(srcXor);		startPoint = thisPoint = thePoint;	gTheRect.left	= thisPoint.h - 100;	gTheRect.right	= gTheRect.left + 200;	gTheRect.top	= thisPoint.v - 100;	gTheRect.bottom	= gTheRect.top + 200;	dm_FrameRect(&gTheRect);	lastRect = gTheRect;	theRuler->SetPrompt("Set Camera Constant:");	while(Button()){		GetMouse(&thisPoint);		if(!EqualPt(thisPoint,thePoint)){			theResult = DeltaPoint(startPoint,thisPoint);			gTheRect.left	= startPoint.h - abs(LoWord(theResult));			gTheRect.right	= startPoint.h + abs(LoWord(theResult));			gTheRect.top	= startPoint.v - abs(HiWord(theResult));			gTheRect.bottom = startPoint.v + abs(HiWord(theResult));			SystemTask();			dm_FrameRect(&lastRect);			dm_FrameRect(&gTheRect);			lastRect = gTheRect;			thePoint = thisPoint;			magX	= (double)theWindow->portRect.right / (double)(lastRect.right - lastRect.left);			magY	= (double)theWindow->portRect.bottom / (double)(lastRect.bottom - lastRect.top);			if(magX < magY){				theMag = magX;			} else {				theMag = magY;			}			if(theMag > 10.0 || theMag < .1)				theMag = 2.0;			theValue = theMag * cameraConstant;			sprintf(gTheText,"%6.2fmm-",theValue);			theRuler->SetInfo(gTheText);			} else {			Delay(6L,&theResult);		}		SystemTask();	}	dm_FrameRect(&lastRect);		SetTheCursor(WATCH_CURSOR);	/*************** Save Previous Zoom ***************/		previousZoom.theObjectSize.v	=	cameraConstant * 100;	previousZoom.hScrollValue	=	centerX;	previousZoom.vScrollValue	=	centerY;				/*************** Find New Center and CmaeraLength Location ***************/		centerX = startPoint.h;	centerY = startPoint.v;	cameraConstant *= theMag;	/*************** Calculate the Picture ***************/		/*zoomFlag = true;*/	//SetPict(true);	newPictReq = true;	dm_EraseRect(&thePictRect);	InvalRect(&thePictRect);	ResetCurvedLabels();	return;}void	KosselObj::ZoomPrevious(void){	double	cameraConstantOld;	short	hVal,vVal;	hVal			= centerX;	vVal			= centerY;	cameraConstantOld = cameraConstant;	cameraConstant	= previousZoom.theObjectSize.v / 100;	centerX 		= previousZoom.hScrollValue;	centerY 		= previousZoom.vScrollValue;	zoomFlag		= false;	changedFlag 	= true;	previousZoom.theObjectSize.v = cameraConstantOld * 100;	previousZoom.hScrollValue = hVal;	previousZoom.vScrollValue = vVal;	ResetCurvedLabels();	return;}Boolean KosselObj::StageControl(void)//Override{	Boolean flag;	projLengthScreen *= 2;	flag = inherited::StageControl();	projLengthScreen /= 2;	return flag;}void	KosselObj::CalculateScreenThetas(double *x,double *y,double *z,Point thePoint){	double temp,length,x1,y1;	SetScaleFactor();		onScreen = true;	LocalToObj(&thePoint);	y1 = thePoint.h - centerX;	x1 = thePoint.v - centerY;	length = sqrt(x1 * x1 + y1 * y1);	if(length < .01){			*x = 0;			*y = 0;			*z = 1;			return;	}	temp = atan(length/projLengthScreen);	*z = cos(temp);	temp = sin(temp) / length;	x1 *= temp;	y1 *= temp;	*x = x1;	*y = y1;	}Point	KosselObj::FindCrossOver(SpotInfoPtr theSpot,Rect testRect){	double			minError = 100.9;	long				time=0;	double			alpha;	double	P;	double	x,y,z;	double	theXForm[3][3];	double	length,zz;	double	factor,L;	short		theX,theY;	double	theXForm00,value,					theXForm10,					theXForm20,					theXForm01,					theXForm11,					theXForm21,					theXForm02,					theXForm12,					theXForm22;	double	theta;	double	x1,y1,z1,xp,yp,zp,distance;	Point		thePoint;	SetScaleFactor();	radius = scaleFactor / wavelength;	thePoint.h = thePoint.v = 0;		if(theSpot->direction)return thePoint;	distance   = 1/ (theSpot->sF.r * wavelength);// /CalcExtinctionDistance(thisPole,1/wavelength);	SetScaleFactor();	//this sets camera length and camera length in pixels.		alpha		= theSpot->angle;	length = sqrt(theSpot->x * theSpot->x + theSpot->y * theSpot->y + theSpot->z * theSpot->z);	x = theSpot->x/length;	y = theSpot->y/length;	z = theSpot->z/length;		FIND_CENTER_XFORM(x,y,z,theXForm);	InvertMatrix(theXForm);	theXForm00 = theXForm[0][0];	theXForm10 = theXForm[1][0];	theXForm20 = theXForm[2][0];	theXForm01 = theXForm[0][1];	theXForm11 = theXForm[1][1];	theXForm21 = theXForm[2][1];	theXForm02 = theXForm[0][2];	theXForm12 = theXForm[1][2];	theXForm22 = theXForm[2][2];	L = sin(alpha);	zz = z = cos(alpha);	theta = 0;	x = L;	y = 0;	TransFormVector(&x,&y,&z,theXForm);	NormalizeVector(&x,&y,&z);	length		= sqrt(x * x + y * y);	factor = projLengthScreen * length / z;		x1 = zz * theXForm02;	y1 = zz * theXForm12;	z1 = zz * theXForm22;			P = PI/90;	for(theta =  0; theta <= PI_2;theta += P){		x = L * cos(theta);		y = L * sin(theta);		xp = x * theXForm00 + y * theXForm01 + x1;		yp = x * theXForm10 + y * theXForm11 + y1;		zp = x * theXForm20 + y * theXForm21 + z1;				length		= sqrt(xp * xp + yp * yp);		factor	= projLengthScreen * length / zp;		value = Round((double)factor * yp/length);				if(fabs(value) > 4000){			continue;		}		theX	= centerX + value;		value = Round((double)factor * xp/length);		if(fabs(value) > 4000){			 continue;		}		theY	= centerY + value;		if(zp < 0){			continue;		}		thePoint.h = theX;		thePoint.v = theY ;		if(PtInRect(thePoint,&testRect)){			thePoint.h = theX;			thePoint.v = theY;			return 	thePoint;		}	}	thePoint.h = 0;	thePoint.v = 0;	return thePoint;}