//ects:D.M. v2.0:Sources.Jim:Window/Menu:WI_RulerButton.c#include	"Diffract_INCs.h"#include	"RulerButton.h"#include 	"defineElectronObj.h"#include 	"XRayDefObj.h"#include 	"NeutronDefObj.h"void RulerButton::DoInit(void){	onFlag = false;	SetRect(&theButtonRect,0,0,0,0);	SetRect(&activateZone,0,0,0,0);	owner = NUL;	thePopUpPict = (PopUpPicture*)D_new(PopUpPicture);	thePopUpPict->DoInit((Ptr)(gCurrentObj));}Boolean RulerButton::DoContent(Point thePoint){	Point	dummyPoint;	dummyPoint = thePoint;	return false;}Boolean RulerButton::DoDblClick(Point thePoint){	Point	dummyPoint;	dummyPoint = thePoint;	return false;}void RulerButton::Enable(void){	onFlag = true;}void RulerButton::Disable(void){	onFlag = false;}void		RulerButton::SetOwner(Ptr theOwner){	owner = theOwner;}void		RulerButton::PictureUpdate(){	return;}void		RulerButton::DoClose(void){	thePopUpPict->DoClose();	D_delete(this);}void		RulerButton::SetButtonRect(Rect theRect){	theButtonRect = theRect;}void	RulerButton::SetName(char *theName){	strcpy(theButtonName,theName);}void	RulerButton::DrawButtonRect(short pmColor){	short	bottom,top;	PenState	theState;	PaletteHandle	thePalette;	RGBColor			foreColor,backColor;	RGBColor			oldForeColor,oldBackColor;	if(!onFlag)return;	GetPenState(&theState);	GetForeColor(&oldForeColor);	GetBackColor(&oldBackColor);	PenNormal();	bottom 	= theButtonRect.bottom;	top		= theButtonRect.top + 1;	TextFont(geneva);	TextSize(9);	{						thePalette = GetPalette(FrontWindow());						GetEntryColor	(thePalette,pmColor,&foreColor);		backColor = foreColor;		InvertColor		(&backColor);		RGBForeColor(&backColor);		RGBBackColor(&foreColor);		EraseRect(&theButtonRect);				MoveTo(theButtonRect.left + 1,bottom);		LineTo(theButtonRect.right,bottom);		LineTo(theButtonRect.right,top);		MoveTo(theButtonRect.left + 3,bottom - 4);	}	DrawString(c2pstr(theButtonName));	p2cstr((unsigned char*)theButtonName);	GetEntryColor	(thePalette,BLACK,&foreColor);	FrameRect(&theButtonRect);	TextFont(0);	TextSize(12);	SetPenState(&theState);	RGBForeColor(&oldForeColor);	RGBBackColor(&oldBackColor);}Boolean CrystalButton::DoContent(Point thePoint){	Rect 				theFrame,aButton;	PicHandle		thePicture;	GrafPtr 		oldPort;	short				startH;	if(!onFlag) 		return false;			aButton = theButtonRect;		if(!PtInRect(thePoint,&aButton)){		return false;	}		GetPort(&oldPort);		OffsetRect(&aButton,-1,-1);	InvertRect(&aButton);			thePicture = ((Crystal*)owner)->DisplayCrystal(&theFrame,aButton.left,aButton.top);	//InsetRect(theFrame,-2,-2);	ClipRect(&theFrame);	/*D_HLock((Handle)thePicture);*/	thePopUpPict->SetPopUpPict(thePicture);		if(theFrame.right  > oldPort->portRect.right - 15)	{		startH = theFrame.right - oldPort->portRect.right;		theFrame.left -= startH + 15;	}	thePopUpPict->DrawPopUpPict(theFrame.left,aButton.bottom + 1,true);	SetPort(oldPort);	ClipRect(&oldPort->portRect);	InvertRect(&aButton);		return true;}Boolean CrystalButton::DoDblClick(Point thePoint){	if(!onFlag) return false;	if(!PtInRect(thePoint,&theButtonRect)) 		return false;	/*********** Eric modified this to allow palette update *************//*  This section allows the evt mgr to pass a cmdkey + keydown to 	*//*	the apps evt loop. The posted keys are cmd key equivalents for  *//*  crystal def routines and as a result these routines get accessed*//*  through the main object thereby allowing acces to the palette   */	/*	((Crystal*)owner)->CrystalDef(); -- Removed this line			*/	{		PostEvent(keyDown,(short)('0' + (char)((Crystal*)owner)->idNum));		((EvQEl*)((GetEvQHdr())->qTail))->evtQModifiers = cmdKey;	}/********************************************************************/	return true;}Boolean BeamButton::DoContent(Point thePoint){				PicHandle thePicture;	Rect theFrame,aButton;	GrafPtr oldPort;	short		startH;		if(!onFlag) return false;		GetPort(&oldPort);	aButton = theButtonRect;		if(!PtInRect(thePoint,&aButton)) return false;		D_SetClip(gUpdateAll);	gCurrentObj->DMForeColor/*PMForeColor*/(10);	switch(((DiffractObject*)owner)->theBeamFlag){		case 1:			thePicture = ((DiffractObject*)owner)->theEBeam->DisplayPict(&theFrame,aButton.left,aButton.top);			break;		case 2:			thePicture = ((DiffractObject*)owner)->theXRay->DisplayPict(&theFrame,aButton.left,aButton.top);			break;		case 3:			thePicture = ((DiffractObject*)owner)->theIon->DisplayPict(&theFrame,aButton.left,aButton.top);			break;	}	OffsetRect(&aButton,-1,-1);	InvertRect(&aButton);//	D_HLock((Handle)thePicture);	ClipRect(&theFrame);	thePopUpPict->SetPopUpPict(thePicture);	if(theFrame.right  > oldPort->portRect.right - 15)	{		startH = theFrame.right - oldPort->portRect.right;		theFrame.left -= startH + 15;	}	thePopUpPict->DrawPopUpPict(theFrame.left + 1,aButton.bottom + 1,true);	SetPort(oldPort);	ClipRect(&oldPort->portRect);	InvertRect(&aButton);//	D_HUnlock((Handle)thePicture);	return true;}Boolean BeamButton::DoDblClick(Point thePoint){	short hRes,vRes;	Boolean aFlag = false;	Rect aButton;	if(!onFlag) return false;	aButton = theButtonRect;	if(!PtInRect(thePoint,&aButton)) return false;/*	switch(((DiffractObject*)owner)->theBeamFlag)	{		case 1:			if(((DiffractObject*)owner)->theEBeam->DoDefine()) aFlag = true;			break;		case 2:			if(((DiffractObject*)owner)->theXRay->DoDefine()) aFlag = true;			break;		case 3:			break;	}*/	((DiffractObject*)owner)->DefineBeamE();	((DiffractObject*)owner)->theRuler->SetBeamButton(((DiffractObject*)owner)->theBeamFlag);	ScreenRes(&hRes,&vRes);	((DiffractObject*)owner)->scaleFactor = (double)((DiffractObject*)owner)->cameraConstant * (double)hRes * (double)((DiffractObject*)owner)->magnification / 25.4;	if(((DiffractObject*)owner)->screenPict != NUL){		if(aFlag == true)			((DiffractObject*)owner)->changedFlag = true;;	}	return true;}void	DefineButton::PictureUpdate(void){}Boolean DefineButton::DoContent(Point thePoint){				PicHandle thePicture;	Rect theFrame,aButton;	GrafPtr oldPort;	short		startH;		if(!onFlag) return false;		GetPort(&oldPort);	aButton = theButtonRect;		if(!PtInRect(thePoint,&aButton)) return false;			D_SetClip(gUpdateAll);	thePicture = ((SADObj*)owner)->DisplayPict(&theFrame,aButton.left,aButton.top);	OffsetRect(&aButton,-1,-1);	InvertRect(&aButton);		ClipRect(&theFrame);	thePopUpPict->SetPopUpPict(thePicture);	if(theFrame.right  > oldPort->portRect.right - 15)	{		startH = theFrame.right - oldPort->portRect.right;		theFrame.left -= startH + 15;	}	thePopUpPict->DrawPopUpPict(theFrame.left + 1,aButton.bottom + 1,true);	SetPort(oldPort);	ClipRect(&oldPort->portRect);	InvertRect(&aButton);			return true;}Boolean DefineButton::DoDblClick(Point thePoint){	if(!onFlag) return false;	if(!PtInRect(thePoint,&theButtonRect)) return false;	((SADObj*)owner)->DoDefine();	return true;}