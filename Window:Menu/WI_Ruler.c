#include	"Diffract_INCs.h"//ects:D.M. v2.0:Sources.Jim:Window/Menu:WI_Ruler.c#include	"RulerButton.h"#include 	"defineElectronObj.h"#include 	"XRayDefObj.h"#include 	"NeutronDefObj.h"pascal	void	MyMDEF(short message,MenuHandle theMenu,Rect* theRect,Point where,short* theItem);ProcPtr	theMDEF;void	Ruler::DoInit(long	owner){	short		i,width,top,bottom,left,right;	Crystal		*theCrystals;	Rect 		theRect;		if(rulerOFF)return;		for(i = 1 ; i < 50 ; i++){		functionPrompt[i] = ' ';	}	functionPrompt[0] 	= 	(char)49;		for(i = 1 ; i < 140 ; i++){		functionText[i] = ' ';	}	functionText[0] = (char)0;		for(i = 1 ; i < 257 ; i++){		helpText[i] = ' ';	}	helpText[0] = (char)0;		width 				= 	StringWidth((unsigned char*)helpText);	maxButton 			= 	3;	theOwner			=	owner;	functionID			=	0;	rulerHeight			=	((DiffractObject*)theOwner)->rulerHeight;		if(rulerHeight < 0){		rulerOFF = true;		return;	}	rulerOFF			=	false;	functionFlag		=	false;	infoStart			=	2000;				SetRect(&infoRect,0,0,0,0);		helpRect.bottom		=	15;	helpRect.top		=	2;	helpRect.left		=	5;	helpRect.right		=	((DiffractObject*)theOwner)->theVisRect.right - 10;		funcRect.bottom		=	rulerHeight - 4;	funcRect.top		=	funcRect.bottom - 15;	funcRect.left		=	5;	funcRect.right		=	((DiffractObject*)theOwner)->theVisRect.right - 10;		TextFont				(geneva);	TextSize				(9);	width 				= 	StringWidth("\pCrystal 1");	TextFont				(0);	TextSize				(12);		top 	= 15;	bottom 	= top + 14;	left 	= 65;	for(i = 0;i <= 5;i++){				right = left + width + 5;		SetRect(&theRect,left,top,right,bottom);		left = right + 5;				if(i <= 3){			rulerButtons[i] 				= 	(Ptr)D_new(CrystalButton);			((CrystalButton*)rulerButtons[i])->	DoInit();			sprintf								(gTheText,"Crystal %d",i + 1);			theCrystals 					= 	((DiffractObject*)theOwner)->theCrystal[i];			((RulerButton*)rulerButtons[i])	->	SetOwner((Ptr)theCrystals);		}		if(i == 4)		{			rulerButtons[i] = (Ptr)D_new(BeamButton);			((BeamButton*)rulerButtons[i])->DoInit();			switch(((SADObj*)theOwner)->theBeamFlag){				case 1:					sprintf(gTheText,"E-Beam");					((BeamButton*)rulerButtons[i])->SetOwner((Ptr)theOwner);					break;				case 2:					sprintf(gTheText,"X-Ray");					((BeamButton*)rulerButtons[i])->SetOwner((Ptr)theOwner);					break;				case 3:					sprintf(gTheText,"Ion-Beam");					((BeamButton*)rulerButtons[i])->SetOwner((Ptr)theOwner);					break;			}							}		if(i == 5)		{			rulerButtons[i] 				= 	(Ptr)D_new(DefineButton);			((DefineButton*)rulerButtons[i])->	DoInit();			sprintf								(gTheText,"Define");			((DefineButton*)rulerButtons[i])->	SetOwner((Ptr)theOwner);		}		((RulerButton*)rulerButtons[i])		->	SetButtonRect(theRect);		((RulerButton*)rulerButtons[i])		->	SetName(gTheText);		if(i <= maxButton){			((RulerButton*)rulerButtons[i])	->	Enable();		}	}	}void	Ruler::EnableButtons(short maxButtons){	short i;	if(rulerOFF)return;	maxButton = maxButtons;	for(i = 0; i <= maxButtons;i++){		((RulerButton*)rulerButtons[i])->Enable();		((RulerButton*)rulerButtons[i])->PictureUpdate();	}	for(i = maxButtons + 1;i <= 5;i++) ((RulerButton*)rulerButtons[i])->Disable();}void	Ruler::DoClose(void){	short i;	for(i = 0;i <= 5;i++)	((RulerButton*)rulerButtons[i])->DoClose();	D_delete(this);	return;}void	Ruler::DrawRuler(void){		Rect				theRect;	PenState		theState;	GrafPtr 		thePort;	RgnHandle		theRgn;	short i;		if(rulerOFF)		return;	GetPenState(&theState);	PenNormal();	GetPort(&thePort);	theRect.top = theRect.left = 0;	theRect.bottom = rulerHeight - 1;	theRect.right = thePort->portRect.right;	PenMode(patCopy);	gCurrentObj->DMForeColor/*PMForeColor*/(WHITE);	theRgn = SetClipToPort(((DiffractObject*)theOwner)->theWindow,0,0,0,0);	dm_PaintRect(&theRect);		gCurrentObj->DMForeColor/*PMForeColor*/(BLACK);		MoveTo(thePort->portRect.left,rulerHeight - 1);	LineTo(thePort->portRect.right,rulerHeight - 1);	MoveTo(thePort->portRect.left,rulerHeight - 3);	LineTo(thePort->portRect.right,rulerHeight - 3);	for(i = 0; i <= maxButton;i++)((RulerButton*)rulerButtons[i])->DrawButtonRect(10 + i);	if(maxButton > 3){		for(i = 4; i <= maxButton;i++)((RulerButton*)rulerButtons[i])->DrawButtonRect(WHITE);	}	DisplayPrompt();	DisplayInfo();	DisplayHelp();	SetPenState(&theState);	D_SetClip(theRgn);	D_DisposeRgn(&theRgn);	return;}void	Ruler::SetPrompt(char*	theText){	short	i,j;	PenState	theState;	RgnHandle	theRgn;	RGBColor	foreColor,backColor;		if(rulerOFF)		return;	theRgn = SetRulerDrawEnv(&theState,&foreColor,&backColor);	j = 11;	functionPrompt[1] = 'F';	functionPrompt[2] = 'u';	functionPrompt[3] = 'n';	functionPrompt[4] = 'c';	functionPrompt[5] = 't';	functionPrompt[6] = 'i';	functionPrompt[7] = 'o';	functionPrompt[8] = 'n';	functionPrompt[9] = ' ';	functionPrompt[10] = '=';	functionPrompt[11] = ' ';		for(i = 0 ; theText[i] != (char)0 && i < 160 ; i++){		functionPrompt[++j] = theText[i];	}	functionPrompt[++j] = ' ';	functionPrompt[0] = (unsigned char)j;	functionFlag = true;		funcRect.right = gTheRect.right;	infoRect = funcRect;			TextFont(geneva);	TextSize(9);		dm_EraseRect(&funcRect);	infoStart = funcRect.left + StringWidth((unsigned char*)functionPrompt) + 5;	infoRect.left = infoStart - 2;	MoveTo(funcRect.left + 2,funcRect.bottom - 3);		DrawDiffractString((unsigned char*)functionPrompt);	functionText[0] = (char)0;	TextFont(0);	TextSize(0);		ClearRulerDrawEnv( theRgn, theState, foreColor, backColor);	return;}void	Ruler::ClearPrompt(void){	PenState	theState;		if(rulerOFF)		return;	GetPenState(&theState);	PenNormal();			gCurrentObj->DMForeColor/*PMForeColor*/(WHITE);	gTheRect = ((DiffractObject*)theOwner)->theWindow->portRect;	gTheRect.bottom = rulerHeight;	gTheRect.right -= 15;	funcRect.right = gTheRect.right;	helpRect.right = gTheRect.right;	RectRgn(gTheRgn,&gTheRect);	D_SetClip(gTheRgn);	dm_PaintRect(&funcRect);	dm_PaintRect(&helpRect);	functionPrompt[0] = (char)0;	functionText[0] = (char)0;	functionFlag = false;	gCurrentObj->DMForeColor/*PMForeColor*/(BLACK);	D_SetClip(((DiffractObject*)theOwner)->drawRgn);	SetPenState(&theState);	return;}void	Ruler::DisplayPrompt(void){	PenState	theState;	RgnHandle	theRgn;	RGBColor	foreColor,backColor;		if(rulerOFF)		return;			if(functionFlag){		theRgn = SetRulerDrawEnv(&theState,&foreColor,&backColor);		MoveTo(funcRect.left + 2,funcRect.bottom - 3);		funcRect.right = gTheRect.right;		DrawDiffractString((unsigned char*)functionPrompt);		ClearRulerDrawEnv(theRgn,theState,foreColor,backColor);	}	return;}void	Ruler::SetInfo(char*	theText){		short	i;	PenState	theState;	RgnHandle	theRgn;	RGBColor	foreColor,backColor;		if(rulerOFF)		return;			if(!functionFlag)		return;		/****************************** Eric Added the Color save and restore **********/		theRgn = SetRulerDrawEnv(&theState,&foreColor,&backColor);		PenNormal();		for(i = 0 ; theText[i] != (char)0 && i < 140 ; i++){		functionText[i] = theText[i];	}	functionText[i] = 	(char)0;	c2pstr(functionText);	MoveTo				(infoStart,infoRect.bottom - 3);		dm_EraseRect			(&infoRect);	TextFont(courier);	TextSize(9);	DrawDiffractString			((unsigned char*)functionText);	TextFont(0);	TextSize(12);	ClearRulerDrawEnv( theRgn, theState, foreColor, backColor);	return;}void	Ruler::DisplayInfo(void){	PenState	theState;	RgnHandle	theRgn;	RGBColor	foreColor,backColor;	if(rulerOFF)		return;			if(functionFlag){		theRgn = SetRulerDrawEnv(&theState,&foreColor,&backColor);		MoveTo			(infoStart,infoRect.bottom - 3);			DrawDiffractString		((unsigned char*)functionText);				ClearRulerDrawEnv(theRgn,theState,foreColor,backColor);	}	return;}void			Ruler::SetHelp(char*	theText){	short i;	PenState	theState;	RgnHandle	theRgn;	RGBColor	foreColor,backColor;	if(rulerOFF)		return;		theRgn = SetRulerDrawEnv(&theState,&foreColor,&backColor);	helpRect.right = gTheRect.right;	if(helpActive){		dm_EraseRect(&helpRect);	}					for(i = 0 ; theText[i] != (char)0 && i < 256 ; i++){		helpText[i] = theText[i];	}	helpText[i] = (char)0;	c2pstr(helpText);			MoveTo(helpRect.left + 1,helpRect.bottom - 3);	DrawDiffractString((unsigned char*)helpText);	helpActive = true;				ClearRulerDrawEnv(theRgn,theState,foreColor,backColor);	return;}void			Ruler::ClearHelp(){	PenState	theState;	if(rulerOFF)		return;	GetPenState(&theState);	PenNormal();			if(helpActive){		gTheRect = ((DiffractObject*)theOwner)->theWindow->portRect;		gTheRect.bottom = rulerHeight;		gTheRect.right -= 15;		RectRgn(gTheRgn,&gTheRect);		D_SetClip(gTheRgn);		gCurrentObj->DMForeColor/*PMForeColor*/(WHITE);		helpRect.right = gTheRect.right;		dm_PaintRect(&helpRect);		gCurrentObj->DMForeColor/*PMForeColor*/(BLACK);		//InvalRect(&helpRect);		helpActive = false;		helpText[0] = (char)0;		D_SetClip(((DiffractObject*)theOwner)->drawRgn);	}	SetPenState(&theState);	return;}	void			Ruler::DisplayHelp(){	PenState	theState;	RgnHandle	theRgn;	RGBColor	foreColor,backColor;	if(rulerOFF)		return;	if(helpActive){		MoveTo(helpRect.left + 1,helpRect.bottom - 3);	theRgn = SetRulerDrawEnv(&theState,&foreColor,&backColor);		helpRect.right = gTheRect.right;		DrawDiffractString((unsigned char*)helpText);		ClearRulerDrawEnv(theRgn,theState,foreColor,backColor);	}	return;}	void 	 Ruler::SetBeamButton(short theBeamFlag){	if(rulerOFF)		return;	switch(theBeamFlag){		case 1:			sprintf(gTheText,"Electron");			break;		case 2:			sprintf(gTheText,"X-Ray");			break;		case 3:			sprintf(gTheText,"Ion");			break;	}	((RulerButton*)rulerButtons[4])->SetName(gTheText);	((RulerButton*)rulerButtons[4])->DrawButtonRect(16);			}void	Ruler::DoDblClick(Point where){	PenState	theState;	Point		there;	short		i;		there = where; /* this line suppresses a warning */	if(rulerOFF) return;	GetPenState(&theState);	PenNormal();	for(i = 0; i <= maxButton;i++)((RulerButton*)rulerButtons[i])->DoDblClick(where);	SetPenState(&theState);}void	Ruler::DoContent(Point	where){	PenState	theState;	Point		there;	short		i;		there = where; /* this line suppresses a warning */	if(rulerOFF) return;			GetPenState(&theState);	PenNormal();	for(i = 0; i <= maxButton;i++){		((RulerButton*)rulerButtons[i])->DoContent(where);		}	SetPenState(&theState);	return;}#pragma segment MainRgnHandle Ruler::SetRulerDrawEnv(PenState *theState,RGBColor *foreColor,RGBColor *backColor){	RgnHandle theRgn;	GetForeColor(foreColor);	GetBackColor(backColor);	GetPenState(theState);	PenNormal();	theRgn = D_NewRgn();	GetClip(theRgn);	gTheRect = ((DiffractObject*)theOwner)->theWindow->portRect;	gTheRect.bottom = rulerHeight;	gTheRect.right -= 15;	RectRgn(gTheRgn,&gTheRect);	D_SetClip(gTheRgn);	gCurrentObj->DMBackColor		(WHITE);	gCurrentObj->DMForeColor		(BLACK);	TextFont(geneva);	TextSize(9);	return theRgn;}#pragma segment Mainvoid Ruler::ClearRulerDrawEnv(RgnHandle theRgn,PenState theState,RGBColor foreColor,RGBColor backColor){	D_SetClip(theRgn);	D_DisposeRgn(&theRgn);	SetPenState(&theState);	RGBBackColor(&backColor);	RGBForeColor(&foreColor);	TextFont(0);	TextSize(12);	return;}