//s.Jim:E_Diffract:E_ERingObj.c#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"ERingObj.h"void ERingObj::SetObjectMenu(){	theMenuBar = GetNewMBar(E_RING_OBJ_MB);	ClearMenuBar();/* July 1992 */	SetMenuBar(theMenuBar);	}void ERingObj::ResizeGraphBox(void){}void	ERingObj::SetObjectWindowTitle(void){	inherited::SetObjectWindowTitle();	theLabels	= NULL;	theCurvedLabels = NULL;			SetPlotScales();	minX = 1.0;	greyFlag = true;	fullCircle = false;	maxX = theCrystal[0]->theUnitCell.a;			theBeamFlag = 1;	energy =  theEBeam->energy;	wavelength = theEBeam->wavelength;		theRuler->SetBeamButton(theBeamFlag);	thePictRect = theWindow->portRect;	thePictRect.right	-= 15;	thePictRect.left		+= 15;	thePictRect.bottom	-= 15;	thePictRect.top		+= rulerHeight;	centerX = (thePictRect.right + thePictRect.left) / 2;	centerY = (thePictRect.bottom + thePictRect.top) / 2;		if(gTheFile->file_is_Open){		SetWTitle(theWindow,fileInfo.sfFile.name);		return;	}	sprintf(gTheText,"E-Rings %d",g_Window_Number - 1);	SetWTitle(theWindow,c2pstr(gTheText));}Boolean ERingObj::DialogRead(DialogPtr theDialog){	GetMinMax( theDialog);	if(greyFlag != GetBoolean(theDialog,_9_))newPictReq = true;	if(fullCircle != GetBoolean(theDialog,_10_))newPictReq = true;	greyFlag = GetBoolean(theDialog,_9_);	fullCircle = GetBoolean(theDialog,_10_);	return false;}double ERingObj::SetRecpSize(void){	if(graph)return 1. / (double)minX;	else	return 1 / (double)minX;}void ERingObj::SetDLogNames(DialogPtr theDialog){	GetDItem(theDialog,_11_,&gType,&gTheHandle,&gTheRect);	sprintf(gTheText,"min D-Space \r\rmax D-Space");	SetIText(gTheHandle,c2pstr(gTheText));		GetDItem(theDialog,_12_,&gType,&gTheHandle,&gTheRect);	sprintf(gTheText," \r\r");	SetIText(gTheHandle,c2pstr(gTheText));		SwitchBoolean(theDialog,_9_,!greyFlag);	SwitchBoolean(theDialog,_10_,!fullCircle);			HideDItem(theDialog,15);	HideDItem(theDialog,16);	HideDItem(theDialog,17);	HideDItem(theDialog,18);		HideDItem(theDialog,19);	HideDItem(theDialog,20);	HideDItem(theDialog,21);	HideDItem(theDialog,22);	HideDItem(theDialog,23);	}void	ERingObj::DoPictDraw(void){	double 		intensityRange;	Rect 		oldOval,theRect;	long 		theX;	SpotInfoPtr thisSpot;	short 		theIdent,i,negPtsH,negPtsW;	short 		hRes,vRes,theSize;	double		aMaxSize;			SetDrawEnviron();		ScreenRes(&hRes,&vRes);	negPtsW = (negWidth * hRes) /  50.8;	negPtsH = (negHeight * vRes) / 50.8;	SetPlotScales();			obj_Index->DoInit(false,theCrystal[0]);				SetRect(&theRect,centerX - 2,centerY - 2, centerX + 2,centerY + 2);	dm_PaintRect(&theRect);	thisSpot = (SpotInfoPtr)*theDataHandle;	intensityRange = 1. / (double)dyRange;	aMaxSize = (short)expoTime + 2;	thisSpot++;	for(i = 1; i < data_Count; i++,thisSpot++){				theIdent = thisSpot->flags & CRYSTAL_MASK;				if(!plotFlags[theIdent] && i > 1) continue;		theSize = Round(aMaxSize * pow((double)thisSpot->intensity,intensityRange));		if(!theSize){			SetRect(&oldOval,0,0,0,0);				thisSpot->spotRect = oldOval;			continue;		}		if(g_Monitor)		{			if(greyFlag)			{				DMForeColor(220 * pow((double)thisSpot->intensity,intensityRange) + 15);			}else{				DMForeColor(theIdent + 10);			}		}else{			PenNormal();			DMForeColor(BLACK);			if(greyFlag)			{				short patID;				double theValue;				PatHandle hPat;				theValue = 10 * pow((double)thisSpot->intensity,intensityRange);				patID = Round(theValue);				patID += 300;				hPat = GetPattern(patID);				PenPat(*hPat); 				ReleaseResource((Handle)hPat);			}		}						theX	= (short)(scaleFactor * (thisSpot->x));		SetRect(&oldOval,-theX,-theX,theX,theX);			OffsetRect(&oldOval,centerX,centerY);		thisSpot->spotRect = oldOval;		DrawSpot(&oldOval);		PenPat(&qd.black);	}	PenNormal();	theSearchObj->PlotRings(scaleFactor,scaleFactor,centerX,centerY,minX, maxX);	ClearDrawEnviron();}void	ERingObj::CalcFullSimulation(double hMaxAvg) {hMaxAvg = hMaxAvg;}void	ERingObj::SetDialogValues(DialogPtr theDialog,double *minXX,double *maxXX){		SetItemValue( theDialog,_19_,dwellTime * (maxX - minX) / (60 *stepSize),2);		*minXX = minX;		*maxXX  = maxX;		SetItemValue( theDialog,_7_,minX,2);		SetItemValue( theDialog,_8_,maxX,2);}double	ERingObj::GetMinMax(DialogPtr theDialog){	double oldV;	oldV = minX;	minX =  GetItemValue( theDialog,_7_);		if(minX != oldV)changedFlag = true;	oldV = maxX;	maxX =  GetItemValue( theDialog,_8_);	if(maxX != oldV)changedFlag = true;	return oldV;}void ERingObj::DrawSpot(Rect *theRect){	if(fullCircle)	{		dm_FrameOval(theRect);	}else{		short startAngle = 45;		FrameArc(theRect,startAngle,90);		FrameArc(theRect,startAngle - 90,-90);	}			}void ERingObj::SetPlotScales(void){	short hRes,vRes;	ScreenRes(&hRes,&vRes);	scaleFactor 		= (double)cameraConstant * (double)hRes / 25.4;	}void ERingObj::MyCalculate(void){	SpotInfoPtr thisSpot;	ResetCurvedLabels();	inherited::MyCalculate();	thisSpot		=	(SpotInfoPtr)*theDataHandle;	thisSpot->x =  0.1;	SetRect(&thisSpot->spotRect,centerX - 4,centerY - 4,centerX + 4,centerY + 4);}Boolean ERingObj::FindSpot(Point thePoint){	short 			i,n;	unsigned long			time;	SpotInfo		*theSpot;	static	Point	lastPoint;	static	short	lastLoc;	static	long	thelastClick;	static	Boolean	wasFound;	double			intensityRange;	double			delX,delY,radius;		time = gTheEvent.when;	if(thelastClick == time){	/* if NO elapsed time, then same event, data is OK */		return wasFound;	}	thelastClick = time;	LocalToObj(&thePoint);	/*MFTemp*/D_HLock			(theDataHandle);	theSpot 	= 	(SpotInfoPtr)*theDataHandle;		n = 1;	if(gShifted){		double	x,y;		x = thePoint.h - lastPoint.h;		y = thePoint.v - lastPoint.v;		if(sqrt(x * x + y * y) < 4.2){			n = lastLoc;		} else {			n = 1;		}	}	spotLoc = -1;		theRoundObj = (TextRoundObj*)NULL;	if(theCurvedLabels)	theRoundObj = (TextRoundObj*)theCurvedLabels->DoFind(thePoint);			if(theRoundObj){		wasFound				= 	true;		GetClip(gTheRgn);		/*MFTemp*/D_HUnlock(theDataHandle);		return 	true;	}		delX = (double)(thePoint.h - centerX);	delY = (double)(thePoint.v - centerY);	radius = sqrt(delX * delX + delY * delY);					intensityRange 	= 	1. / (double)dyRange; 	for(i = n , theSpot = &(((SpotInfoPtr)*theDataHandle)[n - 1])  ; i <= data_Count ; i++,theSpot++){				delX = centerX - theSpot->spotRect.left;			if(fabs(radius -  fabs(delX)) < 2){			/*MFTemp*/D_HUnlock(theDataHandle);			spotLoc 				= 	i - 1;			obj_Index->theCrystal	= 	THE_CURRENT_SPOT.theCrystal;			obj_Index->h 			= 	THE_CURRENT_SPOT.h;			obj_Index->k 			= 	THE_CURRENT_SPOT.k;			obj_Index->l 			= 	THE_CURRENT_SPOT.l;			obj_Index->direction 	= 	THE_CURRENT_SPOT.direction;						lastLoc		 			= 	i + 1;			thelastClick 			= 	time;			lastPoint 				= 	thePoint;			wasFound				= 	true;			return 						true;		}	}	spotLoc = -1;		thelastClick = time;	lastPoint = thePoint;		/*MFTemp*/D_HUnlock(theDataHandle);	if(n != 1){		SysBeep(30);	} else {		FlashMenuBar(0);		Delay(6L,&time);		FlashMenuBar(0);	}	lastLoc = 1;					/* in case the spot was close but missed */	wasFound = false;	return wasFound;}void ERingObj::LabelSpot(void){	Point	thePoint;		if((long)theRoundObj){		PenState thePenState;		newPictReq = true;		GetPenState(&thePenState);		DMForeColor(BACKGROUND_COLOR);		if(IsPressed((unsigned short )56)){			if(theRoundObj == theCurvedLabels){				theCurvedLabels = theCurvedLabels->next;				DoSetOrigin();				((SpotInfoPtr)(*theDataHandle))[theRoundObj->spotLoc].flags -= TEXT_MASK;				theRoundObj->Kill();				DoResetOrigin();				D_delete(theRoundObj);				theRoundObj = NUL;			}else{				DoSetOrigin();				if(theCurvedLabels)theCurvedLabels->EraseObject(theRoundObj);				DoResetOrigin();				theRoundObj = NUL;			}		}else{			theRoundObj->Move();			PenNormal();		}		SetPenState(&thePenState);	}	theRoundObj = 0L;	if(spotLoc >= 0){		newPictEnable = true;		if(THE_CURRENT_SPOT.flags & TEXT_MASK){			if(LabelAllLines(false))return;			if(!theCurvedLabels)THE_CURRENT_SPOT.flags -= TEXT_MASK;			DoSetOrigin();			if(theCurvedLabels)theCurvedLabels = (TextRoundObj*)theCurvedLabels->Erase(spotLoc,(TextObj*)theCurvedLabels);			DoResetOrigin();		} else {			if(LabelAllLines(true))return;			THE_CURRENT_SPOT.flags |= (TEXT_MASK);			THE_CURRENT_SPOT.theCrystal->SetColor();			GetMouse(&thePoint);			if(theCurvedLabels){				//theCurvedLabels->Add(spotLoc,(&THE_CURRENT_SPOT),thePoint);				TextRoundObj* line;				line = theCurvedLabels->Add(spotLoc,(&THE_CURRENT_SPOT),thePoint);				CleanLabel((TextObj*)line);				line -> Move();			}else{				theCurvedLabels = (TextRoundObj*)D_new(TextRoundObj);				theCurvedLabels->DoInit(false,theCrystal[0]);				theCurvedLabels->InsertNewLoc(spotLoc,(&THE_CURRENT_SPOT),thePoint);				CleanLabel(theCurvedLabels);				theCurvedLabels->Move();			}		}		return;	}}Boolean	ERingObj::LabelAllLines(Boolean label){	double 			x,y;//length;	Point 			thePoint,aPoint,centP;	short 			i,displacement;	SpotInfoPtr thisLine;	Rect				centerRect;	TextRoundObj* newLine;	double 			radius;		if(!IsPressed((unsigned short )58))return false;	D_HLock(theDataHandle);	thisLine 		= 	((SpotInfoPtr)*theDataHandle);	centerRect = thisLine->spotRect;	thisLine++;	ResetCurvedLabels();	newPictReq = true;	if(!label){		for(i = 1 ; i < data_Count; i++,thisLine++){			thisLine->flags -= TEXT_MASK;		} 		D_HUnlock(theDataHandle);		return true;	} 	y = 2 * PI / (double)(data_Count - 1); 	x = 0; 	centP.h = centerX; 	centP.v = centerY;	for(i = 1 ; i < data_Count; i++,thisLine++, x += y){		thisLine->flags |= TEXT_MASK;				radius = fabs((double)((thisLine->spotRect.right - thisLine->spotRect.left) / 2));		if(radius < 1) continue;		thePoint.h = centP.h + (radius * sin(x));		thePoint.v = centP.v + (radius * cos(x));		displacement = radius + 20 + 5 * x;		aPoint.h = centP.h + (displacement * sin(x));		aPoint.v = centP.v + (displacement * cos(x));		ObjToLocal(&aPoint);  //curvedlabels assume local coordinates coming into Add function		if(!theCurvedLabels){			theCurvedLabels = (TextRoundObj*)D_new(TextRoundObj);			theCurvedLabels->DoInit(false,theCrystal[0]);			newLine = theCurvedLabels->Add(i,thisLine,aPoint);		}else{			newLine = theCurvedLabels->Add(i,thisLine,aPoint);					}		newLine->lineRect.right = newLine->lineRect.left = thePoint.h;		newLine->lineRect.top 	= newLine->lineRect.bottom = thePoint.v;		theCurvedLabels->Draw(true);			}	D_HUnlock(theDataHandle);	return true;}void ERingObj::DrawTheText(void){		if(theCurvedLabels)theCurvedLabels->DrawAll();}void ERingObj::DoMenu(long theResult){	short theMenu,theItem;	Point thePoint;	static Boolean searchFlag = true;	theMenu = HiWord(theResult);	theItem = LoWord(theResult);	switch(theMenu){	case   EBEAM_DEFINE:		switch(theItem){			case 1: 				//DoDefine();				DoSetUp();				newPictReq = true;				break;			case 2:				changedFlag = true;								break;			case 3:				//SetPict(true);				newPictReq = true;				break;			case 5:								dyRange += .5;				//SetPict(true);				newPictReq = true;				switch(theBeamFlag)				{					case 1:						theEBeam->dyRange = dyRange;						break;					case 2:						theXRay->dyRange = dyRange;						break;					case 3:						break;				}				break;			case 6:				if(dyRange >= .5)					dyRange -= .5;				//SetPict(true);				newPictReq = true;				switch(theBeamFlag)				{					case 1:						theEBeam->dyRange = dyRange;						break;					case 2:						theXRay->dyRange = dyRange;						break;					case 3:						break;				}				break;		}		break;	case EBEAM_INFO:			switch(theItem){				case	LABEL_SPOT:						functionID		= LABEL_SPOT_F;						theRuler->SetPrompt("Add Label");						theRuler->SetHelp("Labels toggle on/off with succesive clicks. Hold <opt> to label/erase all spots.Hold <shift>to delete actual label.Labels are moveable.");/*dec 1992*/						SetTheCursor(TARGET_CURSOR);					break;					case	2:						functionID		= SHOW_INFO_F;						theRuler->SetHelp("Hold mouse down on ring of interest.");						theRuler->SetPrompt("Show Info:");						SetTheCursor(TARGET_CURSOR);					break;					case 4:						functionID = ADD_SPOT_SIMPLE_F;						theRuler->SetPrompt("Add a Ring. ");						theRuler->SetHelp("Click anywhere to add ring of that radius. Dbl-Click to change spot numerically.");						SetTheCursor(TARGET_CURSOR);					break;					case 6:						functionID = MOVE_RECONFIGURE_SPOT;						theRuler->SetPrompt("Move/Reconfigure Ring");						theRuler->SetHelp("Click on ring to be expanded or contracted. Dbl-Click to change spot numerically.");						SetTheCursor(TARGET_CURSOR);					break;					case 5:						functionID = DELETE_SPOT_F;						theRuler->SetHelp("Click on ring to delete it from picture");						theRuler->SetPrompt("Delete a Ring.");						SetTheCursor(TARGET_CURSOR);					break;					case 8:						functionID = MOVE_PATTERN;						theRuler->SetHelp("Click and hold on central spot to move it.");						theRuler->SetPrompt("Move Pattern");						thePoint.v = thePoint.h = 0;						MovePatternCenter(thePoint);						break;					default:						theResult = INFO_MENU * 65536 + theItem;						inherited::DoMenu(theResult); 						break;			}			break;					case SADSEARCH:			if(theItem > 5){							theSearchObj->wavelength = wavelength;				theSearchObj->requiredFOM = G_VECTOR_SEARCH;				theSearchObj->DoMenu(theResult);								//gMode = addOver;				/*SetPict(false);								tempPict = OpenPicture (&(*screenPict)->picFrame);				theSearchObj->PlotRings(scaleFactor,scaleFactorY,centerX,centerY,minPlottedX, maxPlottedX);								DrawPicture(screenPict,&(*screenPict)->picFrame);				ClosePicture ();								gMode = srcCopy;				PenMode(srcCopy);							KillPicture(screenPict);				screenPict = tempPict;				dm_EraseRect(&theWindow->portRect);				InvalRect(&theWindow->portRect);				*/			}else{				inherited::DoMenu(theResult);			}			break;					case 52:			CheckItem(base_Crystal_Menu,referenceCrystal + 1,false);			referenceCrystal = theItem - 1;				CheckItem(base_Crystal_Menu,theItem,true);			newPictReq = true;			break;										default:			inherited::DoMenu(theResult); 			break;	}		HiliteMenu(0);}void ERingObj::DoClose(void){	KillAllLabels();	inherited::DoClose();}Point 	ERingObj::MovePatternCenter(Point thePoint){	thePoint = inherited::MovePatternCenter(thePoint);	if(theCurvedLabels)theCurvedLabels->MoveAll( thePoint);	return thePoint;/*added for Think C*/}void		ERingObj::AddSpotSimple(Point thePoint){	double radius,x,y,intensityRange;	SpotInfoPtr theSpot;	short	theValue;	static Boolean hitSpot;				if(!Button())		hitSpot = false;		if(Button()){		if(FindSpot(thePoint)){			MoveReconfigureSpot(thePoint);			hitSpot = true;			return;		}		if(hitSpot) return;		if(data_Count >= data_Length)			ExpandMemory();		theSpot = &((SpotInfoPtr)*theDataHandle)[data_Count++];		theSpot->intensity = .6;		x = (thePoint.h - centerX);		y = (thePoint.v - centerY);		radius = sqrt(x * x + y * y);		SetRect(&theSpot->spotRect,-radius,-radius,radius,radius);		OffsetRect(&theSpot->spotRect,centerX,centerY);		theSpot->x =  radius  / scaleFactor;		theSpot->y =  0.0;		theSpot->z =  0.0;		theSpot->h = (short)1;		theSpot->k = (short)0;		theSpot->l = (short)0;		theSpot->direction = false;		theSpot->theCrystal = this->theCrystal[referenceCrystal];		theSpot->angle = 0.0;		theSpot->flags = referenceCrystal;		intensityRange = 1. / (double)dyRange;		if(greyFlag){			theValue = 220 * pow((double)theSpot->intensity,intensityRange);			DMForeColor(theValue + 15);		}else{			DMForeColor((theSpot->flags & CRYSTAL_MASK) + 10);			}		DrawSpot(&theSpot->spotRect);		hitSpot = true;	}}void	ERingObj::DeleteSpot(void){	short		i,end;	short 		theValue;	SpotInfo	*sourceSpot,*destSpot;	Rect		*theRect;	PenState	thePenState;	double			intensityRange;	/*MFTemp*/D_HLock(theDataHandle);	GetPenState(&thePenState);	sourceSpot = destSpot = &(((SpotInfoPtr)*theDataHandle)[spotLoc]);	sourceSpot++;		theRect = &(destSpot->spotRect);	ObjRectToLocal(theRect);	PenMode		(srcXor);	intensityRange = (double)1 / dyRange;	if(greyFlag){			theValue = 150 * pow((double)destSpot->intensity,intensityRange);			DMForeColor(theValue + 15);	}else{		DMForeColor(destSpot->flags & CRYSTAL_MASK + 10);		}	PenSize(2,2);	DrawSpot(&destSpot->spotRect);	end = data_Count - 1;	for(i = spotLoc ; i < end ; i++,sourceSpot++,destSpot++){		*destSpot = *sourceSpot;	}	data_Count--;	/*MFTemp*/D_HUnlock(theDataHandle);	//newPictEnable = true;	SetPenState(&thePenState);	if(theCurvedLabels)theCurvedLabels = (TextRoundObj*)theCurvedLabels->Erase(spotLoc,(TextObj*)theCurvedLabels);		return;}void ERingObj::MoveReconfigureSpot(Point thePoint){	Point oldPoint;	double radius,x,y;	short	theValue;	PenState thePenState;	GetPenState(&thePenState);	if(!StillDown()) return;	PenMode		(srcXor);	if(greyFlag){			theValue = 150 * pow((double)THE_CURRENT_SPOT.intensity,1/dyRange);			DMForeColor(theValue + 15);	}else{		DMForeColor((THE_CURRENT_SPOT.flags & CRYSTAL_MASK) + 10);		}		if(FindSpot(thePoint)){		while(StillDown()){			GetMouse(&thePoint);			if(thePoint.h != oldPoint.h || thePoint.v != oldPoint.v){				DrawSpot(&(THE_CURRENT_SPOT.spotRect));				x = (thePoint.h - centerX);				y = (thePoint.v - centerY);				radius = sqrt(x * x + y * y);				SetRect(&(THE_CURRENT_SPOT.spotRect),-radius,-radius,radius,radius);				OffsetRect(&(THE_CURRENT_SPOT.spotRect),centerX,centerY);				DrawSpot(&(THE_CURRENT_SPOT.spotRect));				oldPoint = thePoint;				THE_CURRENT_SPOT.x = radius / scaleFactor;				//newPictEnable = true;			}		}	}	SetPenState(&thePenState);}void ERingObj::DoAuxRead(void){	if( gTheFile->ReadBoolean()){		if(theCurvedLabels){theCurvedLabels->		ReadAll(theCrystal);		}else{			theCurvedLabels = (TextRoundObj*)D_new(TextRoundObj);			theCurvedLabels->DoInit(false,theCrystal[0]);			theCurvedLabels->		ReadAll(theCrystal);		}	}	fullCircle = gTheFile->ReadBoolean();	inherited::DoAuxRead();}void ERingObj::DoAuxWrite(void){		if(theCurvedLabels){		 gTheFile->WriteBoolean(true);		theCurvedLabels->		WriteAll();	}else{		 gTheFile->WriteBoolean(false);	}			gTheFile->WriteBoolean(fullCircle);	inherited::DoAuxWrite();}void		ERingObj::DoCourser(Point thePoint){	short 		hRes,vRes;	double 		theValue,theValue2,theH,theV,dspace;	static Point 		oldPoint;			GetMouse(&thePoint);				if(oldPoint.h == thePoint.h)			return;			theRuler->SetPrompt("Cursor Info:");		ScreenRes(&hRes,&vRes);		theH =  ((double)(thePoint.h - centerX)) / hRes;		theV =  ((double)(thePoint.v - centerY)) / vRes;		theValue = (sqrt((double)theH * theH + (double)theV * theV)) * 25.4;		if(theValue < .1){			theValue = 0;			dspace = 0;		}else{			theH =  (thePoint.h - centerX);			theV =  (thePoint.v - centerY);			theValue2 = (sqrt((double)theH * theH + (double)theV * theV));			dspace = scaleFactor / (theValue2);		}				sprintf(gTheText,"radius = %6.2f mm,D-Spacing = %7.3f ",theValue,dspace);				theRuler			->SetInfo(gTheText);		oldPoint 		= 	thePoint;}void ERingObj::InitializeGraph(void)//Override{	graph = 0L;}	