//ces.Jim:E_Diffract:E_SADObj2.c#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"PCVNumerical.h"#include	"RulerButton.h"#include	"AtomicScatter.h"#include	"SF_MathLib.h"#include	"Diffract_INCs.h"#include	"MicrographObj.h"#include 	"mathRecipies.h"#include 	"nrutil.h"#include 	"PictUtils.h"#include	"SADObj.h"//s.Jim:Desktop.2.0:E_Diffract 2:EL2_Micrograph.c#include "PoleBox.h"#include 	"PointObj.h"#include 	"GraphObject.h"      #include 	"TextTableObj.h"  //#include	"UBitMapObj.h"  #include 	"AtomData.h"#include 	"MultisliceFunctions.h"#include "f2c.h"#include "FortranProtos.h"#define SADDEFINE_OBJ 300double ReturnDspace(short sX1,short sY1,short eX1,short eY1,short sX2,short sY2,short eX2,short eY2);void SetAtomicMass(void);void	SADObj::InitializeGraph(void){	Rect graphBox;	SetRect(&graphBox,80,80,300,200);	if(graph){		graph->DoClose(graph);		graph = 0L;	}	graph	= (GraphSpots*)D_new(GraphSpots);	if(!graph)return;	graph->DoInit(graphBox,theCrystal[0]->crystalColor,true,true);	sprintf(gTheText,"2 Theta in Degrees");	graph->SetTitleX(gTheText);	sprintf(gTheText,"Intensity as Percentage");	graph->SetTitleY(gTheText);	sprintf(gTheText,"Diffractometer");	graph->SetTitleGraph(gTheText);	c2pstr(gTheText);	graph->titleMenu->P_AppendMenu	(gTheText);	graph->titleMenu->P_CheckItem		(2,true);}Boolean		SADObj::DoContent(Point thePoint){	short i;	Boolean flag = false;			/* Do Picture selects and moves */			PenNormal();	for(i = 1; i <= 4;i++) CheckItem(g_Base_Crystal_Menu,i,false);	CheckItem(g_Base_Crystal_Menu,referenceCrystal + 1,true);			PenNormal();	switch(functionID){		case RING_D_SPACING:		case SET_MAG_RING_F:			ExperimentalDSpRing(thePoint);			return true;		case SETUP_LATTICE_F:			SetupExpLattice( thePoint);			return true;		case SET_MAG_LINE_F:			SetMagLine(thePoint);			return true;		case D_SPACE_FR_LINE:			GetDSpaceLine(thePoint);			return true;		case ZONEAXIS_FR_LINE:							//GetZoneAxisFrLine(thePoint);//bloch			GetZoneAxisFromBox(thePoint);			return true;		case ZONE_AXIS_FR_PT:						GetZoneAxisByPoint(thePoint);			return true;		case PRIMITIVE_VOLUME:			GetPrimitiveVolume(thePoint);			return true;		case ADD_SPOT_SIMPLE_F:			AddSpotSimple(thePoint);			return true;		case MOVE_RECONFIGURE_SPOT:			MoveReconfigureSpot(thePoint);			return true;		case ROTATE_PATTERN:			RotateSpotsAroundZ(thePoint);			return true;		case ADD_SPOT_SUM_F:			AddSpotSummation( thePoint);			return true;		case  MOVE_PATTERN:			thePoint = MovePatternCenter(thePoint);			return true;		case SET_ASPECT_RATIO_F:			 DefineAspectRatioSquare(thePoint);			return true;		case MANUAL_SPOTS_F:			SetManualSpots( thePoint);			return true;		case  SET_BETHE_PERTURB_F://bloch		SetBethPerturb(thePoint);		return true;		default:			if(theImagePixels)				theImagePixels->DoContent(thePoint,&flag,REG_POINT);			if(graph != (GraphFunction*)NUL){				GraphFunction*  aGraph;				aGraph = graph->GetSelected();				if(aGraph){					if( PtInRect(thePoint,&aGraph->graphRect))						aGraph->DoContent(thePoint);					else						graph->ClearSelects();					if((inherited::DoContent(thePoint))) return true;					break;				}				if(graph->DoSelect(thePoint)){							//Delay(15,&gLongScratch);					graph->DoContent(thePoint);									}else{					graph->ClearSelects();				}			}				 	if((inherited::DoContent(thePoint))) return true;			break;			}		return false;}void		SADObj::DoIdle(void){	Point thePoint;	if(newPictReq){		if(!theRuler->functionFlag && theImagePixels){		//	theImagePixels->DrawAllText();		}	}	if(graph != (GraphFunction*)NUL){		graph->DoIdle();	}	GetMouse(&thePoint);	if(!functionID && theLine){		theLine->KillAll();		theLine = 0L;	}	switch(functionID){		case RING_D_SPACING:		case SET_MAG_RING_F:			ExperimentalDSpRing(thePoint);			break ;		case D_SPACE_FR_LINE:			GetDSpaceLine(thePoint);			break;			case SET_MAG_LINE_F:				SetMagLine(thePoint);			break;		case SETUP_LATTICE_F:			SetupExpLattice( thePoint);			break;		case ZONEAXIS_FR_LINE:			//GetZoneAxisFrLine(thePoint);//bloch			GetZoneAxisFromBox(thePoint);			break;		case ZONE_AXIS_FR_PT:			GetZoneAxisByPoint(thePoint);			break;		case PRIMITIVE_VOLUME:			GetPrimitiveVolume(thePoint);			break;		case ADD_SPOT_SIMPLE_F:			AddSpotSimple(thePoint);			break;		case MOVE_RECONFIGURE_SPOT:			MoveReconfigureSpot(thePoint);			break;		case ROTATE_PATTERN:			RotateSpotsAroundZ(thePoint);			break;		case ADD_SPOT_SUM_F:			AddSpotSummation( thePoint);			break;		case SET_ASPECT_RATIO_F:		case MANUAL_SPOTS_F:			//if(theImagePixels)theImagePixels->DoIdle();			break ;			}	if(theImagePixels)theImagePixels->DoIdle();	inherited::DoIdle();		return;}void		SADObj::DoDblClick(Point thePoint){	Boolean flag;	flag = IsPressed( (unsigned short )56);		switch(functionID){		case RING_D_SPACING:			return ;		case SETUP_LATTICE_F:		case SET_MAG_LINE_F:			if(theLine)theLine->SetSegments();		break;		case ADD_SPOT_SIMPLE_F:		case MOVE_RECONFIGURE_SPOT:			Set_Spot_Info(thePoint);			return;		case SET_ASPECT_RATIO_F:						DetermineCameraConstantsFromStandard();			sprintf(gTheText,"Aspect Ratio is now set to: x = %4.3fx'+ %4.3fy'+ %4.3fxy', y = %4.3fx'+ %4.3fy'+ %4.3fxy'",			xDis[1][1],xDis[2][1],xDis[3][1],yDis[1][1],yDis[2][1],yDis[3][1]);			theRuler->SetPrompt(gTheText);			if(flag){				if(theImagePixels)theImagePixels->DeleteAllOfType(ASPECT_RATIO);			}			return;		case ZONEAXIS_FR_LINE:			if(thePoleBox)thePoleBox->DoDblClick(thePoint);			break;			default:			break;	}	if(graph)graph->DoDblClick(thePoint);	inherited::DoDblClick(thePoint);}void	SADObj::DoKey(char theChar){	Point thePoint;	PointObj	*theObj,*anObject;	Boolean		flag = false;	short			hitLine = -1;		GetMouse(&thePoint);	switch(functionID){		case RING_D_SPACING:		case SET_MAG_RING_F:			GetMouse(&thePoint);			ExperimentalDSpRing(thePoint);			return;		case SET_ASPECT_RATIO_F:			if(theChar == 'ç'){				DetermineCameraConstantsFromStandard();				sprintf(gTheText,"Aspect Ratio is now set to: x = %4.3fx'+ %4.3fy'+ %4.3fxy', y = %4.3fx'+ %4.3fy'+ %4.3fxy'",				xDis[1][1],xDis[2][1],xDis[3][1],yDis[1][1],yDis[2][1],yDis[3][1]);				theRuler->SetPrompt(gTheText);				return;			}			if(theImagePixels){				if(theImagePixels->GetActive())flag = true;				theImagePixels->DoKey(theChar);				theImagePixels->DoCleanUp();				if(flag)return;			}						break ;		case SET_MAG_LINE_F:			if(theChar == 'µ'){				if(SetMagnification((double)theLine->GetLength()/(double)theLine->segments)) newPictReq = true;			}			break;		case SETUP_LATTICE_F:				if(theChar == '©'){theImagePixels->DeleteAllOfType(REG_POINT);SetExpLattice();}				else if(theChar == '∂' && theImagePixels)theImagePixels->DeleteAllOfType(REG_POINT);				else if(theChar == '†')	SetPointTable();				if(theImagePixels){					if(theImagePixels->GetActive())flag = true;					theObj = (PointObj*)theImagePixels->GetPointOfType(REG_POINT);					thePoint.h = theObj->hor;					thePoint.v = theObj->ver;					if(theLine && theLine->TakeCareOfLines(thePoint,thePoint,2,&hitLine)){						theImagePixels->DoKey(theChar);												theImagePixels->DoCleanUp();												if(theLine->HitLine(thePoint)){							thePoint.h = theObj->hor;							thePoint.v = theObj->ver;							theLine->ManipulateLine(thePoint);						}else{							thePoint.h = theObj->hor;							thePoint.v = theObj->ver;							theLine->next->ManipulateLine(thePoint);						}						PenMode						(patXor);						theLine->DrawAllLines(false);						if(flag)return;					}				}			break;		case MANUAL_SPOTS_F:			if(theImagePixels){				if(theImagePixels->GetActive())flag = true;				theImagePixels->DoKey(theChar);				theImagePixels->DoCleanUp();				if(theChar == '†')	SetPointTable();				if(theChar == '∂' && theImagePixels)theImagePixels->DeleteAllOfType(REG_POINT);				if(flag)return;			}			break;		default:			if(theChar == '\b')			{				theObj = 0L;				if(theImagePixels)theObj = (PointObj*)theImagePixels->GetActive();				if((long)theObj != 0L){					anObject = (PointObj*)theImagePixels->DeleteObject(theObj,theObj);					if((long)anObject != 0L){						theImagePixels  = (PointObj*)anObject;					}					return;				}							}		break;	}		inherited::DoKey(theChar);}void	SADObj::DoRefresh(void){	short i;	WindowPtr pWindow;		for(i = 1; i <= 4;i++) CheckItem(g_Base_Crystal_Menu,i,false);	CheckItem(g_Base_Crystal_Menu,referenceCrystal + 1,true);			inherited::DoRefresh();	pWindow = FrontWindow();		if(pWindow == theWindow){		/*short theSize;		theSize = 	(double)scaleFactor * (double)theEBeam->convergenceAngle;		theImagePixels->SetPointRectDiameters( theSize);*/		if(theImagePixels)theImagePixels->DrawAllText();	}		return;}void	SADObj::DoAuxWrite(void){	short i;	gTheFile->WriteShort(baseCrystal);	gTheFile->WriteShort(referenceCrystal);	 	gTheFile->WriteBoolean(objectDrawnFlag);	gTheFile->WriteDataBlock((Ptr)plotFlags,(sizeof(Boolean) * 6));		gTheFile->WriteFloat(lastDSpace);	gTheFile->WriteShort(MAXEXPDSPACE);	gTheFile->WriteDataBlock((Ptr)dspacings,(sizeof(float) * MAXEXPDSPACE));		gTheFile		->WriteBoolean(showPeriods);	gTheFile		->WriteFloat(xDis[1][1]);	gTheFile		->WriteFloat(xDis[2][1]);	gTheFile		->WriteFloat(xDis[3][1]);		gTheFile		->WriteFloat(yDis[1][1]);	gTheFile		->WriteFloat(yDis[2][1]);	gTheFile		->WriteFloat(yDis[3][1]);		gTheFile		->WriteFloat(sliceDistance);	gTheFile		->WriteFloat(numGVectors);	gTheFile		->WriteFloat(voxelThickness);	gTheFile		->WriteShort(numOfVoxSlice);	gTheFile		->WriteShort(unitOfMeasure);	gTheFile		->WriteShort(streakRes);	gTheFile		->WriteShort(kLimit);		gTheFile		->WriteBoolean(autoSlice);	gTheFile		->WriteBoolean(multiSlice);	gTheFile		->WriteBoolean(fullCalcPPt);	gTheFile		->WriteBoolean(pptSimple);	gTheFile		->WriteBoolean(objectDrawnFlag);	gTheFile		->WriteBoolean(calcPPtSize);	gTheFile		->WriteBoolean(kikuchiLines);					gTheFile->WriteDataBlock((Ptr)streakSize,(sizeof(long) * 3));	for(i = 0; i < 3;i++){		if(streakSize[i] > 0)		gTheFile->WriteHandle((Handle)streaks[i]);	}												inherited::DoAuxWrite();}void	SADObj::RationalizeData(void){	inherited::RationalizeData();}void	SADObj::DoAuxRead(void)			/*	Stub for offspring reads		*/{	short theNumber,i;if(!GetVersion(objectType)){		centerX 			= gTheFile->ReadShort();	centerY 			= gTheFile->ReadShort();}	baseCrystal 		= gTheFile->ReadShort();	referenceCrystal 	= gTheFile->ReadShort();		objectDrawnFlag 	= gTheFile->ReadBoolean();	gTheFile			-> ReadDataBlock((Ptr)plotFlags,(sizeof(Boolean) * 6));	for(i = 0 ; i <= 3 ; i++){		calculateFlags[i] = plotFlags[i];	}	if(!GetVersion(objectType))	{		theFoilThickness = 	gTheFile->ReadFloat();		rotationAngle 	= 	gTheFile->ReadFloat();		offLaueDistance = 	gTheFile->ReadFloat();	}	lastDSpace 		= 	gTheFile->ReadFloat();	if(!GetVersion(objectType))	{		totalRot 		= 	gTheFile->ReadFloat();	}	theNumber		= 	gTheFile->ReadShort();	gTheFile		->	ReadDataBlock((Ptr)dspacings,(sizeof(float) * theNumber));	if(!GetVersion(objectType))	{		theZoneAxis		->	ReadIndex(theCrystal);		theRotationAxis	->	ReadIndex(theCrystal);		theFoilNormal	->	ReadIndex(theCrystal);	}	showPeriods 	= 	gTheFile->ReadBoolean();		if(GetVersion(objectType)){		xDis[1][1] = gTheFile		->ReadFloat();		xDis[2][1] = gTheFile		->ReadFloat();		xDis[3][1] = gTheFile		->ReadFloat();			yDis[1][1] = gTheFile		->ReadFloat();		yDis[2][1] = gTheFile		->ReadFloat();		yDis[3][1] = gTheFile		->ReadFloat();			sliceDistance		=	gTheFile		->ReadFloat();		numGVectors			=	gTheFile		->ReadFloat();		voxelThickness	=	gTheFile		->ReadFloat();		numOfVoxSlice	=	gTheFile		->ReadShort();		unitOfMeasure =	gTheFile		->ReadShort();		streakRes		=		gTheFile		->ReadShort();		kLimit			=		gTheFile		->ReadShort();		autoSlice		=		gTheFile		->ReadBoolean();		multiSlice	=		gTheFile		->ReadBoolean();		fullCalcPPt	=		gTheFile		->ReadBoolean();		pptSimple		=		gTheFile		->ReadBoolean();		objectDrawnFlag	=	gTheFile		->ReadBoolean();		calcPPtSize			=	gTheFile		->ReadBoolean();		kikuchiLines		=	gTheFile		->ReadBoolean();						gTheFile->ReadDataBlock((Ptr)streakSize,(sizeof(long) * 3));		for(i = 0; i < 3;i++){			if(streakSize[i] > 0){				if(!streaks[i]){					streaks[i] = (PointInfo**)D_NewHandle(10 * sizeof(float));				}				gTheFile->ReadHandle((Handle)streaks[i]);			}		}		}else{		objectType += 1;	}	inherited::DoAuxRead();}void	SADObj::GetDSpaceLine(Point thePoint){		double 			dspace;	double 			theValue;	short 				length,i;	Crystal 			*aCrystal;	char 					theText[255];	short 				maxLines = 1;	static short hitLine;	short					hRes,vRes;	RgnHandle		theNewClip;		//newPictEnable = true;		if(!MaintainLines(maxLines,false,thePoint,thePoint))return;		GetClip(gTheRgn);	theNewClip = D_NewRgn();	RectRgn(theNewClip,&theVisRect);	D_SetClip(theNewClip);		dspace 		=  (double)scaleFactor / theLine->AvgPixelsBetween(theLine->next);	sprintf				(gTheText,"%8.2f Å",(double)dspace);	aCrystal 	= 	this->theCrystal[referenceCrystal];	obj_Index	->	DoInit(false,aCrystal);	theText[0] = 0;	ScreenRes			(&hRes,&vRes);	theValue 	= theLine->next->GetLength() * 25.4/(hRes * magnification);	sprintf(gTheText,"%8.2f Å S.L. Length = %d mm",dspace,(short)theValue);		for(i = 0; i < MAX_STORE_DSPACE; i++){		if(fabs(dspace - aCrystal->dspacings[i].x) < (.03 * dspace)){			obj_Index->h = aCrystal->dspacings[i].h;			obj_Index->k = aCrystal->dspacings[i].k;			obj_Index->l = aCrystal->dspacings[i].l;			obj_Index->IndexToIndecies(theText);			length = strlen(gTheText);			strcpy(&gTheText[length],p2cstr((unsigned char*)theText));		}	}	theRuler->SetInfo(gTheText);	D_SetClip(gTheRgn);	D_DisposeRgn(&theNewClip);}void	SADObj::GetZoneAxisFrLine(Point thePoint){	double 		dspace1,dspace2,x,y,z;	double 		theta,angle1,theValue;	short 			length,i,j,k,theCount,latticeType;	Crystal 		*aCrystal;	Index  			*theIndex1;	char 						theText[255];	CrystalFace 		newFaces[100],theFace;	short 					maxLines = 3;	static short 	hitLine;	short	 					hRes,vRes;	LineObj				*line2;	GetZoneAxisFromBox( thePoint);//bloch	return;//	newPictEnable = true;	if(!MaintainLines(maxLines,false,thePoint,thePoint))return;		line2 = theLine->next->next;		aCrystal 		= 	this->theCrystal[referenceCrystal];	theIndex1		= 	(Index*)D_new(Index);;	obj_Index		->	DoInit(false,aCrystal);	theIndex1		->	DoInit(false,aCrystal);	latticeType 	= 	obj_Index->theCrystal->lattice_Type;	dspace1 		=  	(double)scaleFactor / theLine->AvgPixelsBetween(0L);	dspace2 		=  	(double)scaleFactor / line2->AvgPixelsBetween(0L);	theta 		= 	180 * fabs(theLine->AngleBetween(line2)) / PI;	theText[0] = 0;	ScreenRes(&hRes,&vRes);	theValue =theLine->next->GetLength() * 25.4/(hRes * magnification);	sprintf(gTheText,"%8.2f Å %8.2f Å %6.2f ° L.L. Length = %d",dspace1,dspace2,theta, (short)theValue);	for(i = 0; i < MAX_STORE_DSPACE; i++){		if(fabs(dspace2 - aCrystal->dspacings[i].x) < (.03 * dspace1)){			theIndex1->h = aCrystal->dspacings[i].h;			theIndex1->k = aCrystal->dspacings[i].k;			theIndex1->l = aCrystal->dspacings[i].l;			for(j = 0; j <  MAX_STORE_DSPACE; j++){				if(fabs(dspace1 - aCrystal->dspacings[j].x) < (.03 * dspace1)){					theFace.h = obj_Index->h = aCrystal->dspacings[j].h;					theFace.k = obj_Index->k = aCrystal->dspacings[j].k;					theFace.l = obj_Index->l = aCrystal->dspacings[j].l;					theCount = -1;					CubicPermutate(&theCount,theFace,newFaces,true,latticeType);										for(k = 0; k <= theCount;k++){						obj_Index->h = newFaces[k].h;						obj_Index->k = newFaces[k].k;						obj_Index->l = newFaces[k].l;						angle1 = fabs(theIndex1->GetTheAngle(obj_Index));						if(fabs(angle1 - theta) <= 3.){							CrossProduct(&x,&y,&z,(double)newFaces[k].h,										(double)newFaces[k].k,(double)newFaces[k].l										,(double)theIndex1->h,(double)theIndex1->k,(double)theIndex1->l);							goto THESPOT2;													}					}				}			}		}	}	goto THESPOT3;THESPOT2:	obj_Index->h = (short)x;	obj_Index->k = (short)y;	obj_Index->l = (short)z;		obj_Index->direction 	= 	true;	theText[0] 		= 	0;	obj_Index			->	IndexToIndecies(theText);	length 			= 	strlen(gTheText);	strcpy		(&gTheText[length],p2cstr((unsigned char*)theText));	length 			= 	strlen(gTheText);		gTheText				[length++] = ' ';	theText[0] = 0;	obj_Index->h = newFaces[k].h;	obj_Index->k = newFaces[k].k;	obj_Index->l = newFaces[k].l;	obj_Index->direction = false;	obj_Index->IndexToIndecies(theText);		strcpy(&gTheText[length],p2cstr((unsigned char*)theText));		length = strlen(gTheText);	gTheText[length++] = ' ';		theText[0] = 0;		theIndex1->IndexToIndecies(theText);	strcpy(&gTheText[length],p2cstr((unsigned char*)theText));	THESPOT3:	D_delete(theIndex1);	PenNormal();	theRuler->SetInfo(gTheText);	return;}void SADObj::GetPrimitiveVolume(Point thePoint){	long theResult;	double dspace1,dspace2,P,m,theta,dia;	static double zozlScaleFactor;	static short lineNo;	static Point oldPoint;	static Rect oldPicRect;			if(thePoint.h == -3000){		short cX,cY,delH,delV;		theResult = BEAM_SEL_HIER * 65536 + theBeamFlag;		scaleFactor *= 2.;		oldPicRect = thePictRect;		delH = (thePictRect.right - thePictRect.left) * magnification;		delV = (thePictRect.bottom - thePictRect.top) * magnification;		cX = (thePictRect.right + thePictRect.left) / 2.0;		cY = (thePictRect.bottom + thePictRect.top) / 2.0;		SetRect(&thePictRect,cX - delH,cY - delV,cX + delH,cY + delV);		if((long)picObjList != NUL){			picObjList->ZoomAll(2.);		}		SetPict(true);		DoSetOrigin();		if((long)picObjList != NUL){			PenMode(transparent+addPin);			picObjList->DrawThePicts();			picObjList->DrawSelected();		}		if(gTheSelection->isValid){			gTheSelection->DoFrame();		}		DoResetOrigin();		DoSetOrigin();		PenMode(gMode);		DrawPicture(screenPict,&thePictRect);		PenNormal();		DoResetOrigin();		zozlScaleFactor = scaleFactor;		theRuler->SetPrompt("Set Two Vectors");			GetZoneAxisByPoint(thePoint);		oldPoint = thePoint;		lineNo = 0;				scaleFactor /= 2.;		return;	}	while(!gShifted && lineNo == 0){		scaleFactor *= 2.;		GetZoneAxisByPoint(thePoint);		scaleFactor /= 2.;		gShifted = false;		return;	}	lineNo++;	//newPictEnable = true;	if(lineNo == 1){		theResult = BEAM_SEL_HIER * 65536 + theBeamFlag;				if((long)picObjList != NUL){			picObjList->ZoomAll(.5);		}		thePictRect = oldPicRect;		SetPict(true);		DoSetOrigin();		if((long)picObjList != NUL){			PenMode(transparent+addPin);			picObjList->DrawThePicts();			picObjList->DrawSelected();		}		if(gTheSelection->isValid){			gTheSelection->DoFrame();		}		DoResetOrigin();		DoSetOrigin();				PenMode(gMode);		DrawPicture(screenPict,&thePictRect);		PenNormal();		DoResetOrigin();		theRuler->SetPrompt("Set FOLZ Diameter");		lineNo++;		return;	}	if(thePoint.h == oldPoint.h && thePoint.v == oldPoint.v ) return;		ExperimentalDSpRing		(thePoint);	oldPoint 		= 		thePoint;		if(!Button()) return;		theRuler->SetPrompt("Calc. Primitive Vol.");	dspace1 	=  	(double)zozlScaleFactor / theLine->GetLength();	dspace2 	=  	(double)zozlScaleFactor / theLine->next->GetLength();	theta		= 	fabs(theLine->AngleBetween(theLine->next));	P 		= 	wavelength / (1 - cos(atan(wavelength /lastDSpace)));	m 		= 	(1./( dspace1 * dspace2)) * sin(theta);	dia 		= 	2. * cameraConstant / lastDSpace;	sprintf		(gTheText," %6.2f Å3,%6.1f mm,%6.2f Å",P/m,dia,P);	theRuler->SetInfo(gTheText);	gShifted = false;}void	SADObj::GetZoneAxisByPoint(Point thePoint){	double 		dspace1,dspace2,x,y,z;	double					theta,angle1;	short 					length,i,j,k,theCount,latticeType;	static Crystal *aCrystal;	Index  				*theIndex1;	char			 		theText[255];	CrystalFace 	newFaces[100],theFace;	static Rect 	theCenterRect;	static Rect 	theRect;		short 		maxLines = 1;	short			hRes,vRes;	double		theValue;	Point 		aPoint;	aPoint.h = centerX;	aPoint.v = centerY;	if(!MaintainLines(maxLines,true,thePoint,aPoint))return;		aCrystal = theCrystal[referenceCrystal];	theIndex1 = (Index*)D_new(Index);	obj_Index->DoInit(false,aCrystal);	theIndex1->DoInit(false,aCrystal);		latticeType = obj_Index->theCrystal->lattice_Type;	dspace1 =  (double)scaleFactor / theLine->GetLength();	dspace2 =  (double)scaleFactor / theLine->next->GetLength();	theta = 180 * fabs(theLine->AngleBetween(theLine->next)) / PI;	theText[0] = 0;	ScreenRes(&hRes,&vRes);		theValue =theLine->next->GetLength() * 25.4/(hRes * magnification);	sprintf(gTheText,"%8.2f Å %8.2f Å %6.2f° S.L. Length = %d",dspace1,dspace2,theta,(short)theValue);	for(i = 0; i < MAX_STORE_DSPACE; i++){		if(fabs(dspace2 - aCrystal->dspacings[i].x) < (.03 * dspace1)){			theIndex1->h = aCrystal->dspacings[i].h;			theIndex1->k = aCrystal->dspacings[i].k;			theIndex1->l = aCrystal->dspacings[i].l;			for(j = 0; j < MAX_STORE_DSPACE; j++){				if(fabs(dspace1 - aCrystal->dspacings[j].x) < (.03 * dspace1)){					theFace.h = obj_Index->h = aCrystal->dspacings[j].h;					theFace.k = obj_Index->k = aCrystal->dspacings[j].k;					theFace.l = obj_Index->l = aCrystal->dspacings[j].l;					theCount = -1;					CubicPermutate(&theCount,theFace,newFaces,true,latticeType);										for(k = 0; k <= theCount;k++){						obj_Index->h = newFaces[k].h;						obj_Index->k = newFaces[k].k;						obj_Index->l = newFaces[k].l;						angle1 = fabs(theIndex1->GetTheAngle(obj_Index));						if(fabs(angle1 - theta) <= 3.){							CrossProduct(&x,&y,&z,(double)newFaces[k].h,										(double)newFaces[k].k,(double)newFaces[k].l										,(double)theIndex1->h,(double)theIndex1->k,(double)theIndex1->l);							goto THESPOT2;													}					}				}			}		}	}	goto THESPOT3;THESPOT2:	obj_Index->h = (short)x;	obj_Index->k = (short)y;	obj_Index->l = (short)z;	obj_Index->direction = true;	theText[0] = 0;	obj_Index->IndexToIndecies(theText);	length = strlen(gTheText);	strcpy(&gTheText[length],p2cstr((unsigned char*)theText));	length = strlen(gTheText);	gTheText[length++] = ' ';	theText[0] = 0;	obj_Index->h = newFaces[k].h;	obj_Index->k = newFaces[k].k;	obj_Index->l = newFaces[k].l;	obj_Index->direction = false;	obj_Index->IndexToIndecies(theText);		strcpy(&gTheText[length],p2cstr((unsigned char*)theText));		length = strlen(gTheText);	gTheText[length++] = ' ';		theText[0] = 0;		theIndex1->IndexToIndecies(theText);	strcpy(&gTheText[length],p2cstr((unsigned char*)theText));	THESPOT3:	D_delete(theIndex1);	theRuler->SetInfo(gTheText);	PenNormal();	return;}void SetAtomicMass(void){	short i,j,anErr;	Handle theReshandle;	float *x;	float theValue;	x = (float*)D_NewPtr(95L * sizeof(float));	for(i = 0; i <= 94; i++){		j = i + 1;		switch(j){			case 1:				theValue = 1.0080;				break;			case 2:				theValue = 4.0026;				break;			case 3:				theValue = 6.941;				break;			case 4:				theValue = 9.01218;				break;			case 5:				theValue = 10.81;				break;			case 6:				theValue = 12.011;				break;			case 7:				theValue = 14.0067;				break;			case 8:				theValue = 15.9984;				break;			case 9:				theValue = 18.9984;				break;			case 10:				theValue = 20.179;				break;			case 11:				theValue = 22.9898;				break;			case 12:				theValue = 24.305;				break;			case 13:				theValue = 26.9815;				break;			case 14:				theValue = 28.086;				break;			case 15:				theValue = 30.9738;				break;			case 16:				theValue = 32.06;				break;			case 17:				theValue = 35.453;				break;			case 18:				theValue = 39.948;				break;			case 19:				theValue = 39.102;				break;			case 20:				theValue = 40.08;				break;			case 21:				theValue = 44.9559;				break;			case 22:				theValue = 47.90;				break;			case 23:				theValue = 50.9414;				break;			case 24:				theValue = 51.996;				break;			case 25:				theValue = 54.9380;				break;			case 26:				theValue = 55.847;				break;			case 27:				theValue = 58.9332;				break;			case 28:				theValue = 58.71;				break;			case 29:				theValue = 63.546;				break;			case 30:				theValue = 65.37;				break;			case 31:				theValue = 69.72;				break;			case 32:				theValue = 72.59;				break;			case 33:				theValue = 74.9216;				break;			case 34:				theValue = 78.96;				break;			case 35:				theValue = 79.904;				break;			case 36:				theValue = 83.8;				break;			case 37:				theValue = 85.4678;				break;			case 38:				theValue = 87.62;				break;			case 39:				theValue = 88.9059;				break;			case 40:				theValue = 91.22;				break;			case 41:				theValue = 92.9064;				break;			case 42:				theValue = 95.94;				break;			case 43:				theValue = 99.0;				break;			case 44:				theValue = 101.07;				break;			case 45:				theValue = 102.9055;				break;			case 46:				theValue = 106.4;				break;			case 47:				theValue = 107.868;				break;			case 48:				theValue = 112.4;				break;			case 49:				theValue = 114.82;				break;			case 50:				theValue = 118.69;				break;			case 51:				theValue = 121.75;				break;			case 52:				theValue = 127.6;				break;			case 53:				theValue = 126.9045;				break;			case 54:				theValue = 131.3;				break;			case 55:				theValue = 132.9055;				break;			case 56:				theValue = 137.34;				break;			case 57:				theValue = 138.9055;				break;			case 58:				theValue = 140.12;				break;			case 59:				theValue = 140.9077;				break;			case 60:				theValue = 144.24;				break;			case 61:				theValue = 147.;				break;			case 62:				theValue = 150.4;				break;			case 63:				theValue = 151.96;				break;			case 64:				theValue = 157.25;				break;			case 65:				theValue = 158.9254;				break;			case 66:				theValue = 162.5;				break;			case 67:				theValue = 164.9303;				break;			case 68:				theValue = 167.26;				break;			case 69:				theValue = 168.9342;				break;			case 70:				theValue = 173.04;				break;			case 71:				theValue = 174.97;				break;			case 72:				theValue = 178.49;				break;			case 73:				theValue = 180.9479;				break;			case 74:				theValue = 183.85;				break;			case 75:				theValue = 186.207;				break;			case 76:				theValue = 190.2;				break;			case 77:				theValue = 192.22;				break;			case 78:				theValue = 195.09;				break;			case 79:				theValue = 196.9665;				break;			case 80:				theValue = 200.59;				break;			case 81:				theValue = 204.37;				break;			case 82:				theValue = 207.2;				break;			case 83:				theValue = 208.9806;				break;			case 84:				theValue = 210;				break;			case 85:				theValue = 210;				break;			case 86:				theValue = 222;				break;			case 87:				theValue = 223;				break;			case 88:				theValue = 226;				break;			case 89:				theValue = 227;				break;			case 90:				theValue = 232.0381;				break;			case 91:				theValue = 231;				break;			case 92:				theValue = 238.029;				break;			case 93:				theValue = 237;				break;			case 94:				theValue = 242;				break;			case 95:				theValue = 247;				break;			default:				break;		}		x[i] = theValue;	}	theReshandle = GetResource('info',100);	anErr = ResError();	HNoPurge(theReshandle);	anErr = ResError();	*theReshandle = (Ptr)x;	ChangedResource(theReshandle);	anErr = ResError();	if(ResError() != noErr){		ReleaseResource(theReshandle);		return;	}	WriteResource(theReshandle);	HPurge(theReshandle);	ReleaseResource(theReshandle);	KillPtr((Ptr)x);	UpdateResFile(CurResFile());}#define SPOT_INFO_DIALOG 303void	SADObj::Set_Spot_Info(Point thePoint){	DialogPtr 		theDialog;	short			i;	Boolean			quit = false;	PopUpMenu	*thePopMenu;	short 		lastCrystal;	short		theItem;		if(!FindSpot(thePoint))		return;	SetTheCursor(0);		theDialog	= DM_GetNewDialog(SPOT_INFO_DIALOG,NUL,IN_FRONT);		for(i = 0; i <= 3;i++){		if(THE_CURRENT_SPOT.theCrystal == theCrystal[i]) lastCrystal = i;	}	lastCrystal++;	thePopMenu = (PopUpMenu*)D_new(PopUpMenu);	thePopMenu->Init(theDialog,10,52,lastCrystal);	obj_Index->h = THE_CURRENT_SPOT.h;	obj_Index->k = THE_CURRENT_SPOT.k;	obj_Index->l = THE_CURRENT_SPOT.l;	obj_Index->SetIndex(theDialog,3);	GetDItem(theDialog,8,&gType,&gTheHandle,&gTheRect);	if(THE_CURRENT_SPOT.direction)SetCtlValue((ControlHandle)gTheHandle,1);	else SetCtlValue((ControlHandle)gTheHandle,0);		GetDItem(theDialog,9,&gType,&gTheHandle,&gTheRect);	if(!THE_CURRENT_SPOT.direction)SetCtlValue((ControlHandle)gTheHandle,1);	else SetCtlValue((ControlHandle)gTheHandle,0);		SetItemValue(theDialog,4,100 * THE_CURRENT_SPOT.intensity,2);	SetItemValue(theDialog,5,THE_CURRENT_SPOT.x,2);	SetItemValue(theDialog,6,THE_CURRENT_SPOT.y,2);	SetItemValue(theDialog,7,THE_CURRENT_SPOT.z,2);		while(!quit){		ModalDialog(TheFilterUPP,&theItem);		switch(theItem){			case -1:			case 2:				thePopMenu->DoClose();				DM_DisposDialog(&theDialog);								SetTheCursor(TARGET_CURSOR);				return;			case DLOG_ENTER_OR_CR:			case 1:				quit = true;				SetTheCursor(TARGET_CURSOR);				break;			case 8:				GetDItem(theDialog,8,&gType,&gTheHandle,&gTheRect);				if(!GetCtlValue((ControlHandle)gTheHandle)){					SetCtlValue((ControlHandle)gTheHandle,1);					GetDItem(theDialog,9,&gType,&gTheHandle,&gTheRect);					SetCtlValue((ControlHandle)gTheHandle,0);				}				break;			case 9:				GetDItem(theDialog,9,&gType,&gTheHandle,&gTheRect);				if(!GetCtlValue((ControlHandle)gTheHandle)){					SetCtlValue((ControlHandle)gTheHandle,1);					GetDItem(theDialog,8,&gType,&gTheHandle,&gTheRect);					SetCtlValue((ControlHandle)gTheHandle,0);				}				break;			case 10:								lastCrystal = LoWord(thePopMenu->DoPopUp());								break;			default:				break;			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			}	}			obj_Index	->		GetIndex(theDialog,3);	THE_CURRENT_SPOT.h = obj_Index->h;	THE_CURRENT_SPOT.k = obj_Index->k;	THE_CURRENT_SPOT.l = obj_Index->l;			THE_CURRENT_SPOT.intensity = (double)GetItemValue(theDialog,4) / 100.;	THE_CURRENT_SPOT.x = GetItemValue(theDialog,5);	THE_CURRENT_SPOT.y = GetItemValue(theDialog,6);	THE_CURRENT_SPOT.z = GetItemValue(theDialog,7);	THE_CURRENT_SPOT.theCrystal = theCrystal[lastCrystal - 1];	CheckItem(g_Base_Crystal_Menu,referenceCrystal + 1,false);	referenceCrystal = lastCrystal - 1;		THE_CURRENT_SPOT.flags = referenceCrystal;	plotFlags[referenceCrystal] = true;		GetDItem		(theDialog,8,&gType,&gTheHandle,&gTheRect);		if(GetCtlValue((ControlHandle)gTheHandle))THE_CURRENT_SPOT.direction = true;	else THE_CURRENT_SPOT.direction = false;		thePopMenu	->	DoClose();	DM_DisposDialog(&theDialog);	objectDrawnFlag = true;}PicHandle SADObj::DisplayPict(Rect *theRect,short horiz,short vert){	short 	length,h,v,i,width;	PicHandle	thePict;	Rect			frameRect,theRect1;	char 		theText[255];	Boolean flag = true;	TextFont(systemFont);	PenNormal();	PenPat(&qd.black);	DMForeColor(10);	sprintf(gTheText,"Crystal Type:  Orthorhombic");	c2pstr(gTheText);	width = StringWidth(pTheText);	SetRect(theRect,2,2,width + 30,225);	OffsetRect(theRect,horiz,vert);	frameRect = *theRect;	//InsetRect(&frameRect,-2,-2);	thePict = OpenPicture(theRect);			v = 25;		for(i = 1 ; i <= 10 ; i++){				switch(i){			case 1:				sprintf(gTheText,"Zone Axis = ");				theZoneAxis->IndexToText(theText);				theZoneAxis->IndexToIndecies(theText);				p2cstr((unsigned char*)theText);				strcat(gTheText,theText);				break;			case 2:				sprintf(gTheText,"Foil Normal = ");				theFoilNormal->IndexToText(theText);				theFoilNormal->IndexToIndecies(theText);				p2cstr((unsigned char*)theText);				strcat(gTheText,theText);				break;			case 3:				sprintf(gTheText,"Foil Thickness = %5.1f nm",theFoilThickness);				break;			case 4:				if(plotFlags[0]){					sprintf(gTheText,"Matrix Plotted");					SetRect(&theRect1,frameRect.right - 32,v + vert - 4,frameRect.right - 24,v + vert + 4);					DM_DrawRect(theRect1, 0,1., false);					SetRect(&theRect1,frameRect.right - 16,v + vert - 4,frameRect.right - 8,v + vert + 4);					DM_DrawRect(theRect1, 0,1., true);				}else flag = false;				break;			case 5:				if(plotFlags[1]){					sprintf(gTheText,"Precipitate 1 Plotted");					SetRect(&theRect1,frameRect.right - 32,v + vert - 4,frameRect.right - 24,v + vert + 4);					DM_DrawRect(theRect1, 1,1., false);					SetRect(&theRect1,frameRect.right - 16,v + vert - 4,frameRect.right - 8,v + vert + 4);					DM_DrawRect(theRect1, 1,1., true);				}				else flag = false;				break;			case 6:				if(plotFlags[2]){					sprintf(gTheText,"Precipitate 2 Plotted");					SetRect(&theRect1,frameRect.right - 32,v + vert - 4,frameRect.right - 24,v + vert + 4);					DM_DrawRect(theRect1, 2,1., false);					SetRect(&theRect1,frameRect.right - 16,v + vert - 4,frameRect.right - 8,v + vert + 4);					DM_DrawRect(theRect1, 2,1., true);				}				else flag = false;				break;			case 7:				if(plotFlags[3]){					sprintf(gTheText,"Precipitate 3 Plotted");					SetRect(&theRect1,frameRect.right - 32,v + vert - 4,frameRect.right - 24,v + vert + 4);					DM_DrawRect(theRect1, 3,1., false);					SetRect(&theRect1,frameRect.right - 16,v + vert - 4,frameRect.right - 8,v + vert + 4);					DM_DrawRect(theRect1, 3,1., true);				}				else flag = false;				break;			case 8:				DMForeColor(10);				if(plotFlags[4])sprintf(gTheText,"Pattern Off Zone Axis");				else flag = false;				break;			case 9:				TextFont(courier);				TextSize(10);				if(plotFlags[4]){					sprintf(gTheText,"Rotated %5.2fo along the ",rotationAngle);					theZoneAxis->IndexToText(theText);					theZoneAxis->IndexToIndecies(theText);					p2cstr((unsigned char*)theText);					strcat(gTheText,theText);				}else flag = false;				break;			case 10:				if(plotFlags[4]){					sprintf(gTheText,"%4.1f mm Off Of Laue Condition ", offLaueDistance);				}else flag = false;				break;		}		if(flag){			c2pstr(gTheText);			length = StringWidth(pTheText);			h = 200;			MoveTo(horiz + 6,v + vert);  /* h + horiz - length,v + vert */			DrawDiffractString(pTheText);			v += 20;		}		flag = true;	}	PenSize(2,2);	TextFont(systemFont);	TextSize(12);	DMForeColor(BLACK);	FrameRect(&frameRect);	PenNormal();	ClosePicture();	return(thePict);}Point 	SADObj::MovePatternCenter(Point thePoint){	short		theSize = 10;	Point 		centerPoint,oldPoint,newCt,aPoint;	short 		difX,difY;	 Rect 		theCenterRect;	RgnHandle		theNewClip;	PenState		thePenState;		theSize 	= 	(double)scaleFactor * (double)theEBeam->convergenceAngle;	SetRect		(&theCenterRect,-theSize,-theSize,theSize,theSize);			centerPoint.h = centerX;	centerPoint.v = centerY;	OffsetRect	(&theCenterRect,centerPoint.h,centerPoint.v);	GetMouse(&thePoint);	oldPoint.h = 0;	oldPoint.v = 0;	aPoint = oldPoint;	PenNormal();	ObjRectToLocal(&theCenterRect);	if(!PtInRect(thePoint,&theCenterRect))		return oldPoint;				ObjToLocal(&centerPoint);	GetPenState(&thePenState);	newCt = oldPoint = centerPoint;/*this is important to add!!!!*/		GetClip(gTheRgn);	theNewClip = D_NewRgn();	RectRgn(theNewClip,&theVisRect);	D_SetClip(theNewClip);		//newPictEnable = false;	while(StillDown()){		GetMouse(&thePoint);		if(!EqualPt(thePoint,oldPoint) && PtInRgn(thePoint,drawRgn)){						PenMode(patXor);						dm_FrameOval(&theCenterRect);			difX = thePoint.h - oldPoint.h;			difY = thePoint.v - oldPoint.v;			newCt.h = thePoint.h;			newCt.v = thePoint.v;			OffsetRect(&theCenterRect,difX,difY);			dm_FrameOval(&theCenterRect);			oldPoint = thePoint;			newPictReq = true;					}			}	D_SetClip(gTheRgn);	D_DisposeRgn(&theNewClip);		thePoint.h =  newCt.h - centerPoint.h ;	thePoint.v = newCt.v - centerPoint.v;	SetPenState(&thePenState);		if(thePoint.h != 0 || thePoint.v != 0 && newPictReq){		LocalToObj(&newCt);		centerX = newCt.h;		centerY = newCt.v;	}	return  thePoint;}void	DiffractObject::PlotPeriods(short zoneOrder/*,SpotInfoPtr  thisSpot*/){	Rect aOval;	double thePeriod2;	double diameter;	short theSize;	double cameraLength;	double	xFormMatrix[3][3],xForm[3][3];	double	x,y,z,length;	short	h,v,j,l;	Crystal	*thisCrystal;	cameraLength 	= 	cameraConstant/wavelength;	GetOrientation(xFormMatrix);	thisCrystal = theCrystal[baseCrystal];	GetPPTXFormMatrixBase		(xForm,thisCrystal,0);	MatrixMultiply			(xForm,xFormMatrix,xForm);	theZoneAxis->DoCopy(obj_Index);	obj_Index->GetXYZ(xForm);	x = obj_Index->x;	y = obj_Index->y;	z = obj_Index->z;	length = sqrt(x * x + y * y + z * z);	x /= length;	y /= length;	ScreenRes(&j,&l);	x *= cameraLength / 25.4;	y *= cameraLength / 25.4;	h = (y * j);	h +=  centerX;	v = (x * l);	v += centerY;	if(zoneOrder == 0){		if(h != centerX ||  v != centerY){			x = centerX - h;			y = centerY - v;			theSize = sqrt(x * x + y * y);			SetRect(&aOval,-theSize,-theSize,theSize,theSize);			OffsetRect(&aOval,(short)h,(short)v);			dm_FrameOval(&aOval);		}	}	thePeriod2 = 1/theZoneAxis->Periodicity(zoneOrder,cameraLength * 2,wavelength,&diameter);	theSize = (double)scaleFactor * (double)diameter * .5 / cameraConstant;	SetRect(&aOval,-theSize,-theSize,theSize,theSize);	OffsetRect(&aOval,(short)h,(short)v);	dm_FrameOval(&aOval);	}