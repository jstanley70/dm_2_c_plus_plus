//ces.Jim:E_Diffract:E_SADObj.c#include 	"mathRecipies.h"#include 	"nrutil.h"#include 	"PictUtils.h"//s.Jim:Desktop.2.0:E_Diffract 2:EL2_Micrograph.c#include 	"PointObj.h"#include 	"GraphObject.h"      #include 	"TextTableObj.h"  //#include	"UBitMapObj.h" #include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"PCVNumerical.h"#include	"RulerButton.h"#include	"AtomicScatter.h"#include	"SF_MathLib.h"#include	"StereoObject.h"#include 	"PoleBox.h"#include	"SADObj.h"#include 	"JimsLib.h"/*enum{	DSPACER = 3,	ZONEAXISL,	DSPACEK = 6,	ZONEAXISK,	VOLUMEEXP,	VOLUMENUM};*/#include 	"JCPDFCrystal.h" double ReturnDspace(short sX1,short sY1,short eX1,short eY1,short sX2,short sY2,short eX2,short eY2);void SetAtomicMass(void);void SADObj::DoInit(){	short i;	kLimit = 5;	voxelThickness = .02;	numOfVoxSlice  =  8;	numGVectors		=		1;	autoSlice      =  false;	multiSlice		=		false;	fullCalcPPt		=		false;	sliceDistance = 	.05;	pptSimple			=		true;	variSize					=	true;	rulerHeight					=	50;	streakRes					=	10;	plotFlags[0] 				= 	true;	for(i = 1; i < 6;i++)plotFlags[i] 				= 	0;	graph							=	0L;	theTable					=	0L;	theTable          =   0L;  thePoleBox        =   0L;//bloch  theImagePixels 		= 0;   stereoObj = 0L;	data_Size					=	sizeof(SpotInfo);	greyFlag					= 	false;	calcPPtSize					=	false;	kikuchiLines				=	false;	numberOfSteps				=	0;	interval						=	10;	delugeFlag					=	false;	calcIntensities			=	0L;//Bloch	xDis = matrix(1,4,1,1);	yDis = matrix(1,4,1,1);	xDis[1][1] = 1; xDis[2][1] =  xDis[3][1] = 0;	yDis[2][1] = 1; yDis[1][1] =  yDis[3][1] = 0;	inherited::DoInit();	stage->enableBragg = true;	for(i = 0; i < 3;i++){streaks[i] = 0L;streakSize[i] = 0;}			referenceCrystal 	= 0;	theRuler->EnableButtons(5);	fileInfo.sfType = DIF_OBJ;	resizeOK			=	false;		thePictRect = theWindow->portRect;	thePictRect.right	-= 15;	thePictRect.left		+= 15;	thePictRect.bottom	-= 15;	thePictRect.top		+= rulerHeight;			FinishMenuSetUp();	theLine = 0L;			ClearDspacings(); 	for(i = 0; i <= 3; i++) calculateFlags[i] = false;	thePictRect = theWindow->portRect;	centerX = (thePictRect.right + thePictRect.left) / 2;	centerY = (thePictRect.bottom + thePictRect.top) / 2;	showPeriods = false;		SetObjectWindowTitle(); 	/*KillMBHandle*/DisposeHandle(theMenuBar);	theMenuBar = GetMenuBar();	DrawMenuBar();		for(i = 1; i <= 4;i++) CheckItem(g_Base_Crystal_Menu,i,false);	CheckItem(g_Base_Crystal_Menu,referenceCrystal + 1,true);				if(gTheFile->file_is_Open)		return;	DoDefine();		return;}void SADObj::FinishMenuSetUp(void){		gTheText[0] = 0;	InsertMenu(g_Base_Crystal_Menu,-1);	InsertMenu(g_Exp_Man_Menu,-1);	InsertMenu(g_Exp_Lat_Menu,-1);	InsertMenu(g_Exp_Vol_Meth_Menu,-1);	InsertMenu(g_Exp_Line_Meth_Menu,-1);}void	SADObj::DoClose(void){	short i;	free_matrix(xDis,1,4,1,1);	free_matrix(yDis,1,4,1,1);	for(i = 0; i < 3;i++){		if(streaks[i] != 0L)KillHandle((Handle*)&(streaks[i]));	}	if(calcIntensities)KillHandle((Handle*)&calcIntensities);	//Bloch	calcIntensities = 0L;//Bloch		if(stereoObj)stereoObj->poleObject = (SADObj*)0L;	if(thePoleBox)thePoleBox->KillAll();//bloch		if(theLine)theLine->KillAll();	theLine = 0L;	if(theImagePixels)theImagePixels->KillAll();	theImagePixels = 0L;	KillAllLabels();	inherited::DoClose();}void	SADObj::SetObjectWindowTitle(void){		{		gTheText[0] 				= 0;		imageFlag 					= 	false;	}		theBeamFlag 	= 	1;	energy 				=  	theEBeam->energy;	wavelength 		= 	theEBeam->wavelength;	theRuler		->SetBeamButton(theBeamFlag);		if(gTheFile->file_is_Open){		SetWTitle(theWindow,fileInfo.sfFile.name);		return;	}	sprintf(gTheText,"SAD Patterns %d",g_Window_Number);	SetWTitle(theWindow,c2pstr(gTheText));	g_Window_Number++;	}void SADObj::ClearDspacings(void){	short i ;	for(i = 0; i < MAXEXPDSPACE; i++)		dspacings[i] = -1;}void SADObj::SetObjectMenu(){	ClearMenuBar();//added augs 1996	theMenuBar = GetNewMBar(SAD_OBJ_MB);	SetMenuBar	(theMenuBar);}void		SADObj::AddSpotSimple(Point thePoint){	static Boolean 	spotHit;		short 			theSize;	SpotInfoPtr 	theSpot;	Crystal 		*aCrystal;	Point			aPoint;	if(!Button()){		spotHit = false;		return;	}	if(!PtInRect(thePoint,&thePictRect)) return;		aPoint = thePoint;	if(spotHit || FindSpot(aPoint)){		spotHit = true;		MoveReconfigureSpot(aPoint);		return;	}				aCrystal = this->theCrystal[referenceCrystal];	if(data_Count + 2 >= data_Length)		ExpandMemory();	D_HLock(theDataHandle);	theSpot = &((SpotInfoPtr)*theDataHandle)[data_Count++];	numSpots++;	spotHit = true;	theSpot->intensity = .6;		LocalToObj(&aPoint);		theSpot->x = (aPoint.v - centerY) / scaleFactor;	theSpot->y = (aPoint.h - centerX) / scaleFactor;	theSpot->z =  0.0;	theSpot->h = (short)1;	theSpot->k = (short)0;	theSpot->l = (short)0;	theSpot->direction 	= false;	theSpot->theCrystal = aCrystal;	theSpot->angle 	= 0.0;	theSpot->flags 	= referenceCrystal;	theSize 				=  (expoTime + 2) * pow((double)theSpot->intensity,(1. / (double)dyRange));		SetRect				(&gTheRect,aPoint.h - theSize,aPoint.v - theSize,aPoint.h + theSize,aPoint.v + theSize);	theSpot->spotRect = gTheRect;	ObjRectToLocal(&gTheRect);	dm_PaintOval			(&gTheRect);	D_HUnlock			(theDataHandle);	newPictReq = true;}void	SADObj::ExperimentalDSpRing(Point thePoint){	static Rect 		theRect,theCenterRect,bRect,aRect;	static Boolean 	flag = false;	static Point 		oldPoint;	short			 			h1,v1,h2,v2,shortRadius;	short 					hRes,vRes;	double 					theFactor,delY,delX;	double 					radius;		short 				length,i,j,theSize;	char 					theText[255];	Crystal 			*aCrystal;	static short 	hitCircle;	RgnHandle			theNewClip;	PenState 			thePenState;	aCrystal = this->theCrystal[referenceCrystal];	ScreenRes(&hRes,&vRes);	GetPenState(&thePenState);	if(thePoint.h == -3000)	{		Rect theRect;		hitCircle = -1;				SetRect(&theRect,0,0,0,0);		SetRect(&bRect,0,0,0,0);		PenMode(thePenState.pnMode);		return;	}	//if(textBox		->DoContent(thePoint))return;	theSize = (double)scaleFactor * (double)theEBeam->convergenceAngle;	if(IsPressed((unsigned short )58)) {		Boolean flag;		if(IsPressed( (unsigned short )1)){			ClearDspacings(); 			return;		}		flag = IsPressed( (unsigned short )0);		if( flag){			i = 0;			 if(lastDSpace <= .01) return;			while(dspacings[i] >= lastDSpace && i < MAXEXPDSPACE) i++;			if(i == MAXEXPDSPACE - 1)				dspacings[i] = lastDSpace;			else{				for(j = MAXEXPDSPACE - 1;j >= i; j--)dspacings[j ] = dspacings[j - 1] ;									dspacings[i] = lastDSpace;			}			sprintf(gTheText,"%6.3f",dspacings[i]);			//textBox		->AddListText(gTheText);			qsort(dspacings,MAXEXPDSPACE,sizeof(float),(_compare_function/*__cmp_func_Cmpfun**/)FloatCompare);			PenMode(gMode);			PenPat(&qd.black);			aCrystal->SetColor();			dm_FrameOval(&aRect);			lastDSpace = 0;		}		if(IsPressed( (unsigned short )46) ){			delX = fabs((double)(oldPoint.h - centerX));			delY = fabs((double)(oldPoint.v - centerY));			radius = sqrt((double)(delX * delX + delY * delY));			shortRadius = (short)((double)radius);			if(SetMagnification(shortRadius))newPictReq = true;//SetPict(true);				PenMode(gMode);				PenPat(&qd.black);				aCrystal->SetColor();				dm_FrameOval(&aRect);				lastDSpace = 0;		}		}	if(!Button()){		//if(hitCircle == 1) newPictReq = true;//SetPict(true);		SetRect(&theRect,0,0,0,0);		SetRect(&bRect,0,0,0,0);		hitCircle = -1;		 return;	}	i = 0;			SetTheCursor(306);		onScreen = true;		aCrystal->SetColor();	if(hitCircle < 0){		hitCircle = 1;	}	GetClip(gTheRgn);	theNewClip = D_NewRgn();	RectRgn(theNewClip,&theVisRect);	D_SetClip(theNewClip);			obj_Index->DoInit(false,aCrystal);	onScreen = true;	LocalToObj(&thePoint);	delX = fabs((double)(thePoint.h - centerX));	delY = fabs((double)(thePoint.v - centerY));	radius = sqrt((double)(delX * delX + delY * delY));	h1 = 		centerX - (short)radius;	v1 = 		centerY - (short)radius;	h2 = 		centerX + (short)radius;	v2 =  	centerY + (short)radius;			SetRect(&aRect,h1,v1,h2,v2);	StdOvalMarquee(&aRect);		if(EqualPt(thePoint,oldPoint) || !PtInRgn(thePoint,drawRgn))return;	oldPoint = thePoint;	flag = true;	PenMode(thePenState.pnMode);	if(radius != 0){		lastDSpace = theFactor = (double)scaleFactor / (double)radius;		sprintf(gTheText,"%6.2f Å Dia. =%6.2f mm ",theFactor,radius * 50.8 / ((double)hRes * magnification));		for(i = 0; i < MAX_STORE_DSPACE; i++){			if(fabs(theFactor - aCrystal->dspacings[i].x) < (.03 * theFactor)){				obj_Index->h = aCrystal->dspacings[i].h;				obj_Index->k = aCrystal->dspacings[i].k;				obj_Index->l = aCrystal->dspacings[i].l;				obj_Index->IndexToText(theText);				length = strlen(gTheText);				sprintf(&gTheText[length]," (");				length += 2;				if(length > 200)					continue;				strcpy(&gTheText[length],p2cstr((unsigned char*)theText));				length = strlen(gTheText);				sprintf(&gTheText[length]," )");			}		}		theRuler->SetInfo(gTheText);		aCrystal->SetColor();	}	D_SetClip(gTheRgn);	D_DisposeRgn(&theNewClip);}#define PIXELCONVERSION  201enum{	SETMAG = 1,	CANCEL1,	PIXELS,	DISTANCE,	MAGNIFICATION,	ANGSTROMS,	NANOMETERS,	MICRONS,	MILLIMETERS,	CENTIMETERS,	METERS,	INVERSEANGS,	FINAL,	SET_CAM_CONST};Boolean	SADObj::SetMagnification(short pixelValue){	short 			i,item,type,oldItem = 1;	Handle 			theHandle;	Rect 			theRect;	pascal Boolean 	TheFilter();	Boolean 		newFlag = false;	DialogPtr 		theDialog;	short 			hRes,vRes;	double  		dRes,screenDistance,dist;	theDialog 		= 		DM_GetNewDialog(PIXELCONVERSION, 0L,(WindowPtr)-1L);			GetDItem			(theDialog,PIXELS,&type,&theHandle,&theRect);	unitOfMeasure = MILLIMETERS - ANGSTROMS;		GetDItem			(theDialog,MILLIMETERS,&type,&theHandle,&theRect);	SetCtlValue		((ControlHandle)theHandle,1);	HiliteControl		((ControlHandle)theHandle,0);	oldItem 		= 	MILLIMETERS;		ScreenRes(&hRes,&vRes);	dRes = hRes;	dRes /= 25.4;		GetDItem			(theDialog,PIXELS,&type,&theHandle,&theRect);	sprintf			(gTheText,"%d",pixelValue);	c2pstr			(gTheText);	SetIText			(theHandle,pTheText);		GetDItem			(theDialog,DISTANCE,&type,&theHandle,&theRect);	screenDistance = 	(double)pixelValue / ((double)dRes);	dist			=	screenDistance / magnification;	sprintf			(gTheText,"%6.2f",dist);	c2pstr			(gTheText);	SetIText			(theHandle,pTheText);		GetDItem			(theDialog,MAGNIFICATION,&type,&theHandle,&theRect);	SetIText			(theHandle,"\p1.00");		GetDItem		(theDialog,SET_CAM_CONST,&type,&theHandle,&theRect);	InvalRect(&theRect);	SetCtlValue	((ControlHandle)theHandle,0);	HiliteControl 	((ControlHandle)theHandle, 255);		while(1 != 2){		double actualCameraConstant,distanceReal;		SystemTask();		ModalDialog(TheFilterUPP,&item);		switch(item){			case SETMAG:				GetDItem(theDialog,DISTANCE,&type,&theHandle,&theRect);				GetIText(theHandle,pTheText);				p2cstr(pTheText);				distanceReal = atof(gTheText);												if(distanceReal == 0)					distanceReal = screenDistance;									if(unitOfMeasure == 6){					actualCameraConstant = (double)screenDistance /  distanceReal ;					magnification = actualCameraConstant / cameraConstant;					SetScaleFactor();					newFlag = true;					DM_DisposDialog(&theDialog);					return true;				}				if(unitOfMeasure == 0 || unitOfMeasure == 1){					if(unitOfMeasure == 1)						screenDistance *= 10;					actualCameraConstant = screenDistance *  distanceReal ;					GetDItem		(theDialog,SET_CAM_CONST,&type,&theHandle,&theRect);					if(GetCtlValue((ControlHandle)theHandle)){						cameraConstant 			= actualCameraConstant;						theEBeam->cameraConstant 	= cameraConstant;						magnification	 			= 1.0;						SetScaleFactor();						changedFlag = true;					} else {						magnification 	 =    actualCameraConstant / cameraConstant ;						SetScaleFactor();					}					newFlag = true;					DM_DisposDialog(&theDialog);										return true;				}				if(unitOfMeasure == 2){					screenDistance /= 1.0e-3;				}				if(unitOfMeasure == 4){					screenDistance *= 10;				}				if(unitOfMeasure == 5){					screenDistance *= 1000;				}				magnification =  screenDistance / distanceReal ;				GetDItem(theDialog,MAGNIFICATION,&type,&theHandle,&theRect);				GetIText(theHandle,pTheText);				p2cstr(pTheText);				magnification *=  atof(gTheText) ; 				SetScaleFactor();				newFlag = true;			case CANCEL1:			case CANCELCLICK: 				DM_DisposDialog(&theDialog);								return true;							case ANGSTROMS:			case NANOMETERS:				GetDItem		(theDialog,SET_CAM_CONST,&type,&theHandle,&theRect);				HiliteControl ((ControlHandle)theHandle, 0);				SetCtlValue	((ControlHandle)theHandle,1);				SelIText(theDialog,DISTANCE,0,100);				InvalRect(&theRect);			case MICRONS:			case MILLIMETERS:			case CENTIMETERS:			case METERS:			case INVERSEANGS:				if(item >= MICRONS){					GetDItem		(theDialog,SET_CAM_CONST,&type,&theHandle,&theRect);					SetCtlValue	((ControlHandle)theHandle,0);					HiliteControl 	((ControlHandle)theHandle, 255);					InvalRect(&theRect);				}				for(i = ANGSTROMS ; i <= INVERSEANGS ; i++){					GetDItem		(theDialog,i,&type,&theHandle,&theRect);					SetCtlValue	((ControlHandle)theHandle,0);					HiliteControl	((ControlHandle)theHandle,0);				}				GetDItem		(theDialog,item,&type,&theHandle,&theRect);				SetCtlValue	((ControlHandle)theHandle,1);				SelIText(theDialog,DISTANCE,0,100);								unitOfMeasure = item - ANGSTROMS;				oldItem = item;				break;			case SET_CAM_CONST:				GetDItem		(theDialog,SET_CAM_CONST,&type,&theHandle,&theRect);				if(GetCtlValue((ControlHandle)theHandle)){					SetCtlValue	((ControlHandle)theHandle,0);				} else {					SetCtlValue	((ControlHandle)theHandle,1);				}				break;			default:				break;			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			}	}}void	SADObj::DrawTheText(void){	SpotInfoPtr 	thisSpot;	short		i,theIdent;		SetDrawEnviron();	//if(theImagePixels)theImagePixels->DrawAllText();	D_HLock(theDataHandle);	thisSpot		= &((SpotInfoPtr)*theDataHandle)[0];	for(i = 0 ; i < data_Count ; i++,thisSpot++){		if(objectType == DIFFRACT_METER){			if(thisSpot->spotRect.right > graph->frame.right) continue;			if(thisSpot->spotRect.left < graph->frame.left) continue;			if(thisSpot->spotRect.top < graph->frame.top) continue;		}		if(thisSpot->flags & TEXT_MASK){									 			Point		thePoint;					theIdent 				= thisSpot->flags & CRYSTAL_MASK;			if(plotFlags[theIdent]){								 				thePoint.h 			= (thisSpot->spotRect.left + thisSpot->spotRect.right) / 2;	 				thePoint.v 			= thisSpot->spotRect.top;							 				obj_Index->theCrystal	= thisSpot->theCrystal;				 				obj_Index->h 			= thisSpot->h;						 				obj_Index->k 			= thisSpot->k;						 				obj_Index->l 			= thisSpot->l;						 				obj_Index->direction 		= thisSpot->direction;					if(gInColor){					DMForeColor(10 + theIdent);				}else{					PenNormal();					DMForeColor(BLACK);				} 				obj_Index->DrawIndex(thePoint);				}							 		}	}	D_HUnlock(theDataHandle);	if(theCurvedLabels)theCurvedLabels->DrawAll();	ClearDrawEnviron();}											enum{	ADD_SPOT_SUMMATION = 6,	ADD_SPOT_SIMPLE,	MOVE_SPOT,	DELETE_SPOT_SAD,	ROT_PATTERN_MENU = 11,	MOVE_PATTERN_MENU	};void	SADObj::DoMenu(long theResult){	short 			theMenu,theItem,i;	Point 			thePoint;	static 			Boolean searchFlag = true;	PCVNumerical 	*pCVNum;	short			theOffset;	PointObj		*thePointObj;	short				n;	thePoint.h = thePoint.v = 0;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);	theOffset = 0;	if(theImagePixels)thePointObj = (PointObj*)theImagePixels->GetActive();		switch(functionID){		case SET_ASPECT_RATIO_F:		case MANUAL_SPOTS_F:		if(thePointObj != 0L){			if(theMenu == EDIT_MENU)			{				thePointObj->DoTScrap(theItem);				if(theImagePixels)theImagePixels->DoCleanUp();				HiliteMenu(0);				return;			}		}			break;		default:			break;	}			for(i = 1; i <= 4;i++) CheckItem(g_Base_Crystal_Menu,i,false);	CheckItem(g_Base_Crystal_Menu,referenceCrystal + 1,true);		theMenu = HiWord(theResult);	theItem = LoWord(theResult);	if(RING_D_SPACING == functionID)	{		//textBox->DoClose();	}	functionID = 0;		switch(theMenu){		case SADMANIP:			switch(theItem){					case SET_ASPECT:						functionID = SET_ASPECT_RATIO_F;						if(!theImagePixels)CreateExpPointObj();						theRuler->SetHelp("Click on three additional points,then type distance,recp. lat,real lattice or (hkl) into box.Formats: x,ymm,x,ycm ,(hkl),(-h,-k,-l),x,yÅ-1, or x,yÅ Double Click or opt-c to Calculate");						sprintf(gTheText,"Set aspect ratio. Current Aspect Ratio is Set to: x = %4.3fx'+ %4.3fy'+ %4.3fxy', y = %4.3fx'+ %4.3fy'+ %4.3fxy'",							xDis[1][1],xDis[2][1],xDis[3][1],yDis[1][1],yDis[2][1],yDis[3][1]);						theRuler->SetPrompt(gTheText);						SetTheCursor(TARGET_CURSOR);					break;				case SET_MAG_RING:					functionID = SET_MAG_RING_F;					thePoint.h = -3000;					/* TARGET_CURSOR */					SetTheCursor(306);					theRuler->SetPrompt("Set Magnification Ring:"); 					theRuler->SetHelp("Click and move anywhere to see d-space. opt-m to set magnification");					ExperimentalDSpRing(thePoint);					break;				case SET_MAG_LINE:						functionID = SET_MAG_LINE_F;						if(theLine)theLine->KillAll();						theLine = 0L;						theRuler->SetHelp("Draw Line between two points with known value, dbl-click on line to set segments, opt-m to set magnification");						theRuler->SetPrompt("Set magnification ");						SetTheCursor(TARGET_CURSOR);					break;				 case CORRECT_IMAGE:				 	CorrectImageDistortions();				 break;				 case DELETE_ASPECT_POINTS:						if(!theImagePixels)break;						theImagePixels->DeleteAllOfType(ASPECT_RATIO);						n = 0;						n = theImagePixels->GetTotalNoObjects(n);						if(n < 2){							theImagePixels->KillAll();							theImagePixels = 0L;						}					break;					case  SET_ASPECT_BY_DBOX:						SetAspectRatioDBox();						break;			}		break;		case SADLATTICE:			switch(theItem){				case ADD_SPOTS_MAN:					functionID = MANUAL_SPOTS_F;					theRuler->SetHelp("Click on spots of interest. Use Center Spots to auto center. (opt-t or menu)Tabulate Exp. Spots to see values.");					theRuler->SetPrompt("Set Spots. ");					SetTheCursor(TARGET_CURSOR);									break;					case GEN_LATTICE:					functionID = SETUP_LATTICE_F;					sprintf(gTheText,"Draw 2 lines to set lattice. shift-click on lines to set segments. opt-g to create lattice. opt-d to delete lattice.opt-t to tabulate spots");					theRuler->SetHelp(gTheText);					theRuler->SetPrompt("Set Lattice. ");					SetTheCursor(TARGET_CURSOR);					break;				case CENTER_SPOTS_EXP:					CenterPoints();					break;				case TABULATE_EXP_SPOTS:				 	SetPointTable();				 	break;				case DELETE_ALL_POINTS:						if(theImagePixels)theImagePixels->DeleteAllOfType(REG_POINT);						n = 0;						n = theImagePixels->GetTotalNoObjects(n);						if(n < 2){								theImagePixels->KillAll();							theImagePixels = 0L;						}					break;							}		break;		case SADVOLEXP:			switch(theItem){				case CELL_VOL_LINE:					thePoint.h = -3000;					functionID = PRIMITIVE_VOLUME;					theRuler->SetHelp("Click to zoom in. Select to points for two radial lines. Then shift-click to zoom out. Click again to select 1st order zone dia.");					GetPrimitiveVolume(thePoint);					break;				case CELL_VOL_CALCULATOR:					pCVNum = (PCVNumerical*)D_new(PCVNumerical);					pCVNum->Init(energy,cameraConstant,referenceCrystal);					pCVNum->DoDefine();					pCVNum->Kill();					break;			}		break;				case DYNAMIC_MENU:			BetheMenu( theItem);//bloch			break;		case  MULTISLICE_MENU:			MultiSliceMenu(theItem);		break;		case 305:			switch(theItem){				case 10:					functionID = ZONEAXIS_FR_LINE;										SetTheCursor(PLUS_CURSOR);					theRuler->SetPrompt("Zone Axis Tool:"); 					theRuler->SetHelp("Clicking on Circles moves sides/all.Click on corner to distort. Hold option key, move mouse to rotate. Dbl-Click on center to Add to Stereogram");					GetZoneAxisFromBox(thePoint);//bloch					SetTheCursor(TARGET_CURSOR);				break;				case 11:										SetTheCursor(PLUS_CURSOR);					SetBeamORToPole();//DM3.0				break;				default:				break;			}		break;		case SADLINERING:			switch(theItem){				Rect rDataBnds,theRect;				Point cellSize;				case DSPACE_RING:										functionID = RING_D_SPACING;					SetRect(&rDataBnds,0,0,1,5);					SetRect(&theRect,40,100,120,175);					cellSize.h = 40;					cellSize.v = 15;					thePoint.h = -3000;					/* TARGET_CURSOR */					SetTheCursor(306);					theRuler->SetPrompt("Experimental d-space:"); 					theRuler->SetHelp("Click and move anywhere to see d-space. opt-a (add) will add dspace/ opt-s (subtract)  clear dspacings");					ExperimentalDSpRing(thePoint);					break;				case ZONE_AXIS_POINT:					functionID = ZONE_AXIS_FR_PT;					if(theLine)theLine->KillAll();						theLine = 0L;					theRuler->SetHelp("Click and move mouse over spot of interest,click agian for second spot. Z.A. calc. from radial distance and angle between.");						theRuler->SetPrompt("Zone Axis:");					SetTheCursor(306);					break;								case DSPACE_LINE:					functionID = D_SPACE_FR_LINE;					SetTheCursor(PLUS_CURSOR);					if(theLine)theLine->KillAll();						theLine = 0L;					theRuler->SetPrompt("Exp. dspace - line:"); 					theRuler->SetHelp("Draw Two Parallel Lines,d-space = avg. separation");						SetTheCursor(TARGET_CURSOR);					break;				case ZONE_AXIS_LINE:					functionID = ZONEAXIS_FR_LINE;					SetTheCursor(PLUS_CURSOR);					theRuler->SetPrompt("Zone Axis Tool:"); 					theRuler->SetHelp("Clicking on Circles moves sides/all.Click on corner to distort. Hold option key, move mouse to rotate. Dbl-Click on center to Add to Stereogram");					GetZoneAxisFromBox(thePoint);//bloch					SetTheCursor(TARGET_CURSOR);					break;			}		break;		case SADDEFINE:			switch(theItem){				case 1:					DoSetUp();					break;				case 2:				case 3:					changedFlag = true;					reSizeFlag = true;					break;								case 5:					StartWatch();					if(DoubleDiffractIterative()){						newPictReq = true;					}					StopWatch();					break;				case 7:					DeleteDoubleDif();					break;				case 8:					DeleteWeakSpots();					break;				case 10:					dyRange += .5;					//SetPict(true);					newPictReq = true;					switch(theBeamFlag)					{						case 1:							theEBeam->dyRange = dyRange;							break;						case 2:							theXRay->dyRange = dyRange;							break;						case 3:							break;					}					break;				case 11:					dyRange -= .5;					SetPict(true);					newPictReq = true;					switch(theBeamFlag)					{						case 1:							theEBeam->dyRange = dyRange;							break;						case 2:							theXRay->dyRange = dyRange;							break;						case 3:							break;					}					break;				case 13:					CalcDySinglePoint();					break;				default:					break;							}			break;		case SADINFO:			switch(theItem){				case ADD_SPOT_SUMMATION:					functionID = ADD_SPOT_SUM_F;					theRuler->SetHelp("Click on spot to select adding g-vector. Move over 2nd spot for summation.");					theRuler->SetPrompt("Add a spot by summation. ");					SetTheCursor(TARGET_CURSOR);					break;				case ADD_SPOT_SIMPLE:					functionID = ADD_SPOT_SIMPLE_F;					theRuler->SetPrompt("Add a spot. ");					theRuler->SetHelp("Shift-Click to change intensity. Dbl-Click to change spot numerically.");					SetTheCursor(TARGET_CURSOR);					break;				case MOVE_SPOT:					functionID = MOVE_RECONFIGURE_SPOT;					theRuler->SetPrompt("Move/Reconfigure Spot");					theRuler->SetHelp("Click to select. Shift-Click to change intensity. Dbl-Click to change spot numerically.");					SetTheCursor(TARGET_CURSOR);					break;				case DELETE_SPOT_SAD:					functionID = DELETE_SPOT_F;					theRuler->SetHelp("Click on spot to delete"); 					theRuler->SetPrompt("Delete a spot.");					SetTheCursor(TARGET_CURSOR);					break;				case ROT_PATTERN_MENU:					functionID = ROTATE_PATTERN;					theRuler->SetPrompt("Rotate Pattern");					SetTheCursor(TARGET_CURSOR);					theRuler->SetHelp("Click & move to select point to rotate from, Click & move again to select pt. to rotate to.");															break;				case MOVE_PATTERN_MENU:					functionID = MOVE_PATTERN;					theRuler->SetPrompt("Move Pattern");					SetTheCursor(306);					theRuler->SetHelp("Click and hold on central point, then move mouse");					thePoint = MovePatternCenter(thePoint);					break;							default:					theResult = INFO_MENU * 65536 + theItem;										inherited::DoMenu(theResult); 					break;			}			break;				case SADSEARCH:			switch(theItem){				case 1:					if(searchFlag == true) {						theAlloyObj->CopyElementFiles(0,&theSearchObj->theElements[0][0]);						theAlloyObj->CopyElementFiles(referenceCrystal + 1,&theSearchObj->theElements[1][0]);						//for(i = 0; i <= 9; i++) theSearchObj->theElements[0][i] = true;					}					searchFlag = false;					theSearchObj->DoDefine();				break;				case 2:					theSearchObj->SearchByDSpace(dspacings,cameraConstant,wavelength,1);					break;				case 3:					theSearchObj->SearchByDSpace(dspacings,cameraConstant,wavelength,2);					break;				case 4:					theSearchObj->SearchByDSpace(dspacings,cameraConstant,wavelength,5);					break;							}			if(theItem > 5){				SetScaleFactor();				theSearchObj->requiredFOM = G_VECTOR_SEARCH;				theSearchObj->DoMenu(theResult);				theRuler->SetHelp("Hold shift-key down when selecting crystal to bring up Crystal Dialog.  Use Dump option to put into active matrix/ppt."); 			}				break;				case 53:			for(i = 1; i <= 4;i++)CheckItem(g_Base_Crystal_Menu,i,false);								referenceCrystal = theItem - 1;				CheckItem(g_Base_Crystal_Menu,theItem,true);			if(thePoleBox){				thePoleBox->NewReferenceCrystal();			}			break;					default:			inherited::DoMenu(theResult); 			break;	}		HiliteMenu(0);	return;}