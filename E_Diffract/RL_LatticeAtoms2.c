//Jim:E_Diffract:RL_LatticeAtoms2.c#include	"Diffract_INCs.h"#include	"AtomData.h"#include	"a_LatticeObject.h"#include	"UT_VectorMacros.c"short	AtomCompare(LatticeAtomPtr,LatticeAtomPtr);#define	OWNER_LAT_A		((LatticeObject*)ownerObj)->cellVectors[1]#define	OWNER_LAT_B		((LatticeObject*)ownerObj)->cellVectors[2]#define	OWNER_LAT_C		((LatticeObject*)ownerObj)->cellVectors[3]#define	OWNER_CENTER	((LatticeObject*)ownerObj)->cellCenter#define	CX				((LatticeObject*)ownerObj)->imageCenter.h#define	CY				((LatticeObject*)ownerObj)->imageCenter.v#define	SCALE			((LatticeObject*)ownerObj)->scaling#define	BASE_OBJ		((LatticeObject*)ownerObj)void 		lattice::OffsetThisAtom(LatticeAtomPtr sourceAtom,short axes){	if(BASE_OBJ->data_Count >= BASE_OBJ->data_Length){		BASE_OBJ->ExpandMemory();		if(BASE_OBJ->data_Count >= BASE_OBJ->data_Length){			return;		}	}		theAtoms 	= 	&((*theLattice)[BASE_OBJ->data_Count++]);	*theAtoms 	= 	*sourceAtom;	theAtoms->labeled = false;	switch(axes){		case 1:			theAtoms->x = 	theAtoms->x * theAtoms->length + 							OWNER_LAT_A.x * OWNER_LAT_A.length;			theAtoms->y = 	theAtoms->y * theAtoms->length + 							OWNER_LAT_A.y * OWNER_LAT_A.length;			theAtoms->z = 	theAtoms->z * theAtoms->length + 							OWNER_LAT_A.z * OWNER_LAT_A.length;			break;					case 2:			theAtoms->x = 	theAtoms->x * theAtoms->length + 							OWNER_LAT_B.x * OWNER_LAT_B.length;										theAtoms->y = 	theAtoms->y * theAtoms->length + 							OWNER_LAT_B.y * OWNER_LAT_B.length;										theAtoms->z = 	theAtoms->z * theAtoms->length + 							OWNER_LAT_B.z * OWNER_LAT_B.length;			break;					case 3:			theAtoms->x = 	theAtoms->x * theAtoms->length + 							OWNER_LAT_A.x * OWNER_LAT_A.length +							OWNER_LAT_B.x * OWNER_LAT_B.length;										theAtoms->y = 	theAtoms->y * theAtoms->length + 							OWNER_LAT_A.y * OWNER_LAT_A.length +							OWNER_LAT_B.y * OWNER_LAT_B.length;										theAtoms->z = 	theAtoms->z * theAtoms->length + 							OWNER_LAT_A.z * OWNER_LAT_A.length +							OWNER_LAT_B.z * OWNER_LAT_B.length;			break;					case 4:								theAtoms->x = 	theAtoms->x * theAtoms->length + 							OWNER_LAT_C.x * OWNER_LAT_C.length;						theAtoms->y = 	theAtoms->y * theAtoms->length + 							OWNER_LAT_C.y * OWNER_LAT_C.length;						theAtoms->z = 	theAtoms->z * theAtoms->length + 							OWNER_LAT_C.z * OWNER_LAT_C.length;			break;					case 5:			theAtoms->x = 	theAtoms->x * theAtoms->length + 							OWNER_LAT_A.x * OWNER_LAT_A.length +							OWNER_LAT_C.x * OWNER_LAT_C.length;										theAtoms->y = 	theAtoms->y * theAtoms->length + 							OWNER_LAT_A.y * OWNER_LAT_A.length +							OWNER_LAT_C.y * OWNER_LAT_C.length;										theAtoms->z = 	theAtoms->z * theAtoms->length + 							OWNER_LAT_A.z * OWNER_LAT_A.length +							OWNER_LAT_C.z * OWNER_LAT_C.length;			break;				case 6:			theAtoms->x = 	theAtoms->x * theAtoms->length + 							OWNER_LAT_B.x * OWNER_LAT_B.length +							OWNER_LAT_C.x * OWNER_LAT_C.length;										theAtoms->y = 	theAtoms->y * theAtoms->length + 							OWNER_LAT_B.y * OWNER_LAT_B.length +							OWNER_LAT_C.y * OWNER_LAT_C.length;										theAtoms->z = 	theAtoms->z * theAtoms->length + 							OWNER_LAT_B.z * OWNER_LAT_B.length +							OWNER_LAT_C.z * OWNER_LAT_C.length;			break;					case 7:			theAtoms->x = 	theAtoms->x * theAtoms->length + 							OWNER_LAT_A.x * OWNER_LAT_A.length +							OWNER_LAT_B.x * OWNER_LAT_B.length +							OWNER_LAT_C.x * OWNER_LAT_C.length;										theAtoms->y = 	theAtoms->y * theAtoms->length + 							OWNER_LAT_A.y * OWNER_LAT_A.length +							OWNER_LAT_B.y * OWNER_LAT_B.length +							OWNER_LAT_C.y * OWNER_LAT_C.length;										theAtoms->z = 	theAtoms->z * theAtoms->length + 							OWNER_LAT_A.z * OWNER_LAT_A.length +							OWNER_LAT_B.z * OWNER_LAT_B.length +							OWNER_LAT_C.z * OWNER_LAT_C.length;			break;		default:			return;	}		theAtoms->length = sqrt(theAtoms->x * theAtoms->x + 							theAtoms->y * theAtoms->y + 							theAtoms->z * theAtoms->z);	if(fabs(theAtoms->length) > .0000001){		theAtoms->x /= theAtoms->length;		theAtoms->y /= theAtoms->length;		theAtoms->z /= theAtoms->length;	} else {		theAtoms->x 		= 0.0;		theAtoms->y 		= 0.0;		theAtoms->z 		= 0.0;		theAtoms->length	= 0.0;	}}			void 		lattice::SliceLattice(void){	DialogPtr		theDialog;	short			theSelect,type,ax1,ax2,comp1,comp2;	ControlHandle	theHandle;	double			radiusValue,tempVal,minZ,value1,value2,lastTemp;	Boolean			quit = false,hideThem,doAnd,shrink = false,direction;	GrafPtr			theOldPort;	double			theXForm[3][3],x,y,z;	Index			*theIndex;		GetPort(&theOldPort);	theIndex 	= (Index*)D_new(Index);	theDialog 	= DM_GetNewDialog(7004,NUL,IN_FRONT);	SetRect(&gTheRect,40,40,90,90);	((WStateData*)(*(((WindowPeek)theDialog)->dataHandle)))->stdState = gTheRect;	direction = false;				lastTemp 		= 100000.0;	D_HLock((Handle)theLattice);	theAtoms 	= *theLattice;		for(i = 1 ; i <= BASE_OBJ->data_Count; i++,theAtoms++){		tempVal = abs(theAtoms->z * theAtoms->length);		if(tempVal < lastTemp){			lastTemp 		= tempVal;			radiusValue 	= theAtoms->atomicRadius;			minZ			= theAtoms->z * theAtoms->length;		}	}	theAtoms 	= *theLattice;	D_HUnlock((Handle)theLattice);		for(i = 6 ; i <= 25 ; i++){		switch(i){			case 6:			case 10:			case 11:			case 13:			case 17:			case 19:			case 25:				GetDItem(theDialog,i,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,1);				break;			default:				break;		}	}	GetDItem(theDialog,20,&type,(Handle*)&theHandle,&gTheRect);	sprintf(gTheText,"%6.3f",minZ - radiusValue);	c2pstr(gTheText);	SetIText((Handle)theHandle,pTheText);	GetDItem(theDialog,21,&type,(Handle*)&theHandle,&gTheRect);	sprintf(gTheText,"%6.3f",minZ + radiusValue);	c2pstr(gTheText);	SetIText((Handle)theHandle,pTheText);		theIndex->DoInit(direction,BASE_OBJ->theCrystal[BASE_OBJ->baseCrystal]);	theIndex->x = 0;	theIndex->y = 0;	theIndex->z = 1;	theXForm[0][0] = cellX.x;	theXForm[1][0] = cellX.y;	theXForm[2][0] = cellX.z;	theXForm[0][1] = cellY.x;	theXForm[1][1] = cellY.y;	theXForm[2][1] = cellY.z;	theXForm[0][2] = cellZ.x;	theXForm[1][2] = cellZ.y;	theXForm[2][2] = cellZ.z;	INVERT_MATRIX(theXForm); 	theIndex->GetTheUVWFromXYZ(theXForm);	theIndex->ConvertXYZToHKLReduce();	if(theIndex->direction == false) theIndex->reduceFlag = false;		theIndex->SetIndex(theDialog,26);		while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;						case -1:			case 2:				quit = true;				break;			case DLOG_ENTER_OR_CR:			case 1:				quit = true;			case 3:				for(i = 6 ; i <= 19 ; i++){					GetDItem(theDialog,i,&type,(Handle*)&theHandle,&gTheRect);					if(GetCtlValue(theHandle) == 1){						switch(i){							case 6:								hideThem = false;								break;							case 7:								hideThem = true;								break;							case 8:							case 9:							case 10:								ax1 = i - 7;								break;							case 11:							case 12:								comp1 = i - 10;								break;							case 13:								doAnd = true;								break;							case 14:								doAnd = false;								break;							case 15:							case 16:							case 17:								ax2 = i - 14;								break;							case 18:							case 19:								comp2 = i - 17;								break;							default:								break;						}					}				}								GetDItem(theDialog,20,&type,(Handle*)&theHandle,&gTheRect);				GetIText((Handle)theHandle,pTheText);				p2cstr(pTheText);				value1 = atof(gTheText);								GetDItem(theDialog,21,&type,(Handle*)&theHandle,&gTheRect);				GetIText((Handle)theHandle,pTheText);				p2cstr(pTheText);				value2 = atof(gTheText);								D_HLock((Handle)theLattice);				theAtoms 	= *theLattice;								if(doAnd){					for(i = 1 ; i <= BASE_OBJ->data_Count; i++,theAtoms++){						if(	TestAtom(theAtoms,ax1,comp1,value1) &&							TestAtom(theAtoms,ax2,comp2,value2)){														theAtoms->hidden = hideThem;						}					}				} else {					for(i = 1 ; i <= BASE_OBJ->data_Count; i++,theAtoms++){						if(	TestAtom(theAtoms,ax1,comp1,value1) ||							TestAtom(theAtoms,ax2,comp2,value2)){														theAtoms->hidden = hideThem;						}					}				}								theAtoms 	= *theLattice;				D_HUnlock((Handle)theLattice);				if(shrink)					ZoomWindow(theDialog,inZoomOut,true);				SetPort(theOldPort);				SetSurface();				BASE_OBJ->SetPict(true);				BASE_OBJ->D_DrawPict();				SetPort(theDialog);				break;			case 4:				D_HLock((Handle)theLattice);				theAtoms 	= *theLattice;								for(i = 1 ; i <= BASE_OBJ->data_Count; i++,theAtoms++){					theAtoms->hidden = false;				}				theAtoms 	= *theLattice;				D_HUnlock((Handle)theLattice);				SetPort(theOldPort);				SetSurface();				BASE_OBJ->SetPict(true);				BASE_OBJ->D_DrawPict();				SetPort(theDialog);				break;			case 5:				D_HLock((Handle)theLattice);				theAtoms 	= *theLattice;								for(i = 1 ; i <= BASE_OBJ->data_Count; i++,theAtoms++){					theAtoms->hidden = true;				}				theAtoms 	= *theLattice;				D_HUnlock((Handle)theLattice);				SetPort(theOldPort);				SetSurface();				BASE_OBJ->SetPict(true);				BASE_OBJ->D_DrawPict();				SetPort(theDialog);				break;			case 6:			case 7:				GetDItem(theDialog,6,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,7,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,theSelect,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,1);				break;			case 8:			case 9:			case 10:				GetDItem(theDialog,8,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,9,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,10,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,theSelect,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,1);								break;			case 11:			case 12:				GetDItem(theDialog,11,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,12,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,theSelect,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,1);				break;			case 13:			case 14:				GetDItem(theDialog,13,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,14,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,theSelect,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,1);				break;			case 15:			case 16:			case 17:				GetDItem(theDialog,15,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,16,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,17,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,theSelect,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,1);				break;			case 18:			case 19:				GetDItem(theDialog,18,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,19,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,theSelect,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,1);				break;			case 22:				GetDItem(theDialog,22,&type,(Handle*)&theHandle,&gTheRect);				if(GetCtlValue(theHandle) == 1){					SetCtlValue(theHandle,0);					shrink = false;				} else {					SetCtlValue(theHandle,1);					shrink = true;				}				break;			case 23:				if(shrink)					ZoomWindow(theDialog,inZoomOut,true);				SetPort(theOldPort);				theIndex->GetIndex(theDialog,26);				theIndex->SetIndex(theDialog,26);				BASE_OBJ->theImageVectors->DoRotate(theXForm);				DoRotate(theXForm);				BASE_OBJ->theCrystal[BASE_OBJ->baseCrystal]->Get001XForm(theXForm);				theIndex->DirOfPlaneNormal(&x,&y,&z);								TRANSFORM_VECTOR(x,y,z,theXForm);				FIND_CENTER_XFORM(x,y,z,theXForm);				BASE_OBJ->theImageVectors->DoRotate(theXForm);				DoRotate(theXForm);				BASE_OBJ->DoZoom(1.0);				SortByZ();				SetIntensity();				SetSurface();				BASE_OBJ->SetPict(true);				BASE_OBJ->D_DrawPict();				SetPort(theDialog);				theXForm[0][0] = cellX.x;				theXForm[1][0] = cellX.y;				theXForm[2][0] = cellX.z;				theXForm[0][1] = cellY.x;				theXForm[1][1] = cellY.y;				theXForm[2][1] = cellY.z;				theXForm[0][2] = cellZ.x;				theXForm[1][2] = cellZ.y;				theXForm[2][2] = cellZ.z;				INVERT_MATRIX(theXForm); 				theIndex->GetTheUVWFromXYZ(theXForm);				break;			case 24:			case 25:				GetDItem(theDialog,24,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,25,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,0);				GetDItem(theDialog,theSelect,&type,(Handle*)&theHandle,&gTheRect);				SetCtlValue(theHandle,1);				if(theSelect == 24){					direction = false;				} else {					direction = true;				}				break;			default:				break; 		}	}	DM_DisposDialog(&theDialog);	theIndex->DoClose();}void 		lattice::UnSliceLattice(void){	D_HLock((Handle)theLattice);	theAtoms 	= *theLattice;		for(i = 1 ; i <= BASE_OBJ->data_Count; i++,theAtoms++){		theAtoms->sliced = false;	}	D_HUnlock((Handle)theLattice);}Boolean 		lattice::PointVisible(double theX,double theY,double theZ){	double	xVal,yVal,rad2,zVal,dist;		D_HLock((Handle)theLattice);	theAtoms 	= *theLattice;		for(i = 1 ; i <= BASE_OBJ->data_Count; i++,theAtoms++){		if(theAtoms->hidden || theAtoms->covered)			continue;		xVal 	= theX - theAtoms->x * theAtoms->length;  		yVal 	= theY - theAtoms->y * theAtoms->length;		dist	= xVal * xVal + yVal * yVal;		rad2 	= theAtoms->atomicRadius;		rad2	*= rad2;		if(dist < rad2){			zVal = sqrt(rad2 - dist);			zVal += (theAtoms->z * theAtoms->length);			if(zVal > theZ){				D_HUnlock((Handle)theLattice);				return(false);			}		}	}	D_HUnlock((Handle)theLattice);	return(true);}		void 		lattice::GetPicSize(Rect*	theRect){	double	x1,x2,y1,y2,x,y,rad;		x1 = y1 = 123456;	x2 = y2 = -123456;		D_HLock((Handle)theLattice);	theAtoms 	= *theLattice;		for(i = 1 ; i <= BASE_OBJ->data_Count; i++,theAtoms++){			rad	= theAtoms->atomicRadius;		x = theAtoms->length * theAtoms->x;		y = theAtoms->length * theAtoms->y;				if(x + rad > x2){			x2 = x + rad;		}		if(x - rad < x1){			x1 = x - rad;		}				if(y + rad > y2){			y2 = y + rad;		}		if(y - rad < y1){			y1 = y - rad;		}	}	D_HUnlock((Handle)theLattice);	x1 *= SCALE;	y1 *= SCALE;	x2 *= SCALE;	y2 *= SCALE;	theRect->top 		= y1;	theRect->bottom 	= y2;	theRect->left 		= x1;	theRect->right 		= x2;	}		void 		lattice::ZoomAll(void){	double	x1,x2,y1,y2,x,y,rad;		x1 = y1 = 123456;	x2 = y2 = -123456;		D_HLock((Handle)theLattice);	theAtoms 	= *theLattice;		for(i = 1 ; i <= BASE_OBJ->data_Count; i++,theAtoms++){			rad	= theAtoms->atomicRadius;		if(theAtoms->length * theAtoms->x + rad > x2)			x2 = theAtoms->length * theAtoms->x  + rad;		if(theAtoms->length * theAtoms->x - rad < x1)			x1 = theAtoms->length * theAtoms->x - rad;		if(theAtoms->length * theAtoms->y + rad > y2)			y2 = theAtoms->length * theAtoms->y + rad;		if(theAtoms->length * theAtoms->y - rad < y1)			y1 = theAtoms->length * theAtoms->y - rad;	}	D_HUnlock((Handle)theLattice);	/*august 1993*/	if(!BASE_OBJ->printing){		x = (double)BASE_OBJ->theWindow->portRect.right - 40;		y = (double)BASE_OBJ->theWindow->portRect.bottom - 60 - BASE_OBJ->heightOfRuler;	}else{		x = (double)BASE_OBJ->theWindow->portRect.right - 70;		y = (double)BASE_OBJ->theWindow->portRect.bottom - 70;	}	x /= (x2 - x1);	y /= (y2 - y1);	if(x < y){		SCALE = x;	} else {		SCALE = y;	}}					void 		lattice::SetColor(Point thePoint) {	short  	z,colorNum,last;	Boolean	found = false;	float atomicRadius;		D_HLock((Handle)theLattice);	theAtoms 	= *theLattice;		for(i = 1 ; i <= BASE_OBJ->data_Count && !found; i++,theAtoms++){		if(theAtoms->hidden || theAtoms->covered)			continue;		if(PtInRect(thePoint,&(theAtoms->spotRect))){			z 			= theAtoms->atNum;			colorNum	= theAtoms->color;			atomicRadius		 = theAtoms->atomicRadius;			found 		= true;		}	}			if(found){		float atomicRadiusOld;				last			= colorNum;		atomicRadiusOld = atomicRadius;		colorNum 	= SetAtomColor(colorNum,z,&atomicRadius);		if(last != colorNum){			theAtoms 	= *theLattice;			for(i = 1 ; i <= BASE_OBJ->data_Count ; i++,theAtoms++){				if(theAtoms->atNum == z)					theAtoms->color = colorNum;			}				BASE_OBJ->newPictReq = true;		}		if(fabs(atomicRadiusOld - atomicRadius) > .03){			 AdjustAtomicRadii(z,atomicRadius);			 BASE_OBJ->newPictReq = true;		}			}	D_HUnlock((Handle)theLattice);}void 		lattice::DoFileRead(void){	gTheFile->ReadDataBlock((Ptr)&cellX,sizeof(latticeVector));	gTheFile->ReadDataBlock((Ptr)&cellY,sizeof(latticeVector));	gTheFile->ReadDataBlock((Ptr)&cellZ,sizeof(latticeVector));}void 		lattice::DoFileWrite(void){	gTheFile->WriteDataBlock((Ptr)&cellX,sizeof(latticeVector));	gTheFile->WriteDataBlock((Ptr)&cellY,sizeof(latticeVector));	gTheFile->WriteDataBlock((Ptr)&cellZ,sizeof(latticeVector));}	short	lattice::SetAtomColor(short color,short atNum,float *atomicRadius){	DialogPtr	theDialog;	PopUpMenu	*colorMenu;	Boolean		quit = false;	short		theSelect,retVal,anAtomNum;	long		menuValue;	Boolean 	flag = false;	Crystal    *aCrystal;			aCrystal 		= 	(Crystal*)D_new(Crystal);		retVal 			= 	color;		theDialog 	= 		DM_GetNewDialog(7001,NUL,IN_FRONT);			aCrystal		->	GetAtomicSymbol(atNum,gTheText);	c2pstr				(gTheText);	GetDItem			(theDialog,3,&gType,&gTheHandle,&gTheRect);	SetIText			(gTheHandle,pTheText);		anAtomNum 		= 	atNum;		menuValue = aCrystal->ReturnValance(&anAtomNum);		D_delete(aCrystal);		sprintf		(gTheText,"%3d",anAtomNum);	c2pstr		(gTheText);	GetDItem	(theDialog,4,&gType,&gTheHandle,&gTheRect);	SetIText	(gTheHandle,pTheText);		sprintf		(gTheText,"%6.3f",(double)*atomicRadius * 2 / BASE_OBJ->displayType);	c2pstr		(gTheText);	GetDItem	(theDialog,5,&gType,&gTheHandle,&gTheRect);	SetIText	(gTheHandle,pTheText);		colorMenu = (PopUpMenu*)D_new(PopUpMenu);	colorMenu->Init(theDialog,6,7200,color);		while(!quit){		ModalDialog(NUL,&theSelect);		switch(theSelect){			case 1:				if(colorMenu->lastResult > 0)				retVal = colorMenu->lastResult;				flag = true;			case 2:				quit = true;				break;			case 6:				menuValue = colorMenu->DoPopUp();				break;							default:				break;			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;					}	}					if(flag){		 gTheHandle 	= 	GetResource('Colr',7000);		((short*)(*gTheHandle))[anAtomNum] = retVal;		ChangedResource		((Handle)gTheHandle);		WriteResource		((Handle)gTheHandle);		ReleaseResource		((Handle)gTheHandle);		((LatticeObject*)ownerObj)->colors[anAtomNum] = retVal;			GetDItem			(theDialog,5,&gType,&gTheHandle,&gTheRect);		GetIText			(gTheHandle,pTheText);		*atomicRadius 	= 	atof(p2cstr(pTheText));		*atomicRadius 	*= 	BASE_OBJ->displayType * .5;	}			colorMenu		->	DoClose();	DM_DisposDialog(&theDialog);		return(retVal);}	Boolean		lattice::TestAtom(LatticeAtomPtr theAtom,short axis,short comparison,double value){	double	atomValue;	switch(axis){		case 1:	/* X */			atomValue = theAtom->x * theAtom->length;			break;		case 2:	/* Y */			atomValue = theAtom->y * theAtom->length;			break;		case 3:	/* Z */			atomValue = theAtom->z * theAtom->length;			break;		default:			return false;			break;	}	switch(comparison){		case 1:			if(atomValue > value)				return true;			break;		case 2:			if(atomValue < value)				return true;			break;		default:			break;	}	return false;}void lattice::CalculateDisplacements(void){	double	x,y,z;	short	i;	double	length;		D_HLock((Handle)theLattice);	theAtoms 	= *theLattice;	for(i = 1 ; i <= BASE_OBJ->data_Count; i++,theAtoms++){			x = theAtoms->length * theAtoms->x;		y = theAtoms->length * theAtoms->y;		z = theAtoms->length * theAtoms->z;		BASE_OBJ->theDefects->CalculateDisplacement(&x,&y,&z);		length = sqrt(x * x + y * y + z * z);		theAtoms->x = x/length;		theAtoms->y = y/length;		theAtoms->z = z/length;		theAtoms->length = length;	}	D_HUnlock((Handle)theLattice);}					short	AtomCompare(LatticeAtomPtr atomA,LatticeAtomPtr atomB){	double z1,z2;									/* NOTE:  Descending sort  */	z1 = atomA->z * atomA->length;	z2 = atomB->z * atomB->length;	if(z1 == z2){		z1 = atomA->x * atomA->length;		z2 = atomB->x * atomB->length;		if(z1 == z2){			z1 = atomA->x * atomA->length;			z2 = atomB->x * atomB->length;			return 0;		}	}	return((short)((z1 > z2) ? -1 : ((z1 < z2) ? 1 : 0)));}	