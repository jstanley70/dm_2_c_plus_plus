#include	"Diffract_INCs.h"//s.Jim:E_Diffract:E_HOLZObj.c#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"SF_MathLib.h"#include	"HOLZObj.h"#include		"COMPLEX.h"#include	"D_Handles.h"void HOLZObj::DoInit(){	centerW = 0L;	inherited::DoInit();	}void	HOLZObj::SetObjectWindowTitle(void){	theCurvedLabels =(TextRoundObj*)D_new(TextRoundObj);	theCurvedLabels->DoInit(false,theCrystal[0]);	theLabels = (TextObj*)D_new(TextObj);	theLabels->DoInit(false,theCrystal[0]);		deltaData		= 	(SpotInfoHandle)/*Temp*/D_NewHandle(20 * sizeof(SpotInfo));//,&errorCode	setCrystal 		=	theCrystal[0];		greyFlag					= 	false;	curvedLines				=	false;	approximateFlag		=	false;	theBeamFlag 			= 1;	energy 						=  	theEBeam->energy;	wavelength 				= 	theEBeam->wavelength;	convergenceAngle 	= 	theEBeam->convergenceAngle;	adjustEnergy			=	true;	SetScaleFactor();		theRuler->SetBeamButton(theBeamFlag);	if(gTheFile->file_is_Open){		SetWTitle(theWindow,fileInfo.sfFile.name);		return;	}	sprintf(gTheText,"HOLZ %d",g_Window_Number);	SetWTitle(theWindow,c2pstr(gTheText));		g_Window_Number++;}void HOLZObj::SetObjectMenu(void){	theMenuBar 	= 		GetNewMBar(HOLZ_OBJ_MB);	ClearMenuBar();/* July 1992 */	SetMenuBar			(theMenuBar);	theDistortMenu = 	GetMenu(DISTORTION);	InsertMenu			(theDistortMenu,-1);	lowOrder 	= 	1;	highOrder 	= 	1;	deltaCell.a 		= 	0;	deltaCell.b 		=	0;	deltaCell.c			= 	0;	deltaCell.alpha 	= 	0;	deltaCell.beta 		= 	0;	deltaCell.gamma 	= 	0;	delVoltage 			= 	0;	theDeltaItem		=		1;	}void HOLZObj::DoPictDraw(void){	short 		i;	short		zoneOrder;	float		intensityRange;	double	bigK,ratio,Uo;	Rect 		theRect;	SpotInfoPtr thisLine;	short		theIdent,theValue;	float		maxIntensity,					minIntensity,					range;	RgnHandle	newClipRgn,oldClipRgn;	double		value;	double		theEnergy,diameter;	short centerD;	SetDrawEnviron();	if(curvedLines && theLabels){		ResetCurvedLabels();	}	if(!curvedLines && theCurvedLabels){		ResetCurvedLabels();	} 	thisLine 		= 	((SpotInfoPtr)*theDataHandle);			centerD 		= 	convergenceAngle  * scaleFactor;		SetRect				(&theRect,-centerD,-centerD,centerD,centerD);	OffsetRect			(&theRect,centerX,centerY);	centerDisk = theRect;	thisLine->spotRect = theRect;	theIdent			=		(thisLine->flags & CRYSTAL_MASK);	DMForeColor			(10 +  theIdent);	intensityRange 	= 	1. / (double)dyRange;	dm_FrameOval			(&theRect);			newClipRgn = D_NewRgn();		oldClipRgn = D_NewRgn();		GetClip(oldClipRgn);		OpenRgn();		 dm_FrameOval(&theRect);		CloseRgn(newClipRgn);		D_SetClip(newClipRgn);		maxIntensity = - 500;	minIntensity = 500;	thisLine 			++;		for(i = 1 ; i < data_Count ; i++,thisLine++){		if(thisLine->intensity < intensityRange)			continue;		if(thisLine->intensity < minIntensity)			minIntensity = thisLine->intensity;		if(thisLine->intensity > maxIntensity)			maxIntensity = thisLine->intensity;	}	thisLine 		= 	((SpotInfoPtr)*theDataHandle);	thisLine 			++;	range = maxIntensity - minIntensity;		ratio 		= (.006648352) * (1 + (1.9569341e-3 * energy));// this converts Vg to Ug, Vg is the fourier components of the 	//crystal potential given in eV, Ug is the Dynamical Structure factor	Uo  		= ratio * zeroIntensity;	bigK  		= sqrt( (1/(wavelength * wavelength)) + Uo); // this calculates the momentum vector	//K inside the crystal.  sF.r is the mean inner potential Uo for this crystal			value = (1 + 1.956e-6 * energy) * theZoneAxis->Periodicity(1,cameraConstant/wavelength,wavelength,&diameter);	theEnergy = energy;		for(i = 1 ; i <= data_Count - 1 ; i++,thisLine++){				zoneOrder = thisLine->h * theZoneAxis->h + thisLine->k * theZoneAxis->k + thisLine->l * theZoneAxis->l;		if(adjustEnergy){			energy += (gamma * bigK * bigK * 300 / ((zoneOrder * value)));			switch(theBeamFlag)			{				case 1:					theEBeam->		SetWaveAndEnergy(energy);					wavelength	=	theEBeam->wavelength;					break;				case 2:					theXRay->		SetWaveAndEnergy(wavelength);					energy		=	theXRay->energy;					break;				case 3:					break;			}		}		if(thisLine->intensity > intensityRange && zoneOrder >= lowOrder && zoneOrder <= highOrder)		{			if(greyFlag){				theValue = (short)(220 * (double)((thisLine->intensity - minIntensity)/ range));				DMForeColor(theValue + 15);			}			if(curvedLines)				DrawCurved(thisLine);			else				DrawStraight(thisLine,centerD);					}		if(adjustEnergy){			energy = theEnergy;			switch(theBeamFlag)			{				case 1:					theEBeam->		SetWaveAndEnergy(energy);					wavelength	=	theEBeam->wavelength;					break;				case 2:					wavelength	= 	energy;					theXRay->		SetWaveAndEnergy(wavelength);					energy		=	theXRay->energy;					break;				case 3:					break;			}		}	}		D_SetClip(oldClipRgn);		D_DisposeRgn(&newClipRgn);		D_DisposeRgn(&oldClipRgn);	if(functionID == DELTA_UNIT_CELL)DrawDeltaPict();	ClearDrawEnviron();	return;}void HOLZObj::DrawStraight(SpotInfoPtr thisLine,short centerD){	short 		theX,theY;	double 		endX,endY;	double		factor,R,theD;	double 		ewaldSphere,chordLength;	double		theG,phi;	Rect 		theRect;		if(approximateFlag){		ewaldSphere 	= 	2. / wavelength;		theD 		= 	sqrt((double)(thisLine->x * thisLine->x + thisLine->y * thisLine->y));		R 			= 	fabs((ewaldSphere * thisLine->z) - fabs(thisLine->z * thisLine->z));		factor 		= ((sqrt(R) - theD)  / convergenceAngle);		theY 		= 	(factor *  centerD * (thisLine->x/theD));//-		theX 		= 	(factor * centerD * (thisLine->y/theD));//-	}else{		theG 		= 	sqrt((double)(thisLine->x * thisLine->x + thisLine->y * thisLine->y + thisLine->z * thisLine->z));		phi			=	asin(wavelength * theG / 2) - asin(thisLine->z/ theG);		ewaldSphere = 	1. / wavelength; 		factor		=	-ewaldSphere * sin(phi);		theD 		= 	sqrt((double)(thisLine->x * thisLine->x + thisLine->y * thisLine->y));		theY 		= 	(factor *  scaleFactor * (thisLine->x/theD));//-		theX 		= 	(factor * scaleFactor * (thisLine->y/theD));//-	}			chordLength = 	sqrt(((float)centerD * (float)centerD) - ((float)theX * (float)theX) - ((float)theY * (float)theY)); 	theX		+= 	centerX;	theY 		+= 	centerY;	endY		= 	chordLength * thisLine->y / theD;//-	endX  	=  - chordLength * thisLine->x / theD;//+		SetRect			(&theRect,theX-endX,theY-endY,theX+endX,theY+endY);	thisLine->	spotRect = theRect;		MoveTo		(theRect.left,theRect.top);	LineTo		(theRect.right,theRect.bottom);}void HOLZObj::DrawCurved(SpotInfoPtr thisLine){	double 		intensityRange;	short 		theX,theY;	double		offX,offY,R,theD;	double 		ewaldSphere;	double		theG,phi;	Rect 		theRect;	ewaldSphere 	= 	2. / wavelength;	intensityRange 	= 	1. / (double)dyRange;	theD 		= 	sqrt((double)(thisLine->x * thisLine->x + thisLine->y * thisLine->y));	theX 		= 	(scaleFactor * theD);	theY 		= 	(scaleFactor * theD);	if(approximateFlag){		R 			= 	-sqrt(fabs((ewaldSphere * thisLine->z) - fabs(thisLine->z * thisLine->z)));	}else{		theG 		= 	sqrt((double)(thisLine->x * thisLine->x + thisLine->y * thisLine->y + thisLine->z * thisLine->z));		phi			=	asin(wavelength * theG / 2) - asin(thisLine->z/ theG);		ewaldSphere = 	1. / wavelength; 		R			=	ewaldSphere * sin(phi) + theD;			}				SetRect			(&theRect,-theX,-theY,theX,theY);		offX		= 	centerX - (R * scaleFactor *  thisLine->y / theD);//+	offY 		= 	centerY - (R * scaleFactor *  thisLine->x / theD);//+	OffsetRect(&theRect,offX,offY);	thisLine->	spotRect = theRect;	dm_FrameOval(&thisLine->	spotRect);}void HOLZObj::DeltaCalculate(void)	{	double 		chx,chy,chz,				ckx,cky,ckz,				clx,cly,clz;					double  xForm[3][3],					xFormMatrix[3][3];		short 		i;	Crystal 	*thisCrystal;	SpotInfoPtr	deltaSpot;			thisCrystal 					= 	(Crystal*)D_new(Crystal);	thisCrystal->						InitCrystal(0);	setCrystal->						CopyCrystal(thisCrystal);		thisCrystal->theUnitCell.a 		+= deltaCell.a;	thisCrystal->theUnitCell.b 		+= deltaCell.b;	thisCrystal->theUnitCell.c 		+= deltaCell.c;	thisCrystal->theUnitCell.alpha 	+= deltaCell.alpha;	thisCrystal->theUnitCell.beta 	+= deltaCell.beta;	thisCrystal->theUnitCell.gamma 	+= deltaCell.gamma;	thisCrystal->GetSvals();	thisCrystal->CellVolume();				GetOrientation(xFormMatrix);//	InvertMatrix(xFormMatrix);		thisCrystal->		Get001XForm(xForm);	MatrixMultiply		(xForm,xFormMatrix,xForm); 	ConverttoReciprocal	(xForm,(double)thisCrystal->volume,true);	chx = xForm[0][0];			chy = xForm[1][0];			chz = xForm[2][0];			ckx = xForm[0][1];			cky = xForm[1][1];			ckz = xForm[2][1];			clx = xForm[0][2];			cly = xForm[1][2];			clz = xForm[2][2];	/*MFTemp*/D_HLock				(deltaData);	deltaSpot 		= 	*deltaData;	deltaSpot++;	for(i = 1; i < data_Count;i++,deltaSpot++){		deltaSpot->x = chx * deltaSpot->h + ckx * deltaSpot->k + clx * deltaSpot->l;		deltaSpot->y = chy * deltaSpot->h + cky * deltaSpot->k + cly * deltaSpot->l;		deltaSpot->z = fabs(chz * deltaSpot->h + ckz * deltaSpot->k + clz * deltaSpot->l);	}	thisCrystal->		DoClose();	/*MFTemp*/D_HUnlock			(deltaData);		return;}void HOLZObj::DoIdle(void){	if(FrontWindow() == theWindow && functionID == DELTA_UNIT_CELL){		while(IsPressed( (unsigned short )123)) {return;}		while(IsPressed( (unsigned short )124)) {return;}		while(IsPressed( (unsigned short )125)) {return;}		while(IsPressed( (unsigned short )126)) {return;}	}	inherited::DoIdle();}void HOLZObj::DrawDeltaPict(void){	short 		i;	double 		intensityRange;	short			zoneOrder;	double 		ewaldSphere;	SpotInfoPtr thisLine;	PenState 	thePenState;	Rect			theCentralRect;	short			centerD;	double		theEnergy;	RgnHandle	newClipRgn,oldClipRgn;	GetPenState(&thePenState);	switch(theBeamFlag)	{		case 1:			theEnergy 	= 	energy;			energy  	+= 	((double)delVoltage / 1000);			theEBeam->		SetWaveAndEnergy(energy);			wavelength	=	theEBeam->wavelength;			break;		case 2:			theEnergy	= 	wavelength;			wavelength	+=  ((double)delVoltage / 100);			theXRay->		SetWaveAndEnergy(wavelength);			energy 		=	theXRay->energy;			break;		case 3:			break;	}	SetScaleFactor();		ewaldSphere 		= 	2. / wavelength;	intensityRange 	= 	1. / (double)dyRange;	centerD 			= 	convergenceAngle  * scaleFactor;		thisLine 				= 	*deltaData;	/*MFTemp*/D_HLock				(deltaData);			thisLine++;	SetRect				(&theCentralRect,-centerD,-centerD,centerD,centerD);	OffsetRect		(&theCentralRect,centerX,centerY);			DoSetOrigin();				newClipRgn = D_NewRgn();	oldClipRgn = D_NewRgn();	GetClip(oldClipRgn);	OpenRgn();	 dm_FrameOval(&theCentralRect);	CloseRgn(newClipRgn);	{			Rect				theCentralRect;						SetRect				(&theCentralRect,-centerD,-centerD,centerD,centerD);			OffsetRect		(&theCentralRect,centerX,centerY);			LockPixels 		(centerW->portPixMap);			ForeColor (blackColor);			BackColor (whiteColor);				PenMode(0);			CopyBits ( (BitMap *) (*(centerW->portPixMap)),							&((GrafPtr)theWindow)->portBits, &theCentralRect, &theCentralRect,0, nil);//srcCopy			UnlockPixels (centerW->portPixMap);// Now unlock Pixels.			PenMode(gMode);	}		D_SetClip(newClipRgn);	PenMode(0);	PenNormal();	{		RGBColor	aColor;		if(g_Monitor){						setCrystal->SetColor();			GetForeColor(&aColor);			InvertColor	(&aColor);			RGBForeColor(&aColor);		}else{			DMForeColor(BLACK);		}				}	for(i = 1; i < data_Count; i++,thisLine++){		zoneOrder 		= 	thisLine->h * theZoneAxis->h + thisLine->k * theZoneAxis->k + thisLine->l * theZoneAxis->l;																if(thisLine->intensity > intensityRange && 			zoneOrder >= lowOrder && 			zoneOrder <= highOrder)				if(curvedLines)			DrawCurved(thisLine);		else			DrawStraight(thisLine,centerD);	}		/*MFTemp*/D_HUnlock		(deltaData);	SetPenState				(&thePenState);		D_SetClip(oldClipRgn);	D_DisposeRgn(&newClipRgn);	D_DisposeRgn(&oldClipRgn);	switch(theBeamFlag)	{		case 1:			energy  = 		theEnergy;			theEBeam->		SetWaveAndEnergy(energy);			wavelength	=	theEBeam->wavelength;			break;		case 2:			wavelength	= 	theEnergy;			theXRay->		SetWaveAndEnergy(wavelength);			energy		=	theXRay->energy;			break;		case 3:			break;	}	SetScaleFactor();	DoResetOrigin();	return;}void	HOLZObj::DoMenu(long theResult){	short theMenu,theItem;	short centerD;	theMenu = HiWord(theResult);	theItem = LoWord(theResult);		switch(theMenu){				break;							case HOLZDEFMENU:			switch(theItem){				case 1:					//DoDefine();					DoDefineSetUp();					break;				case 2:					plotFlags[4]  = false;					changedFlag = true;					reSizeFlag = false; 					break;				case 3:					plotFlags[4]  = true;					changedFlag = true;					reSizeFlag = true;					break;				case 5:					dyRange += .5;					newPictReq = true;					switch(theBeamFlag)					{						case 1:							theEBeam->dyRange = dyRange;							break;						case 2:							theXRay->dyRange = dyRange;							break;						case 3:							break;					}					break;				case 6:					dyRange -= .5;					newPictReq = true;					switch(theBeamFlag)					{						case 1:							theEBeam->dyRange = dyRange;							break;						case 2:							theXRay->dyRange = dyRange;							break;						case 3:							break;					}					break;				default:					break;								}		break;	 	case HOLZINFOMENU:		 	switch(theItem){										case DELETE_LINE:						functionID = DELETE_SPOT_F;						theRuler->SetHelp("Click on line to delete it."); 						theRuler->SetPrompt("Delete a line.");						SetTheCursor(TARGET_CURSOR);						break;					case ROTATE_MENU:						functionID = ROTATE_PATTERN;						theRuler->SetPrompt("Rotate Pattern");						theRuler->SetHelp("Click & move to select point to rotate from, Click & move again to select pt. to rotate to.");						SetTheCursor(TARGET_CURSOR);						break;					case MOVE_HOLZ_MENU:						functionID = MOVE_PATTERN;						theRuler->SetHelp("Click anywhere inside HOLZ disk to move it. HOLZ disk is outlined");						theRuler->SetPrompt("Move Pattern");						break;					case	LABEL_SPOT:						functionID		= LABEL_SPOT_F;						theRuler->SetPrompt("Add Label");						theRuler->SetHelp("Labels toggle on/off with succesive clicks. Hold <opt> to label/erase all spots.Hold <shift> to  delete actual label.Labels are moveable.");/*dec 1992*/						SetTheCursor(TARGET_CURSOR);					break;					default:						theResult = INFO_MENU * 65536 + theItem;						inherited::DoMenu(theResult); 						break;				}			break;		case HOLZEXP:			switch(theItem){				case 2:					deltaCell.a 		= 	0;					deltaCell.b 		=	0;					deltaCell.c			= 	0;					deltaCell.alpha 	= 	0;					deltaCell.beta 		= 	0;					deltaCell.gamma 	= 	0;					delVoltage = 0;					changedFlag = true;					setCrystal->DetermineBraviasLattice();					theRuler->SetHelp("Reference Crystal has been changed to new values.  You can't go back!");					break;								case 3:										setCrystal->theUnitCell.a 		+= deltaCell.a;					setCrystal->theUnitCell.b 		+= deltaCell.b;					setCrystal->theUnitCell.c 		+= deltaCell.c;					setCrystal->theUnitCell.alpha 	+= deltaCell.alpha;					setCrystal->theUnitCell.beta 	+= deltaCell.beta;					setCrystal->theUnitCell.gamma 	+= deltaCell.gamma;					energy							+= (double)delVoltage / 1000;					deltaCell.a 		= 	0;					deltaCell.b 		=	0;					deltaCell.c			= 	0;					deltaCell.alpha 	= 	0;					deltaCell.beta 		= 	0;					deltaCell.gamma 	= 	0;					delVoltage = 0;					changedFlag = true;					setCrystal->GetSvals();					setCrystal->CellVolume();					setCrystal->DetermineBraviasLattice();					DoCalculate();					newPictReq = true;					theRuler->SetHelp("Reference Crystal has been changed to new values.  You can't go back!");					break;			}			break;		case DISTORTION:			{					CTabHandle	destCTab; 					GWorldPtr 	currPort;    					GDHandle 		currDev;					short 			err;     					Rect				theCentralRect;										centerD 		= 	convergenceAngle  * scaleFactor;					SetRect				(&theCentralRect,-centerD,-centerD,centerD,centerD);					OffsetRect			(&theCentralRect,centerX,centerY);											destCTab 				= GetCTable(2100);					if(centerW){						DisposeGWorld(centerW);					}					GetGWorld(&currPort,&currDev);					err = NewGWorld(&centerW, (*(currPort->portPixMap))->pixelSize,&theCentralRect,destCTab, nil, 0);// Create Offscreen Graphics world.				//err = NewGWorld(&centerW, 8, &theCentralRect,destCTab, nil, 0);// Create Offscreen Graphics world.					if(err)return;					//GetGWorld(&currPort,&currDev);					LockPixels (centerW->portPixMap);					SetGWorld (centerW, nil);								PenMode(0);					ForeColor (blackColor);					BackColor (whiteColor);					dm_EraseRect(&theCentralRect);					CopyBits ( (BitMap *) (*(currPort->portPixMap)),									&((GrafPtr)centerW)->portBits, &theCentralRect, &theCentralRect,0, nil);//srcCopy					SetGWorld (currPort, currDev);					UnlockPixels (centerW->portPixMap);// Now unlock Pixels.					DisposCTable(destCTab);					PenMode(gMode);			}						functionID = DELTA_UNIT_CELL;			theDeltaItem = theItem;						theRuler->SetPrompt("Delta values:"); 			theRuler->SetHelp("Use arrows or mouse to change values. Left/right arrows change numbers, Up/down rotates to next parameter. ");			switch(theDeltaItem){				case 1:					sprintf(gTheText,"changing a");					break;				case 2:					sprintf(gTheText,"changing b");					break;				case 3:					sprintf(gTheText,"changing c");					break;				case 4:					sprintf(gTheText,"changing alpha");					break;				case 5:					sprintf(gTheText,"changing beta");					break;				case 6:					sprintf(gTheText,"changing gamma");					break;				case 7:					sprintf(gTheText,"changing voltage");					break;			}			TextSize(9);			TextFont(geneva);			theRuler->SetInfo(gTheText);			TextSize(0);			TextFont(0);			SetTheCursor(TARGET_CURSOR);			break;		default:			inherited::DoMenu(theResult); 			break;	}	HiliteMenu(0);}Boolean		HOLZObj::DoContent(Point thePoint){	double Uo,ratio,bigK,value,diameter;	PenNormal();	GetMouse(&thePoint);				switch(functionID){		case DELTA_UNIT_CELL:						SetDeltaUnitCell(thePoint);			return(true);		case -1:			if(adjustEnergy){						ratio 		= (.006648352) * (1 + (1.9569341e-3 * energy));// this converts Vg to Ug, Vg is the fourier components of the 						//crystal potential given in eV, Ug is the Dynamical Structure factor				Uo  		= ratio * zeroIntensity;				bigK  		= sqrt( (1/(wavelength * wavelength)) + Uo); // this calculates the momentum vector						//K inside the crystal.  sF.r is the mean inner potential Uo for this crystal						value = (1 + 1.956e-6 * energy) * theZoneAxis->Periodicity(1,cameraConstant/wavelength,wavelength,&diameter);						theRuler->SetPrompt("calc. delta Voltage:");				sprintf(gTheText,"%f6.4 kV",(gamma * bigK * bigK * 300 / ((value))));				theRuler->SetInfo(gTheText); 			}			break;		default:			break;	}	return(inherited::DoContent(thePoint));}void HOLZObj::DeltasByKey(char theChar){	float x;	short delVoltage1;	if((short)theChar == 30){		if(theDeltaItem < 7)			theDeltaItem++;		else			theDeltaItem = 1;	}else{		 if(theChar == 31)		 {		 	if(theDeltaItem > 1)				theDeltaItem--;			else 				theDeltaItem = 7;		 }	}	if(theChar == 30 || theChar == 31){		switch(theDeltaItem){			case 1:				sprintf(gTheText,"changing a");				break;			case 2:				sprintf(gTheText,"changing b");				break;			case 3:				sprintf(gTheText,"changing c");				break;			case 4:				sprintf(gTheText,"changing alpha");				break;			case 5:				sprintf(gTheText,"changing beta");				break;			case 6:				sprintf(gTheText,"changing gamma");				break;			case 7:				sprintf(gTheText,"changing voltage");				break;		}		TextSize(9);		TextFont(geneva);		theRuler->SetInfo(gTheText);		TextSize(0);		TextFont(0);		return;	}	if(theChar == 29){		x = .001;	}else if(theChar == 28){		x = -.001;	}	delVoltage1	=	delVoltage;	switch(theDeltaItem){		case 1:				deltaCell.a += x;						break;		case 2:				deltaCell.b += x;			break;		case 3:				deltaCell.c += x;			break;		case 4:				deltaCell.alpha += x * 10;			break;		case 5:				deltaCell.beta += x * 10;			break;		case 6:				deltaCell.gamma += x * 10;			break;		case 7:								delVoltage1 += x * 50000;			break;		default:			break;				}	sprintf(gTheText,"A = %5.3f,B = %5.3f,C = %5.3f,Alp = %4.2f¡,§ = %4.2f¡,½ = %4.2f¡,ÆV = %d V",			deltaCell.a,deltaCell.b,deltaCell.c,deltaCell.alpha,deltaCell.beta,			deltaCell.gamma,delVoltage1);	TextSize(9);	TextFont(geneva);	theRuler->SetInfo(gTheText);	TextSize(0);	TextFont(0);	DeltaCalculate();	delVoltage = delVoltage1;	//DrawDeltaPict();	newPictReq = true;}void	HOLZObj::SetDeltaUnitCell(Point thePoint){	Point 		oldPoint,fixedPoint;	PenState 	thePenState;		GetPenState		(&thePenState);	GetMouse		(&oldPoint);	fixedPoint 	= 	oldPoint;	thePoint 	= 	oldPoint;		while(StillDown()){		GetMouse(&thePoint);		if(!EqualPt(oldPoint,thePoint)){						switch(theDeltaItem){				case 1:					deltaCell.a += .001 * (thePoint.h - oldPoint.h);					deltaCell.b += .001 * (thePoint.v - oldPoint.v);					break;				case 2:					deltaCell.b += .001 * (thePoint.h - oldPoint.h);					deltaCell.c += .001 * (thePoint.v - oldPoint.v);					break;				case 3:					deltaCell.c += .001 * (thePoint.h - oldPoint.h);					deltaCell.a += .001 * (thePoint.v - oldPoint.v);					break;				case 4:					deltaCell.alpha += .01 * (thePoint.h - oldPoint.h);					deltaCell.beta += .01 * (thePoint.v - oldPoint.v);					break;				case 5:					deltaCell.beta += .01 * (thePoint.h - oldPoint.h);					deltaCell.gamma += .01 * (thePoint.v - oldPoint.v);					break;				case 6:					deltaCell.gamma += .01 * (thePoint.h - oldPoint.h);					deltaCell.alpha += .01 * (thePoint.v - oldPoint.v);					break;				case 7:					delVoltage += 5 * (thePoint.h - oldPoint.h);					break;								}			oldPoint = thePoint;			sprintf(gTheText,"A = %5.3f,B = %5.3f,C = %5.3f,Alp = %4.2f,§ = %4.2f,½ = %4.2f,ÆV = %4.0f V",					deltaCell.a,deltaCell.b,deltaCell.c,deltaCell.alpha,deltaCell.beta,					deltaCell.gamma,delVoltage);			TextSize(9);			TextFont(geneva);			theRuler->SetInfo(gTheText);			TextSize(0);			TextFont(0);			DeltaCalculate();		  DrawDeltaPict();		}			}	newPictReq = true;}Point 	HOLZObj::MovePatternCenter(Point thePoint){	thePoint = inherited::MovePatternCenter(thePoint);	if(!curvedLines){		if(theLabels)theLabels->MoveAll(thePoint);	}else{		if(theCurvedLabels)theCurvedLabels->MoveAll(thePoint);	}		return(thePoint);}void HOLZObj::DrawTheText(void){	if(!curvedLines){		if(theLabels)theLabels->DrawAll();	}else{		if(theCurvedLabels)theCurvedLabels->DrawAll();	}}void HOLZObj::LabelSpot(void){	Point thePoint;	TextObj *line;	thePoint.v = thePoint.h = 0;		if(spotLoc >= 0){		newPictReq = true;		if(THE_CURRENT_SPOT.flags & TEXT_MASK){			if(LabelAllLines(false))return;			if(!theCurvedLabels)THE_CURRENT_SPOT.flags -= TEXT_MASK;			if(curvedLines){				if(theCurvedLabels)theCurvedLabels = (TextRoundObj*)theCurvedLabels->Erase(spotLoc,(TextObj*)theCurvedLabels);			}else{				if(theLabels)theLabels = theLabels->Erase(spotLoc,theLabels);			}						} else {			if(LabelAllLines(true))return;			THE_CURRENT_SPOT.flags |= (TEXT_MASK);			THE_CURRENT_SPOT.theCrystal->SetColor();															GetMouse(&thePoint);			if(curvedLines){				if(theCurvedLabels){					line = theCurvedLabels->Add(spotLoc,(&THE_CURRENT_SPOT),thePoint);					line->lineRect = (&THE_CURRENT_SPOT)->spotRect;					line->Move();				}else{					theCurvedLabels = (TextRoundObj*)D_new(TextRoundObj);					theCurvedLabels->DoInit(false,theCrystal[0]);					theCurvedLabels->InsertNewLoc(spotLoc,(&THE_CURRENT_SPOT),thePoint);					theCurvedLabels->lineRect = (&THE_CURRENT_SPOT)->spotRect;					theCurvedLabels->Move();				}			}else{				if(theLabels){					line = theLabels->Add(spotLoc,(&THE_CURRENT_SPOT),thePoint);					line->lineRect = (&THE_CURRENT_SPOT)->spotRect;					line->Move();				}else{					theLabels = (TextObj*)D_new(TextObj);					theLabels->DoInit(false,theCrystal[0]);					theLabels->InsertNewLoc(spotLoc,(&THE_CURRENT_SPOT),thePoint);					theLabels->lineRect = (&THE_CURRENT_SPOT)->spotRect;					theLabels->Move();				}			}		}		//newPictEnable = true;		thePoint.h = thePoint.v = 0;		return;	}		if(theTextObj){		if(IsPressed((unsigned short )56)){			if(theTextObj == theLabels){				theLabels = theLabels->next;				DoSetOrigin();				((SpotInfoPtr)(*theDataHandle))[theTextObj->spotLoc].flags -= TEXT_MASK;				theTextObj->Kill();				D_delete(theTextObj);				theTextObj = 0L;				DoResetOrigin();			}else{				DoSetOrigin();				theLabels->EraseObject(theTextObj);				DoResetOrigin();				theTextObj = (TextObj*)NUL;			}		}else{			theTextObj->Move();		}				newPictReq = true;		thePoint.h = thePoint.v = 0;			}else if(theRoundObj){				if(IsPressed((unsigned short )56)){			if(theRoundObj == theCurvedLabels && theCurvedLabels){				theCurvedLabels = theCurvedLabels->next;				DoSetOrigin();				((SpotInfoPtr)(*theDataHandle))[theRoundObj->spotLoc].flags -= TEXT_MASK;				theRoundObj->Kill();				D_delete(theRoundObj);				theTextObj = 0L;				DoResetOrigin();			}else{				DoSetOrigin();				if(theCurvedLabels)theCurvedLabels->EraseObject(theRoundObj);				DoResetOrigin();				theRoundObj = NUL;			}		}else{						theRoundObj->Move();		}		newPictReq = true;		thePoint.h = thePoint.v = 0;			}		}Boolean	HOLZObj::FindSpot(Point thePoint){	short 			i,n;	unsigned long			time;	SpotInfo		*theSpot;	static	Point	lastPoint;	static	short	lastLoc;	static	long	thelastClick;	static	Boolean	wasFound;	double			intensityRange;	RgnHandle		searchRgn;	Rect 	frameRect;		time = gTheEvent.when;	if(thelastClick == time){	/* if NO elapsed time, then same event, data is OK */		return wasFound;	}	thelastClick = time;	LocalToObj(&thePoint);	spotLoc = -1;		thelastClick = time;	lastPoint = thePoint;	theTextObj = (TextObj*)NUL;	theRoundObj = (TextRoundObj*)NUL;	if(curvedLines){		if(theCurvedLabels)		theRoundObj = (TextRoundObj*)theCurvedLabels->DoFind(thePoint);		spotLoc = -1;	}else{		if(theLabels)		theTextObj = (TextObj*)theLabels->DoFind(thePoint);		spotLoc = -1;	}	if(theTextObj || theRoundObj){		wasFound				= 	true;		GetClip(gTheRgn);		return 	true;	}			/*MFTemp*/D_HLock			(theDataHandle);	theSpot 	= 	(SpotInfoPtr)*theDataHandle;		if(gShifted){		double	x,y;		x = thePoint.h - lastPoint.h;		y = thePoint.v - lastPoint.v;		if(sqrt(x * x + y * y) < 4.2){			n = lastLoc;		} else {			n = 1;		}	} else {		n = 1;	}	intensityRange 	= 	1. / (double)dyRange; 	frameRect = ((SpotInfoPtr)*theDataHandle)[0].spotRect;	searchRgn		=	D_NewRgn();	OpenRgn();		dm_FrameOval(&frameRect);	CloseRgn(searchRgn);		if(PtInRgn(thePoint,gTheRgn)){		for(i = n , theSpot = &(((SpotInfoPtr)*theDataHandle)[n - 1])  ; i <= data_Count ; i++,theSpot++){			if(theSpot->spotRect.top == -2 || intensityRange > theSpot->intensity)				continue;			if(curvedLines){				double delY,delX,radius,refX,refY;				gTheRect = theSpot->spotRect;								radius = (gTheRect.right - gTheRect.left) / 2;				refX = (gTheRect.right + gTheRect.left) / 2;				refY = (gTheRect.bottom + gTheRect.top) / 2;				delX = thePoint.h - refX;				delY = thePoint.v - refY;				if(fabs(radius - sqrt(delX * delX + delY * delY)) <= 2){					/*MFTemp*/D_HUnlock(theDataHandle);					spotLoc 				= 	i - 1;					obj_Index->theCrystal	= 	THE_CURRENT_SPOT.theCrystal;					obj_Index->h 			= 	THE_CURRENT_SPOT.h;					obj_Index->k 			= 	THE_CURRENT_SPOT.k;					obj_Index->l 			= 	THE_CURRENT_SPOT.l;					obj_Index->direction 	= 	THE_CURRENT_SPOT.direction;										lastLoc		 			= 	i + 1;					thelastClick 			= 	time;					lastPoint 				= 	thePoint;					gTheRect				=	theSpot->spotRect;					wasFound				= 	true;					D_DisposeRgn(&searchRgn);					return 						true;				}			}else{				if(theLine == 0L){					theLine = (LineObj*)D_new(LineObj);						theLine->DoInit(true,THE_CURRENT_SPOT.theCrystal,false,0L,thePoint,thePoint);//bloch				}				theLine->SetLineToRect(theSpot->spotRect);				if(theLine->PointOnLine(thePoint)){					/*MFTemp*/D_HUnlock(theDataHandle);					spotLoc 		= 	i - 1;					obj_Index->theCrystal	= 	THE_CURRENT_SPOT.theCrystal;					obj_Index->h 			= 	THE_CURRENT_SPOT.h;					obj_Index->k 			= 	THE_CURRENT_SPOT.k;					obj_Index->l 			= 	THE_CURRENT_SPOT.l;					obj_Index->direction 	= 	THE_CURRENT_SPOT.direction;					spotLoc 				= 	i - 1;					lastLoc		 			= 	i + 1;					thelastClick 			= 	time;					lastPoint 				= 	thePoint;					gTheRect				=	theSpot->spotRect;					wasFound				= 	true;					D_DisposeRgn(&searchRgn);					return 						true;				}			}		}	}	D_DisposeRgn(&searchRgn);	spotLoc = -1;		thelastClick = time;	lastPoint = thePoint;	/*MFTemp*/D_HUnlock(theDataHandle);	if(n != 1){		SysBeep(30);	} else {		FlashMenuBar(0);		Delay(6L,&time);		FlashMenuBar(0);	}	lastLoc = 1;					/* in case the spot was close but missed */	wasFound = false;	return wasFound;}void	HOLZObj::DoKey(char	theChar){	switch(functionID){		case DELTA_UNIT_CELL:			theRuler->SetPrompt("Delta values:"); 			theRuler->SetHelp("Use arrows or mouse to change values");			DeltasByKey(theChar);			return;		default:			inherited::DoKey(theChar);			return;			}	return;}void 	HOLZObj::DoAuxRead(){	curvedLines = gTheFile->ReadBoolean();	if( gTheFile->ReadBoolean()){		if(theLabels){theLabels->		ReadAll(theCrystal);		}else{			theLabels = (TextObj*)D_new(TextObj);			theLabels->DoInit(false,theCrystal[0]);			theLabels->		ReadAll(theCrystal);		}	}	if( gTheFile->ReadBoolean()){		if(theCurvedLabels)theCurvedLabels->		ReadAll(theCrystal);		else{			theCurvedLabels = (TextRoundObj*)D_new(TextRoundObj);			theCurvedLabels->DoInit(false,theCrystal[0]);			theCurvedLabels->		ReadAll(theCrystal);		}	}		lowOrder	= gTheFile->ReadShort();/*dec 1992 eric changes*/	highOrder	= gTheFile->ReadShort();/*dec 1992 eric changes*/	if(GetVersion(objectType)){		approximateFlag = gTheFile->ReadBoolean();		adjustEnergy		= gTheFile->ReadBoolean();		zeroIntensity		= gTheFile->ReadFloat();		gamma						=	gTheFile->ReadFloat();		delVoltage			=	gTheFile->ReadFloat();	}	inherited::DoAuxRead();}void 	HOLZObj::DoAuxWrite(){	gTheFile->WriteBoolean(curvedLines);	if(theLabels){		 gTheFile->WriteBoolean(true);		theLabels->		WriteAll();	}else{		 gTheFile->WriteBoolean(false);	}	if(theCurvedLabels){		 gTheFile->WriteBoolean(true);		theCurvedLabels->		WriteAll();	}else{		 gTheFile->WriteBoolean(false);	}	gTheFile->WriteShort(lowOrder);	gTheFile->WriteShort(highOrder);	gTheFile->WriteBoolean(approximateFlag);	gTheFile->WriteBoolean(adjustEnergy);	gTheFile->WriteFloat((float)zeroIntensity);	gTheFile->WriteFloat((float)gamma);	gTheFile->WriteFloat((float)delVoltage);			inherited::DoAuxWrite();}/*float	HOLZObj::RotateSpots(Point thePoint){	float rotAngle;		rotAngle	=	inherited::RotateSpots( thePoint);	if(rotAngle == 0.0){		return 0.0;	}	ResetMoveableLabels();	ResetCurvedLabels();	return(rotAngle);}*/void	HOLZObj::DeleteSpot(void){	short		i;	SpotInfo	*sourceSpot,*destSpot;	/*MFTemp*/D_HLock(theDataHandle);		sourceSpot = destSpot = &(((SpotInfoPtr)*theDataHandle)[spotLoc]);	DoSetOrigin();	if(curvedLines){		if(theCurvedLabels)theCurvedLabels = (TextRoundObj*)theCurvedLabels->Erase(spotLoc,(TextObj*)theCurvedLabels);	}else{		if(theLabels)theLabels = theLabels->Erase(spotLoc,(TextObj*)theLabels);	}	DoResetOrigin();	sourceSpot++;	HilightDataPoint(destSpot);	data_Count--;	for(i = spotLoc ; i < data_Count ; i++,sourceSpot++,destSpot++){		*destSpot = *sourceSpot;	}	/*MFTemp*/D_HUnlock(theDataHandle);	//newPictEnable = true;	spotLoc = 1;	return;}void HOLZObj::HilightDataPoint(SpotInfoPtr theSpot){	PenState thePenState;	Rect	theRect;		theRect = theSpot->spotRect;	GetPenState	(&thePenState);	PenMode		(srcXor);	DMForeColor	(COMPLEMENT_COLOR);	MoveTo		(theRect.left,theRect.top);	LineTo		(theRect.right,theRect.bottom);	SetPenState	(&thePenState);	DMForeColor	(10 + setCrystal->idNum & CRYSTAL_MASK);}void HOLZObj::DoClose(void){	DeleteMenu(DISTORTION);	if(centerW)DisposeGWorld(centerW);	ReleaseResource((Handle)theDistortMenu);	KillAllLabels();	/*Temp*/KillHandle((Handle*)&deltaData);	inherited::DoClose();}void HOLZObj::MyCalculate(void)	{	long 	hmax,kmax,lmax,			h,k,l,			thehMax,thekMax,thelMax,			i;	long	x,y,z,			theDotProhkluvw;				double 	zoneAxisLength,reciprocalLatticeSize,			dx,dy,dz,theD,zoneParameter;				double  intens,factor,RofEwaldSph,R;		double 	chx,chy,chz,			ckx,cky,ckz,			clx,cly,clz;				double 	hZoneAxis,kZoneAxis,lZoneAxis;		SpotInfoPtr	theSpots,thisSpot,theSpot;		double 	xForm[3][3],			xFormMatrix[3][3];				double 	maxIntensity,xD,yD,zD;		double 	*theUs,*theVs,*theWs,*theZs,*theBs;		double		dH,dK,dL;				short 	atom_Count;	long	plotCrystal;	OSErr	iErr;	double	diameter,electronMassRation;	Ptr		*theHandle;	dcomplex cAb,sF;	double bigK,ratio,Uo;	electronMassRation =   1. + ( (double)energy / 511.);				ResetCurvedLabels();	if(!SetScatteringPosAIntensity(setCrystal,&theUs,&theVs,&theWs,&theZs,&theBs,&atom_Count))return;//Timebomb!!//*atom_Count cannot be the same address as *crystal->Atom_Couynt  or you will continually increase the number				data_Count		=	0;	data_Size 		= 	sizeof(SpotInfo);					if(lowOrder <= 0)		lowOrder = 1;		deltaCell.a 		= 	0;	deltaCell.b 		=	0;	deltaCell.c			= 	0;	deltaCell.alpha 	= 	0;	deltaCell.beta 		= 	0;	deltaCell.gamma 	= 	0;	delVoltage 			= 	0;			RofEwaldSph 		= 	1. / wavelength; 	plotCrystal 		= setCrystal->idNum;	gamma						=	0;	thisSpot 				= &(((SpotInfoPtr)*theDataHandle)[data_Count++]);		thisSpot->intensity 	= (short double)1.0;	thisSpot->x				= 0.0;	thisSpot->y 			= 0.0;	thisSpot->z 			= 0.0;	thisSpot->angle 		= 0.0;	thisSpot->h 			= (short)theZoneAxis->h;	thisSpot->k 			= (short)theZoneAxis->k;	thisSpot->l 			= (short)theZoneAxis->l;	thisSpot->direction 	= true;	thisSpot->theCrystal 	= setCrystal;	thisSpot->flags 		= plotCrystal;		hZoneAxis 		= (double)theZoneAxis->h;	kZoneAxis 		= (double)theZoneAxis->k;	lZoneAxis		= (double)theZoneAxis->l;	/*Added for v2.0*/		GetOrientation(xFormMatrix);//	InvertMatrix(xFormMatrix);				zoneParameter 		= 	setCrystal->theUnitCell.a;	if(setCrystal->theUnitCell.b < zoneParameter) 		zoneParameter 	= 	setCrystal->theUnitCell.b;	if(setCrystal->theUnitCell.c < zoneParameter)		zoneParameter  	= 	setCrystal->theUnitCell.c ;		zoneAxisLength 	= 1./theZoneAxis->Periodicity(highOrder,cameraConstant/wavelength,wavelength,&diameter);	reciprocalLatticeSize = (diameter/(2 * cameraConstant)) + (2 * convergenceAngle); 		hmax 	= SizeofReciprocalLattice(1.,0.,0.,reciprocalLatticeSize,setCrystal);	kmax 	= SizeofReciprocalLattice(0.,1.,0.,reciprocalLatticeSize,setCrystal);	lmax 	= SizeofReciprocalLattice(0.,0.,1.,reciprocalLatticeSize,setCrystal);		if(setCrystal->lattice_Type == HEXAGONAL || setCrystal->lattice_Type == TRIGONAL){		hmax *= 2;		kmax *= 2;	}		thehMax = -hmax;	thekMax = -kmax;	thelMax = -lmax;				xD = (double)theZoneAxis->h;	yD = (double)theZoneAxis->k;	zD = (double)theZoneAxis->l;			setCrystal->		Get001XForm(xForm);	MatrixMultiply		(xForm,xFormMatrix,xForm); 	ConverttoReciprocal	(xForm,(double)setCrystal->volume,true);	zeroIntensity = (double)Cabs(TotalStructureFactor(0,0,0,theUs,theVs,theWs,atom_Count,theZs,theBs,setCrystal->volume,1,setCrystal,&cAb));	chx 				= xForm[0][0];	chy 				= xForm[1][0];	chz 				= xForm[2][0];	ckx 				= xForm[0][1];	cky 				= xForm[1][1];	ckz 				= xForm[2][1];	clx 				= xForm[0][2];	cly 				= xForm[1][2];	clz 				= xForm[2][2];		ratio 		= (.006648352) * (1 + (1.9569341e-3 * energy));// this converts Vg to Ug, Vg is the fourier components of the 	//crystal potential given in eV, Ug is the Dynamical Structure factor	Uo  		= ratio * zeroIntensity;	bigK  		= sqrt( (1/(wavelength * wavelength)) + Uo); // this calculates the momentum vector	//K inside the crystal.  sF.r is the mean inner potential Uo for this crystal			maxIntensity = 0;	/*MFTemp*/D_HLock((Handle)theDataHandle);	theSpots = (SpotInfoPtr)*theDataHandle;	x = thehMax * hZoneAxis;	theHandle = setCrystal->AtomicScatteringSet(electronMassRation,theBeamFlag);	for(h = thehMax ; h <= hmax  && gNoBreak ;h++){					y = thekMax * kZoneAxis;				for(k = thekMax; k <= kmax && gNoBreak ; k++){						z = lZoneAxis * thelMax;			for(l =  thelMax; l <= lmax && gNoBreak ; l++){								if(!adjustEnergy){					theDotProhkluvw = fabs((double)(-x - y - z));					if(theDotProhkluvw <  (long)lowOrder)goto NEWSTART;					if(theDotProhkluvw > (long)highOrder)goto NEWSTART;				}				//if(!adjustEnergy && (theDotProhkluvw <  lowOrder || theDotProhkluvw > highOrder))goto NEWSTART;				{					dx = chx * h + ckx * k + clx * l;					dy = chy * h + cky * k + cly * l;					dz = chz * h + ckz * k + clz * l;					if(dz < 0.0) 						dz = -dz;										theD 	= sqrt(dx * dx  + dy * dy);					R 		= fabs((2. * RofEwaldSph * dz));					R 		-= (dz * dz);					factor 	= -((sqrt(R) - theD)  / convergenceAngle);										if(fabs(factor) < 1.){													dcomplex cAb;						theD = sqrt(theD);						dH = (double)h;						dK = (double)k;						dL = (double)l;						//setCrystal->AtomicScatteringByD(theBeamFlag,theD,1,theZs);						AtomicScatterForDFromSet(theD,theHandle,theZs,atom_Count);						sF = TotalStructureFactor(dH,dK,dL,theUs,theVs,theWs,atom_Count,theZs,theBs,setCrystal->volume,1/theD,setCrystal,&cAb);						intens = Cabs(sF);												intens *= intens;												if(intens < 1e-14)							goto NEWSTART;						if(adjustEnergy){							double d,sg,ks;							if(theDotProhkluvw != 0){								d 	= dx * dx + dy * dy;// + dz * dz;								sg 	= bigK - sqrt((bigK * bigK) - d) - dz;								//sg = bigK - sqrt((bigK * bigK) + d + (2 * bigK * dz));								ks 	= 2 * bigK * sg; //2KSg = 2Kg - g**2								if(fabs(ks) > .0001)gamma += -intens/ks;							}else{									d = dx * dx + dy * dy + dz * dz;									if(fabs(d) > .0001)gamma += -intens/d;							}							if((theDotProhkluvw <  lowOrder || theDotProhkluvw > highOrder))goto NEWSTART;						}						if(data_Count >= data_Length){							ExpandMemory();								theSpots = (SpotInfoPtr)*theDataHandle;						}												thisSpot 			= &(theSpots[data_Count++]);						thisSpot->intensity = (short double)intens;						thisSpot->angle 	= 0.0;						thisSpot->x 		= (short double)dx;						thisSpot->y 		= (short double)dy;						thisSpot->z 		= (short double)(dz);						thisSpot->h 		= (short)h;						thisSpot->k 		= (short)k;						thisSpot->l 		= (short)l;						thisSpot->direction = false;						thisSpot->theCrystal = setCrystal;						thisSpot->flags 	= (long)plotCrystal;						thisSpot->sF			=		sF;						if(thisSpot->intensity > maxIntensity)								maxIntensity = thisSpot->intensity;																}				}					NEWSTART:  				z += lZoneAxis;			}			y +=  kZoneAxis;		}		x += hZoneAxis;	}	KillPtr				((Ptr)theUs);	if(adjustEnergy){		gamma /= 2 * bigK;	}	setCrystal->ClearAtomicScatSet(theHandle);	thisSpot 		= 	&(((SpotInfoPtr)*theDataHandle)[1]);	for(i = 1;i <= data_Count - 1;thisSpot++,i++){			thisSpot->intensity /= maxIntensity;	}	thisSpot 		= 	&(((SpotInfoPtr)*theDataHandle)[1]);		for(i = 1;i < data_Count;thisSpot++,i++){			if(thisSpot->intensity < .05){				theSpot = thisSpot;				for(k = i;k < data_Count - 1;theSpot++,k++){					*theSpot = theSpot[1];									}				i--;				thisSpot--;			}	}	/*MFTemp*/D_HUnlock			((Handle)theDataHandle);	if(data_Length >  data_Count){		D_RecoverMemory		(theDataHandle,data_Size,(long)data_Count);	}		numSpots = data_Length 	= 	data_Count;	/*Temp*/KillHandle			((Handle*)&deltaData); 	deltaData		= 	(SpotInfoHandle)theDataHandle;	iErr			= 	D_HandToHand((Handle*)&deltaData);	return;}