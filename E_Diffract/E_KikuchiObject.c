#include	"Diffract_INCs.h"//ces.Jim:E_Diffract:E_KikuchiObject.c#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"SF_MathLib.h"#include	"StereoObject.h"#include	"KikuchiObject.h"#include 	"FixMath.h"void	KikuchiObject::DoInit()			/* initialize object			*/{	inherited::DoInit();	return;}void	KikuchiObject::PrintSetUp(void){}void	KikuchiObject::SetObjectMenu(void){	theMenuBar		= GetNewMBar(KIKUCHI_OBJECT_MB);	ClearMenuBar();/* July 1992 */	FlagUser();	SetMenuBar		(theMenuBar);}void	KikuchiObject::FinishSetUp(void){	theLabels		= NULL;	theCurvedLabels = NULL;		theBeamFlag = 1;	energy =  theEBeam->energy;	wavelength = theEBeam->wavelength;					if(gTheFile->file_is_Open){		SetWTitle(theWindow,fileInfo.sfFile.name);		return;	}	sprintf(gTheText,"Kikuchi %d",g_Window_Number);	SetWTitle(theWindow,c2pstr(gTheText));	g_Window_Number++;		}void	KikuchiObject::DoClose(){		KillAllLabels();	inherited::DoClose();}void			KikuchiObject::DoMenu(long	theResult){	short	theMenu,theItem;	theMenu = HiWord(theResult);	theItem = LoWord(theResult);	switch(theMenu){		case	FUNCTION_MENU:			switch(theItem){				case	RE_DRAW:					SetTheCursor(WATCH_CURSOR);					zoomFlag = false;					reSizeFlag = true;					ResetCurvedLabels();					//SetPict(true);					newPictReq = true;					theResult = 0L;					break;				case 7:					theResult &= 0xFFFF0000;					theResult += 12;					break;				default:					break;			}			break;		case 2205:		 switch(theItem)		 {		  case 	4:					AddSpot();					break;		  }		  break;		case	ROTATE_MENU:			switch(theItem){				case	ZOOM_IN:				case	ZOOM_PREVIOUS:					ResetCurvedLabels();					break;				default:					break;			}			break;		default:			break;	}	inherited::DoMenu(theResult);}void	KikuchiObject::MyCalculate(void){	short 	i;	long	flags;	double	theD,PI_Over2;	double	dummy;	SpotInfoPtr	thisSpot;		inherited::MyCalculate();		ResetCurvedLabels();	PI_Over2 = PI / 2.0;	flags = K_MAP_MASK | SMALL_CIRCLE;	/*MFTemp*/D_HLock((Handle)theDataHandle);	thisSpot = ((SpotInfoPtr)*theDataHandle);	for(i = 0 ; i < data_Count ; i++,thisSpot++){		if(!(thisSpot->direction)){		//	if(thisSpot->h != thisSpot->k || thisSpot->l != 0) continue;			theD = thisSpot->theCrystal->DSpacing(thisSpot->h,thisSpot->k,thisSpot->l);			theD += theD;			if(theD <  .000001) continue;			thisSpot->flags |= flags;			dummy = wavelength / theD;			if(fabs(dummy) > 1){				dummy = 1;			}			thisSpot->angle = PI_Over2 - asin(dummy);		}	}	/*MFTemp*/D_HUnlock((Handle)theDataHandle);}void		KikuchiObject::RotateSpotsBase(double	theXForm[][3]){	ResetCurvedLabels();	inherited::RotateSpotsBase(theXForm);}void		KikuchiObject::RotateSpots(double	theXForm[][3]){	ResetCurvedLabels();	inherited::RotateSpotsBase(theXForm);}void KikuchiObject::RotateAround(Point thePoint,Boolean flag1,Boolean flag2){	ResetCurvedLabels();	inherited::RotateAround(thePoint,flag1, flag2);	}				void KikuchiObject::DrawTheText(void){	inherited::DrawTheText();		if(theCurvedLabels)theCurvedLabels->DrawAll();	}void KikuchiObject::LabelSpot(void){	Point thePoint;	DoSetOrigin();	ClipRect(&theWindow->portRect);	DoResetOrigin();	if((long)theRoundObj){		PenState thePenState;		GetPenState(&thePenState);		DMForeColor(BACKGROUND_COLOR);				if(IsPressed(56)){						if(theRoundObj == theCurvedLabels  && theRoundObj != NULL){				theCurvedLabels = theCurvedLabels->next;				((SpotInfoPtr)(*theDataHandle))[theRoundObj->spotLoc].flags -= TEXT_MASK;				DoSetOrigin();				theRoundObj->Kill();				DoResetOrigin();				D_delete(theRoundObj);			}else{				if(theCurvedLabels != 0L){					DoSetOrigin();					theCurvedLabels->EraseObject(theRoundObj);					DoResetOrigin();				}			}		}else{			DoSetOrigin();			ClipRect(&theWindow->portRect);			theRoundObj->Move();			DoResetOrigin();		}		SetPenState(&thePenState);		thePoint.h = thePoint.v = 0;		theRoundObj = 0L;		newPictEnable = true;		spotLoc = -1;	}	theRoundObj = 0L;	if(spotLoc >= 0){		if(THE_CURRENT_SPOT.direction){			ClipRect(&theWindow->portRect);			inherited::LabelSpot();			return;		}		newPictEnable = true;		if(THE_CURRENT_SPOT.flags & TEXT_MASK){			if(LabelAllLines(false))return;			if(!theCurvedLabels)THE_CURRENT_SPOT.flags -= TEXT_MASK;				DoSetOrigin();				ClipRect(&theWindow->portRect);				if(theCurvedLabels)theCurvedLabels = (TextRoundObj*)theCurvedLabels->Erase(spotLoc,theCurvedLabels);			DoResetOrigin();		} else {			if(LabelAllLines(true))return;			THE_CURRENT_SPOT.flags |= (TEXT_MASK);						THE_CURRENT_SPOT.theCrystal->SetColor();			GetMouse(&thePoint);			DoSetOrigin();			ClipRect(&theWindow->portRect);						if(theCurvedLabels){				TextRoundObj* line;				line = theCurvedLabels->Add(spotLoc,(&THE_CURRENT_SPOT),thePoint);				CleanLabel((TextObj*)line);				line -> Move();			}else{				theCurvedLabels = (TextRoundObj*)D_new(TextRoundObj);				theCurvedLabels->DoInit(false,theCrystal[0]);				theCurvedLabels->InsertNewLoc(spotLoc,(&THE_CURRENT_SPOT),thePoint);				CleanLabel(theCurvedLabels);				theCurvedLabels->Move();			}			DoResetOrigin();		}		spotLoc = -1;	}		theRoundObj = 0L;}void KikuchiObject::CleanLabel(TextObj* line){	short hor,ver;	if(((SpotInfoPtr)*theDataHandle)[line->spotLoc].flags & TOO_BIG){		hor = (line->lineRect.left + line->lineRect.right) / 2;		ver = (line->lineRect.top + line->lineRect.bottom) / 2;		line->lineRect.left = line->lineRect.right = hor;		line->lineRect.top = line->lineRect.bottom = ver;	}else{		line->lineRect = ((SpotInfoPtr)*theDataHandle)[line->spotLoc].spotRect;	}}Boolean	KikuchiObject::FindSpot(Point thePoint){	short 			n;	static	Point	lastPoint;	static	short	lastLoc;	static	long	thelastClick;	static	Boolean	wasFound = false;	double				minError = 100.9;	Point 				aPoint;	long					time;			theRoundObj		=	NULL;	if(!theDataHandle)return false;	time = gTheEvent.when;	if(time == thelastClick && spotLoc >= 0){	/* if NO elapsed time, then same event, data is OK */		return wasFound;	}	thelastClick = time;	if(thePoint.h == 0 && thePoint.v == 0){		lastPoint = thePoint;		lastLoc = -1;		return false;	}	StartWatch();	aPoint = thePoint;	if(inherited::FindSpot(thePoint)){		wasFound = true;		StopWatch();		FlushEvents(everyEvent,0);		lastLoc = spotLoc;		return wasFound;	}				LocalToObj(&aPoint);	lastPoint = aPoint;	//LocalToObj(&lastPoint);		if(theCurvedLabels){		theRoundObj = (TextRoundObj*)theCurvedLabels->DoFind(aPoint);	}	if(theRoundObj){		wasFound				= 	true;		StopWatch();		FlushEvents(everyEvent,0);		return true;	}		n = 1;	wasFound = FindTrace(aPoint, n);	if(!wasFound) spotLoc = -1;	StopWatch();	FlushEvents(everyEvent,0);	return wasFound;}void	KikuchiObject::DeleteSpot(void){	short		i;	SpotInfo	*sourceSpot,*destSpot;		if(spotLoc < 0)		return;		/*MFTemp*/D_HLock(theDataHandle);		sourceSpot = destSpot = &(((SpotInfoPtr)*theDataHandle)[spotLoc]);	DoSetOrigin();	if(theCurvedLabels)theCurvedLabels = (TextRoundObj*)theCurvedLabels->Erase(spotLoc,(TextObj*)theCurvedLabels);	DoResetOrigin();	sourceSpot++;		if(destSpot->direction == true){		HilightDataPoint(destSpot);	}else{		DrawSmallCircle((&THE_CURRENT_SPOT),true);	}		for(i = spotLoc ; i < data_Count - 1 ; i++,sourceSpot++,destSpot++){		*destSpot = *sourceSpot;	}	data_Count--;	D_HUnlock(theDataHandle);		return;}Boolean	KikuchiObject::FindTrace(Point thePoint,short n){	short 			i;	unsigned long			time;	SpotInfo		*theSpot;	static	Point	lastPoint;	static	short	lastLoc;	static	long	thelastClick;	static	Boolean	wasFound;	double			intensityRange;	short 			loc = -1;	double			minError = 100.9;	LineObj*		theLine;	if(!theDataHandle)return false;	time = gTheEvent.when;	if(time == thelastClick && spotLoc >= 0){	/* if NO elapsed time, then same event, data is OK */		return wasFound;	}	thelastClick = time;	theLine = (LineObj*)D_new(LineObj);	theLine->DoInit(false,theCrystal[0],false,0L,thePoint,thePoint);		/*MFTemp*/D_HLock			(theDataHandle);	theSpot 	= 	(SpotInfoPtr)*theDataHandle;					intensityRange 	= 	1. / (double)dyRange; 	for(i = n , theSpot = &(((SpotInfoPtr)*theDataHandle)[n - 1])  ; i <= data_Count ; i++,theSpot++){		if(theSpot->direction)			continue;		if(theSpot->flags & TOO_BIG){//theSpot->spotRect.top == -2 || theSpot->spotRect.right == theSpot->spotRect.left){			theLine->hor1 = theSpot->spotRect.left;			theLine->ver1 = theSpot->spotRect.top;						theLine->hor2	= theSpot->spotRect.right;			theLine->ver2	= theSpot->spotRect.bottom;			if(theLine->PointOnLine(thePoint)){goto FOUNE_IT;}		}else{ 			double delY,delX,radius,refX,refY;			Rect theRect;			theRect = theSpot->spotRect;			radius = (theRect.right - theRect.left) / 2;			refX = (theRect.right + theRect.left) / 2;			refY = (theRect.bottom + theRect.top) / 2;			delX = thePoint.h - refX;			delY = thePoint.v - refY;			if(fabs(radius - sqrt(delX * delX + delY * delY)) <= 2){	FOUNE_IT:			/*MFTemp*/D_HUnlock(theDataHandle);				spotLoc 		= 	i - 1;				obj_Index->theCrystal	= 	THE_CURRENT_SPOT.theCrystal;				obj_Index->h 			= 	THE_CURRENT_SPOT.h;				obj_Index->k 			= 	THE_CURRENT_SPOT.k;				obj_Index->l 			= 	THE_CURRENT_SPOT.l;				obj_Index->direction 	= 	THE_CURRENT_SPOT.direction;				spotLoc 				= 	i - 1;				lastLoc		 			= 	i + 1;				thelastClick 			= 	time;				lastPoint 				= 	thePoint;				wasFound				= 	true;				theLine->DoClose();				return 						true;			}		}			}	if(loc > 0 && minError < .1){		/*MFTemp*/D_HUnlock(theDataHandle);		spotLoc 		= 	loc - 1;		obj_Index->theCrystal	= 	THE_CURRENT_SPOT.theCrystal;		obj_Index->h 			= 	THE_CURRENT_SPOT.h;		obj_Index->k 			= 	THE_CURRENT_SPOT.k;		obj_Index->l 			= 	THE_CURRENT_SPOT.l;		obj_Index->direction 	= 	THE_CURRENT_SPOT.direction;		spotLoc 				= 	loc - 1;		lastLoc		 			= 	loc + 1;		thelastClick 			= 	time;		lastPoint 				= 	thePoint;		wasFound				= 	true;		theLine->DoClose();		return 						true;	}	spotLoc = -1;		/*MFTemp*/D_HUnlock(theDataHandle);	if(n != 1){		SysBeep(30);	} else {		FlashMenuBar(0);		Delay(6L,&time);		FlashMenuBar(0);	}	lastLoc = 1;					/* in case the spot was close but missed */	wasFound = false;	theLine->DoClose();	return wasFound;}void	KikuchiObject::HilightDataPoint(SpotInfoPtr destSpot){	if(destSpot->direction == true){		inherited::HilightDataPoint(destSpot);		return;	}}void	KikuchiObject::DoAuxRead(void)			/*	Stub for offspring reads		*/{			theZoneAxis->ReadIndex(theCrystal);	if( gTheFile->ReadBoolean()){		if(theCurvedLabels){theCurvedLabels->		ReadAll(theCrystal);		}else{			theCurvedLabels = (TextRoundObj*)D_new(TextRoundObj);			theCurvedLabels->DoInit(false,theCrystal[0]);			theCurvedLabels->		ReadAll(theCrystal);		}	}	inherited::DoAuxRead();}void	KikuchiObject::RationalizeData(void){	inherited::RationalizeData();}void	KikuchiObject::DoAuxWrite(void){	theZoneAxis->WriteIndex();	if(theCurvedLabels){		 gTheFile->WriteBoolean(true);		theCurvedLabels->		WriteAll();	}else{		 gTheFile->WriteBoolean(false);	}	inherited::DoAuxWrite();}#define INT2FIX(i) ((long) i << 16 )	Boolean	KikuchiObject::LabelAllLines(Boolean label){	Point thePoint,aPoint;	short i,h1,h2,v1,v2;	SpotInfoPtr thisLine;	Rect	centerRect;	TextRoundObj* newLine;	LineObj	*line1,*line2;	Point rectP[8];	short		j = 0,k,hor;	double x, y;	double dangle;	Rect oldRect;	short maxHKL = -1,theIdent = -2,theCrys;		maxHKL = 3;	if(!IsPressed((unsigned short )58))/*optionkey*/return false;	if(IsPressed( (unsigned short )56))/*shiftkey*/maxHKL = 0;	if(IsPressed( (unsigned short )17)){		theIdent 		= THE_CURRENT_SPOT.flags & CRYSTAL_MASK;	}else if(IsPressed( (unsigned short )0)){		theIdent = -1;	}		D_HLock(theDataHandle);	thisLine 		= 	((SpotInfoPtr)*theDataHandle);	h1 = centerX - projLengthScreen;	h2 = centerX + projLengthScreen;	v1 = centerY - projLengthScreen;	v2 = centerY + projLengthScreen;		centerRect = theWindow->portRect;				LocalRectToObj(&centerRect); 	InsetRect(&centerRect,50,50);	oldRect = centerRect;	hor = (centerRect.bottom - centerRect.top) / 2;	hor /= 5;	InsetRect(&oldRect,4 * hor,4 * hor);	thisLine++;	ResetCurvedLabels();	newPictReq = true;	if(!label){		for(i = 1 ; i < data_Count; i++,thisLine++){			if(thisLine->direction)continue;			thisLine->flags -= TEXT_MASK;		} 		D_HUnlock(theDataHandle);		return true;	}		line1 = (LineObj*)D_new(LineObj);	line1->next = 0L;	line1->previous = 0L;	line2 = (LineObj*)D_new(LineObj);	line2->next = 0L;	line2->previous = 0L;	for(i = 1 ; i < data_Count; i++,thisLine++){		thePoint.h = 0;		thePoint.v = 0;		centerRect = oldRect;		k = 0;		if(thisLine->direction)continue;		if(maxHKL){				if(fabs((double)thisLine->h) > 3 || fabs((double)thisLine->k) > 3					|| fabs((double)thisLine->l) > 3)continue;		}		theCrys = thisLine->flags & CRYSTAL_MASK;		if(theIdent > -1 && (theCrys != theIdent)) continue;				while(thePoint.h == 0 && thePoint.v == 0 && k <= 10){						if(thisLine->flags & TOO_BIG){				Boolean flag = false;				rectP[0].h = centerRect.left;				rectP[0].v = centerRect.top;				rectP[1].h = centerRect.left;				rectP[1].v = centerRect.bottom;								rectP[2].h = centerRect.left;				rectP[2].v = centerRect.top;				rectP[3].h = centerRect.right;				rectP[3].v = centerRect.top;								rectP[4].h = centerRect.right;				rectP[4].v = centerRect.top;				rectP[5].h = centerRect.right;				rectP[5].v = centerRect.bottom;								rectP[6].h = centerRect.right;				rectP[6].v = centerRect.bottom;				rectP[7].h = centerRect.left;				rectP[7].v = centerRect.bottom;				j = 0;				while(flag == false && j < 7){					line1 -> SetLine(rectP[j],rectP[j + 1]);					aPoint.h = thisLine->spotRect.left;					aPoint.v = thisLine->spotRect.top;					thePoint.h = thisLine->spotRect.right;					thePoint.v = thisLine->spotRect.bottom;					line2 -> SetLine(thePoint,aPoint);					thePoint = line1->CrossOver(line2);					if(PtInRect(thePoint,&centerRect)){						flag = true;					}else{						thePoint.h = 0;						thePoint.v = 0;					}					j++;				}							}else{				thePoint	= FindCrossOver(thisLine,centerRect);			}			InsetRect(&centerRect,-hor,-hor);			k++;		}		if(thePoint.h == 0 && thePoint.v == 0) continue;				aPoint = thePoint;		//the following offsets the label from the line ~ perpendicular to the line		j = 0;		if(thisLine->h != 0) j = thisLine->h / fabs((double)thisLine->h);		if(j == 0){			if(thisLine->k != 0) j = thisLine->k / fabs((double)thisLine->k);		}		if(j == 0){			 if(thisLine->l != 0) j = thisLine->l / fabs((double)thisLine->l);		}		if(j == 0) j = 1;		if(j < 0)continue;				if(thisLine->flags & TOO_BIG){			Fixed	theSlope;			short	theAngle, dh, dv;				dh = line2->hor1 - line2->hor2;					/* calculate the deltas */				dv = line2->ver1 -  line2->ver2;				theSlope = FixRatio( INT2FIX(dh), INT2FIX(dv) );	/* slope=dh/dv */				theAngle = AngleFromSlope( theSlope );				dangle = theAngle;				y = 20 * cos(dangle);				x = 20 * sin(dangle);		}else{			short angle;			PtToAngle(&thisLine->spotRect,aPoint,&angle);			dangle = angle;			dangle *= PI / 180;			x =  20 * sin(dangle);			y =  20 * cos(dangle);		}		thePoint.h += x;		thePoint.v += y;		ObjToLocal(&thePoint);//necessary because labels are expecting local coordinates for point		if(!theCurvedLabels){			theCurvedLabels = (TextRoundObj*)D_new(TextRoundObj);			theCurvedLabels->DoInit(false,theCrystal[0]);			theCurvedLabels->InsertNewLoc(i,thisLine,thePoint);			newLine = theCurvedLabels;		}else{			newLine = theCurvedLabels->Add(i,thisLine,thePoint);		}		thisLine->flags |= TEXT_MASK;		newLine->lineRect.left = newLine->lineRect.left = aPoint.h;		newLine->lineRect.top = newLine->lineRect.bottom = aPoint.v;		CleanLabel(newLine);		newLine->Draw(true);	}	line1->DoClose();	line2->DoClose();	D_HUnlock(theDataHandle);	return true;}Point	KikuchiObject::FindCrossOver(SpotInfoPtr theSpot,Rect testRect){	return IntersectionOvals(theSpot->spotRect,testRect);}#undef INT2FIX