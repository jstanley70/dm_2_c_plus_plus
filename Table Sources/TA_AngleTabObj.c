#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"//rces.Jim:Table Sources:TA_AngleTabObj.c#include	"UT_VectorMacros.c"#include 	"AngleTabObj.h"#include 	"AtomData.h"void		AngleTabObj::DoInit(void){	inherited::DoInit();	SetObjectWindowTitle("Angle Between Planes Table",360,200);	SetPort(theWindow);	data_Size		= sizeof(TableInfo);	data_Count		= 0;	data_Length		= 0;	data_Expand		= 10;	displayDspace 	= 1;	theTableInfo	= (TableInfoHandle)theDataHandle;		theListRect = ((GrafPtr)theWindow)->portRect;	theListRect.top 	+= 50;	theListRect.left 	= 5;	theListRect.right 	-= 18;	theListRect.bottom	 -= 5;		theVisRect			 = theWindow->portRect;	RectRgn					(picUpdateRgn,&theVisRect);	RectRgn					(drawRgn,&theVisRect);	SetRect			(&thePictRect,0,0,theWindow->portRect.right,50);		dspace1 = 2.;	dspace2 = 2;	angle = 90;	range = 5;	angleRange = 2;		theCrystalButton 	= 	(CrystalButton*)D_new(CrystalButton);	theCrystalButton	->	DoInit();	numColumns 			= 	6;	theCrystalButton2 	= 	(CrystalButton*)D_new(CrystalButton);	theCrystalButton2	->	DoInit();		/*KillMBHandle*/DisposeHandle				(theMenuBar);	theMenuBar 			= 	GetMenuBar();	DrawMenuBar				();	if(gTheFile->file_is_Open){		return;	}		objectType = ANGLE_PLANE_TABLE;/* New 9/10/92*/	DoDefine();}void AngleTabObj::SetObjectMenu(){	theMenuBar = GetNewMBar(TABLE_MB);	ClearMenuBar();/* July 1992 */	SetMenuBar(theMenuBar);}void		AngleTabObj::DoClose(void){	theCrystalButton->DoClose();	theCrystalButton2->DoClose();	inherited::DoClose();	return;}void	AngleTabObj::SetButton(void){	short 	width;	short 	left;	Rect	theRect;		width = StringWidth("\pCrystal 1");	(theCrystalButton)->SetOwner((Ptr)theCrystal[crystalNum]);	left = 6;	SetRect(&theRect,left,6,width + 5 + left,20);	left += width + 11;	sprintf(gTheText,"Crystal %d",crystalNum + 1);	theCrystalButton->SetButtonRect(theRect);	theCrystalButton->SetName(gTheText);	theCrystalButton->Enable();		(theCrystalButton2)->SetOwner((Ptr)theCrystal[crystalNum2]);	SetRect(&theRect,left,6,width + 5 + left,20);	sprintf(gTheText,"Crystal %d",crystalNum2 + 1);	theCrystalButton2->SetButtonRect(theRect);	theCrystalButton2->SetName(gTheText);	theCrystalButton2->Enable();}Boolean		AngleTabObj::DoContent(Point thePoint){	PenState theState;	GetPenState(&theState);	PenNormal();	theCrystalButton->DoContent(thePoint);	theCrystalButton2->DoContent(thePoint);		SetPenState(&theState);	return(inherited::DoContent(thePoint));}void			AngleTabObj::DoIdle(void){		inherited::DoIdle();	return;}#define DEFINE_TABLE 500void		AngleTabObj::DoMenu(long	theResult){	short	theMenu,theItem;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);		switch(theMenu){		case EDIT_MENU:			switch(theItem){				case CUT:				case COPY:				case PASTE:				case DO_CLEAR:					return;					break;				default:					break;			}			break;		case DEFINE_TABLE:			switch(theItem){				case 1:				//DoDefine();				DoDefineSetUp();				case 7:					displayDspace = 1;					DisplayList();					break;				case 8:					displayDspace = 2;					DisplayList();					break;				case 9:					displayDspace = 3;					DisplayList();					break;				case 10:					displayDspace = 4;					DisplayList();					break;				break;				default:					break;			}								break;		default:			break;	}	inherited::DoMenu(theResult);	return;}void AngleTabObj::DrawTheText(void){	inherited::DrawTheText();		theCrystalButton->DrawButtonRect(crystalNum + 10);	theCrystalButton2->DrawButtonRect(crystalNum2 + 10);	MoveTo(theListRect.left,theListRect.top - 10);	switch(displayDspace){		case 1:			sprintf(gTheText,"Zone Axis (H K L)  (H K L)  dspc1 Å dspc2 Å   Angle");		break;		case 2:			sprintf(gTheText,"Zone Axis (H K L)  (H K L)  r.d.1  r.d.2 Å-1  Angle");		break;		case 3:			sprintf(gTheText,"Zone Axis (H K L)  (H K L)  g1 (mm) g2 (mm)   Angle");		break;		case 4:			sprintf(gTheText,"Zone Axis (H K L)  (H K L)  2Theta1° 2Theta2°  Angle");		break;	}		DMForeColor(BLACK);	DrawString(c2pstr(gTheText));}void		AngleTabObj::MyCalculate(void){		short		h,k,l,i,m,maxRec;	SpotInfo 	*dspace;	SpotInfo 	*set1,*set2;	Index		*theIndex1,*theIndex2;	CrystalFace theFace,theFaces2[24];	short 		latticeType1,latticeType2,num1,num2,num4,lastCell;	double 		delX,dspaceLow,dspaceHigh;	double 		testAngle,lowAngle,highAngle;	Crystal 	*thisCrystal;	TableInfoPtr	thisRecord;	Handle			theDataBlock;	Boolean		flag = false;	data_Count = 0;		thisCrystal = theCrystal[crystalNum];		if(crystalNum2 == crystalNum){		if(dspace2 < dspace1){			delX = fabs((range * dspace2 / 100.));			 dspaceLow = dspace2 - delX;		}		else{			delX = fabs((range * dspace1 / 100.));			dspaceLow = dspace1 - delX;		}	}else{		delX = fabs((range * dspace1 / 100.));		dspaceLow = dspace1 - delX;	}	if(dspaceLow < 0.1) dspaceLow = .1;	h = SizeofReciprocalLattice(1.,0.,0.,1./ dspaceLow,thisCrystal);	k = SizeofReciprocalLattice(0.,1.,0.,1./ dspaceLow,thisCrystal);	l = SizeofReciprocalLattice(0.,0.,1.,1./ dspaceLow,thisCrystal);		theDataBlock = SubCalcDSpacings(thisCrystal,h,k,l,theBeamFlag,.1);	/*MFTemp*/D_HLock(theDataBlock);	dspace = *((SpotInfo**)theDataBlock);		numEntries = gCount;	if(numEntries < 0){		/*MFTemp*/D_HUnlock(theDataBlock);		/*Temp*/KillHandle(&theDataBlock);		return;	}	dspaceLow = dspace1 - delX; 	dspaceHigh = dspace1 + delX;	i = 0;	k = -1;	if(dspaceLow < 0.0) dspaceLow = .1;	set1 = (SpotInfoPtr)D_NewPtr(((long)numEntries + 1) * sizeof(SpotInfo));	while(dspace[i].x >= dspaceLow && i < numEntries){		if(dspace[i].x <= dspaceHigh)			 set1[++k] = dspace[i];		i++;	}	if(k == -1){		/*MFTemp*/D_HUnlock(theDataBlock);		/*Temp*/KillHandle(&theDataBlock);		KillPtr((Ptr)set1);		 return;	}		AllowBackground();		num1 = k;	if(crystalNum2 != crystalNum){		delX = (range * dspace2 / 100.);		dspaceLow = dspace2 - delX;		if(dspaceLow < 0.1) dspaceLow = .1;		thisCrystal = theCrystal[crystalNum2];		h = SizeofReciprocalLattice(1.,0.,0.,1./ dspaceLow,thisCrystal);		k = SizeofReciprocalLattice(0.,1.,0.,1./ dspaceLow,thisCrystal);		l = SizeofReciprocalLattice(0.,0.,1.,1./ dspaceLow,thisCrystal);		/*MFTemp*/D_HUnlock(theDataBlock);		/*Temp*/KillHandle(&theDataBlock);		theDataBlock = SubCalcDSpacings(thisCrystal,h,k,l,theBeamFlag,.1);		/*MFTemp*/D_HLock(theDataBlock);		dspace = *((SpotInfo**)theDataBlock);		numEntries = gCount;		if(numEntries < 0){			/*MFTemp*/D_HUnlock(theDataBlock);			/*Temp*/KillHandle(&theDataBlock);			KillPtr((Ptr)set1);			return;		}	}	dspaceLow = dspace2 - delX; 	dspaceHigh = dspace2 + delX;	i = 0;	k = -1;	if(dspaceLow < 0.0) dspaceLow = .1;	set2 = (SpotInfoPtr)D_NewPtr(((long)numEntries + 1) * sizeof(SpotInfo));	while(dspace[i].x >= dspaceLow && i < numEntries){		if(dspace[i].x <= dspaceHigh)			set2[++k] = dspace[i];		i++;	}	if(k == -1){		KillPtr((Ptr)set2);		/*MFTemp*/D_HUnlock(theDataBlock);		/*Temp*/KillHandle(&theDataBlock);		KillPtr((Ptr)set1);	 	return;	}		num2 = k;	/*MFTemp*/D_HUnlock(theDataBlock);	/*Temp*/KillHandle(&theDataBlock);		PenNormal();	theIndex1 = (Index*)D_new(Index);	theIndex1->Init(false,theCrystal[crystalNum]);		theIndex2 = (Index*)D_new(Index);	theIndex2->Init(false,theCrystal[crystalNum2]);			theZoneAxis->Init(true,theCrystal[crystalNum]);			latticeType1 = theCrystal[crystalNum]->lattice_Type;	latticeType2 = theCrystal[crystalNum2]->lattice_Type;	numEntries = 0;	lastCell = 0;	lowAngle = angle - angleRange;	highAngle = angle + angleRange;	TextFont(0); 	TextSize(0);		/*MFTemp*/D_HLock(theDataHandle);	maxRec = 32700 / 60;	theTableInfo	= (TableInfoHandle)theDataHandle;	if(latticeType2 == HEXAGONAL || latticeType2 == TRIGONAL)		flag = true;	for(i = 0; i <= num1 && gNoBreak;i++)	{		theIndex1->h = set1[i].h;		theIndex1->k = set1[i].k;		theIndex1->l = set1[i].l;		for(k = 0; k <= num2 && gNoBreak;k++){			theFace.h = set2[k].h;			theFace.k = set2[k].k;			theFace.l = set2[k].l;			num4 = -1;			CubicPermutate(&num4,theFace,theFaces2,flag,latticeType2);			for(m = 0; m <= num4 && gNoBreak; m++){							AllowBackground();								theIndex2->h = theFaces2[m].h;				theIndex2->k = theFaces2[m].k;				theIndex2->l = theFaces2[m].l;				testAngle = theIndex1->GetTheAngle(theIndex2);				if(testAngle >= lowAngle && testAngle <= highAngle){									if(data_Count >= data_Length){						ExpandMemory();							}					if(data_Count >= maxRec){						gNoBreak = false;					}										thisRecord = &((*theTableInfo)[data_Count++]);					if(theIndex1->ZoneAxis(theIndex2,theZoneAxis)){						thisRecord->zaH	= theZoneAxis->h;						thisRecord->zaK = theZoneAxis->k;						thisRecord->zaL	= theZoneAxis->l;					} else {						thisRecord->zaH	= theZoneAxis->h;						thisRecord->zaK = theZoneAxis->k;						thisRecord->zaL	= theZoneAxis->l;					}											thisRecord->p1H		= theIndex1->h;					thisRecord->p1K		= theIndex1->k;					thisRecord->p1L		= theIndex1->l;											thisRecord->p2H		= theIndex2->h;					thisRecord->p2K		= theIndex2->k;					thisRecord->p2L		= theIndex2->l;										thisRecord->dSpace1	= set1[i].x;					thisRecord->dSpace2	= set2[k].x;					thisRecord->angle	= testAngle;				}			}		}	}		gNoBreak = true;  /* allows list to be drawn */		/*MFTemp*/D_HUnlock(theDataHandle);	theIndex1->DoClose();	theIndex2->DoClose();	KillPtr((Ptr)set2);	KillPtr((Ptr)set1);	numEntries = 0;			if(data_Count >= maxRec){		WarnUser(2);	}			return;}void		AngleTabObj::DisplayList(void){	TableInfoPtr	thisRecord;	Index			*theIndex1,*theIndex2;	short			length;	Cell			theCell;	theIndex1 = (Index*)D_new(Index);	theIndex1->Init(false,theCrystal[crystalNum]);			theIndex2 = (Index*)D_new(Index);	theIndex2->Init(false,theCrystal[crystalNum2]);			theZoneAxis->Init(true,theCrystal[crystalNum]);		/*MFTemp*/D_HLock(theDataHandle);		thisRecord = *theTableInfo;		for(theCell.v = 0 ; theCell.v < data_Count ; theCell.v++,thisRecord++){		theIndex1->h	= thisRecord->p1H;		theIndex1->k	= thisRecord->p1K;		theIndex1->l	= thisRecord->p1L;		theIndex2->h	= thisRecord->p2H;		theIndex2->k	= thisRecord->p2K;		theIndex2->l	= thisRecord->p2L;		theZoneAxis->h	= thisRecord->zaH;		theZoneAxis->k	= thisRecord->zaK;		theZoneAxis->l	= thisRecord->zaL;				theCell.h = 0;		if(theZoneAxis->h != 0 || theZoneAxis->k != 0 || theZoneAxis->l != 0){			theZoneAxis->SetListIndecies(theList,theCell);		} else {			LSetCell("\p",0,theCell,theList);		}				theCell.h++;		theIndex1->SetListIndecies(theList,theCell);				theCell.h++;		theIndex2->SetListIndecies(theList,theCell);				theCell.h++;		switch(displayDspace)		{			case 1:				length = sprintf(gTheText,"%6.3f",thisRecord->dSpace1);				break;			case 2:				length = sprintf(gTheText,"%6.3f",1./thisRecord->dSpace1);				break;			case 3:				length = sprintf(gTheText,"%6.3f",cameraConstant/thisRecord->dSpace1);				break;			case 4:				length = sprintf(gTheText,"%6.3f",(360 / PI) * asin(wavelength/(thisRecord->dSpace1)));				break;		}		LSetCell(gTheText,length,theCell,theList);				theCell.h++;		switch(displayDspace)		{			case 1:				length = sprintf(gTheText,"%6.3f",thisRecord->dSpace2);				break;			case 2:				length = sprintf(gTheText,"%6.3f",1./thisRecord->dSpace2);				break;			case 3:				length = sprintf(gTheText,"%6.3f",cameraConstant/thisRecord->dSpace2);				break;			case 4:				length = sprintf(gTheText,"%6.3f",(360 / PI) * asin(wavelength/(thisRecord->dSpace2)));				break;		}		LSetCell(gTheText,length,theCell,theList);			theCell.h++;		length = sprintf(gTheText,"%6.2f •",thisRecord->angle);		LSetCell(gTheText,length,theCell,theList);	}	/*MFTemp*/D_HUnlock(theDataHandle);	theIndex1->DoClose();	theIndex2->DoClose();	newPictReq = true;}void		AngleTabObj::DoPrint(void){	inherited::DoPrint();	return;}void			AngleTabObj::DoKey(char	theChar){	inherited::DoKey(theChar);	return;}void			AngleTabObj::DoRefresh(void){	inherited::DoRefresh();		return;}void	AngleTabObj::DoHeaderPrint(Rect *topRect){	sprintf(tabelTitle,"Table of Angles Between Planes");	c2pstr(tabelTitle);	switch(displayDspace){		case 1:			sprintf(dataLabel,"Zone Axis (H K L)  (H K L)  dspc1 Å dspc2 Å   Angle");		break;		case 2:			sprintf(dataLabel,"Zone Axis (H K L)  (H K L)  r.d.1 Å-1 r.d.2 Å-1  Angle");		break;		case 3:			sprintf(dataLabel,"Zone Axis (H K L)  (H K L)  g1 (mm) g2 (mm)   Angle");		break;		case 4:			sprintf(dataLabel,"Zone Axis (H K L)  (H K L)  2Theta1° 2Theta2°  Angle");		break;	}	c2pstr(dataLabel);	inherited::DoHeaderPrint(topRect);}void	AngleTabObj::DoDblClick(Point thePoint){	theCrystalButton->DoDblClick(thePoint);	theCrystalButton2->DoDblClick(thePoint);	return ;}void	AngleTabObj::DoAuxWrite(void){	gTheFile->WriteShort(displayDspace);	gTheFile->WriteFloat(dspace1);	gTheFile->WriteFloat(dspace2);	gTheFile->WriteFloat(range);	gTheFile->WriteFloat(angleRange);	gTheFile->WriteFloat(angle);	inherited::DoAuxWrite();	return;}void	AngleTabObj::DoAuxRead(void){	displayDspace	= gTheFile->ReadShort();	dspace1		= gTheFile->ReadFloat();	dspace2		= gTheFile->ReadFloat();	range		= gTheFile->ReadFloat();	angleRange	= gTheFile->ReadFloat();	angle		= gTheFile->ReadFloat();		inherited::DoAuxRead();	return;}void AngleTabObj::RationalizeData(void){	theTableInfo	= (TableInfoHandle)theDataHandle;	}