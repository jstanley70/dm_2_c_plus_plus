#include	"Diffract_INCs.h"//ects:D.M. v2.0:Sources.Jim:Table Sources:TA_Periodicity_Table.c#include 	"AtomData.h"#include	"a_D_Space.h"#include 	"Periodicity_Table.h"#include 	"JimsLib.h"void		Periodicity_Table::DoInit(void){	inherited::DoInit(); 		data_Length			=	350;	data_Size			=	sizeof(SpotInfo);;	data_Expand			=	25;	SetObjectWindowTitle("Periodicity Table",200,266);	lowPeriod = 1;	highPeriod = 1;	crystalNum2 = 5;	firstPlane = 3;		theListRect = ((GrafPtr)theWindow)->portRect;	theListRect.top += 50;	theListRect.left = 5;	theListRect.right -= 18;	theListRect.bottom -= 5;	numColumns = 3;			theCrystalButton = (CrystalButton*)D_new(CrystalButton);	theCrystalButton->DoInit();	theCrystalButton->Enable();		/*KillMBHandle*/DisposeHandle(theMenuBar);	theMenuBar = GetMenuBar();	DrawMenuBar();	objectType = PERIODICITY_TABLE;/* New 9/10/92*/	if(gTheFile->file_is_Open){		return;	}		DoDefine();}void Periodicity_Table::SetObjectMenu(){	theMenuBar = GetNewMBar(PERIODICITY_TABLE_MB);	ClearMenuBar();/* July 1992 */	SetMenuBar(theMenuBar);}void		Periodicity_Table::DoClose(void){	theCrystalButton->DoClose();	inherited::DoClose();	return;}Boolean		Periodicity_Table::DoContent(Point thePoint){	PenState theState;	GetPenState(&theState);	PenNormal();	theCrystalButton->DoContent(thePoint);		SetPenState(&theState);	return(inherited::DoContent(thePoint));}void			Periodicity_Table::DoIdle(void){		inherited::DoIdle();	return;}#define DEFINE_TABLE 500void		Periodicity_Table::DoMenu(long	theResult){	short	theMenu,theItem;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);		switch(theMenu){		case EDIT_MENU:			switch(theItem){				case CUT:				case COPY:				case PASTE:				case DO_CLEAR:					return;					break;				default:					break;			}			break;		case DEFINE_TABLE:			switch(theItem){				case 1:					// DoDefine();					 DoDefineSetUp();					break;				case 3:					break;				case 4:					break;				case 5:					break;				default:					break;			}								break;		default:			break;	}	inherited::DoMenu(theResult);	return;}void Periodicity_Table::DrawTheText(void){	short top,bottom;			inherited::DrawTheText();	bottom 	= theCrystalButton->theButtonRect.bottom;	top		= theCrystalButton->theButtonRect.top + 1;	theCrystalButton->DrawButtonRect(crystalNum + 10);	MoveTo(theListRect.left +12 ,theListRect.top - 10);	DMForeColor(BLACK);	sprintf(gTheText," UVW  Period   Rad. mm");	c2pstr(gTheText);	DrawString(pTheText);	}void		Periodicity_Table::MyCalculate(void){		short			startU,startV,startW,i,u,v,w;	double 			calcPeriodicity,					firstOrderDist;	Index 			*theZoneAxis;	SpotInfoHandle theSpotData;	SpotInfoPtr 	theSpots,thisSpot;	Boolean 		flag,found;	double			cameraLength;	short			endU,endV,endW;	Boolean			hexFlag;	double 			u1,v1,w1;		if(theDataHandle != (Handle)NUL)		/*Temp*/KillHandle(&theDataHandle);		data_Length			= 350;	theDataHandle		= /*Temp*/D_NewHandle(data_Length * data_Size);//,&gTheOSError	theSpotData			= (SpotInfoHandle)theDataHandle;	/*MFTemp*/D_HLock(theDataHandle);	theSpots 			= *theSpotData;					InitList();	hexFlag = false;	u1 = firstPlane;	if((theCrystal[crystalNum]->lattice_Type == HEXAGONAL)  || (theCrystal[crystalNum]->lattice_Type == TRIGONAL))	{		hexFlag = true;		u1 += 3;	}		startU = -fabs((double)u1);	startV = -fabs((double)u1);	startW = -fabs((double)u1);	endU   	= -startU;	endV	= -startV;	endW	= -startW;	if(theCrystal[crystalNum]->lattice_Type == 0)		theCrystal[crystalNum]->lattice_Type = CUBIC;	switch(theCrystal[crystalNum]->lattice_Type){		case CUBIC:		case TETRAGONAL:		case ORTHORHOMBIC:		case HEXAGONAL:		case TRIGONAL:		case TRIGHEX:			startU = 0;startV = 0;startW = 0;			break;		default:			break;	}	theZoneAxis = (Index*)D_new(Index);	theZoneAxis->DoInit(true,theCrystal[crystalNum]);	data_Count	= 0;	cameraLength = cameraConstant/wavelength;	theZoneAxis->reduceFlag = true;		for(u = endU;u >= startU && gNoBreak;u--){		for(v = endV;v >= startV && gNoBreak;v--){			for(w = endW;w >= startW && gNoBreak;w--){				if(u == 0 && v == 0 && w == 0) continue;				if(hexFlag){					u1 = (double)((2 * u) - v);					v1 = (double)((2 * v) - u);					w1 = (double)(w * 3);					if(u1 == 0. && v1 == 0. && w1 == 0)						continue;					Reduce(&u1,&v1,&w1);					if(fabs(u1) > firstPlane)continue;					if(fabs(v1) > firstPlane)continue;					if(fabs(w1) > firstPlane)continue;										if(fabs(u1 + v1) > firstPlane)continue;				}								flag = false;				theZoneAxis->h = u;				theZoneAxis->k = v;				theZoneAxis->l = w;				i = 0;				theZoneAxis->ReduceIndex();				found = true;				for(i = 0 ; i <	data_Count ; i++){					thisSpot = &(theSpots[i]);					AllowBackground();					if(theZoneAxis->CompareTo(thisSpot->h,thisSpot->k,thisSpot->l)){						found = false;						break;					}				}				flag = true;				AllowBackground();				if(found){					firstOrderDist = theZoneAxis->Periodicity(1, cameraLength, wavelength,&calcPeriodicity);					if(firstOrderDist != 0){						if(data_Count >= data_Length)							ExpandMemory();						thisSpot 				= &(theSpots[data_Count++]);						thisSpot->h				= theZoneAxis->h;						thisSpot->k				= theZoneAxis->k;						thisSpot->l				= theZoneAxis->l;						thisSpot->x				= fabs(firstOrderDist);						thisSpot->direction		= true;						thisSpot->intensity		= calcPeriodicity;						thisSpot->theCrystal	= theZoneAxis->theCrystal;					}				}			}		}	}		theZoneAxis->DoClose();	/*MFTemp*/D_HUnlock(theDataHandle);			if(data_Count > 1) {		i = data_Count;		EliminateHKLRedundancy(&i,theDataHandle);		data_Count = i;		qsort(*theDataHandle,(long)(data_Count),sizeof(SpotInfo),(_compare_function/*__cmp_func_Cmpfun**/)InverseDSpaceCompare);	}		AllowBackground();	DisplayList();	return;}void	Periodicity_Table::SetPict(Boolean eraseFlag){	long totalPeriod;	Boolean	dummy;		dummy = eraseFlag; /* this line suppresses a warning */	SetButton();	TextFont(0);	TextSize(0);	DrawTheText();		InitList();	totalPeriod = (long)(highPeriod - lowPeriod + 1);	LAddRow(data_Count * totalPeriod,0,theList);	gNoBreak = true;				/* allow list to be drawn  */	DisplayList();		newPictReq = false;}void		Periodicity_Table::DisplayList(void){	SpotInfoPtr  dspace;	Index *theIndex;	double 	RofEwaldSphere;	short 	length,i;	double	cameraLength;	Cell	theCell;	GrafPtr	theOldPort;	short	j,k;			theCell.v = -1;	theCell.h = 0;	/*MFTemp*/D_HLock(theDataHandle);	dspace = (SpotInfoPtr)(*theDataHandle);	PenNormal();	RofEwaldSphere = 1. / wavelength;	theIndex = (Index*)D_new(Index);	theIndex->Init(true,theCrystal[crystalNum]);	LDoDraw(false,theList);	j = 0;	cameraLength = cameraConstant / wavelength;	for(i = 0; i < data_Count && gNoBreak;i++)	{		double theValue;		AllowBackground();		theIndex->CopyPtrToIndex((Ptr)&(dspace[i]));		theValue = dspace[i].x;		theIndex->ReduceIndex();		theIndex->reduceFlag = false;		for(k = lowPeriod;k <= highPeriod;k++){			double diameter;						theCell.v = j;			theCell.h = 0;			theIndex->h *= k;			theIndex->k *= k;			theIndex->l *= k;			theIndex->SetListIndecies(theList,theCell);			theIndex->h /= k;			theIndex->k /= k;			theIndex->l /= k;			length = sprintf(gTheText,"%6.3f",theValue/k);			theCell.h = 1;			LSetCell(gTheText,length,theCell,theList);			diameter 		= 	2 * cameraLength * tan(acos(1 - ((double)k * wavelength /  theValue)));			length = sprintf(gTheText,"%7.1f",diameter);			theCell.h = 2;			LSetCell(gTheText,length,theCell,theList);			j++;		}	}		GetPort			(&theOldPort);	SetPort			(theWindow);	LDoDraw			(true,theList);	theIndex	->	DoClose();	/*MFTemp*/D_HUnlock		(theDataHandle);	DMForeColor		(10 + crystalNum);	DMBackColor		(BACKGROUND_COLOR);	DrawTheText		();	DMForeColor		(10 + crystalNum);	DMBackColor		(BACKGROUND_COLOR);	InvalRgn		(theWindow->visRgn);	LUpdate			(theWindow->visRgn,theList); 	TextFont		(0);	TextSize		(0);	SetPort			(theOldPort);	newPictReq 		= 	true;	return;}void		Periodicity_Table::DoPrint(void){	inherited::DoPrint();	return;}void			Periodicity_Table::DoKey(char	theChar){	inherited::DoKey(theChar);	return;}void			Periodicity_Table::DoRefresh(void){	inherited::DoRefresh();		return;}void	Periodicity_Table::DoHeaderPrint(Rect *topRect){	sprintf(tabelTitle,"Periodicity Table");	c2pstr(tabelTitle);	sprintf(dataLabel," [UVW] Periodicity  Rad. mm");	c2pstr(dataLabel);	inherited::DoHeaderPrint(topRect);}void	Periodicity_Table::DoDblClick(Point thePoint){	theCrystalButton->DoDblClick(thePoint);	return ;}void	Periodicity_Table::DoAuxWrite(void){	gTheFile->WriteShort(firstPlane);	gTheFile->WriteShort(lowPeriod);	gTheFile->WriteShort(highPeriod);	inherited::DoAuxWrite();	return;}void	Periodicity_Table::DoAuxRead(void){	firstPlane	= gTheFile->ReadShort();	lowPeriod	= gTheFile->ReadShort();	highPeriod	= gTheFile->ReadShort();		inherited::DoAuxRead();	return;}void Periodicity_Table::RationalizeData(void){		SpotInfoPtr	thePlane;	short i;			thePlane	= (SpotInfoPtr)(*theDataHandle);	/* reconnect crystals */	for(i = 0 ; i < data_Count ; i++, thePlane++){		thePlane->theCrystal = theCrystal[crystalNum];	}	}void Periodicity_Table::SetButton(void){	short 		width;	Rect		theRect;			width = StringWidth("\pCrystal 1");	(theCrystalButton)->SetOwner((Ptr)theCrystal[crystalNum]);	SetRect(&theRect,6,6,width + 11,20);	sprintf(gTheText,"Crystal %d",crystalNum + 1);	theCrystalButton->SetButtonRect(theRect);	theCrystalButton->SetName(gTheText);	theCrystalButton->Enable();	}