#include	"Diffract_INCs.h"//rces.Jim:Table Sources:TA_AngleBetDirObj.c#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"AngleBetDirObj.h"#include 	"AtomData.h"typedef	struct	AngleData{					short	h;					short	k;					short	l;					double	angle;				}AngleData,*AngleDataPtr,**AngleDataHandle;				short	AngleSortProc(AngleData* item1,AngleData* item2);void		AngleBetDirObj::DoInit(void){	inherited::DoInit();			SetObjectWindowTitle("Angle Bet. Directions",180,266);	SetPort(theWindow); 	refDir = (Index*)D_new(Index);	refDir->Init(true,theCrystal[crystalNum]);	refDir->h = 1;	refDir->k = 0;	refDir->l = 0;		dirRange = 3;		theListRect 			= ((GrafPtr)theWindow)->portRect;	theListRect.top 		+= 	52;	theListRect.left 		= 	5;	theListRect.right 		-= 18;	theListRect.bottom 		-= 	5;	theVisRect 				= 	theWindow->portRect;	RectRgn						(picUpdateRgn,&theVisRect);	RectRgn						(drawRgn,&theVisRect);	SetRect						(&thePictRect,0,0,theWindow->portRect.right,50);	angle = 90;	angleRange = 2;		theCrystalButton 	= 	(CrystalButton*)D_new(CrystalButton);	theCrystalButton	->	DoInit();	numColumns 			= 	2;	theCrystalButton2 	= 	(CrystalButton*)D_new(CrystalButton);	theCrystalButton2	->	DoInit();		/*KillMBHandle*/DisposeHandle				(theMenuBar);	theMenuBar 			= 	GetMenuBar();	DrawMenuBar				();	if(gTheFile->file_is_Open){		return;	}		objectType = ANGLE_DIR_TABLE;/* New 9/10/92*/	DoDefine();		return;}void AngleBetDirObj::SetButton(void){	Rect theRect;	short width;	short left;		TextFont	(monaco);	TextSize	(9);	width 		= StringWidth("\pCrystal 1");	(theCrystalButton)->SetOwner((Ptr)theCrystal[crystalNum]);	left		 = 	6;	SetRect			(&theRect,left,6,width + 5 + left,20);		sprintf			(gTheText,"Crystal %d",crystalNum + 1);		theCrystalButton->SetButtonRect(theRect);	theCrystalButton->SetName(gTheText);	theCrystalButton->Enable();		(theCrystalButton2)->SetOwner((Ptr)theCrystal[crystalNum2]);	left 		+= 	width + 11;	SetRect			(&theRect,left,6,width + 5 + left,20);	sprintf			(gTheText,"Crystal %d",crystalNum2 + 1);	theCrystalButton2->SetButtonRect(theRect);	theCrystalButton2->SetName(gTheText);	theCrystalButton2->Enable();}void AngleBetDirObj::SetObjectMenu(){	theMenuBar = GetNewMBar(TABLE_MB);	ClearMenuBar();/* July 1992 */	SetMenuBar(theMenuBar);}void		AngleBetDirObj::DoClose(void){	theCrystalButton->DoClose();	theCrystalButton2->DoClose();	refDir->DoClose();	inherited::DoClose();	return;}Boolean		AngleBetDirObj::DoContent(Point thePoint){	PenState theState;	GetPenState(&theState);	PenNormal();	theCrystalButton->DoContent(thePoint);	theCrystalButton2->DoContent(thePoint);		SetPenState(&theState);	return(inherited::DoContent(thePoint));}void			AngleBetDirObj::DoIdle(void){		inherited::DoIdle();	return;}#define DEFINE_TABLE 500void		AngleBetDirObj::DoMenu(long	theResult){	short	theMenu,theItem;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);		switch(theMenu){		case EDIT_MENU:			switch(theItem){				case CUT:				case COPY:				case PASTE:				case DO_CLEAR:					return;					break;				default:					break;			}			break;		case DEFINE_TABLE:			switch(theItem){				case 1:				//DoDefine();				DoDefineSetUp();				break;				default:					break;			}								break;		default:			break;	}	inherited::DoMenu(theResult);	return;}void AngleBetDirObj::DrawTheText(void){	Point thePoint;		inherited::DrawTheText();		theCrystalButton	->	DrawButtonRect(crystalNum + 10);	theCrystalButton2	->	DrawButtonRect(crystalNum2 + 10);	thePoint.h			= 	theCrystalButton2->theButtonRect.right + 10;	thePoint.v 			= 	theCrystalButton2->theButtonRect.bottom - 2;	TextFont(0);	TextSize(12);	refDir		->		ShowIndex(thePoint);	MoveTo				(theListRect.left + 10,theListRect.top - 10);	TextFont			(0);	TextSize			(12);	sprintf				(gTheText," uvw     angle");	DMForeColor			(BLACK);	DrawString			(c2pstr(gTheText));}void		AngleBetDirObj::MyCalculate(void){		short				h,k,l,i = 0;		Index				*theIndex;	short 				latticeType1,latticeType2;	double				testAngle,lowAngle,highAngle,maxRec,zh,zk,zl;	Boolean 			flag;	AngleDataHandle		theAngleData;	AngleDataPtr		theInfo;	short				endU,endV,endW;	short				startU,startV,startW;	double				u1,v1,w1;	Boolean				hexFlag;					if(theDataHandle != (Handle)NUL)		/*Temp*/KillHandle(&theDataHandle);	data_Expand		= 50;	data_Length 	= 100;	data_Count		= 0;	data_Size		= sizeof(AngleData);	theDataHandle 	= /*Temp*/D_NewHandle((long)(data_Length * data_Size));//,&i	if(i != 0 || theDataHandle == (Handle)NUL)		return;	/*MFTemp*/D_HLock(theDataHandle);	theAngleData	= (AngleDataHandle)theDataHandle;		theIndex = (Index*)D_new(Index);	theIndex->Init(true,theCrystal[crystalNum2]);		latticeType1 	= theCrystal[crystalNum]->lattice_Type;	latticeType2 	= theCrystal[crystalNum2]->lattice_Type;	numEntries 		= 0;	highAngle 		= angle + angleRange;	lowAngle 		= angle - angleRange;	maxRec			= (32700 / 18 ) - 2;		if(theCrystal[crystalNum]->lattice_Type == HEXAGONAL || theCrystal[crystalNum]->lattice_Type == TRIGONAL){		hexFlag = true;		u1 = dirRange + 3;	} else {		hexFlag = false;		u1 = dirRange;	}				startU = u1;	startV = u1;	startW = u1;	endU   	= -startU;	endV	= -startV;	endW	= -startW;		for(theIndex->h = startU; theIndex->h >= endU && gNoBreak;theIndex->h--){		for(theIndex->k = startV; theIndex->k >= endV && gNoBreak;theIndex->k--){			for(theIndex->l = startW; theIndex->l >= endW && gNoBreak;theIndex->l--){				if(theIndex->h == 0 && theIndex->k == 0 && theIndex->l == 0)					continue;				if(hexFlag){/*added dec 1992 by jim to accomodate true hex directions*/					u1 = (double)((2 * theIndex->h) - theIndex->k);					v1 = (double)((2 * theIndex->k) - theIndex->h);					w1 = (double)(theIndex->l * 3);					if(u1 == 0. && v1 == 0. && w1 == 0)						continue;					Reduce(&u1,&v1,&w1);					if(fabs(u1) > dirRange)continue;					if(fabs(v1) > dirRange)continue;					if(fabs(w1) > dirRange)continue;										if(fabs(u1 + v1) > dirRange)continue;									}				AllowBackground();								testAngle = theIndex->GetTheAngle(refDir);								if(testAngle < lowAngle || testAngle > highAngle)					continue;							zh		= theIndex->h;				zk		= theIndex->k;				zl		= theIndex->l;								Reduce(&zh,&zk,&zl);								h		= (short)zh;				k		= (short)zk;				l		= (short)zl;								flag	= true;												theInfo = *theAngleData;				for(i = 0 ; i < data_Count ; i++ , theInfo++){					if(h == theInfo->h && k == theInfo->k && l == theInfo->l){						flag = false;						break;					}				}								if(flag){					theInfo->h		= h;						theInfo->k		= k;					theInfo->l		= l;					theInfo->angle	= testAngle;										if(data_Count >= maxRec){						gNoBreak = false;						goto STOP;					}					data_Count++;					ExpandMemory();				}			}		}	}	STOP: 	if(!gNoBreak){		WarnUser(2);	}	gNoBreak = true;  /* allows list to be drawn */	if(data_Length >  data_Count){		D_RecoverMemory		(theDataHandle,data_Size,(long)data_Count);	}	data_Length 	= 	data_Count;			/*MFTemp*/D_HUnlock(theDataHandle);		theIndex->DoClose();		return;}void		AngleBetDirObj::DisplayList(void){	AngleDataHandle		theAngleData;	AngleDataPtr		theInfo;	Cell				theCell;	short				i;	Index				*theIndex;	double				length;		theIndex = (Index*)D_new(Index);	theIndex->Init(true,theCrystal[crystalNum2]);		theAngleData	= (AngleDataHandle)theDataHandle;	theCell.h = theCell.v = 0;		/*MFTemp*/D_HLock(theDataHandle);	theInfo = *theAngleData;	qsort(theInfo,data_Count,sizeof(AngleData),(_compare_function/*__cmp_func_Cmpfun**/)AngleSortProc);	TextSize(0);	TextFont(0);					for(i = 0 ; i < data_Count && gNoBreak; i++ , theInfo++ , theCell.v++){			theIndex->h = theInfo->h;		theIndex->k = theInfo->k;		theIndex->l = theInfo->l;		theCell.h 	= 0;		theIndex->SetListIndecies(theList,theCell);		theCell.h 	= 1;		length 		= sprintf(gTheText,"%6.2f ¥",theInfo->angle);		LSetCell(gTheText,length,theCell,theList);		AllowBackground();	}			/*MFTemp*/D_HUnlock(theDataHandle);	numEntries = 0;	theIndex->DoClose();	if(!gNoBreak){		gNoBreak = true;		SysBeep(10);	}	newPictReq = true;	return;}void		AngleBetDirObj::DoPrint(void){	inherited::DoPrint();	return;}void			AngleBetDirObj::DoKey(char	theChar){	inherited::DoKey(theChar);	return;}void			AngleBetDirObj::DoRefresh(void){	inherited::DoRefresh();	return;}void	AngleBetDirObj::DoDblClick(Point thePoint){	theCrystalButton->DoDblClick(thePoint);	theCrystalButton2->DoDblClick(thePoint);	return ;}void	AngleBetDirObj::DoHeaderPrint(Rect *topRect){	refDir		->	IndexToText(gTheText);	p2cstr			((unsigned char*)gTheText);	sprintf			(tabelTitle,"Table of Angles Between Directions & [");	strcat			(tabelTitle,gTheText);	strcat			(tabelTitle,"]");	c2pstr			(tabelTitle);	sprintf			(dataLabel,"[UVW]   Angle (¡)");	c2pstr			(dataLabel);	inherited::DoHeaderPrint(topRect);}short	AngleSortProc(AngleData* n1,AngleData* n2){	short	value;	value = ((n1->angle < n2->angle) ? -1 : ((n1->angle > n2->angle) ? 1 : 0));	if(value == 0){		value = ((abs(n1->h) < abs(n2->h)) ? -1 : ((abs(n1->h) > abs(n2->h)) ? 1 : 0));		if(value == 0){			value = ((abs(n1->k) < abs(n2->k)) ? -1 : ((abs(n1->k) > abs(n2->k)) ? 1 : 0));			if(value == 0){				value = ((abs(n1->l) < abs(n2->l)) ? -1 : ((abs(n1->l) > abs(n2->l)) ? 1 : 0));				if(value == 0){					value = ((abs(n1->h) < abs(n2->h)) ? -1 : ((abs(n1->h) > abs(n2->h)) ? 1 : 0));					if(value == 0){						value = ((n1->k < n2->k) ? -1 : ((n1->k > n2->k) ? 1 : 0));						if(value == 0){							value = ((n1->l < n2->l) ? -1 : ((n1->l > n2->l) ? 1 : 0));						}					}				}			}		}	}	return(value);}void	AngleBetDirObj::DoAuxWrite(void){	refDir->WriteIndex();	gTheFile->WriteShort(dirRange);	gTheFile->WriteFloat(angleRange);	gTheFile->WriteFloat(angle);	inherited::DoAuxWrite();	return;}void	AngleBetDirObj::DoAuxRead(void){	refDir->ReadIndex(theCrystal);	dirRange	= gTheFile->ReadShort();	angleRange		= gTheFile->ReadFloat();	angle		= gTheFile->ReadFloat();		inherited::DoAuxRead();	refDir->theCrystal = theCrystal[crystalNum];	return;}