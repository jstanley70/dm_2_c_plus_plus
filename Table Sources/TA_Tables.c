//ects:D.M. v2.0:Sources.Jim:Table Sources:TA_Tables.c#include	"Diffract_INCs.h"#include	"a_Table.h"#include 	"JimsLib.h"char* 	ConvertDMTextToRegular(char*  theText);void				Table::DoInit(void){	MenuHandle	theMenuHandle;		variSize 			= false;	valid 				= false;	rulerHeight			= 0;	numEntries			= 0;	PenNormal();		data_Size			= sizeof(SpotInfo);		inherited::DoInit();	data_Size			= sizeof(SpotInfo);	selectRectEnable	= false;	theMenuHandle = GetMHandle(FILE_MENU);			EnableItem(theMenuHandle,EXPORT);		PenNormal();	crystalNum = crystalNum2 = 0;	return;}void	Table::SetObjectWindowTitle(char* title,short hSize,short vSize){	MenuHandle	theMenu;	strcpy((char*)fileInfo.sfFile.name,title);	c2pstr((char*)fileInfo.sfFile.name);	SetWTitle(theWindow,fileInfo.sfFile.name);	SizeWindow(theWindow,hSize,vSize,false);	DoResize();	 	crystalNum	= numEntries = numColumns = 0;	crystalType = theCrystal[crystalNum]->lattice_Type;	theList = (ListHandle)NUL;	theListRect = ((GrafPtr)theWindow)->portRect;	SetRect(&thePictRect,0,0,theWindow->portRect.right,50);	sortMethod = 1;	theListRect.top += 100;	theListRect.left = 5;	theListRect.right -= 18;	theListRect.bottom -= 5;		theMenu = GetMHandle(500);	switch(objectType){		case 503:			DisableItem(theMenu,3);			DisableItem(theMenu,4);			DisableItem(theMenu,5);			EnableItem(theMenu,7);			EnableItem(theMenu,8);			EnableItem(theMenu,9);			EnableItem(theMenu,10);			break;		case 502:		case 505:		case 504:			DisableItem(theMenu,3);			DisableItem(theMenu,4);			DisableItem(theMenu,5);			DisableItem(theMenu,7);			DisableItem(theMenu,8);			DisableItem(theMenu,9);			DisableItem(theMenu,10);			break;		default:			EnableItem(theMenu,3);			EnableItem(theMenu,4);			EnableItem(theMenu,5);			EnableItem(theMenu,7);			EnableItem(theMenu,8);			EnableItem(theMenu,9);			EnableItem(theMenu,10);			break;	}		ShowWindow(theWindow);}void				Table::DoClose(void){		if(numColumns != 0)		KillList();	inherited::DoClose();	return;}Boolean				Table::DoContent(Point	thePoint){	Rect	theRect;				theRect = theListRect;	theRect.right += 20;	TextFont(1124);	TextSize(12);	if(theList != 0L){		if(PtInRect(thePoint,&theRect)){			LClick(thePoint,gTheEvent.modifiers,theList);			return true;		}	}	return(inherited::DoContent(thePoint));}void			Table::DoIdle(void){	inherited::DoIdle();	return;}void		Table::DoMenu(long	theResult){	short 		theMenu,theItem;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);	SetTheCursor(0);	switch(theMenu){ 		case 	FILE_MENU:		switch(theItem){			case EXPORT:				WriteDataToText();				return;		}	}	inherited::DoMenu(theResult);	return;}void			Table::DoResize(void)				/*  Resize Object	Window			*/{	Rect	theRect;		theVisRect = theWindow->portRect;	rulerRect			=	theVisRect;	RectRgn(picUpdateRgn,&theVisRect);	RectRgn(drawRgn,&theVisRect);			InvalTheRect(&theVisRect);	/*************** set Grow Box for redraw **************/	theRect			= theWindow->portRect;	theRect.top 	= theRect.bottom - 15;	theRect.left 	= theRect.right - 15;		InvalRect(&theRect);	}void				Table::InitList(void){	FontInfo 	theFont;	short		textHeight;	Point		cellSize;	Rect		rBounds,theRect;	short		n;	KillList();	GetFontInfo(&theFont);		textHeight 	= theFont.ascent 						+ theFont.descent 						+ theFont.leading;	dm_EraseRect(&theListRect);	theRect = theListRect;	if(numEntries < 0){		numEntries = (-numEntries);	} else {		numEntries = 0;	}	SetRect(&rBounds,0,0,numColumns,numEntries);	cellSize.h = 55;	cellSize.v = textHeight;	n = (theRect.bottom - theRect.top) / cellSize.h;	theRect.bottom = theRect.top + n * cellSize.h;	theList = LNew(&theListRect,&rBounds,cellSize,0,theWindow,true,false,false,true);	(*theList)->selFlags = 0x80;	return;}void				Table::KillList(void){	if((long)theList != NUL){		LDispose(theList);		theList = (ListHandle)NUL;	}	return;}void				Table::DoPrint(void){	TPPrPort 	thePrintPort;	GrafPtr 	oldPort;	short 		theTop = 20,theLeft = 20;	TPrStatus 	theStatus;	Rect 		pageRect;	PrOpen();	printing = true;		GetPort(&oldPort);//	gPrintRecHandle = (THPrint)GetResource('PREC',(short)1000);	if(!gPrintRecHandle) gPrintRecHandle = (THPrint)GetResource('PREC',(short)1000);		if(GetHandleSize((Handle)gPrintRecHandle) != sizeof(TPrint)){		SetHandleSize((Handle)gPrintRecHandle,sizeof(TPrint));		ChangedResource((Handle)gPrintRecHandle);		WriteResource((Handle)gPrintRecHandle);	}	pageRect 		= (*gPrintRecHandle)->prInfo.rPage;			if(!PrJobDialog(gPrintRecHandle)){		SetPort(oldPort);	//	ReleaseResource((Handle)gPrintRecHandle);	PrClose();		return;	}	thePrintPort = PrOpenDoc(gPrintRecHandle,0L,0L);		PrOpenPage	(thePrintPort,0L);		SetPort		((GrafPtr)thePrintPort);		DoPrintPict	(pageRect,thePrintPort);	PrClosePage	(thePrintPort);	PrCloseDoc	(thePrintPort);		if((*gPrintRecHandle)->prJob.bJDocLoop == bSpoolLoop){		PrPicFile(gPrintRecHandle,0L,0L,0L,&theStatus);	}		//ReleaseResource((Handle)gPrintRecHandle);		SetPort(oldPort);	printing = false;	PrClose();	return;}void Table::DoPrintPict(Rect pageRect,TPPrPort thePrintPort){	Cell 		theCell;	short 		dataLen;		short 		theTop = 20,theLeft = 20,i,k,cntr,pNum;	short 		length;	short 		startTop;	Rect 		topRect;	short 		oldDateLen;	short 		maxColumns;	short 		stringWidth,noOfPrintColumns;	char 		theText[255];	short 		charHeigth = 12;	if(theList == 0L)return;	PenNormal	();	TextFont	(times); 	TextSize	(9);		oldDateLen 		= 	10 * sizeof(char);	topRect 		= 	pageRect;	topRect.bottom 	= 	150;	DoHeaderPrint		(&topRect);	dm_FrameRect			(&pageRect);	noOfPrintColumns = 	0;	startTop 		= 	topRect.bottom + 20;	theCell.v 		= 	0;	gTheText[0] 	= 	NUL;	for(k = 0; k <= numColumns - 1;k++){		dataLen 	= 	oldDateLen;		theCell.h 	= 	k;		LGetCell		((Ptr)theText,&dataLen,theCell,theList); 		length 		= 	dataLen / (sizeof(char));		theText[length + 1] = NUL;		strcat			(gTheText,theText);		strcat			(gTheText,"    ");	}	stringWidth 	= 	StringWidth(c2pstr(gTheText));	stringWidth 	+= 	5;	maxColumns 		= 	(pageRect.right - pageRect.left - theLeft) / stringWidth;	noOfPrintColumns = 1;	theTop 			= 	startTop;		pNum 		= 	1;	MoveTo			(theLeft - 15,topRect.bottom - 10);	DrawString		((unsigned char*)dataLabel);	sprintf			(gTheText,"Page #%2d",pNum++);	cntr 		= 	(pageRect.right + pageRect.left - StringWidth(c2pstr(gTheText))) / 2;	MoveTo			(cntr,pageRect.bottom - 4);	DrawString		(pTheText);			for(i = 0; i < data_Count;i++){		theCell.v 	= 	i;		gTheText[0] = 	NUL;		for(k = 0; k < numColumns ;k++){			dataLen = 	oldDateLen;			theCell.h = k;			LGetCell	((Ptr)theText,&dataLen,theCell,theList); 			length 	= 	dataLen/(sizeof(char));			theText[length] = NUL;			strcat(gTheText,theText);			strcat(gTheText,"    ");		}		MoveTo			(theLeft,theTop);		c2pstr			(gTheText);		DrawTheString	(gTheText);		theTop 	+= 		charHeigth;		if(theTop >= pageRect.bottom - 20){			theTop = startTop;			if(++noOfPrintColumns > maxColumns){				PrClosePage	(thePrintPort);				PrOpenPage	(thePrintPort,0L);								noOfPrintColumns 	= 1;				theLeft 			= 20;				DoHeaderPrint			(&topRect);				dm_FrameRect				(&pageRect);				sprintf					(gTheText,"Page #%2d",pNum++);				cntr = (pageRect.right + pageRect.left - StringWidth(c2pstr(gTheText))) / 2;				MoveTo					(cntr,pageRect.bottom - 4);				DrawString				(pTheText);			} else {				theLeft += stringWidth;			}			MoveTo(theLeft - 15,topRect.bottom - 10);			DrawString((unsigned char*)dataLabel);		}	}	TextFont(0); 	TextSize(0);}void			Table::DoKey(char	theChar){	inherited::DoKey(theChar);	return;}void	Table::DoHeaderPrint(Rect *theRect){	short theTop = 16,theLeft = 8,i;	Rect	topRect;		topRect = *theRect;	i = (topRect.right + topRect.left - StringWidth((unsigned char*)tabelTitle)) / 2;	MoveTo(i,theTop);	DrawDiffractString((unsigned char*)tabelTitle);		InsetRect(&topRect,3,3);	dm_FrameRect(&topRect);		theTop += 25;		theLeft = topRect.left + 2;	theCrystal[crystalNum]->TableDisplayCrystal(&theLeft,&theTop);}void			Table::FastPictDraw(void){}void			Table::D_DrawPict(void){}void			Table::DoRefresh(void){	GrafPtr	theOldPort;	Rect	drawRect;		GetPort(&theOldPort);	SetPort(theWindow);	DMBackColor(BACKGROUND_COLOR);	drawRect = theWindow->portRect;	drawRect.top = thePictRect.bottom;	DrawTheText();	InvalRect(&drawRect);	dm_EraseRect(&drawRect); 	inherited::DoRefresh();	TextFont(1124);	TextSize(12);	DMForeColor(10 + crystalNum);	DMBackColor(BACKGROUND_COLOR);		if(theList != 0L)		LUpdate(theWindow->visRgn,theList); 		TextFont(1124);	TextSize(12); 		if(theWindow == FrontWindow()){		MenuHandle	theMenu;				theMenu = GetMHandle(500);		switch(objectType){		case 503:			DisableItem(theMenu,3);			DisableItem(theMenu,4);			DisableItem(theMenu,5);			EnableItem(theMenu,7);			EnableItem(theMenu,8);			EnableItem(theMenu,9);			EnableItem(theMenu,10);			break;		case 502:		case 505:		case 504:			DisableItem(theMenu,3);			DisableItem(theMenu,4);			DisableItem(theMenu,5);			DisableItem(theMenu,7);			DisableItem(theMenu,8);			DisableItem(theMenu,9);			DisableItem(theMenu,10);			break;		default:			EnableItem(theMenu,3);			EnableItem(theMenu,4);			EnableItem(theMenu,5);			EnableItem(theMenu,7);			EnableItem(theMenu,8);			EnableItem(theMenu,9);			EnableItem(theMenu,10);			break;	}			DrawMenuBar();	}		SetPort(theOldPort);		return;}void			Table::DrawTheText(void){	Rect	theRect;		D_SetClip(gUpdateAll);	DMBackColor(BACKGROUND_COLOR);	theRect = thePictRect;	InsetRect(&theRect,2,2);	DMForeColor(0);	dm_PaintRect(&theRect);	DMForeColor(10 + crystalNum2);	theRect.bottom -= 1;	theRect.right  -= 1;	dm_FrameRect(&theRect);	MoveTo(theRect.left + 1,theRect.bottom);	LineTo(theRect.right,theRect.bottom);	LineTo(theRect.right,theRect.top + 1);	DMForeColor(10 + crystalNum);}void			Table::DrawTheString(char*	theText){	Point 		penPt,lastPt;	short		length,i,y;	char		*theChar;	FontInfo	fInfo;	Boolean		drawFlag;		GetFontInfo(&fInfo);	y = fInfo.ascent + fInfo.leading;	theChar = (char*)theText;	length = (short)*theChar++;	for(i = 1 ; i <= length ; i++,theChar++){		GetPen(&lastPt);		switch(*theChar){			case (char)0xDA:				DrawChar('1');				GetPen(&penPt);				drawFlag = true;				break;			case (char)0xDB:				DrawChar('2');				GetPen(&penPt);				drawFlag = true;				break;			case (char)0xDC:				DrawChar('3');				GetPen(&penPt);				drawFlag = true;				break;			case (char)0xDD:				DrawChar('4');				GetPen(&penPt);				drawFlag = true;				break;			case (char)0xDE:				DrawChar('5');				GetPen(&penPt);				drawFlag = true;				break;			case (char)0xDF:				DrawChar('6');				GetPen(&penPt);				drawFlag = true;				break;			case (char)0xE0:				DrawChar('7');				GetPen(&penPt);				drawFlag = true;				break;			case (char)0xF5:				DrawChar('8');				GetPen(&penPt);				drawFlag = true;				break;			case (char)0xE1:				DrawChar('9');				GetPen(&penPt);				drawFlag = true;				break;			default:				DrawChar(*theChar);				drawFlag = false;				break;		}		if(drawFlag){			lastPt.v -= y;			Move(-2,-y);			LineTo(lastPt.h,lastPt.v);			MoveTo(penPt.h,penPt.v);		}	}}void			Table::DoAuxRead(void){	valid = true;	newPictReq = true;	gNoBreak = true;				/* allow list to be drawn  */	}	void	Table::SetPict(Boolean eraseFlag){	Boolean dummy;		dummy = eraseFlag; /* This line suppresses a warning */	SetButton();	TextFont(1124);	TextSize(12);	DrawTheText();	InitList();	if(data_Count <= 0){		LAddRow(1,0,theList);	}else{		LAddRow(data_Count,0,theList);	}	gNoBreak = true;				/* allow list to be drawn  */	DisplayList();		newPictReq = false;}void Table::DisplayList(void){}void Table::SetButton(void){}void Table::RationalizeData(void){}void Table::WriteDataToText(void){	Cell	theCell;	short 	i,k,length;	long	totalChar = 500,actual = 0;	char	**theText;	char	*aText,*newText;	char	tab[3],ret[3];	if(theList == 0L) return;	GetWTitle(theWindow,gTheFile->theFileInfo.sfFile.name);		gTheFile->SaveFileOpen('TEXT');	if(!gTheFile->file_is_Open) return;		theText	=	(char**)D_NewHandle(totalChar * sizeof(char));	D_HLock((Handle)theText);	aText	= *theText;	aText[0] = 0;	sprintf(tab,"\t");	sprintf(ret,"\r");	for(i = 0; i < data_Count;i++)	{		theCell.v = i;		for(k = 0;k < numColumns;k++)		{			theCell.h = k;			length = 20;			LGetCell(&(gTheText[1]),&length,theCell,theList);			gTheText[length + 1] = 0;			actual	+=	length + 1;			if(!CheckHandleSize((Handle)theText,&totalChar,actual,sizeof(char)))continue;			aText = *theText;			strcat(aText,&gTheText[1]);			strcat(aText,tab);		}		actual	+=	1;		if(!CheckHandleSize((Handle)theText,&totalChar,actual,sizeof(char)))continue;		aText = *theText;		strcat(aText,ret);	}	newText =  	ConvertDMTextToRegular(aText);	gTheFile->WriteTextPtr((Ptr)newText);	KillPtr(newText);	gTheFile->DoFileClose();	D_HUnlock((Handle)theText);	KillHandle((Handle*)&theText);}char* 	ConvertDMTextToRegular(char*  theText){	unsigned short	length,newLength;	unsigned char		*theChar;	char						*newText;	short						i,j;	length = strlen(theText);	theChar = (unsigned char*)theText;	newLength = length;	for(i = 0 ; i < length ; i++,theChar++){		switch((char)(*theChar)){			case (char)0xDA:			case (char)0xDB:			case (char)0xDC:			case (char)0xDD:			case (char)0xDE:			case (char)0xDF:			case (char)0xE0:			case (char)0xF5:			case (char)0xE1:				newLength++;				break;			default:				break;		}			}	newText = D_NewPtr(sizeof(char) * newLength);	theChar = (unsigned char*)theText;	for(i = 0,j = 0 ; i < length ; i++,theChar++,j++){		switch((char)(*theChar)){			case (char)0xDA:				newText[j++] = '-';				newText[j] = '1';				break;			case (char)0xDB:				newText[j++] = '-';				newText[j] = '2';				break;			case (char)0xDC:				newText[j++] = '-';				newText[j] = '3';				break;			case (char)0xDD:				newText[j++] = '-';				newText[j] = '4';				break;			case (char)0xDE:				newText[j++] = '-';				newText[j] = '5';				break;			case (char)0xDF:				newText[j++] = '-';				newText[j] = '6';				break;			case (char)0xE0:				newText[j++] = '-';				newText[j] = '7';				break;			case (char)0xF5:				newText[j++] = '-';				newText[j] = '8';				break;			case (char)0xE1:				newText[j++] = '-';				newText[j] = '9';				break;			default:				newText[j] = theText[i];				break;		}			}	return newText;}		 void Table::ListOrientation(void) { } void Table::UpdateOR(short axis) { 	axis = axis; } void Table::DoARotation(double angle,short axis) { 	angle = angle; 	axis = axis; }