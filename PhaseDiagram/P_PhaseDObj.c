#include	"Diffract_INCs.h"#include	"PhaseDObj.h"#include	"Dir_Paths.h"short	DgRead(Ptr theData,short refnum,long dataLength);FontRec **gSymbolFont,**gGenevaFont,**gGenevaSmallFont;void				PhaseDiagram::DoInit(void){	FSSpec		theFSSpec;	short		err;		err				= GetDirPath(SEARCH_PHASED,&theFSSpec);	strcpy((char*)theFSSpec.name,"PhaseDiagrams");	c2pstr((char*)theFSSpec.name);	resFileID 			= FSpOpenResFile(&theFSSpec,fsRdPerm);		variSize 			= true;	hideLabels			= false;	rulerHeight		= 0;			inherited::DoInit();	if(theTextSystem)theTextSystem->DoClose();	theTextSystem = (TheTextSystem*)0L;				//ResetBackgroundColor();		SetObjectWindowTitle();	theFrame = theWindow->portRect;	InsetRect(&theFrame,40,40);	theFrame.top += 40;	theFrame.bottom -= 20;	theFrame.right -= 30;	theFrame.left += 55;	SetRect(&tempControl,2,theFrame.bottom - 6,14,theFrame.bottom + 6);	SetRect(&compControl,theFrame.right - 6,30,theFrame.right + 6,42);	SetRect(&loComp,-1,-1,-1,-1);	SetRect(&hiComp,-1,-1,-1,-1);	theSnapInfo = (SnapInfo*)D_new(SnapInfo);/*dec 1992*/	theSnapInfo->DoInit();		/*KillMBHandle*/DisposeHandle(theMenuBar);	theMenuBar = GetMenuBar();	DrawMenuBar();		DoDefine();	if(newPictReq){		DoNewSize();	}else{		CloseTheObject(theWindow);	}	}void		PhaseDiagram::SetObjectMenu(void){	theMenuBar 		= GetNewMBar(PHASED_OBJ_MB);	ClearMenuBar();/* July 1992 */	SetMenuBar(theMenuBar);}void PhaseDiagram::FinishMenuSetUp(void){	MenuHandle	theMenu;	theMenu = GetMHandle(FILE_MENU);	DisableItem(theMenu,3);	DisableItem(theMenu,6);	DisableItem(theMenu,7);		theMenu = GetMHandle(EDIT_MENU);	DisableItem(theMenu,1);	DisableItem(theMenu,3);/*	DisableItem(theMenu,4);	DisableItem(theMenu,5);	DisableItem(theMenu,10);*/	DisableItem(theMenu,6);	DisableItem(theMenu,7);}void	PhaseDiagram::SetObjectWindowTitle(void){	fileInfo.sfType = DIF_OBJ;	if(gTheFile->file_is_Open){		SetWTitle(theWindow,fileInfo.sfFile.name);		return;	}	sprintf(gTheText,"Phase Diagram %d",g_Window_Number);	SetWTitle(theWindow,c2pstr(gTheText));	g_Window_Number++;	}void		PhaseDiagram::DoDefine(void){	DialogPtr		theDialog;	short			theSelect,atNum,i,j,element1,element2;	Boolean			quit = false,first,cancel = false;	Rect			baseRect,dgramRect;	Point			thePoint;	Boolean			found[108];	PDFileInfoPtr	theFoundDiagrams;			theFoundDiagrams	= FileSearch();			theDialog = DM_GetNewDialog(PHASED_OBJ_MB,NUL,IN_FRONT);		GetDItem(theDialog,3,&gType,&gTheHandle,&dgramRect);	baseRect.left		= dgramRect.left + 1;	baseRect.top		= dgramRect.top + 10;	baseRect.right		= dgramRect.left + 25;	baseRect.bottom		= dgramRect.top + 33;	for(i = 0 ; i <= 106 ; i++){		found[i] = false;	}	first = false;		for(i = 1 ; i <= 106 ; i++){		for(j = 1 ; j <= 106 ; j++){			if(theFoundDiagrams->dgramArray[i][j] >= 0){				if(!found[i]){					found[i] = true;					MarkElement(baseRect,i,3);				}				if(!found[j]){					found[j] = true;					MarkElement(baseRect,j,3);				}			}		}	}		while(!quit){		ModalDialog(SmallFilterUPP,&theSelect);		switch(theSelect){			case DLOG_ENTER_OR_CR:			case 1:				EraseRect(&dgramRect);				DrawDialog(theDialog);				for(i = 0 ; i <= 106 ; i++){					found[i] = false;				}				for(i = 1 ; i <= 106 ; i++){					for(j = 1 ; j <= 106 ; j++){						if(theFoundDiagrams->dgramArray[i][j] >= 0){							if(!found[i]){								found[i] = true;								MarkElement(baseRect,i,3);							}							if(!found[j]){								found[j] = true;								MarkElement(baseRect,j,3);							}						}					}				}				first = false;				break;			case 2:				cancel = quit = true;				break;			case 3:				thePoint = gTheEvent.where;				GlobalToLocal(&thePoint);				atNum = GetAtNum(baseRect,thePoint);				if(found[atNum]){					if(!first){						element1 = atNum;						EraseRect(&dgramRect);						DrawDialog(theDialog);						for(i = 0 ; i <= 106 ; i++){							found[i] = false;						}						for(i = 1 ; i <= 106 ; i++){							if(theFoundDiagrams->dgramArray[element1][i] >= 0){									if(!found[i]){									found[i] = true;									MarkElement(baseRect,i,3);								}							}						}						MarkElement(baseRect,element1,1);						first = true;					} else if(atNum != element1){						element2 = atNum;						MarkElement(baseRect,element2,1);						quit = true;					}				} else {					SysBeep(30);				}					break;			default:				break;			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;					}	}		DM_DisposDialog(&theDialog);	InvalRect(&theWindow->portRect);	if(first && !cancel){		i				= theFoundDiagrams->dgramArray[element1][element2];		thePDFileSpec	= theFoundDiagrams->theFilesSpecs[i];		DisposePtr((Ptr)theFoundDiagrams);		ReadDiagram();		DoNewSize();		SetPictMode(1);		newPictReq = true;		return;	}	DisposePtr((Ptr)theFoundDiagrams);	return;}	 void PhaseDiagram::ListOrientation(void) { } void PhaseDiagram::UpdateOR(short axis) 	 { axis = axis; } void PhaseDiagram::DoARotation(double angle,short axis) { 	angle = angle; 	axis = axis; }		void				PhaseDiagram::DoClose(void){	theSnapInfo->DoClose();	inherited::DoClose();	return;}void				PhaseDiagram::DoRefresh(void){	Rect		theRect;	SetPort(theWindow);	InvalRect(&theWindow->portRect);		theRect 		= theFrame;	theRect.right 	+= 1;	theRect.bottom 	+= 1;	PenMode(gMode);	inherited::DoRefresh();	}void				PhaseDiagram::DoMenu(long theResult){	short	theMenu,theItem;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);	switch(theMenu){		case	PHASE_D_MENU:			switch(theItem){				case	PD_RE_SIZE:					DoNewSize();					break;				case PD_PLOT_WEIGHT:					weightLinear = !weightLinear;					KillPicture(screenPict);					screenPict = (PicHandle)NUL;					if(weightLinear){						ConvertToWeight();						SetItem(GetMHandle(theMenu),theItem,"\pLinear By At %");					} else {						ReadDiagram();						SetItem(GetMHandle(theMenu),theItem,"\pLinear By Wt %");					}					DoNewSize();					break;				case PD_HIDE_TEXT:					hideLabels = !hideLabels;					if(hideLabels){						SetItem(GetMHandle(theMenu),theItem,"\pShow Text");					} else {						SetItem(GetMHandle(theMenu),theItem,"\pHide Text");					}					DrawMenuBar();					SetPict(true);					break;									case	PD_ZOOM_IN:				case	PD_ZOOM_OUT:				case	PD_OPEN_LIB:				case	PD_OPEN_DB:					break;			}			break;		default:			inherited::DoMenu(theResult);			break;	}	HiliteMenu(0);	return;}typedef struct geneva9{			short	fontType;			short	firstChar;			short	lastChar;			short	widMax;			short	kernMax;			short	mDescent;			short	fRectWidth;			short	fRectHeight;			short	owTLoc;			short	ascent;			short	descent;			short	leading;			short	rowWords;			unsigned short	fontBits[624];			unsigned short	locTable[220];			unsigned short	offWidTable[220];		}geneva9;Boolean				PhaseDiagram::DoContent(Point		thePoint)  /** Needs work onclipping **/{	Point			lastPoint,thisPoint;	//RgnHandle		newClip;		thisPoint = lastPoint = thePoint;	//if(editActive){DoEditContent(Point thePoint); return;}		LocalToObj(&thisPoint);		if(PtInRect(thisPoint,&tempControl)){		while(StillDown()){			GetMouse(&thisPoint);			if(!EqualPt(lastPoint,thisPoint)){				lastPoint = thisPoint;				tempControl.top 	= thisPoint.v - 6;				tempControl.bottom 	= thisPoint.v + 6;				refreshFlag = true;				DoRefresh();			}		}				return(true);	} else if(PtInRect(thisPoint,&compControl)){				while(StillDown()){			GetMouse(&thisPoint);			if(!EqualPt(lastPoint,thisPoint)){				lastPoint = thisPoint;				compControl.left 	= thisPoint.h - 6;				compControl.right 	= thisPoint.h + 6;				refreshFlag = true;				DoRefresh();			}		}			return(true);	}	return(inherited::DoContent(thePoint));}void				PhaseDiagram::FastPictDraw(void){	gMode = 0;	inherited::FastPictDraw();	DMBackColor(BACKGROUND_COLOR);	DMForeColor(COMPLEMENT_COLOR);	DrawCompControl(true);	DrawTempControl(true);	DrawCompSpots(true);}void				PhaseDiagram::DoIdle(void){	static	short h,v;	inherited::DoIdle();	if(h != compControl.left || v != tempControl.top){		//DrawCompSpots(false);		h = compControl.left;		v = tempControl.top;	}		return;}void				PhaseDiagram::DoNewSize(void){	if(!printing)/* august 1993 */		inherited::DoResize();	theFrame = theWindow->portRect;	InsetRect(&theFrame,40,40);	theFrame.top += 40;	theFrame.bottom -= 20;	if(printing){				/*august 1993*/		theFrame.right -= 40;		theFrame.left += 40;	}else{		theFrame.right -= 30;		theFrame.left += 55;	}	SetRect(&tempControl,2,theFrame.bottom - 6,14,theFrame.bottom + 6);	SetRect(&compControl,theFrame.right - 6,30,theFrame.right + 6,42);	SetRect(&loComp,-1,-1,-1,-1);	SetRect(&hiComp,-1,-1,-1,-1);	newPictReq = true;	//if(!printing)		//SetPict(true);}void 	PhaseDiagram::DrawCurve(void){	double			xScale,yScale,xOffset,yOffset;	short			h,v,i;	Boolean			init = true;	BezierCurve		thisCurve;	BezierCurvePtr		theCurve;	Rect				theRect;	Point				thePoint;		xOffset = theFrame.left;	xScale	= theFrame.right - theFrame.left;		yOffset = theFrame.top;	yScale	= theFrame.bottom - theFrame.top;		thisCurve.curveType		= workCurve->curveType;	thisCurve.curveWeight	= workCurve->curveWeight;	for(i = 0 ; i <= 3 ; i++){		thePoint = FromDgram(workCurve->x[i],workCurve->t[i]);		thisCurve.x[i] = thePoint.h;		thisCurve.t[i] = thePoint.v;	}	theCurve = &thisCurve;			PenNormal();		switch(theCurve->curveWeight){		case 0:			PenPat(&qd.gray);			break;		case 1:			break;		case 2:			PenSize(2,2);			break;		default:			break;	}				switch(theCurve->curveType){		case 0:			theSnapInfo->SetPoint(	theCurve->x[0],									theCurve->t[0],									workCurve->x[0],									workCurve->t[0]);													theSnapInfo->SetPoint(	theCurve->x[3],									theCurve->t[3],									workCurve->x[3],									workCurve->t[3]);													DrawBezier(theCurve);			break;					case 1:    /* Horizontal Arrow */			DrawBezier(theCurve);			break;					case 2:	 /* Vertical Arrow */			if(hideLabels)				break;			DrawBezier(theCurve);			v = theCurve->t[0] - 4;			h = theCurve->x[0] - 2;			MoveTo(h,v);			Line(2,4);			Line(2,-4);			Line(-4,0);			break;					case 4:	 /* Dotted End */			if(hideLabels)				break;			DrawBezier(theCurve);			v = theCurve->t[0];			h = theCurve->x[0];			SetRect(&theRect,-2,-2,2,2);			OffsetRect(&theRect,h,v);			PaintOval(&theRect);			break;					default:			break;	}	PenNormal();		}	void	PhaseDiagram::DoPrint(void)	/*august 1993 Jim*/{	inherited::DoPrint();	DoNewSize();}void	PhaseDiagram::DoPictDraw(void)//(Boolean	eraseFlag){	short 	i;	Rect	theRect;	DoNewSize();	PenMode(gMode);		SetDrawEnviron();	theRect 		= theFrame;	theRect.right 	+= 1;	theRect.bottom 	+= 1;	if(!hideLabels)		DisplayTheText();	DrawAtScale();	DrawWtScale();	DrawTempScale();	FrameRect(&theRect);	i = 0;	theSnapInfo->DoInit();	for(workCurve = &theCurves[numCurves - 1];workCurve >= theCurves; workCurve--){		i++;		DrawCurve();	}	ClearDrawEnviron();	return;}	void	PhaseDiagram::DrawAtScale(void){	short		h,width,num,begin,end,fontOffset;	double		pos,span,start,z;	char		theText[4],label[20];	FontInfo	theFontInfo;		TextFont(monaco);	TextSize(9);	GetFontInfo(&theFontInfo);	fontOffset = 1 + theFontInfo.ascent + theFontInfo.descent + theFontInfo.leading;		start 	= (double)theFrame.left + .5;	span 	= theFrame.right - theFrame.left;	theText[0] = (char)2;	theText[2] = '0';		sprintf(label,"Atomic P %s",elementB);	label[7] = '%';	c2pstr(label);		TextFace(bold);	width 	= StringWidth(c2pstr(elementA)) / 2;	MoveTo((short)start - width,theFrame.bottom + fontOffset + 4);	begin 	= start + width + 3;	DrawString((unsigned char*)elementA);		p2cstr((unsigned char*)elementA);			width 	= StringWidth(c2pstr(elementB)) / 2;	end 	= theFrame.right - width;	MoveTo(end,theFrame.bottom + fontOffset + 4);	DrawString((unsigned char*)elementB);	p2cstr((unsigned char*)elementB);	TextFace(0);		for(pos = .1 , num = 1 , theText[1] = '1' ; num <= 9 ; pos += .1 , num++ , theText[1]++){		width 	= StringWidth((unsigned char*)theText) / 2;		if(weightLinear){			z 	= (pos * massB) / (pos * massB + (1.0 - pos) * massA);		} else {			z = pos;		}		h 		= (short)(start + span * z);		MoveTo(h,theFrame.bottom);		Line(0,4);		if((h - width) > begin){			begin = h + width + 3;			if(begin < end){				Move(-width,fontOffset);				DrawString((unsigned char*)theText);			}		}		if(num == 5){			width 	= StringWidth((unsigned char*)label) / 2;			h 		= (short)(start + span * pos);			MoveTo(h - width,theFrame.bottom + fontOffset + fontOffset + 5);			DrawString((unsigned char*)label);		}	}	TextFont(applFont);	TextSize(12);}		void	PhaseDiagram::DrawWtScale(void)	{	short	h,v,width,num,fontOffset,begin,end,last,n;	double	w,span,start,z,x;	char		theText[4],label[20],temp[10];	FontInfo	theFontInfo;		TextFont(monaco);	TextSize(9);	GetFontInfo(&theFontInfo);	fontOffset = 1 + theFontInfo.ascent + theFontInfo.descent +theFontInfo.leading;		start 	= (double)theFrame.left + .5;	span 	= theFrame.right - theFrame.left;	theText[0] = (char)2;	theText[2] = '0';		sprintf(label,"Weight P %s",elementB);	label[7] = '%';	c2pstr(label);		TextFace(bold);	c2pstr(elementA);	width 	= StringWidth((unsigned char*)elementA) / 2;	MoveTo((short)start - width,theFrame.top - theFontInfo.descent - 2);	begin 	= start + width + 3;	last	= begin;	DrawString((unsigned char*)elementA);		p2cstr((unsigned char*)elementA);		c2pstr(elementB);	width 	= StringWidth((unsigned char*)elementB) / 2;	end 	= theFrame.right - width;	MoveTo(end,theFrame.top - theFontInfo.descent - 2);	DrawString((unsigned char*)elementB);	p2cstr((unsigned char*)elementB);	TextFace(0);		for(w = .1 , num = 1 , theText[1] = '1' ; num <= 9 ; w += .1 , num++ ,theText[1]++){		width 	= StringWidth((unsigned char*)theText) / 2;		if(weightLinear){			z	 = w;		} else {			z 	= (w * massRatio) / (w * massRatio - w + 1.0);		}		h 		= (short)(start + span * z);		MoveTo(h,theFrame.top);		Line(0,4);		if((h - width) > begin){			begin = h + width + 3;			if(begin < end){				Move(-width,(-6 - theFontInfo.descent));				DrawString((unsigned char*)theText);			}			if((begin - last) > (10 * width)){				x = (w - .05);				if(weightLinear){					z	= x;				} else {					z 	= (x * massRatio) / (x * massRatio - x + 1.0);				}				h = (short)(start + span * z);				MoveTo(h,theFrame.top);				Line(0,2);				n = (short)(100.0 * x + .5);				sprintf(temp,"%2d",n);				c2pstr(temp);				width 	= StringWidth((unsigned char*)temp) / 2;				Move(-width,(- 4 - theFontInfo.descent));				DrawString((unsigned char*)temp);			}			last = begin;		}	}		if((end - last) > (10 * width)){		x = .95;		if(weightLinear){			z	= x;		} else {			z 	= (x * massRatio) / (x * massRatio - x + 1.0);		}		h = (short)(start + span * z);		MoveTo(h,theFrame.top);		Line(0,2);		n = (short)(100.0 * x + .5);		sprintf(temp,"95");		c2pstr(temp);		width 	= StringWidth((unsigned char*)temp) / 2;		Move(-width,(- 4 - theFontInfo.descent));		DrawString((unsigned char*)temp);	}		h = (theFrame.left + theFrame.right - StringWidth((unsigned char*)label)) / 2;	v = theFrame.top - fontOffset - 6;	MoveTo(h,v);	DrawString((unsigned char*)label);			TextFont(geneva);	TextSize(24);	TextFace(bold);	sprintf(label,"%s-%s",elementA,elementB);	c2pstr(label);	width 	= StringWidth((unsigned char*)label) / 2;	h		= theFrame.left - width;	v 		= theFrame.top - fontOffset - 6;	MoveTo(h,v);	DrawString((unsigned char*)label);			TextFont(applFont);	TextSize(12);	TextFace(0);}	void	PhaseDiagram::DrawTempScale(void){	short	i,num,temp,h,v,width,tempStepF,loTemp,hiTemp;	char	theText[20];	double	base,scale,tempLoF,fspan;		TextFont(monaco);	TextSize(9);		num 		= (tempHi - tempLo) / tempStep;	temp 		= tempLo;	scale		= (double)(theFrame.bottom - theFrame.top) * tempRatio /(double)(tempHi - tempLo);	base		= .5 + (double)theFrame.bottom;	fspan		= scale / 1.8;	tempLoF 	= 1.8 * tempLo + 32.;		for(i = 0 ; i <= num ; i++,temp += tempStep){		sprintf(theText,"%4d",temp);		c2pstr(theText);		v = (short)(base - (double)(temp - tempLo) * scale);		MoveTo(theFrame.left,v);		Line(-4,0);		width = 1 + StringWidth((unsigned char*)theText);		Move(-width,4);		DrawString((unsigned char*)theText);	}	tempStepF 	= (32.0 + 1.8 * tempStep) / 100;	tempStepF 	*= 100;	tempLoF		= (32.0 + 1.8 * tempLo);	loTemp		= tempLoF / 100;	loTemp		*= 100;	hiTemp		= (32.0 + tempHi * 1.8);		for(i = loTemp ; i <= hiTemp ; i += tempStepF){		sprintf(theText,"%4d",i);		c2pstr(theText);		v = (short)(base - (double)(i - tempLoF) * fspan);		if(v < theFrame.bottom && v > theFrame.top){			MoveTo(theFrame.right,v);			Line(4,0);			Move(1,4);			DrawString((unsigned char*)theText);		}	}	TextFace(bold);	v = (theFrame.top + theFrame.bottom) / 2;	h = 30;		sprintf(theText,"0C");	c2pstr(theText);	width = h + StringWidth((unsigned char*)theText);	MoveTo(theFrame.left - width,v);	DrawString((unsigned char*)theText);		sprintf(theText,"0F");	c2pstr(theText);	MoveTo(theFrame.right + h,v);	DrawString((unsigned char*)theText);	TextFace(bold);		TextFont(applFont);	TextSize(12);}void	PhaseDiagram::DisplayTheText(void){	short		i,j,k,n,v,numCRs,height;	char		*text,line[40];	FontInfo	fInfo;	Point		thePoint;			TextFace(0);		gSymbolFont = GetFontHandle("\pSymbol",9);	if(gSymbolFont == (FontRec**)NUL){		WarnUser(3);		return;	}		gGenevaFont = GetFontHandle("\pGeneva",9);	if(gGenevaFont == (FontRec**)NUL){		WarnUser(4);		return;	}		TextFont(geneva);	TextSize(9);	GetFontInfo(&fInfo);	height = fInfo.ascent + fInfo.descent + fInfo.leading;		for(i = 0 ; i < numLabels ; i++){		text = theLabels[i].theLabel;		numCRs = -1;		j = 0;		while(text[j] != (char)0){			if(text[j] == (char)13)				numCRs++;			j++;		}		thePoint 	= FromDgram(theLabels[i].x,theLabels[i].t);		v			= thePoint.v - ((height * numCRs) / 2);		n 			= 0;		for(k = 0 ; k < j ; k++){			if(text[k] == (char)13){				line[n] = (char)0;				DrawTheString(line,thePoint.h,v,theLabels[i].vertical);				v += height;				n = 0;			} else {				line[n++] = text[k];			}		}		line[n] = (char)0;		DrawTheString(line,thePoint.h,v,theLabels[i].vertical);	}	ReleaseResource((Handle)gSymbolFont);	ReleaseResource((Handle)gGenevaFont);}		void	DrawTheString(char*	line, short h, short v,Boolean vertical){	short 	width;	unsigned char	*thisChar,theChar;	Boolean	subscript,plus;	FontRec **theFont;		plus 		= subscript = false;	width 	= 0;	thisChar 	= (unsigned char*)line;	while(*thisChar != (char)0){		if((short)*thisChar > 0x7E){			TextFont(symbol);		} else {			TextFont(geneva);		}		width += CharWidth(CharConvert(*thisChar++));	}	v -= 3;	width /= 2;	if(vertical){		FontInfo	fInfo;				GetFontInfo(&fInfo);		h -= (fInfo.ascent / 2);		v -= width;		MoveTo(h,v);		thisChar = (unsigned char*)line;				while(*thisChar != (char)0){			theChar = *thisChar++;			if((short)theChar > 0x7E){				theFont = gSymbolFont;				theChar = CharConvert(theChar);			} else {				theFont = gGenevaFont;			}						if(theChar >= '0' && theChar <= '9'){				subscript = true;				Move(-4,0);				DrawVertChar(theFont,theChar);				Move(4,0);				} else if(subscript && theChar == '+'){				plus = true;				Move(-4,0);				DrawVertChar(theFont,theChar);				Move(4,0);			} else if(subscript && plus && theChar == 'x'){				Move(-4,0);				DrawVertChar(theFont,theChar);				Move(4,0);			} else {				plus = subscript = false;				DrawVertChar(theFont,theChar);			}		}	} else {		h -= width;		MoveTo(h,v);		thisChar = (unsigned char*)line;		while(*thisChar != (char)0){			theChar = *thisChar++;			if((short)theChar > 0x7E){				TextFont(symbol);				theChar = CharConvert(theChar);			} else {				TextFont(geneva);			}			if(theChar >= '0' && theChar <= '9'){				subscript = true;				Move(0,4);				DrawChar(theChar);				Move(0,-4);			} else if(subscript && theChar == '+'){				plus = true;				Move(0,4);				DrawChar(theChar);				Move(0,-4);			} else if(subscript && plus && theChar == 'x'){				Move(0,4);				DrawChar(theChar);				Move(0,-4);			} else {				plus = subscript = false;				DrawChar(theChar);			}		}	}}	Point	PhaseDiagram::FromDgram(short double x,short double temp){	short h,v;	double	z,height;	Point	thePoint;		z		= (x / 100.0) * (double)(theFrame.right - theFrame.left);	z		+= (double)theFrame.left;		h		= (short)z;		height	= (double)(theFrame.bottom - theFrame.top) * tempRatio;	z		= height * (temp - tempLo) / (tempHi - tempLo);	v		= (short)((double)theFrame.bottom - z);		thePoint.h = h;	thePoint.v = v;		return(thePoint);}		void	PhaseDiagram::ToDgram(Point thePoint,short double *x,short double *temp){	double	z,scale,tempSpan;		z 			= 	theFrame.bottom - thePoint.v;	scale		= 	theFrame.bottom - theFrame.top;	scale		*= 	tempRatio;	z			/=	scale;	tempSpan	=	tempHi - tempLo;	z			*= 	tempSpan;	z			+=	tempLo;	*temp		=	z;		z 			=	thePoint.h - theFrame.left;	z 			/=	(double)(theFrame.right - theFrame.left);	*x			=	z * 100.;}	void	PhaseDiagram::DrawBezier(BezierCurvePtr theCurve){	short	h,v,lastH,lastV;	double	u,theX,theY,a,b,c,d;		double z,z2,zu,zu2,dist,dx,dy,inc;			dx = theCurve->x[3] - theCurve->x[0];	dy = theCurve->t[3] - theCurve->t[0];	dist = sqrt(dx * dx + dy * dy);		if(dist < 100){		inc = 1.0 / dist;	} else {		inc = .01;	}		for(u = 0.0 ; u <= 1.0 ; u += inc){				z 	= 1.0 - u;		z2 	= z * z;		a 	= z2 * z;		zu 	= u;		zu2 = u * u;		d 	= zu2 * u;		b 	= 3.0 * zu * z2;		c	= 3.0 * zu2 * z;						theX = 	theCurve->x[0] * a +				theCurve->x[1] * b +				theCurve->x[2] * c +				theCurve->x[3] * d +				.5;								theY = 	theCurve->t[0] * a +				theCurve->t[1] * b +				theCurve->t[2] * c +				theCurve->t[3] * d +				.5;						h	= (short)theX;		v	= (short)theY;				if(u < .01 ){			MoveTo(h,v);			lastH	= h;			lastV	= v;		} else {			if(h != lastH || v != lastV){				LineTo(lastH,lastV);				LineTo(h,v);				lastH	= h;				lastV	= v;			}		}	}}	void		PhaseDiagram::DrawTempControl(Boolean hilite){	short			center,h1,h2,h3,v1,v2,theVal;	PenState		thePenState;	short double	compAt,temp;	Point			thePoint;		center 	= (tempControl.top + tempControl.bottom) / 2;	if(center <= (theFrame.top + 1)){		OffsetRect(&tempControl,0,theFrame.top - center + 1);	}		if(center >= (theFrame.bottom - 1)){		OffsetRect(&tempControl,0,theFrame.bottom - center - 1);	}		h1 		= tempControl.left;	h2 		= tempControl.right;	v1 		= tempControl.top;	v2 		= tempControl.bottom;	center 	= (v1 + v2) / 2;	h3		= h2 + (h2 - h1) / 2;		if(hilite){		PenSize(2,2);	} else {		PenSize(1,1);	}		MoveTo(h1,v1);	LineTo(h1,v2);	LineTo(h2,v2);	LineTo(h3,center);	LineTo(h2,v1);	LineTo(h2,v2);	LineTo(h1,v1);	LineTo(h2,v1);	LineTo(h1,v2);	PenSize(1,1);	GetPenState(&thePenState);	//PenMode(srcXor);	//TextMode(srcXor);	GetMouse(&thePoint);	if(!theSnapInfo->SnapTemp(thePoint.h,center,&temp)){		thePoint.v = center;		ToDgram(thePoint,&compAt,&temp);		TextFace(0);	} else {		TextFace(bold);	}			TextFont(geneva);	TextSize(9);		theVal = (short)(temp + .5);		sprintf(gTheText,"%4d 0C",theVal);	MoveTo(2,center - 8);	DrawString(c2pstr(gTheText));		temp = temp * 1.8 + 32.0;	theVal = (short)(temp + .5);	sprintf(gTheText,"%4d 0F",theVal);	MoveTo(2,center + 15);	DrawString((unsigned char*)c2pstr(gTheText));			MoveTo(theFrame.right - 1,center);	LineTo(theFrame.left + 1,center);	if(hilite){		LineTo(h3,center);	}	TextMode(0);	SetPenState(&thePenState);}	void		PhaseDiagram::DrawCompControl(Boolean hilite){	short				center,h1,h2,v1,v2,v3,x;	PenState			thePenState;	short double		compAt,compWt,temp,r;	Point				thePoint;	static Boolean		snapFlag;		center 	= (compControl.left + compControl.right) / 2;	if(center <= (theFrame.left + 1)){		OffsetRect(&compControl,theFrame.left - center + 1,0);	}		if(center >= (theFrame.right - 1)){		OffsetRect(&compControl,theFrame.right - center - 1,0);	}		h1 		= compControl.left;	h2 		= compControl.right;	v1 		= compControl.top;	v2 		= compControl.bottom;	v3		= v2 + (v2 - v1) / 2;	center 	= (h1 + h2) / 2;		if(hilite){		PenSize(2,2);	} else {		PenSize(1,1);	}		MoveTo(h2,v1);	LineTo(h1,v1);	LineTo(h1,v2);	LineTo(center,v3);	LineTo(h2,v2);	LineTo(h2,v1);	LineTo(h1,v2);	LineTo(h2,v2);	LineTo(h1,v1);	PenSize(1,1);		GetPenState(&thePenState);	//PenMode(srcXor);	//TextMode(srcXor);		GetMouse(&thePoint);	if(!theSnapInfo->SnapComp(center,thePoint.v,&compAt)){		thePoint.h = center;		ToDgram(thePoint,&compAt,&temp);		TextFace(0);	} else {		TextFace(bold);	}	if(weightLinear){		compWt = compAt;		r = compWt * .01;		compAt = -(massA * compWt) / (r * (massB - massA) - massB);	} else {		r = compAt * .01;		compWt 	= compAt / ((1.0 - r) * massRatio + r);	}		TextFont(geneva);	TextSize(9);	sprintf(gTheText,"%6.1f %%At",(compAt + .05));	x	 	= center - StringWidth(c2pstr(gTheText)) / 2;	MoveTo(x,v1 - 4);	DrawString((unsigned char*)gTheText);	sprintf(gTheText,"%6.1f %%Wt",(compWt + .05));	MoveTo(x,v1 - 15);	DrawString((unsigned char*)c2pstr(gTheText));		TextMode(0);		MoveTo(center,theFrame.bottom - 1);	LineTo(center,theFrame.top + 1);	if(hilite){		LineTo(center,v3);	}	SetPenState(&thePenState);}void		PhaseDiagram::SearchCurves(short double comp,short double temp,shortdouble *a,short double *b){	BezierCurvePtr		lastCurve,theCurve;	double				hiDif,loDif,dif,theComp;	theCurve	= theCurves;	lastCurve	= &theCurves[numCurves];	loDif 		= -comp;	hiDif		= 100 - comp;	*a			= 0.0;	*b			= 100.0;	for( ; theCurve < lastCurve ; theCurve++){		if(theCurve->curveType != 0)			continue;		if(temp > theCurve->t[0] && temp > theCurve->t[3])			continue;		if(temp < theCurve->t[0] && temp < theCurve->t[3])			continue;				theComp = GetCompFromCurve(theCurve,comp,temp);		dif 	= theComp - comp;				if(dif < 0){			if(dif > loDif){				loDif = dif;				*a	  = theComp;			}		} else if(dif > 0){			if(dif < hiDif){				hiDif = dif;				*b	  = theComp;			}		} else {			*a = theComp;			*b = theComp;			return;		}	}}void		PhaseDiagram::DrawCompSpots(Boolean	refresh){	Rect				theRect;	Point				thePoint;	short double		x,t,a,b,r1,r2;	short				h,h2;	static short		lastWidth;		SetRect(&theRect,-3,theFrame.bottom - 8,4,theFrame.bottom - 1);		//PenMode(srcXor);	if(!refresh){		FrameOval(&loComp);		FrameOval(&hiComp);	}		thePoint.h = (compControl.left + compControl.right) / 2;	thePoint.v = (tempControl.top + tempControl.bottom) / 2;		ToDgram(thePoint,&x,&t);	SearchCurves(x,t,&a,&b);	r1 = 100.0 * (b - x) / (b - a);	r2 = 100.0 - r1;	loComp = hiComp = theRect;	thePoint = FromDgram(a,t);	OffsetRect(&loComp,thePoint.h,0);	thePoint = FromDgram(b,t);	OffsetRect(&hiComp,thePoint.h,0);	FrameOval(&loComp);	FrameOval(&hiComp);	PenNormal();		SetRect(&theRect,0,0,lastWidth,30);	TextSize(9);	TextMode(0);	TextFace(0);	TextFont(geneva);	sprintf(gTheText,"%3.1f  %3.1f  %3.1f",a,x,b);	c2pstr(gTheText);	h = StringWidth(pTheText);	lastWidth = 3 + h;	//EraseRect(&theRect);	MoveTo(2,12);	DrawString(pTheText);	sprintf(gTheText,"%4.1f        %4.1f",r1,r2);	c2pstr(gTheText);	h2 = 2 + (h - StringWidth(pTheText)) / 2;	MoveTo(h2,24);	DrawString(pTheText);	MoveTo(h + 2,14);	LineTo(2,14);	h /= 2;	h += 2;	MoveTo(h,15);	Line(-5,10);	Line(10,0);	Line(-5,-10);		Line(-3,10);	Move(6,0);	Line(-3,-10);	Line(0,10);		}		void		PhaseDiagram::ReadDiagram(void){	long				dataOffset,length;	short				i,j,iErr,refnum,version,flag;	short double		theValue;	Rect				tempRect;	iErr 		= FSpOpenDF(&thePDFileSpec,fsRdPerm,&refnum);	iErr 		= DgRead((Ptr)&version,refnum,sizeof(short));	iErr 		= DgRead((Ptr)&dataOffset,refnum,sizeof(long));	iErr 		= DgRead((Ptr)&theFrame,refnum,sizeof(Rect));	iErr 		= DgRead((Ptr)&length,refnum,sizeof(long));		iErr 		= DgRead((Ptr)elementA,refnum,length);	iErr 		= DgRead((Ptr)&length,refnum,sizeof(long));		iErr 		= DgRead((Ptr)elementB,refnum,length);	iErr 		= DgRead((Ptr)&flag,refnum,sizeof(short));	if(flag == 0){		weightLinear = false;	} else {		weightLinear = true;	}	iErr 		= DgRead((Ptr)&massRatio,refnum,sizeof(short double));	iErr 		= DgRead((Ptr)&tempLo,refnum,sizeof(short double));	iErr 		= DgRead((Ptr)&tempHi,refnum,sizeof(short double));	iErr 		= DgRead((Ptr)&tempStep,refnum,sizeof(short double));	iErr 		= DgRead((Ptr)&tempRatio,refnum,sizeof(short double));	iErr 		= DgRead((Ptr)&numCurves,refnum,sizeof(short));	iErr 		= DgRead((Ptr)&numLabels,refnum,sizeof(short));	iErr 		= DgRead((Ptr)&flag,refnum,sizeof(short));		iErr 		= SetFPos(refnum,fsFromStart,dataOffset);		i 			= theCrystal[0]->TheAtomicNum(elementA);	massA 		= GetAtWeight(i);	i 			= theCrystal[0]->TheAtomicNum(elementB);	massB 		= GetAtWeight(i);	massRatio	= massA / massB;// Bezier Curves		for(i = 0 ; i < numCurves ; i++){		iErr 		= DgRead((Ptr)&theCurves[i].curveType,refnum,sizeof(short));		//curve type		iErr 		= DgRead((Ptr)&theCurves[i].curveWeight,refnum,sizeof(short));		//curve weight				for(j = 0 ; j <= 3 ; j++){														// composition values			iErr 				= DgRead((Ptr)&theValue,refnum,sizeof(short double));			if(weightLinear){				theCurves[i].x[j]	= 100.0 * massRatio / ((1.0 / (theValue / 100.0)) -1.0 + massRatio);			} else {				theCurves[i].x[j]	= theValue;			}		}		for(j = 0 ; j <= 3 ; j++){														// T values			iErr 		= DgRead((Ptr)&theCurves[i].t[j],refnum,sizeof(short double));		}		iErr 		= DgRead((Ptr)&flag,refnum,sizeof(short));							// data flag	}	// Diagram Labels		TextFont(geneva);	TextSize(9);		for(i = 0 ; i < numLabels ; i++){		iErr 			= DgRead((Ptr)&theValue,refnum,sizeof(short double));		if(weightLinear){			theLabels[i].x 	= 100.0 * massRatio / ((1.0 / (theValue / 100.0)) - 1.0 + massRatio);  // composition		} else {			theLabels[i].x 	= theValue;		}		iErr 		= DgRead((Ptr)&theLabels[i].t,refnum,sizeof(short double));				// T value		iErr 		= DgRead((Ptr)&flag,refnum,sizeof(short));								// vertical flag		if(flag == 0){			theLabels[i].vertical = false;		} else {			theLabels[i].vertical = true;		}		iErr 		= DgRead((Ptr)&tempRect,refnum,sizeof(Rect));							// destRect		iErr 		= DgRead((Ptr)&tempRect,refnum,sizeof(Rect));							// viewRect		iErr 		= DgRead((Ptr)&length,refnum,sizeof(long));								// string length		iErr 		= DgRead((Ptr)theLabels[i].theLabel,refnum,(length * sizeof(char)));	// characters		iErr 		= DgRead((Ptr)&flag,refnum,sizeof(short));								// data Flag		if(theLabels[i].theLabel[length - 2] == '.'){			theLabels[i].vertical 				= true;			theLabels[i].theLabel[length - 2] 	= (char)0;		}	}	weightLinear	= false;			iErr			= FSClose(refnum);}		void		PhaseDiagram::ConvertToWeight(void){	double	x;	short	i,j;		for(i = 0 ; i < numCurves ; i++){		for(j = 0 ; j <= 3 ; j++){			x 				= theCurves[i].x[j];			theCurves[i].x[j] 	= 100.0 * x / ((100.0 - x) * massRatio + x);		}	}	for(i = 0 ; i < numLabels ; i++){		x 			= theLabels[i].x;		theLabels[i].x 	= 100.0 * x / ((100.0 - x) * massRatio + x);	}}			void	DrawVertChar(FontRec **theFont,char theChar){	unsigned short  *fontBits,*locTable,*offWidTable,theData,h,v;	unsigned short 	i,j,address,bitMapWidth,width,arrayWord,bitOffset,value,mask;	Boolean			sysLocked;	char			theState;	//	strcpy(gTheRoutine,"DrawVertChar");	theState	= HGetState((Handle)theFont);	if((theState & 0x80) != 0){		D_HLock((Handle)theFont);		sysLocked	= false;	} else {		sysLocked	= true;	}		fontBits 	= (unsigned short*)&(*theFont)->rowWords;	fontBits++;	locTable 	= &fontBits[(*theFont)->rowWords * (*theFont)->fRectHeight];	offWidTable = &locTable[(*theFont)->lastChar - (*theFont)->firstChar + 3];	address		= locTable[(short)theChar];	bitMapWidth = locTable[(short)theChar + 1] - address;	arrayWord	= address / 16;	bitOffset 	= address % 16;	value 		= 0x8000;	width		= (offWidTable[(short)theChar] & 0x00FF) - bitMapWidth;		while(bitOffset > 0){		value /= 2;		bitOffset--;	}	Move((*theFont)->fRectHeight + 1,0);	h = 0;	v = 0;	for(j = 0 ; j < (*theFont)->fRectHeight ; j++){		/*  for each row */		arrayWord	= j * (*theFont)->rowWords + address / 16;		theData 	= fontBits[arrayWord];		mask = value;		Move(-1,-v);		h++;		v = 0;				for(i = 1 ; i <= bitMapWidth ; i++){			if((mask & theData) != 0){				Line(0,0);			}			Move(0,1);			v++;			mask /= 2;			if(mask == 0){				mask = 0x8000;				theData = fontBits[++arrayWord];			}		}	}	Move(-1,width);	if(!sysLocked){		D_HUnlock((Handle)theFont);	}}			char	CharConvert(unsigned char theChar){	unsigned char	thisChar;		switch(theChar){		case (unsigned char)'e':				thisChar = 'a';		break;				case (unsigned char)'':				thisChar = 'b';		break;				case (unsigned char)'g':				thisChar = 'c';		break;				case (unsigned char)'':				thisChar = 'd';		break;				case 171:				thisChar = 'e';		break;				case (unsigned char)'':				thisChar = 'f';		break;				case (unsigned char)')':				thisChar = 'g';		break;				case 250:				thisChar = 'h';		break;				case 246:				thisChar = 'i';		break;				case (unsigned char)'':				thisChar = 'j';		break;				case 251:				thisChar = 'k';		break;				case (unsigned char)',':				thisChar = 'l';		break;				case (unsigned char)'5':				thisChar = 'm';		break;				case 247:				thisChar = 'n';		break;				case (unsigned char)'x':				thisChar = 'o';		break;				case (unsigned char)'<':				thisChar = 'p';		break;				case (unsigned char)'&':				thisChar = 'q';		break;				case (unsigned char)'.':				thisChar = 'r';		break;				case (unsigned char)'_':				thisChar = 's';		break;				case (unsigned char)']':				thisChar = 't';		break;				case 172:				thisChar = 'u';		break;				case (unsigned char)'':				thisChar = 'v';		break;				case (unsigned char)'':				thisChar = 'w';		break;				case (unsigned char)'	':				thisChar = 'x';		break;				case (unsigned char)'%':				thisChar = 'y';		break;				case (unsigned char)'':				thisChar = 'z';		break;				default:			thisChar = theChar;			break;	}	return(thisChar);}double	GetCompFromCurve(BezierCurvePtr theCurve,short double	comp,shortdouble	temp){	short double	u,dif,t1,t2,t,hi,lo,x,lastU;		if(theCurve->t[0] == theCurve->t[3]){		if(comp > theCurve->x[0] && comp > theCurve->x[3]){			return(-200.0);		} else if(comp < theCurve->x[0] && comp < theCurve->x[3]){			return(200.0);		}		return(comp);	}		if(theCurve->x[0] == theCurve->x[3]){		if(fabs(comp - theCurve->x[0]) < .1)			return(0.0);		return(theCurve->x[0]);	}		lastU = 0;	t1 	= GetCurveValue(theCurve,.25,&x);	t2 	= GetCurveValue(theCurve,.75,&x);	lo 	= 0;	hi 	= 1.0;	dif = 100;		while(dif > .5){		u = (hi + lo) * .5;		t = GetCurveValue(theCurve,u,&x);		if(t2 > t1){			if(temp > t){				lo = u;			} else {				hi = u;			}		} else {			if(temp < t){				lo = u;			} else {				hi = u;			}		}		dif = fabs(t - temp);		if(fabs(lastU - u) < .0001)			return(200.0);		lastU = u;	}		return (x);}		double	GetCurveValue(BezierCurvePtr theCurve,short double	u,short double *x){		double	theY,a,b,c,d;	double 	z,z2,zu,zu2;		z 	= 1.0 - u;	z2 	= z * z;	a 	= z2 * z;	zu 	= u;	zu2 = u * u;	d 	= zu2 * u;	b 	= 3.0 * zu * z2;	c	= 3.0 * zu2 * z;		*x = 	theCurve->x[0] * a +			theCurve->x[1] * b +			theCurve->x[2] * c +			theCurve->x[3] * d;		theY = 	theCurve->t[0] * a +			theCurve->t[1] * b +			theCurve->t[2] * c +			theCurve->t[3] * d;	return(theY);}	void	DrawArrow(Point	thePoint){	MoveTo(thePoint.h,thePoint.v);	Line(3,-3);	Line(-2,0);	Line(0,-2);	Line(-2,0);	Line(0,2);	Line(-2,0);	Line(3,3);	}void		FindElementRect(Rect* baseRect,short atNum){		short h,v;		if(atNum == 1){		h = v = 0;	} else if (atNum == 2){		h = 17 * 25;		v = 0;	} else if (atNum <= 4){		h = (atNum - 3) * 25;		v = 24;	} else if (atNum <= 10){		h = (7 + atNum) * 25;		v = 24;	} else if (atNum <= 12){		h = (atNum - 11) * 25;		v = 48;	} else if (atNum <= 18){		h = (atNum - 1) * 25;		v = 48;	} else if (atNum <= 36){		h = (atNum - 19) * 25;		v = 72;	} else if (atNum <= 54){		h = (atNum - 37) * 25;		v = 96;	} else if (atNum <= 57){		h = (atNum - 55) * 25;		v = 120;	} else if (atNum <= 71){		h = (atNum - 55) * 25;		v = 168;	} else if (atNum <= 86){		h = (atNum - 69) * 25;		v = 120;	} else if (atNum <= 89){		h = (atNum - 87) * 25;		v = 144;	} else if (atNum <= 103){		h = (atNum - 87) * 25;		v = 192;	} else if (atNum <= 106){		h = (atNum - 101) * 25;		v = 144;	}	OffsetRect(baseRect,h,v);}void		MarkElement(Rect	baseRect,short atNum,short	type){		FindElementRect(&baseRect,atNum);		switch(type){		case 1:			InvertRect(&baseRect);			break;		case 2:			EraseRect(&baseRect);			break;		case 3:			FrameRect(&baseRect);			break;		default:			break;	}}short	GetAtNum(Rect baseRect,Point thePoint){	short atNum;		for(atNum = 1 ; atNum <= 106 ; atNum++){		gTheRect = baseRect;		FindElementRect(&gTheRect,atNum);		if(PtInRect(thePoint,&gTheRect)) {			return(atNum);		}	}	return(0);}		double	GetAtWeight(short atNum){	char**	theRes;	char*	theChar;	short	i = 0;	double	theValue;		theRes = (char**)GetResource('AtIn',atNum);	//	strcpy(gTheRoutine,"GetAtWeight");	D_HLock((Handle)theRes);	theChar = *theRes;		while(i < 3){		if(*theChar++ == '\t')			i++;	}		theValue = atof(theChar);	D_HUnlock((Handle)theRes);	ReleaseResource((Handle)theRes);	return(theValue);}		void		MemFlash(void){	long			size;	static long		last;		MaxMem(&size);	size = MaxBlock();	if((last - size) > 30000)		SysBreak();	last = size;}PDFileInfoPtr	FileSearch(void){	OSErr 			iErr;	CSParam			paramBlock;	CInfoPBRec		ioSearchInfo1,ioSearchInfo2;	FSSpec			dirFSS;	Ptr				searchBuff;	short			i,fRefNum,el1,el2,*dataPtr;	char			elementA[4],elementB[4];	long			inOutCount,length;	PDFileInfoPtr	thePDInfo;		GetSearchFSSPec('Phas',&dirFSS);	thePDInfo	= (PDFileInfoPtr)NewPtr(sizeof(PDFileInfo));	searchBuff	= NewPtr(16000L);	paramBlock.ioNamePtr 							= NUL;	paramBlock.ioCompletion							= NUL;	paramBlock.ioVRefNum							= dirFSS.vRefNum;	paramBlock.ioMatchPtr							= (FSSpec*)thePDInfo;		/* max number allowed	*/	paramBlock.ioReqMatchCount						= 1500;		paramBlock.ioSearchBits 						= fsSBFlParID + fsSBFlFndrInfo;		paramBlock.ioCatPosition.initialize 			= NUL;			/* start at begining		*/	paramBlock.ioSearchInfo1						= &ioSearchInfo1;	paramBlock.ioSearchInfo2						= &ioSearchInfo2;	paramBlock.ioSearchTime							= 0L;	paramBlock.ioCatPosition.initialize				= 0L;	paramBlock.ioOptBuffer							= searchBuff;	paramBlock.ioOptBufSize							= 16000;		ioSearchInfo1.hFileInfo.ioFlFndrInfo.fdType			= 'PDgm';	ioSearchInfo1.hFileInfo.ioFlFndrInfo.fdCreator		= 'pdED';	ioSearchInfo1.hFileInfo.ioFlFndrInfo.fdFlags		= 0;	ioSearchInfo1.hFileInfo.ioFlFndrInfo.fdLocation.h	= 0;	ioSearchInfo1.hFileInfo.ioFlFndrInfo.fdLocation.v	= 0;	ioSearchInfo1.hFileInfo.ioFlFndrInfo.fdFldr			= 0;	ioSearchInfo1.hFileInfo.ioFlParID					= dirFSS.parID;	ioSearchInfo1.hFileInfo.ioNamePtr					= NUL;	ioSearchInfo1.hFileInfo.ioFlAttrib					= NUL;	ioSearchInfo1.hFileInfo.ioFlLgLen					= NUL;	ioSearchInfo1.hFileInfo.ioFlPyLen					= NUL;	ioSearchInfo1.hFileInfo.ioFlRLgLen					= NUL;	ioSearchInfo1.hFileInfo.ioFlRPyLen					= NUL;	ioSearchInfo1.hFileInfo.ioFlCrDat					= NUL;	ioSearchInfo1.hFileInfo.ioFlMdDat					= NUL;	ioSearchInfo1.hFileInfo.ioFlBkDat					= NUL;		ioSearchInfo2.hFileInfo.ioFlFndrInfo.fdType			= 'PDgm';	ioSearchInfo2.hFileInfo.ioFlFndrInfo.fdCreator		= 'pdED';	ioSearchInfo2.hFileInfo.ioFlFndrInfo.fdFlags		= 0;	ioSearchInfo2.hFileInfo.ioFlFndrInfo.fdLocation.h	= 0;	ioSearchInfo2.hFileInfo.ioFlFndrInfo.fdLocation.v	= 0;	ioSearchInfo2.hFileInfo.ioFlFndrInfo.fdFldr			= 0;	ioSearchInfo2.hFileInfo.ioFlParID					= dirFSS.parID;	ioSearchInfo2.hFileInfo.ioNamePtr					= NUL;	ioSearchInfo2.hFileInfo.ioFlAttrib					= 0x10;	ioSearchInfo2.hFileInfo.ioFlLgLen					= NUL;	ioSearchInfo2.hFileInfo.ioFlPyLen					= NUL;	ioSearchInfo2.hFileInfo.ioFlRLgLen					= NUL;	ioSearchInfo2.hFileInfo.ioFlRPyLen					= NUL;	ioSearchInfo2.hFileInfo.ioFlCrDat					= NUL;	ioSearchInfo2.hFileInfo.ioFlMdDat					= NUL;	ioSearchInfo2.hFileInfo.ioFlBkDat					= NUL;				iErr 			= PBCatSearchSync(&paramBlock);	DisposePtr(searchBuff);	dataPtr			= (short*)thePDInfo->dgramArray;	for(i = 0 ; i < (107L * 107L) ; i++){		*dataPtr++ = -1;	}		for(i = 0 ; i < paramBlock.ioActMatchCount ; i++){		iErr 							= FSpOpenDF(&thePDInfo->theFilesSpecs[i],fsRdPerm,&fRefNum);		iErr 							= SetFPos(fRefNum,fsFromStart,14L);		inOutCount						= sizeof(long);		iErr 							= FSRead(fRefNum,&inOutCount,(Ptr)&length);		iErr 							= FSRead(fRefNum,&length,(Ptr)&elementA);		inOutCount						= sizeof(long);		iErr 							= FSRead(fRefNum,&inOutCount,(Ptr)&length);		iErr 							= FSRead(fRefNum,&length,(Ptr)&elementB);		iErr							= FSClose(fRefNum);		el1								= GetTheAtomicNum(elementA);		el2								= GetTheAtomicNum(elementB);		thePDInfo->dgramArray[el1][el2]	= i;		thePDInfo->dgramArray[el2][el1]	= i;	}				return(thePDInfo);}typedef struct  FONT_Info{			short		size;			short		style;			short		resID;			}FONT_Info;typedef struct	FOND_Info{			short		miscInfo[26];			short		numFonts;			FONT_Info	theFonts[100];			} **FOND_InfoHandle;			FontRec**	GetFontHandle(unsigned char* fontName,short size){	FOND_InfoHandle	theFOND_Info;	short			i,fontNum;	Handle			theRes;	FONT_Info		*theFInfoPtr;	Boolean			sysLocked;	char			theState;		GetFNum(fontName,&fontNum);	theFOND_Info 	= (FOND_InfoHandle)GetResource('FOND',fontNum);	theState		= HGetState((Handle)theFOND_Info);	if((theState & 0x80) != 0){		sysLocked 	= false;		D_HLock((Handle)theFOND_Info);	} else {		sysLocked	= true;	}	theFInfoPtr	= (*theFOND_Info)->theFonts;	for(i = 0 ; i <= (*theFOND_Info)->numFonts; i++){		if(theFInfoPtr->style == 0){			if(theFInfoPtr->size == size){				theRes = GetResource('NFNT',theFInfoPtr->resID);				if(theRes != NUL && ResError() == 0){					if(!sysLocked){						D_HUnlock((Handle)theFOND_Info);					}					return((FontRec**)theRes);				}				theRes = GetResource('FONT',theFInfoPtr->resID);				if(theRes != NUL && ResError() == 0){					if(!sysLocked){						D_HUnlock((Handle)theFOND_Info);					}					return((FontRec**)theRes);				}			}		}	theFInfoPtr++;	}	if(!sysLocked){		D_HUnlock((Handle)theFOND_Info);	}	return((FontRec**)NUL);}						void			PhaseDiagram::ResetBackgroundColor(void){	SetObjectDrawTransferMode();		DMBackColor(BACKGROUND_COLOR);	DMForeColor(COMPLEMENT_COLOR);}short	GetTheAtomicNum(char	*theText){	short i,sign,theValue,length,number;	char *el1,*el2,*el3,*el4;		el1 = "H HELIBEB C N O F NENAMGALSIP S CLARK CASCTIV CRMNFE";	el2 = "CONICUZNGAGEASSEBRKRRBSRY ZRNBMOTCRURHPDAGCDINSNSBTE";	el3 = "I XECSBALACEPRNDPMSMEUGDTBDYHOERTMYBLUHFTAW REOSIRPT";	el4 = "AUHGTLPBBIPOATRNFRRAACTHPAU NPPUAMCMBKCFESFMMDNOLR??";	sign = 1;	theValue = 0;	length = strlen(theText);	i = 0;	while(theValue == 0 && i <= length) theValue = atof(&theText[i++]);	if(theValue > 0){		theValue++;	}	if(theValue < 0)		sign = -1;	for ( i = 0 ; i <= 1 ; i++){		if(theText[i] >= 'a' && theText[i] <= 'z')			theText[i] -= (char)32;	 	if(theText[i] < 'A' || theText[i] > 'z')			theText[i] = ' ';	}		for(i = 0 ; i <= 50 ; i += 2){		if(el1[i] == theText[0] && el1[i + 1] == theText[1] ){			number = sign * (1 + i / 2) + 100 * theValue;			goto ENDIT;		}		if(el2[i] == theText[0] && el2[i + 1] == theText[1] ){			number = sign * (27 + i / 2) + 100 * theValue;			goto ENDIT;		}		if(el3[i] == theText[0] && el3[i + 1] == theText[1] ){			number = sign * (53 + i / 2) + 100 * theValue;			goto ENDIT;		}		if(el4[i] == theText[0] && el4[i + 1] == theText[1] ){			number = sign * (79 + i / 2) + 100 * theValue;			goto ENDIT;		}	}	return (104); ENDIT:		return number;}short	DgRead(Ptr theData,short refnum,long dataLength){	return(FSRead(refnum,&dataLength,theData));}