//a_DiffractObject.h#ifndef	_DIFFRACT_OBJ	#define	_DIFFRACT_OBJ		#include "a_Crystal.h" 	#include "a_ControlObj.h"	#include "a_Ruler.h"	#include "Pict_Obj.h"	#include "ML_BeamOrientation.h"	#include "ML_BeamE.h"	/* Jim's Code */	#include 	"defineElectronObj.h"	#include 	"XRayDefObj.h"	#include 	"NeutronDefObj.h"	#include 	"DefineIonBeamObj.h"	#include 	"alloyCompEnt.h"	#include	"TextObject.h" /* July 1992 */	#include	"TheTextSystem.h" /* August 1993 */	#include	"StageObj.h"	#include	"ObjectiveLens.h"				/* April 1993 by Jim */	//#include	"QDOffscreen.h"	#include "ML_FoilNormal.h"	#include "ML_StructFactor.h"	#include "ML_PlotSetUp.h"	#include "f2c.h"	class GraphFunction;	class Crystal;typedef struct  SpotInfoD{	double h;	double k;	double l;	double x;	double y;	double z;	dcomplex sF;	Crystal* theCrystal;}SpotInfoD,*SpotInfoDPtr;typedef struct  AddResourceType{	Handle theHandle;	ResType theRes;	short   resNum;	char*   name;}AddResourceType,*AddResourceTypePtr;typedef struct  MultiSliceVariables{	Index		*x_Vector;	Index		*y_Vector;	float		 xShift;	float		 yShift;	short		 meshX;	short		 meshY;	float		 deltaZ;	short		 noOfSlices;	short		 noOfDifSlices;	float		 tilt[2];}MultiSliceVariables,*MultiSliceVariablesPtr;			class StageObj;	class	TextBoxFree;	class DiffractObject{	public:		Ruler			*theRuler;					/*  Ruler Object					*/		WindowPtr		theWindow;					/*  The Object Window				*/		PicHandle		thePopPict;					/*	Handle to the current Pop Pict	*/		Crystal*		theCrystal[4];				/*  Ptrs to Matrix and ppts	 (obj)	*/		PPT_Info*		the_PPT_Info[3];			/*  Precipitate and OR info			*/		Handle			theMenuBar;					/*  Menu Bar handle for object		*/		PicHandle		screenPict;					/*  Picture for Refresh				*/		PictObj*		picObjList;					/*  Object Background Picture list	*/				Rect			thePictRect;				/*  Picture Rectangle for above		*/		Rect			theVisRect;					/*  Rectangle of visual screen		*/ 		Rect			selectRect;					/*  Selection Rect for cut or copy	*/		Rect			rulerRect;					/*	Rectangle for Ruler (filled)	*/		Handle			theDataHandle;				/*  Handle to the object's data		*/		long			data_Length;				/*  Num of entries available		*/		long			data_Count;					/*  Num of entries used				*/				long			data_Size;					/*  Entry size in bytes				*/		long			data_Expand;				/*  Num entries to add w/ expansion	*/		short			portHeight;					/*  Drawing area height in pixels	*/		short			portWidth;					/*  Drawing area width in pixels	*/		short			objectType;					/*  Type of Object					*/		short			rulerHeight;				/*  Height of ruler (if any)		*/		short			theCursorID;				/*  Res Id of current cursor		*/		short			functionID;					/*  ID of current DoContent Func	*/		RGBColor		backgroundColor;			/*  Window background color			*/		PaletteHandle	thePalette;					/*	Objects color palette			*/		Cursor			theCursor;					/*  Current cursor					*/		Point			origin;						/*  Picture zero point				*/		Point			objectSize;					/*  Size of the object in Pixels	*/		RgnHandle		drawRgn;					/*  Drawing Rgn of screen			*/		RgnHandle		eventRgn;					/*  Event Rgn for Prog (portRect)	*/		RgnHandle		picUpdateRgn;				/*  Update Rgn w.o. scroll bars		*/		Boolean			abortFlag;					/*  Abort flag to signal errors		*/		Boolean			changedFlag;				/*	Comm Flag for idle routine		*/		Boolean			refreshFlag;				/*	Flag to ind Refresh in Prog		*/		Boolean			newPictReq;					/*  request for new picture			*/		Boolean			newPictEnable;				/*	allow new picture generation	*/		Boolean			saveDataFlag;				/*	Set when data has changed		*/		Boolean			variSize;					/*  Flag for scrollable window		*/		Boolean			funcInit;					/*	Flag - initialization required	*/		Boolean			reSizeFlag;					/*	Fit Pict to page flag (SetPict)	*/		Boolean			resizeOK;					/*	Ok to fit to page flag			*/		Boolean			onScreen;					/*  Set by DoContent to ind screen coords	*/		Boolean			selectRectEnable;			/*	Enables the selection rect		*/		ScrollBar*		vScroll;					/*	Vertical Scroll Bar				*/		ScrollBar*		hScroll;					/*	Horizontal Scroll Bar			*/		StandardFileReply	fileInfo;				/*  Info for current file			*/				/* Jim's Code Follows */		short			negWidth;		short			negHeight;		float			energy;		float			maxEnergy;		float			wavelength;		float			cameraConstant;		float			dyRange;		float			expoTime;		float			scaleFactor;		float			convergenceAngle;		float			magnification;		short			theBeamFlag;		DefineElecObj	*theEBeam;		XRayDefObj		*theXRay;		IonDefObj		*theIon;		NeutronDefObj	*theNeutron;		AlloyCompDef  	*theAlloyObj;		Boolean			greyFlag;		short			theCrysSymbols_P[5];		short			theCrysSymbols_D[5];		TheTextSystem	*theTextSystem;		Boolean			printing;		short			centerX;		short			centerY;		/*Added for v2.0*/		short			linking;/*linking indicator*/		short			baseCrystal;		Axis			x_001;		Axis			y_001;		Axis			z_001;		StageObj		*stage;		float			cameraLength;		float			projLengthScreen;		float			rotationAngle;		float			offLaueDistance;		Index			*theZoneAxis;		Index			*theRotationAxis;		Index			*g_Vector;		float			totalRot;		short			calcFoil;				/*Added for v2.0*/	/* Jim's Code Ends */		/*  Watch  &  Multi_processing / background Stuff  */			Boolean			isCalculating;		Boolean			crystalDialogFlag;		DiffractObject*	watchQueue;		short			calcIrrational;		Boolean			foilParallel;		float			theFoilThickness;		Index			*theFoilNormal;		Index			*theFNRotationAxis;		Index			*theFoilBragg;		float			theFNRotationAngle;		float			theFNOffLaueDistance;		float			trueThickness;		ObjectiveLens	*theLens;		PenState			oldPenState;	  GWorldPtr 		gMyOffG;	  Boolean				toggleDraw;		double				delAngle;		short					pictTransferMode;		short					gMode;		double				absorpMean;  //Bloch		double				temperature;		Boolean				forceOverlay;		Boolean				calcDW;		short					startCount[5];		Boolean				dynamic_Calc;		short					spotLoc;		long					numSpots;		short 				nOut;//Bloch		Boolean				delugeFlag;//Bloch		short					numberOfSteps;//Bloch		Index					*obj_Index;		double				interval;//Bloch		double				**calcIntensities;//Bloch		GraphFunction *graph;		Crystal				*setCrystal;		Crystal				*currentCrystal;		TextBoxFree		*textBox;		float					kLineMult;		float					spotMult;		float					beamAzimuth;		Rect					centerDisk;		short					cbedSmear;		short					plotType;//use this to tell which plot function to use (currently to discriminate 		//between bloch and multislice plots		/*the following does not have to be saved, added to give a basis of or renormalization*/		Index*		rockZA;		Index*		rockGVect;		Index*		rockRotVec;		short			rockCalcIrr;		double		rockRotAng;		double		rockOffLaueD;		double		rockTotalRot;		double		rockBeamAximuth;		double		rockAxes[3][3];		double		totalTilts[3];		MultiSliceVariables  theMSVariables;		public:		virtual void	DoInit(void);				/*  Default Object Init method		*/		virtual void	DoDiffObjInit(void);		/*  Object Init method				*/		virtual void	DoPrint(void);				/*  Object Print method				*/		void			DoCut(void);				/*	Object Cut method				*/			void			DoCopy(void);				/*	Object Copy method				*/		void			DoPaste(void);				/*	Object Paste method				*/		void			DoOpen(Boolean);			/*	Object Open method				*/		virtual void	DoFileRead(void); 			/*  Read data from file				*/		virtual void	DoFileWrite(void); 			/*  Write data to file				*/		virtual void	RationalizeData(void);		/*	Allows reconnect of ptr hooks 	*/		void			DoSave(void);				/*	Object Save method				*/		void			DoSaveAs(void);				/*	Object SaveAs method			*/		virtual void	DoAuxWrite(void);			/*	Stub for offspring writes		*/		virtual void	DoAuxRead(void);			/*	Stub for offspring reads		*/		virtual void	DoClose(void);				/*	Object Close method				*/		virtual void	DoQuit(void);				/*	Object Quit method				*/		virtual void	DoMenu(long);				/*	Menu Method						*/		virtual Boolean	DoContent(Point);			/*	Content Method					*/		virtual void	DoIdle(void);				/*	Idle Routine					*/		virtual void	DoDblClick(Point);			/*	Double Click Routine			*/		void			ExpandMemory(void);			/*  Memory expansion routine		*/		virtual void	DoKey(char);				/*  Key Down Response				*/		virtual void	DoRefresh(void);			/*	Screen	Refresh					*/		virtual void	DoResize(void);				/*  Resize Object	Window			*/		virtual void	DoCalculate(void);			/*  Main calculation setup			*/		virtual	void	MyCalculate(void);			/*	Object spcific calculate (stub) */		void			DoSetOrigin(void);			/*  Set the draw origin				*/		void			DoResetOrigin(void);		/*  Set the draw origin				*/		void			ObjRectToLocal(Rect*);		/*	Convert Obj Rect to local coord */		void			LocalRectToObj(Rect*);		/*	Convert local Rect to obj coord */		void			EraseTheFrame(Rect*);		/*	Obj coord Erase & Inval	of frame*/		void			EraseTheRect(Rect*);		/*  Does Obj coord Erase & Inval	*/		void			InvalTheRect(Rect*);		/*  Does Obj coord Inval			*/		void			InvertTheRect(Rect*);		/*	Does object coord InvertRect	*/		void			FrameTheRect(Rect*);		/*	Does object coord FrameRect		*/		void			PaintTheRect(Rect*);		/*	Does object coord PaintRect		*/		void			STDTheRect(GrafVerb,Rect*);	/*	Does object coord StdRect		*/		void			LocalToObj(Point*);			/*  Local to Obj coord conversion	*/		void			ObjToLocal(Point*);			/*  Obj to Local coord conversion	*/		void			SetTheCursor(short);		/*  Sets the current cursor			*/		void			RestoreTheCursor(void);		/*  Restores current cursor			*/		virtual	void	SetPict(Boolean eraseFlag);	/*  Dummy routine -- should be another */		virtual	void	DoPictDraw(void);			/*  Objects picture drawing routine	*/		virtual	void	DrawTheText(void);			/*	Draws the objects labels		*/		void			TitleTheWindow(void);		/*  Sets the window title to fName	*/				void			GetRotPptwrtoMatrixBase(ORel*,double[][3]);		void			GetPPTXFormMatrixBase(double theYForm[][3],Crystal *thisCrystal,short variant);		void  			OpenPICT(void);		void	  		DoPlace(void);		void 			CenterRects(Rect theRect2, Rect *theRect1);		Boolean  		OpenTIFF(void);		Boolean  		OpenMCID(void);		virtual void  	OpenGeneral(void);		void 			SetScaleFactor(void);				void			AddToQueue(DiffractObject*	newObj);		void			ModifyQueueCursor(Cursor*	theCursor);		void			RemoveFromQueue(DiffractObject*	newObj);		/* Jim ADDED this subroutine */		Boolean 		SetPlotParameters(void);		void			DM_DrawRect(Rect theRect,short theCrystal,short theIntensity,Boolean direction);		virtual	void	SetObjectMenu(void); /*Jim July 1992 */		void			SetObjectDrawTransferMode(void);		void CopyObjTo(DiffractObject *theObj,Boolean all);/* Jim Added March 1993*/				void			DMForeColor(short index);		void			DMBackColor(short index);				void			STDTheRectMarquee(Rect*	theRect);/*Added by Jim August 1993*/		void			StdRectMarquee(Rect*	theRect);		void			StdOvalMarquee(Rect*	theRect);		void 			DrawPalette(void);/*added for PPC*/		/*Added For V2.0*/		PicHandle		SetPrintPicture(Rect*	theRect,GrafPort thePort);		short			SetFileType(void);		void 			CopyMatrixIntoAxes(double matrix[3][3]);		void 			CopyAxesIntoMatrix(double matrix[3][3]);		virtual Boolean	StageControl(void);				virtual void			RotateSpots(double matrix[3][3]);		virtual void			CalculateScreenThetas(double *x,double *y,double *z,Point thePoint);		Boolean 		SetPreferences(void);		virtual    void			D_DrawPict(void);		void 	CalculateOrientation(Index *zone,Index *about,Index *bragg,double x1,double y1,double rotation,double az,short method,double matrix[3][3]);			void GetOrientation(double matrix[3][3]);		void SetOrientation(double matrix[3][3]);		void IrrationalZoneAxis(Index *zone,Index *about,Index *gvector,double xx,double yy,double rotation,double azR,short method,double *u,double *v,double *w,double aMatrix[3][3]);				void	ZoneAxisFromMatrix(Boolean locked,double matrix[3][3],short *method,Index *theIndex,Index *about,Index *gvec,float *x,float *y,float *rotation,float *rotation2);		Boolean 		CheckAxes(DiffractObject *theObj);		virtual	void 	DynamicLinking(void);		Boolean 		SameObject(DiffractObject *theObj);	Boolean 			DefineOrientation(Boolean resetBeam,double *xx,double *yy,double *zz);	void 					GetDialogValues(DialogPtr theDialog,short method,Index *theIndex,Index *aIndex,Index *bIndex,double *x,double *y/*,double *z*/);	void 					SetForZone(DialogPtr theDialog,short method,Index *theIndex,Index *aIndex,Index *bIndex,  double x,double y/*,double z*/);	Boolean DefineFoilNormal(void);	double GetSpikingFactor(Index *theIndex,Index *aIndex,Index *bIndex,double rot1,double rot2,double thick,short method,Crystal *thisCrystal);	virtual void  TransformAxes(double matrix[3][3]);	double CalculateW_OffBragg(Index *zone,Index *rotAxis,Index *a_Vector,double x,double y,double z,short method,double *sZ,double *sL);	double AngleBetFoilAndBeam(Index *theIndex,Index *aIndex,Index *bIndex,double x,double y,double z,short method);	void PlotMovedPeriod(short h,short v);	virtual void  ConvertToTextTable(void);	void  GetMuLambda(Point thePoint,double *mu,double *lambda,Boolean switchAxis);	void  SetDrawEnviron(void);	void ClearDrawEnviron(void);	virtual void	FastPictDraw(void);	void	SetTransferModeText(void);	virtual Boolean GetFoilPtrs(Boolean *thePtr1,short *thePtr2,short *thePtr3);	virtual void SetFoilPtrs(Boolean thePtr1,short thePtr2,short thePtr3);	virtual void SetORToNewBase(short newCrystal);	Boolean DoDefineOR(DialogPtr theDialog,Boolean defineFlag, short dlogOffset);	void SetWindowColors(short thePalletteNum );	void StructureFactorSetUp(void);//bloch	virtual short  SetPictMode(short theItem);//bloch	void ReadBeamORData(DialogPtr theDialog,Boolean resetBeam,short oldIr,double *x,double *y);	Boolean DoBeamORSwitch(DialogPtr theDialog,short theSelect,ML_BeamORParamsPtr theMLParams,Boolean *saveData);	Boolean  DoBeamESwitch(DialogPtr theDialog,short theSelect,Ptr  thePtr,Boolean *saveData);	void	DoBeamERead(DialogPtr theDialog,Ptr thePtr,Boolean saveData);	void	DoBeamESetUp(DialogPtr theDialog,ML_BeamEParamsPtr  theParams,short beamFlag);	void  DefineBeamE(void);	Boolean DoFoilSwitch(DialogPtr theDialog,short theSelect,ML_FoilParamsPtr theMLParams,Boolean *saveData);	void DoFoilRead(DialogPtr theDialog,ML_FoilParamsPtr theParams,Boolean saveData);	void SFRead(DialogPtr theDialog,ML_StructFacParamsPtr thePr,Boolean saveData);	Boolean SFHit(DialogPtr theDialog,short theSelect,ML_StructFacParamsPtr thePr,Boolean *saveData);	void 	SFSetUp(DialogPtr theDialog,ML_StructFacParamsPtr thePr);	Boolean	ML_SwitchPlotParameters(DialogPtr theDialog,short theSelect,ML_SetPlotParamsPtr thePr,Boolean *saveData);void ML_ReadPlotParameters(DialogPtr theDialog,ML_SetPlotParamsPtr thePtr,Boolean saveData);void	ML_SetPlotParameters(DialogPtr theDialog,ML_SetPlotParamsPtr thePtr);void SwitchDefault(short theSelect);void ReadMiscParameters(DialogPtr theDialog,ML_SetPlotParamsPtr thePtr,Boolean saveData);Boolean SwitchMiscPlotParameters(DialogPtr theDialog,short theSelect,ML_SetPlotParamsPtr thePr,Boolean *saveData);void SetMiscParameters(void);void SetUpMiscParameters(DialogPtr theDialog,ML_SetPlotParamsPtr thePtr);virtual void	DoDefine(void);void  DoSwitchDefault(void);//blochdouble Single2BeamWaveDynamic	(short *nout,dcomplex *sF,SpotInfoDPtr theSpotsSt);Boolean SetUp2BeamUgh					(Handle* theUgReal,Handle* theUgIm,short *nbeams,short *pBeams,SpotInfoDPtr theSpotsSt,short totalBeams);double* BlochMethod						(rreal **theUgReal,rreal **theUgIm,double matrix[3][3],short nout,short nbeams,short pBeams,dcomplex *sF,SpotInfoDPtr theSpotsSt);//matrix is the matrix required to tilt the reciprocal lattice to mimic the beam tilt;void ThruTilt									(SpotInfoPtr theSpotsSt);//bloch;void SingleBlochWaveDynamic		(short *nout,dcomplex *sF,SpotInfoPtr theSpotsSt);void FullTilt									(short *nout,SpotInfoPtr theSpotsSt);void BetheMenu								(short item);void FullPlot									(short nout,SpotInfoPtr theSpotsSt);Boolean SortAndFindPerturbedBeams(short *nBeams,short *pBeams,SpotInfoPtr baseSpots,short totBeam);void	SetBethPerturb					(Point thePoint);Boolean SetUpUgh							(Handle* theUgReal,Handle* theUgIm,short *nbeams,short *pBeams,SpotInfoPtr theSpotsSt,short totalBeams);double* BlochMethod						(rreal **theUgReal,rreal **theUgIm,double matrix[3][3],short nout,short nbeams,short pBeams,dcomplex *sF,SpotInfoPtr theSpotsSt);//matrix is the matrix required to tilt the reciprocal lattice to mimic the beam tilt;void BethePerturbations				(rreal **theUgReal,rreal **theUgIm,short nbeams,short pbeams);double* GetBeamIntensities		(double bigKZ,rreal **ccR,rreal **ccI,rreal *vR,rreal *vI,dcomplex *cinV,short nBeams,short nout,dcomplex *sF,short theSpotLoc);void EisPack		/*was short,short....*short*/			(long nm,long n,rreal **ar,rreal **ai,rreal *wr,rreal *wi,rreal **vr,rreal **vi,long *err);Boolean GetStartStop	/*was short,short*/	(SpotInfoPtr theSpotsHit,long *start,long *total);void ThruThicknessRockingCurve	(SpotInfoPtr theSpotsSt);//blochvoid CriticalVoltagePlot				(SpotInfoPtr theSpotsSt);//blochvirtual void	PlotPeriods				(short zoneOrder/*,SpotInfoPtr  thisSpot*/);virtual	void 	CalculateSpotLocation	(long *theX,long *theY,SpotInfoPtr thisSpot);virtual void PlotKLines(SpotInfoPtr thisSpot);virtual Boolean FindSpot(Point thePoint);double* BlochMethod2Beam(rreal **theUgReal,rreal **theUgIm,double matrix[3][3],short nout,short nbeams,short pBeams,dcomplex *sF,SpotInfoDPtr theSpotsSt);//matrix is the matrix required to tilt the reciprocal lattice to mimic the beam tilt	virtual void ListOrientation(void);	virtual void UpdateOR(short axis);	virtual void DoARotation(double angle,short axis);Boolean OpenPreferenceFile(FSSpec	theFSSpec);void 	GetPreferenceFile(void);Boolean GetPreferenceFolder(FSSpec *theFSSpec);void SetPreferenceFile(Handle theHandle,short resNum,ResType theType,char* name);Boolean ReadHandleFromPrefFile(AddResourceType *resources);void SetPreferenceObject(DiffractObject *newStuff);virtual void  CheckMode(void);void OrientationMatrixDialogBox(void);void RenormalizeToFoundation(void);/*new code 1997*/void SetFoundation(void);void CopyFoundation(DiffractObject *theObj);	double* MultiSlice(double matrix[3][3]);	double CalculateSigma(void);	Handle Make2DCell(Index *h,Index *k,double cell2D[3],double cell2R[3],double *volume,short theCrystal,double theXForm[3][3]);	void MultiSlice_Full(short *nout,SpotInfoPtr theSpotsSt);	void MultiSliceMenu(short item);	void MS_ThruTilt(SpotInfoPtr theSpotsSt);	void MS_SingleTilt(short *nout,dcomplex *sF,SpotInfoPtr theSpotsSt);	void MS_CriticalVoltagePlot(SpotInfoPtr theSpotsSt);	void MS_ThruThicknessRockingCurve(SpotInfoPtr theSpotsSt);//MultiSlice	Boolean DoMS_SetUp(void);	Boolean MS_SetupSwitch(DialogPtr theDialog,short theSelect,Ptr  thePtr,Boolean *saveData);	void		DoMS_SetUpRead(DialogPtr theDialog,Ptr thePtr,Boolean saveData,Boolean closeDialog);	void		DoMS_SetUp_SetUp(DialogPtr theDialog,MultiSliceVariablesPtr  theParams);	Boolean DoMS_Define(void);	void 		ConvertToORType(short oldMethod,short newMethod,Index *aIndex,Index *theIndex,float *x,float *y);	void 		FullPlot_MS(short nout,SpotInfoPtr theSpot);	void		CalcSpotLocAngsToPixels(double x,double y,double z,long *theX,long *theY);	void  	TEST_BOX(Ptr thePtr,Handle theHandle,short theType,char *theTitle,short row);};#endif