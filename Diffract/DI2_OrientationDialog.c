#include	"Diffract_INCs.h"#include "UextBoxFree.h"void FillInMatrix(double matrix[3][3],Cell cellStart,char *theText,TextBoxFree *textBox);void DiffractObject::OrientationMatrixDialogBox(void){	TextBoxFree		*textBox;	DialogPtr 		theDialog;	double			matrix[3][3],xForm[3][3],aMatrix[3][3];	Rect 			rDataBnds,theRect;	Rect			tRect;	Cell			theCell,cellSize;	Index			*theIndex;	short 			theItem;	GrafPtr			oldPort;		GetPort(&oldPort);	theDialog = GetNewDialog(129, 0L,(WindowPtr)-1L);	textBox				=	(TextBoxFree*)D_new(TextBoxFree);	SetRect(&rDataBnds,0,0,14,4);	GetDItem			(theDialog,2,&gType,&gTheHandle,&gTheRect);	tRect = theRect = gTheRect;	tRect.right += 32;	tRect.bottom += 32;	theRect.right -= 30;	cellSize.h = 58;	cellSize.v = 15;	textBox		-> DoInit(&theRect,&rDataBnds,cellSize,0,theDialog,true,false,true,true,false,false,geneva,9,0);	textBox		-> ResetCell();	textBox		-> selected = true;	GetDItem			(theDialog,3,&gType,&gTheHandle,&textBox		->iconBox);	textBox->SetDrawFlag(true);	GetOrientation(matrix);		theCell.v = 0;	theCell.h = 0;	//Rotation MATRIX	sprintf(gTheText,"Rotation Matrix");		FillInMatrix( matrix, theCell,gTheText,textBox);	theCell.h += 4;	theCell.v = 0;	//Transform To Cartesian Matrix	theCrystal[baseCrystal]->Get001XForm(xForm);	sprintf		(gTheText,"Real Transform");	FillInMatrix( xForm, theCell,gTheText,textBox);	//Transform To Cartesian Reciprocal Lattice Matrix		theCell.v += 5;	sprintf(gTheText,"Recip. Transform");	ConverttoReciprocal			(xForm,(double)theCrystal[baseCrystal]->volume,true);	FillInMatrix( xForm, theCell,gTheText,textBox);		GetOrientation(matrix);	theCell.v = 0;	theCell.h += 4;	theCrystal[baseCrystal]->Get001XForm(xForm);	MatrixMultiply(matrix,xForm,xForm);	sprintf(gTheText,"Transform +Rotation");	FillInMatrix( xForm, theCell,gTheText,textBox);		GetOrientation(matrix);	theCell.v = 5;	theCrystal[baseCrystal]->Get001XForm(xForm);	MatrixMultiply(matrix,xForm,xForm);	sprintf(gTheText,"Recip. Transform +Rotation");	ConverttoReciprocal			(xForm,(double)theCrystal[baseCrystal]->volume,true);	FillInMatrix( xForm, theCell,gTheText,textBox);		theIndex	=	(Index*)D_new(Index);	theIndex->DoInit(true,theCrystal[baseCrystal]);	GetOrientation(aMatrix);	InvertMatrix(aMatrix);	theIndex->x = 0;	theIndex->y = 0;	theIndex->z = 1;	theIndex->direction = true;	theIndex->GetTheUVWFromXYZ(aMatrix);	theIndex->NormalizeToGreatestXYZ();	matrix[2][0] = theIndex->x;	matrix[2][1] = theIndex->y;	matrix[2][2] = theIndex->z;		theIndex->x = -1;	theIndex->y = 0;	theIndex->z = 0;	theIndex->direction = true;	theIndex->GetTheUVWFromXYZ(aMatrix);	theIndex->NormalizeToGreatestXYZ();	matrix[1][0] = theIndex->x;	matrix[1][1] = theIndex->y;	matrix[1][2] = theIndex->z;		theIndex->x = 0;	theIndex->y = 1;	theIndex->z = 0;	theIndex->direction = true;	theIndex->GetTheUVWFromXYZ(aMatrix);	theIndex->NormalizeToGreatestXYZ();	matrix[0][0] = theIndex->x;	matrix[0][1] = theIndex->y;	matrix[0][2] = theIndex->z;		sprintf(gTheText,"Directions");	theCell.v = 0;	theCell.h += 4;	FillInMatrix( matrix, theCell,gTheText,textBox);			GetOrientation(aMatrix);	InvertMatrix(aMatrix);	theIndex->x = 0;	theIndex->y = 0;	theIndex->z = 1;	theIndex->direction = false;	theIndex->GetTheUVWFromXYZ(aMatrix);	theIndex->NormalizeToGreatestXYZ();	matrix[2][0] = theIndex->x;	matrix[2][1] = theIndex->y;	matrix[2][2] = theIndex->z;		theIndex->x = -1;	theIndex->y = 0;	theIndex->z = 0;	theIndex->direction = false;	theIndex->GetTheUVWFromXYZ(aMatrix);	theIndex->NormalizeToGreatestXYZ();	matrix[1][0] = theIndex->x;	matrix[1][1] = theIndex->y;	matrix[1][2] = theIndex->z;		theIndex->x = 0;	theIndex->y = 1;	theIndex->z = 0;	theIndex->direction = false;	theIndex->GetTheUVWFromXYZ(aMatrix);	theIndex->NormalizeToGreatestXYZ();	matrix[0][0] = theIndex->x;	matrix[0][1] = theIndex->y;	matrix[0][2] = theIndex->z;			sprintf(gTheText,"Planes");	theCell.v = 5;		FillInMatrix( matrix, theCell,gTheText,textBox);	theIndex->DoClose();	while(1 != 2){		SystemTask();		Point thePoint;		ModalDialog(MLogFilterUPP/*TheFilterUPP*/,&theItem);		switch(theItem){			case CANCELCLICK:			case 1:			textBox->DoClose();				DisposDialog(theDialog);			SetPort(oldPort);			return;		case ML_UPDATE_EVT:						BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			 default:				GetMouse(&thePoint);								if(Button())textBox->DoContent(thePoint);				textBox->DoIdle();				break;		}	}}void FillInMatrix(double matrix[3][3],Cell cellStart,char *theText,TextBoxFree		*textBox){	Cell theCell;	short i = 0,k;	char aText[255];	theCell = cellStart;	while(*theText){		i = 0;		while(*theText != ' ' && *theText && i < 20){			aText[i] = *theText;			theText++;			i++;		}		aText[i] = 0;		textBox->SetListText(aText,theCell);		theCell.h++;		if(*theText == ' ')*theText++;	}	theCell.v = cellStart.v + 1;	for(i = 0; i < 3;i++,theCell.v++){		theCell.h = cellStart.h;		for(k = 0; k < 3;k++,theCell.h++){			sprintf(gTheText,"%6.5f",matrix[i][k]);			textBox->SetListText(gTheText, 	theCell);		}	}}