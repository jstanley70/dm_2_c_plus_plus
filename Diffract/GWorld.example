/* CODE EXAMPLE #1 */#define	OffLeft 	30#define	OffTop	30#define	OffBottom	250#define	OffRight	400/* These constants for the bounds of the offscreen PixMap are chosen because     we know what the extent of the drawing will be and we want to restrict the     size of the map as much as possible. *//* typedef BitMapPtr for use during CopyBits operation */typedef	BitMap	*BitMapPtr;long		offRowBytes, sizeOfOff;Ptr			myBits;Rect		destRect, globRect, bRect;short		theDepth, i, err;CGrafPort	myCGrafPort;CGrafPtr	myCGrafPtr;CTabHandle	ourCMHandle;GDHandle	theMaxDevice, oldDevice;Point		tempP;/* Create a color window on screen. */	myWindow = GetNewCWindow(SomeID,nil,(WindowPtr) -1);	/* set to this port for the LocalToGlobals that follow */	SetPort((WindowPtr) myWindow);	SetRect(&bRect,OffLeft,OffTop,OffRight,OffBottom);	if (!SectRect(&(*myWindow).portRect,&bRect,&globRect))		ExitToShell();		/*nothing to do, clean up and EXIT*//* Since there are no topLeft or bottomRight fields for a Rect, you should*//* use the macros which give you access to the equivalent that are provided *//* in the THINK C environment in THINK.h. The example below does not *//* assume access to these handy macros. */	tempP.v = globRect.top;	tempP.h = globRect.left;	LocalToGlobal(&tempP);	globRect.top = tempP.v;	globRect.left = tempP.h;	tempP.v = globRect.bottom;	tempP.h = globRect.right;	LocalToGlobal(&tempP);	globRect.bottom = tempP.v;	globRect.right = tempP.h;	theMaxDevice = GetMaxDevice(&globRect);										/ *get the maxDevice*/	oldDevice = GetGDevice();	/* save theGDevice so we */										/*   can restore it later*/	SetGDevice(theMaxDevice);	/* Set to the maxdevice*//* Now you can set up the offscreen pixel map.*/	myCGrafPtr = &myCGrafPort;	/* initialize this color port */	OpenCPort(myCGrafPtr);	/* open a new color port, */										/*  this calls InitCPort */	theDepth = (**(*myCGrafPtr).portPixMap).pixelSize;	/* Bitshift and adjust for local coordinates */	offRowBytes = (((theDepth * (OffRight - OffLeft)) + 15) >> 4) << 1;	sizeOfOff = (long) (OffBottom - OffTop) * offRowBytes;	OffsetRect(&bRect, - OffLeft, - OffTop);	myBits = NewPtr(sizeOfOff);	/* Remember to be a PixMap */	(**(*myCGrafPtr).portPixMap).baseAddr = myBits;	(**(*myCGrafPtr).portPixMap).rowBytes = offRowBytes + 0x8000;	(**(*myCGrafPtr).portPixMap).bounds = bRect;	ourCMHandle = (**(**theMaxDevice).gdPMap).pmTable;	err = HandToHand(&((Handle) ourCMHandle));	/* Real programs do error checking here */	for (i = 0; i <= (**ourCMHandle ).ctSize; ++i)		(**ourCMHandle ).ctTable[i].value = i;	(**ourCMHandle ).ctFlags &= 0x7fff;	(**ourCMHandle ).ctSeed = GetCTSeed();	/* This code is necessary for converting GDevice cluts to Pixmap cluts */	(**(*myCGrafPtr).portPixMap).pmTable = ourCMHandle;	SetPort((GrafPtr) myCGrafPtr);	/************************************************/	/*                                                                                                            */	/*     function for setting the wanted color                                            */	/*                                                                                                            */	/************************************************/	RGBColor FillInColor(short r, short g, short b)	{	/*FillInColor*/		RGBColor	theColor;		theColor.red = r;		theColor.green = g;		theColor.blue = b;		return (theColor);	}	/****************************************************/	/*                                                                                                                     */	/*  Drawing routine that makes the background blue                                    */	/* then draws a red oval, white oval, and green oval                                     */	/* After drawing to the offscreen it CopyBits to the                                    */	/*                      screen                                                                                    */	/*                                                                                                                     */	/****************************************************/	void DrawIt()	{		Rect	OvalRect;		RGBColor	myRed,myBlue,myWhite,myGreen,myBlack;		myRed = FillInColor(-1,0,0);		myBlue = FillInColor(0,0,-1);		myGreen = FillInColor(0,-1,0);		myWhite = FillInColor(-1,-1,-1);		myBlack = FillInColor(0,0,0);		PenMode(patCopy);		RGBBackColor(&myBlue);		EraseRect(&thePort->portRect);		RGBBackColor(&myWhite);		RGBForeColor(&myRed);		SetRect(&OvalRect,30,30,190,150);		PaintOval(&OvalRect);		InsetRect(&OvalRect,1,20);		EraseOval(&OvalRect);		RGBForeColor(&myGreen);		InsetRect(&OvalRect,40,1);		PaintOval(&OvalRect);		RGBForeColor(&myBlack);		SetPort((WindowPtr) myWindow);		SetGDevice(oldDevice);		destRect = bRect;		OffsetRect(&destRect,OffLeft,OffTop);		CopyBits((BitMapPtr) *(*myCGrafPtr).portPixMap,			&(*myWindow).portBits,&bRect, &destRect, 0, nil);		return;	}/*  Once again, you clean up as a final act. */	CloseCPort(myCGrafPtr);	DisposPtr(myBits);	DisposHandle((Handle) ourCMHandle);/******************************//* CODE EXAMPLE #1 *///  This is a simple demonstration of how to use PlotCIcon to copy to an//  offscreen pixmap, and then copy it back and display the 'cicn' in a window.#include <QDOffscreen.h>// Assumes inclusion of <MacHeaders>#define MY_ICON   128   // ID of  cicn resource to plotmain(){	Rect rBounds; 	// Bounding rectangle of sample window	Rect r;	// Rect used to display icon in	CWindowPtr wind;	/ WIndow to display ICON in	CIconHandle theIcon;	// Handle to ICON to display	// Offscreen world variables	GWorldPtr currPort;    // Saves the current port prior to setting up							// offscreen world	GDHandle currDev;       // Saves the current device prior to setting up							// offscreen world	short err;                    //  error returned from	static Rect dOffBounds = {0,0,360,360};   // Bounds of OffScreen Graphics													// World	static GWorldPtr gMyOffG;	// Pointer to OffScreen Graphics World	// Grab Icon from Resource File	if (theIcon) {		// Build Offscreen Graphics world		GetGWorld(&currPort,&currDev);		// Create Offscreen Graphics world.		err = NewGWorld(&gMyOffG, 0, &dOffBounds, nil, nil, 0);		if (!err) {			// Lock down Pixels that we are drawing to so that memory will not			// move			LockPixels (gMyOffG->portPixMap);			// Setup drawing area to be our offscreen graphics world			SetGWorld (gMyOffG, nil);			// Plot Icon			SetRect (&r, 40,40, 100,100);			// Clear Rectangle, so that CopyBits will not copy extra background			EraseRect (&r);			PlotCIcon (&r, theIcon);			// Done drawing, now reset Port etc.			SetGWorld (currPort, currDev);			// Now copy offscreen drawing to Window			// Set ForeColor to black, and BackColor to white			// NOTE:  This is necessary to prevent copybits from displaying			// unwanted colors  in the copied image.			ForeColor (blackColor);			BackColor (whiteColor);			CopyBits ( (BitMap *) (*(gMyOffG->portPixMap)),						&((GrafPtr)wind)->portBits, &r, &r, srcCopy, nil);			// Now unlock Pixels.			UnlockPixels (gMyOffG->portPixMap);		}	}/*****************/#define	OffLeft 	30#define	OffTop	30#define	OffBottom	250#define	OffRight	400/* These constants for the bounds of the offscreen PixMap are chosen because     we know what the extent of the drawing will be and we want to restrict the     size of the map as much as possible. *//* typedef BitMapPtr for use during CopyBits operation */typedef	BitMap	*BitMapPtr;long		offRowBytes, sizeOfOff;Ptr			myBits;Rect		destRect, globRect, bRect;short		theDepth, i, err;CGrafPort	myCGrafPort;CGrafPtr	myCGrafPtr;CTabHandle	ourCMHandle;GDHandle	theMaxDevice, oldDevice;Point		tempP;GrafPtr		theOldPort;/* Create a color window on screen. */	/* set to this port for the LocalToGlobals that follow */	SetPort((WindowPtr) theWindow);	GetPort(&theOldPort);	SetRect(&bRect,OffLeft,OffTop,OffRight,OffBottom);	if (!SectRect(&(*theWindow).portRect,&bRect,&globRect))		ExitToShell();		/*nothing to do, clean up and EXIT*//* Since there are no topLeft or bottomRight fields for a Rect, you should*//* use the macros which give you access to the equivalent that are provided *//* in the THINK C environment in THINK.h. The example below does not *//* assume access to these handy macros. */	tempP.v = globRect.top;	tempP.h = globRect.left;	LocalToGlobal(&tempP);	globRect.top = tempP.v;	globRect.left = tempP.h;	tempP.v = globRect.bottom;	tempP.h = globRect.right;	LocalToGlobal(&tempP);	globRect.bottom = tempP.v;	globRect.right = tempP.h;	theMaxDevice = GetMaxDevice(&globRect);										/*get the maxDevice*/	oldDevice = GetGDevice();	/* save theGDevice so we */										/*   can restore it later*/	SetGDevice(theMaxDevice);	/* Set to the maxdevice*//* Now you can set up the offscreen pixel map.*/	myCGrafPtr = &myCGrafPort;	/* initialize this color port */	OpenCPort(myCGrafPtr);	/* open a new color port, */										/*  this calls InitCPort */	theDepth = (**(*myCGrafPtr).portPixMap).pixelSize;	/* Bitshift and adjust for local coordinates */	offRowBytes = (((theDepth * (OffRight - OffLeft)) + 15) >> 4) << 1;	sizeOfOff = (long) (OffBottom - OffTop) * offRowBytes;	OffsetRect(&bRect, - OffLeft, - OffTop);	myBits = NewPtr(sizeOfOff);	/* Remember to be a PixMap */	(**(*myCGrafPtr).portPixMap).baseAddr = myBits;	(**(*myCGrafPtr).portPixMap).rowBytes = offRowBytes + 0x8000;	(**(*myCGrafPtr).portPixMap).bounds = bRect;	ourCMHandle = (**(**theMaxDevice).gdPMap).pmTable;	err = HandToHand((Handle*) &ourCMHandle);	/* Real programs do error checking here */	for (i = 0; i <= (**ourCMHandle ).ctSize; ++i)		(**ourCMHandle ).ctTable[i].value = i;	(**ourCMHandle ).ctFlags &= 0x7fff;	(**ourCMHandle ).ctSeed = GetCTSeed();	/* This code is necessary for converting GDevice cluts to Pixmap cluts */	(**(*myCGrafPtr).portPixMap).pmTable = ourCMHandle;	SetPort((GrafPtr) myCGrafPtr);	DrawPicture(screenPict,&thePictRect);	destRect = bRect;	OffsetRect(&destRect,OffLeft,OffTop);	CopyBits((BitMapPtr) *(*myCGrafPtr).portPixMap,			&(*theWindow).portBits,&thePictRect, &thePictRect, 0, nil);	if(!printing){		CloseCPort(myCGrafPtr);		SetGDevice(oldDevice);		SetPort(theOldPort);		DisposPtr(myBits);		DisposHandle((Handle) ourCMHandle);	}	return;