#include	"Diffract_INCs.h"#include	"UT_VectorMacros.c"#include	"DI_SpotMacros.c"#include "UA2_Text_Box.h"#include "UextBoxFree.h"#include "SpotObject.h"#include	"SF_MathLib.h"void	SpotObject::DoInit(){//s.Jim:Diffract:DI_SpotObject.c	textBox			=	0L;	theLine			=	0L;	inherited::DoInit();		obj_Index 		= (Index*)D_new(Index);	obj_Index			->	DoInit(true,theCrystal[0]);	thePopUpPict 	= 	(PopUpPicture*)D_new(PopUpPicture);	thePopUpPict	->	DoInit((Ptr)this);	if(theWindow)SetPort						(theWindow);	spotLoc	= 	-1;/*dec 1992*/	data_Length			=	100;	data_Expand			=	100;	data_Count			=	0;	data_Size			=	sizeof(SpotInfo);	theCurvedLabels 	= NULL;	theLabels			= NULL;	if(theDataHandle != 0L)		/*Temp*/KillHandle(&theDataHandle);	theDataHandle		= 	/*Temp*/D_NewHandle(data_Length * data_Size);//,&gTheOSError	dm_EraseRect(&(theWindow->portRect));/*	ZoomWindow(theWindow,inZoomOut,true);  */	fixPicFlag = false;	if(theWindow != 0L)		ActivatePalette(theWindow);}void SpotObject::ResetCurvedLabels(void){	KillAllLabels();/*	if(theCurvedLabels){		theCurvedLabels	->	KillAll();		theCurvedLabels	->	Kill();		theCurvedLabels->	DoInit(false,theCrystal[0]);	}*/	theRoundObj		= NULL;	}void SpotObject::KillAllLabels(void){	if(theLabels != NULL){		theLabels->KillAll();		//theLabels->Kill();		//D_delete(theLabels);		theLabels = 0L;		newPictEnable = true;	}	if(theCurvedLabels != NULL){		theCurvedLabels->KillAll();		//theCurvedLabels->Kill();		theCurvedLabels = 0L;		//theCurvedLabels = (TextRoundObj*)D_new(TextRoundObj);		//theCurvedLabels->DoInit(false,theCrystal[0]);		newPictEnable = true;	}	}void SpotObject::ResetMoveableLabels(void){		if(!theLabels)return;	theLabels	->	KillAll();	theLabels = 0L;	theTextObj		= NULL;}/* QuickDraw Constants of Possible Importance:enum {    invalColReq = -1,                   invalid color table request transfer modes     srcCopy = 0,                        the 16 transfer modes    srcOr = 1,    srcXor = 2,    srcBic = 3,    notSrcCopy = 4,    notSrcOr = 5,    notSrcXor = 6,    notSrcBic = 7,    patCopy = 8,    patOr = 9,    patXor = 10,    patBic = 11,    notPatCopy = 12,    notPatOr = 13,    notPatXor = 14,    notPatBic = 15, Special Text Transfer Mode        grayishTextOr = 49, Arithmetic transfer modes     blend = 32,    addPin = 33};enum {    addOver = 34,    subPin = 35,    addMax = 37,    adMax = 37,    subOver = 38,    adMin = 39,    ditherCopy = 64, Transparent mode constant     transparent = 36,    normalBit = 0,                      normal screen mapping    inverseBit = 1,                     inverse screen mapping    redBit = 4,                         RGB additive mapping    greenBit = 3,    blueBit = 2,    cyanBit = 8,                        CMYBk subtractive mapping    magentaBit = 7,    yellowBit = 6,    blackBit = 5,    blackColor = 33,                    colors expressed in these mappings    whiteColor = 30,    redColor = 205};*/void	SpotObject::DoClose(){	obj_Index->DoClose();	thePopUpPict->DoClose(); //added by Jim  -- Ack	if(textBox != 0L)textBox->DoClose();	if(theLine) theLine->KillAll();	inherited::DoClose();}void	SpotObject::DrawSpotAttributes(void){	SpotInfoPtr thisSpot;	short	i,theIdent;		PenState thePenState;	if(!theDataHandle)return;	D_HLock(theDataHandle);	thisSpot = (SpotInfoPtr)*theDataHandle;	GetPenState(&thePenState);		for(i = 1 ; i <= data_Count ; i++,thisSpot++){		if(thisSpot->z < -0.0000001)			continue;		if((thisSpot->flags & SPOT_FUNCS) == 0)			continue;				if(gInColor){				theIdent = thisSpot->flags & CRYSTAL_MASK;				/*PenPat(&qd.black);				DMBackColor(BACKGROUND_COLOR);				DMForeColor(10 + theIdent);*/			}				if(objectType == KIKUCHI_OBJECT && !thisSpot->direction|| 			objectType == KIKUCHI_OBJECT + 10 && !thisSpot->direction)continue;		if(objectType == DIFFRACT_METER){			if(thisSpot->spotRect.right > graph->frame.right) continue;			if(thisSpot->spotRect.left < graph->frame.left) continue;			if(thisSpot->spotRect.top < graph->frame.top) continue;		}		if(thisSpot->flags & TEXT_MASK){									 			Point		thePoint;										 			thePoint.h = (thisSpot->spotRect.left + thisSpot->spotRect.right) / 2;	 			thePoint.v = thisSpot->spotRect.top;							 			obj_Index->theCrystal	= thisSpot->theCrystal;				 			obj_Index->h 			= thisSpot->h;						 			obj_Index->k 			= thisSpot->k;						 			obj_Index->l 			= thisSpot->l;						 			obj_Index->direction 	= thisSpot->direction;			obj_Index->DrawIndex(thePoint);			}			DRAW_ANGLE_SEL(thisSpot);	}	SetPenState(&thePenState);		D_HUnlock(theDataHandle);}Boolean	SpotObject::FindSpot(Point thePoint){	short 			i,n;	unsigned long			time;	SpotInfo		*theSpot;	static	Point	lastPoint;	static	short	lastLoc;	static	long	thelastClick = 0;	static	Boolean	wasFound = false;	if(!theDataHandle)return false;	time = gTheEvent.when;	if(thelastClick == time && spotLoc >= 0){	/* if NO elapsed time, then same event, data is OK */		return wasFound;	}	thelastClick = time;	if(thePoint.h == 0 && thePoint.v == 0){		lastPoint = thePoint;		lastLoc = -1;		return false;	}	LocalToObj(&thePoint);		/*MFTemp*/D_HLock(theDataHandle);	theSpot = (SpotInfoPtr)*theDataHandle;	if(gShifted){		double	x,y;		x = thePoint.h - lastPoint.h;		y = thePoint.v - lastPoint.v;		if(sqrt(x * x + y * y) < 4.2){			n = lastLoc;		} else {			n = 1;		}	} else {		n = 1;	}		 	for(i = n , theSpot = &(((SpotInfoPtr)*theDataHandle)[n - 1])  ; i <= data_Count ; i++,theSpot++){		if(theSpot->spotRect.top == -2)			continue;		if(!theSpot->direction && objectType == BEKP_OBJECT) continue;		if(!theSpot->direction && objectType == KOSSEL_OBJECT) continue;		 if(!theSpot->direction && objectType == KIKUCHI_OBJECT) continue;		if(PtInRect(thePoint,&(theSpot->spotRect))){			short theIdent;			 			spotLoc 		= i - 1;			obj_Index->CopyPtrToIndex((Ptr)&THE_CURRENT_SPOT);		/*	obj_Index->theCrystal	= .theCrystal;			obj_Index->h 			= THE_CURRENT_SPOT.h;			obj_Index->k 			= THE_CURRENT_SPOT.k;			obj_Index->l 			= THE_CURRENT_SPOT.l;			obj_Index->x 			= THE_CURRENT_SPOT.x;			obj_Index->y 			= THE_CURRENT_SPOT.y;			obj_Index->z 			= THE_CURRENT_SPOT.z;			obj_Index->direction 	= THE_CURRENT_SPOT.direction;		*/			/*MFTemp*/D_HUnlock(theDataHandle);			lastLoc = i + 1;			thelastClick = time;			lastPoint = thePoint;			wasFound = true;			theIdent = (THE_CURRENT_SPOT.flags & CRYSTAL_MASK);			if(theIdent == 4) return wasFound;			ActionsOnSpot(theIdent);			return wasFound;		}	}	SystemTask();	spotLoc = -1;	/*MFTemp*/D_HUnlock(theDataHandle);	thelastClick = time;	lastPoint = thePoint;	if(n != 1){		SysBeep(30);	} else {		FlashMenuBar(0);		Delay(6L,&time);		FlashMenuBar(0);	}	lastLoc = 1;					/* in case the spot was close but missed */	wasFound = false;	return wasFound;}void	SpotObject::DeleteSpot(void){	short		i;	SpotInfo	*sourceSpot,*destSpot;	Rect		*theRect;	if(!theDataHandle)return;	/*MFTemp*/D_HLock(theDataHandle);		sourceSpot = destSpot = &THE_CURRENT_SPOT;	sourceSpot++;		theRect = &(destSpot->spotRect);	ObjRectToLocal(theRect);	dm_EraseRect(theRect);	data_Count--;	if(numSpots >= spotLoc) numSpots--;	i = (destSpot->flags & CRYSTAL_MASK);	while(i < 4){startCount[i + 1] -= 1;i++;}	for(i = spotLoc ; i < data_Count ; i++,sourceSpot++,destSpot++){		*destSpot = *sourceSpot;	}			/*MFTemp*/D_HUnlock(theDataHandle);	newPictEnable = true;	return;}void	SpotObject::LabelSpot(void){	Point		thePoint;		if(spotLoc < 0) 		return;/*dec 1992*/	if(THE_CURRENT_SPOT.flags & TEXT_MASK){		THE_CURRENT_SPOT.flags -= TEXT_MASK;		thePoint.h = (THE_CURRENT_SPOT.spotRect.left + THE_CURRENT_SPOT.spotRect.right) / 2;		thePoint.v = THE_CURRENT_SPOT.spotRect.top;		ObjToLocal(&thePoint);		obj_Index->EraseDrawnIndex(thePoint);		PenNormal();		DoAllSpots(false);	} else {		THE_CURRENT_SPOT.flags |= (TEXT_MASK);		if(THE_CURRENT_SPOT.z > -.05){			thePoint.h = (THE_CURRENT_SPOT.spotRect.left + THE_CURRENT_SPOT.spotRect.right) / 2;			thePoint.v = THE_CURRENT_SPOT.spotRect.top;			ObjToLocal(&thePoint);			obj_Index->DrawIndex(thePoint);		}		DoAllSpots(true);	}		newPictEnable = true;	return;}void	SpotObject::ShowAngleBetween(void){	static	short	loc1,loc2,width;	static	double	x1,y1,z1;	static	char	label1[10];		Point	where;	double	x2,y2,z2,angle;	char	label2[10];	long	when;	if(!theDataHandle)return;	if(funcInit){		funcInit = false;		loc1 = -10;		loc2 = -10;		fixPicFlag = true;	}	if(spotLoc < 0) 		return;/*dec 1992*/	if((THE_CURRENT_SPOT.flags & ANGLE_FLAG) != 0){		if(gShifted && spotLoc == loc2){			loc2 = loc1;			loc1 = spotLoc;			x1 = THE_CURRENT_SPOT.x;			y1 = THE_CURRENT_SPOT.y;			z1 = THE_CURRENT_SPOT.z;			obj_Index->IndexToIndecies(label1);			p2cstr((unsigned char*)label1);		}		where.h = where.v = -100;		FindSpot(where);		return;	}			if(gShifted){		theRuler->ClearHelp();		theRuler->SetHelp("Click on Additional Points To See Angles.");		if(loc1 >= 0 && loc1 < data_Count){			if((((SpotInfoPtr)*theDataHandle)[loc1].flags & ANGLE_FLAG) != 0){				((SpotInfoPtr)*theDataHandle)[loc1].flags ^= ANGLE_FLAG;				HilightDataPoint(&(((SpotInfoPtr)*theDataHandle)[loc1]));			}		}		loc1 = spotLoc;		THE_CURRENT_SPOT.flags |= ANGLE_FLAG;		HilightDataPoint(&(((SpotInfoPtr)*theDataHandle)[loc1]));		x1 = THE_CURRENT_SPOT.x;		y1 = THE_CURRENT_SPOT.y;		z1 = THE_CURRENT_SPOT.z;				obj_Index->IndexToIndecies(label1);		p2cstr((unsigned char*)label1);		when = TickCount();		where.h = where.v = -100;		FindSpot(where);		return;	}		when = TickCount();	if(loc1 >= 0 && loc1 < data_Count){		if(loc2 >= 0 && loc2 < data_Count){			if((((SpotInfoPtr)*theDataHandle)[loc2].flags & ANGLE_FLAG) != 0){				((SpotInfoPtr)*theDataHandle)[loc2].flags ^= ANGLE_FLAG;				HilightDataPoint(&(((SpotInfoPtr)*theDataHandle)[loc2]));			}			theRuler->ClearHelp();			theRuler->SetHelp("Shift-Click to reset first point.");		}		loc2 = spotLoc;		THE_CURRENT_SPOT.flags |= ANGLE_FLAG;		HilightDataPoint(&(((SpotInfoPtr)*theDataHandle)[loc2]));				x2 = THE_CURRENT_SPOT.x;		y2 = THE_CURRENT_SPOT.y;		z2 = THE_CURRENT_SPOT.z;		angle = 180. * acos((x1 * x2 + y1 * y2 + z1 * z2) / (sqrt(x1 * x1 + y1 * y1 + z1 * z1) * 		sqrt(x2 * x2 + y2 * y2 + z2 * z2)))/ PI;   /*****  Jim's Code  -- Ack*****/			obj_Index->IndexToIndecies(label2);		p2cstr((unsigned char*)label2);				sprintf(gTheText,"%s & %s -> %5.2f°",label1,label2,angle);		theRuler->SetInfo(gTheText);		//newPictEnable = true;	}	else if(!funcInit){		if(!theRuler->helpActive)			SysBeep(30);		theRuler->SetHelp("Shift-Click to set first point.");	}	where.h = where.v = -100;	FindSpot(where);	return;}void	SpotObject::DrawLine(void){	return;}void	SpotObject::DrawCircle(void){	return;}void	SpotObject::DoMenu(long	theResult){	short theMenu,theItem;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);		if(textBox != 0L)if(textBox->DoMenu(theResult))return;	switch(theMenu){		case	FUNCTION_MENU:			switch(theItem){				case 	DELETE_SPOT:					functionID		= DELETE_SPOT_F;					theRuler->SetHelp("Click on spot to delete it from screen");					theRuler->SetPrompt("Delete a spot.");					SetTheCursor(TARGET_CURSOR);					break;									default:					inherited::DoMenu(theResult);					break;			}			break;		case	INFO_MENU:			switch(theItem){								case	LABEL_SPOT:					functionID		= LABEL_SPOT_F;					theRuler->SetPrompt("Add Label");					theRuler->SetHelp("Labels toggle on/off with succesive clicks. Hold <shift> for hidden spots.<opt-t> to label crys to 3.<opt-shift-t>to label crys. to max <a instead of t> for all crystals.");/*dec 1992*/					SetTheCursor(TARGET_CURSOR);					break;									case	ANGLE_BETWEEN:					theRuler->SetHelp("Shift-Click to set/reset first point.");/*dec 1992*/					functionID		= ANGLE_BETWEEN_F;					theRuler->SetPrompt("Angle Between:");					SetTheCursor(TARGET_CURSOR);					break;				case	SHOW_INFO:					functionID		= SHOW_INFO_F;					theRuler->SetHelp("Click on spot & hold to view info.  Shift-click to view hidden spots.");/*dec 1992*/					theRuler->SetPrompt("Show Info:");					SetTheCursor(TARGET_CURSOR);					break;				case CONVERT_TO_TEXT:					ConvertToTextTable();					break;				case	DRAW_LINE:					break;									case	DRAW_CIRCLE:					break;									default:					inherited::DoMenu(theResult);					break;			}			break;		default:			theRuler->ClearPrompt();			functionID = -1;			funcInit = true;			inherited::DoMenu(theResult);			break;	}	//HiliteMenu(0);	return;}Boolean			SpotObject::DoContent(Point thePoint){	if(textBox != 0L)textBox->DoContent(thePoint);	if(theRuler->functionFlag){		if(FindSpot(thePoint)){			theEvtPoint = thePoint;			switch(functionID){				case	ANGLE_BETWEEN_F:					ShowAngleBetween();					return true;					break;				case LABEL_SPOT_F:				case THRU_THICKNESS_DY://Bloch				case THRU_TILT_DY://Bloch				case FULL_TILT_DY:				case CRITICAL_VOLTAGE_F:					LabelSpot();					return true;					break;				case SHOW_INFO_F:					ShowInfo();					return true;					break;				case DELETE_SPOT_F:					DeleteSpot();					return true;					break;				default:					break;			}		}	}	return(inherited::DoContent(thePoint));}void			SpotObject::DoIdle(void){	short	j;	Rect	theRect;	static	short 	i;	static	Boolean	inProcess;		if(fixPicFlag && functionID != ANGLE_BETWEEN_F){		if(!inProcess){			i = 0;			inProcess = true;		}		for(j = 1 ; j <= 10 &&  data_Count > i ; j++,i++){			if((((SpotInfoPtr)*theDataHandle)[i].flags & ANGLE_FLAG)){								theRect 	= 	((SpotInfoPtr)*theDataHandle)[i].spotRect;				InsetRect		(&theRect,-2,-2);				InvertTheRect	(&theRect);								((SpotInfoPtr)*theDataHandle)[i].flags &= FIX_MASK;						}		}		if(i >= data_Count){			fixPicFlag = inProcess = false;			newPictReq = true;		}	}	if(textBox != 0L)textBox->DoIdle();	inherited::DoIdle();		return;}void			SpotObject::DoKey(char	theChar){	if(textBox != 0L)textBox->doKey(theChar);	inherited::DoKey(theChar);	return;}void			SpotObject::DoRefresh(void){	RgnHandle theRgn;	inherited::DoRefresh();	if(!isCalculating)theRgn =  SetClipToPort(theWindow,0,rulerHeight,15,15);//if(textBox)textBox->DrawList();	if(!isCalculating)D_DisposeRgn(&theRgn);	return;}PicHandle		SpotObject::SetInfoPict(void){	short		n,vSpace,h,v;	double		value;	Rect		theRect;	PicHandle	thePicture;	Point		thePoint;	RgnHandle	clipRgn;	if(spotLoc < 0) 		return((PicHandle)NUL);/*dec 1992*/	if(obj_Index->direction){		SetRect(&theRect,0,0,270,180);/*dec 1992*/	} else {		SetRect(&theRect,0,0,270,180);	}	clipRgn = D_NewRgn();	GetClip(gTheRgn);	RectRgn(clipRgn,&theRect);	D_SetClip(clipRgn);	ForeColor (blackColor);	BackColor (whiteColor);	thePicture = OpenPicture(&theRect);		dm_EraseRect(&theRect);	h = 10;	v = 18;	vSpace = 15;		n = sprintf(gTheText,"Spot Index: ");	MoveTo(h,v);	DrawText(gTheText,0,n);	c2pstr(gTheText);	n = StringWidth((unsigned char*)gTheText);	thePoint.h = h + n;	thePoint.v = v;	obj_Index->ShowIndex(thePoint);	v += vSpace;		TextFont(newYork);	TextSize(9);		if(THE_CURRENT_SPOT.theCrystal->idNum == 0){		n = sprintf(gTheText,"Matrix");	} else {		n = sprintf(gTheText,"Crystal #%1d",THE_CURRENT_SPOT.theCrystal->idNum);	}	MoveTo(h,v);	DrawText(gTheText,0,n);	v += vSpace;	if(obj_Index->direction){		obj_Index->h = obj_Index->k = obj_Index->l = 0;		obj_Index->direction = false;	}	{		double electronMassRation;		dcomplex cAb;		value = obj_Index->theCrystal->DSpacing(obj_Index->h,obj_Index->k,obj_Index->l);		n = sprintf(gTheText,"D spacing : %6.4f Å",value);		MoveTo(h,v);		DrawText(gTheText,0,n);		v += vSpace;				value = obj_Index->theCrystal->DSpacing(obj_Index->h,obj_Index->k,obj_Index->l);		n = sprintf(gTheText,"x = %6.2f,y = %6.2f,z = %6.4e ",THE_CURRENT_SPOT.x,THE_CURRENT_SPOT.y,THE_CURRENT_SPOT.z);		MoveTo(h,v);		DrawText(gTheText,0,n);		v += vSpace;		if(!THE_CURRENT_SPOT.direction){					double x1,y1,z1,d,rWave,sZ,electronMassRation,extDist,w;											x1 =	THE_CURRENT_SPOT.x;					y1 =	THE_CURRENT_SPOT.y;					z1 =	THE_CURRENT_SPOT.z;					d = x1 * x1 + y1 * y1;					rWave = 1/wavelength;					sZ = rWave - sqrt((rWave * rWave) - d) - z1;					electronMassRation 	= 	1. + ( (double)energy / 511.);					extDist 			= 	obj_Index->TheExtinctionDist(1./ wavelength,electronMassRation,theBeamFlag);					w = sZ;					n = sprintf						(gTheText,"w = %6.4f,s =%6.4f Å",w * extDist,sZ);					MoveTo(h,v);					DrawText(gTheText,0,n);					v += vSpace;		}								electronMassRation = 1. + ( (double)energy / 511.);		if(value < .001)value = 0;		else{			value = 1/value;		}		value  = obj_Index->IndexStructureFactor(value,electronMassRation,theBeamFlag,&cAb);				obj_Index->sF = ConvertStructureFactor(obj_Index->sF,g_StructureEV,obj_Index->theCrystal->volume);								switch(g_StructureEV)		{			case 0:				n = sprintf(gTheText,"S. F. : %6.4e, %6.4e Å (Fg)",obj_Index->sF.r,obj_Index->sF.i);				break;			case 1:				n = sprintf(gTheText,"S.F. : %6.4e, %6.4e eV (Vg)",obj_Index->sF.r,obj_Index->sF.i);			break;			case 2:				n = sprintf(gTheText,"S.F. : %6.4e, %6.4e Å2 (Ug)",obj_Index->sF.r,obj_Index->sF.i);				break;		}		MoveTo(h,v);		DrawText(gTheText,0,n);		v += vSpace;				n = sprintf(gTheText,"S.F. Used In Plot : %6.4e, %6.4e Å2 (Ug)",THE_CURRENT_SPOT.sF.r,THE_CURRENT_SPOT.sF.i);		MoveTo(h,v);		DrawText(gTheText,0,n);		v += vSpace;				n = sprintf(gTheText,"Rel. Intensity : %6.1f",100 * THE_CURRENT_SPOT.intensity);		MoveTo(h,v);		DrawText(gTheText,0,n);		v += vSpace;						if(value > .00000005){			value = obj_Index->TheExtinctionDist(1/wavelength,electronMassRation,theBeamFlag);			n = sprintf(gTheText,"Extinction Dist. : %6.0f Å",value);		}else{			n = sprintf(gTheText,"Extinction Dist. : Not Given");		}		MoveTo(h,v);		DrawText(gTheText,0,n);		v += vSpace;	}	InsetRect(&theRect,2,2);	PenSize(2,2);	dm_FrameRect(&theRect);	PenNormal();	TextFont(0);	TextSize(12);	ClosePicture();	D_DisposeRgn(&clipRgn);	DMBackColor(BACKGROUND_COLOR);	return(thePicture);}void			SpotObject::ShowInfo(void){	Rect			theRect;	Point			thePoint;	Boolean			dummy;	if(spotLoc < 0)		return;/*dec 1992*/	PenNormal();	HilightDataPoint((&THE_CURRENT_SPOT));			theRuler->SetHelp("Shift-Click to search at same location.");		thePopUpPict->SetPopUpPict(SetInfoPict());	thePopUpPict->DrawPopUpPict(10,rulerHeight + 4,true);	thePopUpPict->ClearPopUpPict();		theRect = THE_CURRENT_SPOT.spotRect;  /* this section re-inverts thespot */	InsetRect (&theRect,-3,-3);	ObjRectToLocal(&theRect);	InvalRect(&theRect);	HilightDataPoint((&THE_CURRENT_SPOT));	theRuler->SetHelp("Hold mouse down over spot.");	thePoint.h = thePoint.v = -100;	dummy = FindSpot(thePoint);	return;}void 			SpotObject::GetRotPptwrtoMatrix(ORel* theOR,double xForm[][3]){	double theta,x,y,z,xFormMatrix[3][3],xForm1[3][3],				vector[3][3],crystalvector[3][3];			theCrystal[0]->Get001XForm(xForm1);	x = (double)theOR->theMatrix1->h;	y = (double)theOR->theMatrix1->k;	z = (double)theOR->theMatrix1->l;	if(!(theOR->theMatrix1->direction))	{		theCrystal[0]->PlaneToDir(&x,&y,&z);	}		TransFormVector(&x,&y,&z,xForm1);	FindCenterXform(x,y,z,xFormMatrix);	MatrixMultiply(xForm,xFormMatrix,crystalvector); 	theta = theOR->rot1 * PI / 180.;		x = cos(theta);	y = sin(theta);	vector[0][0] = x;	vector[1][0] = y;	vector[2][0] = 0.0;	vector[0][1] = -y;	vector[1][1] = x;	vector[2][1] = 0.0;	vector[0][2] = 0.0;	vector[1][2] = 0.0;	vector[2][2] = 1.0;	MatrixMultiply(crystalvector,vector,xForm1);	InvertMatrix(xFormMatrix);	NormalizeMatrixRows(xFormMatrix);	MatrixMultiply(xForm1,xFormMatrix,xForm); 		theCrystal[0]->Get001XForm(xForm1);	x = (double)theOR->theMatrix2->h;	y = (double)theOR->theMatrix2->k;	z = (double)theOR->theMatrix2->l;	if(!(theOR->theMatrix2->direction)){		theCrystal[0]->PlaneToDir(&x,&y,&z);	}	TransFormVector(&x,&y,&z,xForm1);	FindCenterXform(x,y,z,xFormMatrix);	MatrixMultiply(xForm,xFormMatrix,crystalvector); 	theta =  theOR->rot2 * PI / 180.;		x = cos(theta);	y = sin(theta);	vector[0][0] = x;	vector[1][0] = y;	vector[2][0] = 0.0;	vector[0][1] = -y;	vector[1][1] = x;	vector[2][1] = 0.0;	vector[0][2] = 0.0;	vector[1][2] = 0.0;	vector[2][2] = 1.0;	MatrixMultiply	(crystalvector,vector,xForm1);	InvertMatrix	(xFormMatrix);	NormalizeMatrixRows	(xFormMatrix);	MatrixMultiply	(xForm1,xFormMatrix,xForm); }void	SpotObject::DoAuxRead(void){}void	SpotObject::RationalizeData(void)		/*	Allows reconnect of ptr hooks 	*/{	short		i;	long		id;	SpotInfoPtr	theSpot;	if(!theDataHandle)return;	/*MFTemp*/D_HLock(theDataHandle);	theSpot = (SpotInfoPtr)*theDataHandle;	for(i = 0 ; i < data_Count ; i++,theSpot++){		id = theSpot->flags & CRYSTAL_MASK;		theSpot->theCrystal = theCrystal[id];	}	/*MFTemp*/D_HUnlock(theDataHandle);}	void			SpotObject::HilightDataPoint(SpotInfoPtr theSpot){	Rect 			theRect;	Point			thePoint;	theRect 		= theSpot->spotRect;		thePoint.h 		= theRect.left;	thePoint.v 		= theRect.top;	ObjToLocal			(&thePoint);	theRect.left 	= thePoint.h;	theRect.top 	= thePoint.v;		thePoint.h 		= theRect.right;	thePoint.v 		= theRect.bottom;	ObjToLocal			(&thePoint);	theRect.right 	= thePoint.h;	theRect.bottom 	= thePoint.v;		InsetRect			(&theRect,-3,-3);	if(theSpot->direction){		InvertRect(&theRect);	} else {		InvertOval(&theRect);	}}void  SpotObject::ConvertToTextTable(void)//Override{	SpotInfoPtr    theSpot;	Index				*theIndex;	short				i,k;	double			d;	dcomplex		sF;	if(!theDataHandle)return;	if(textBox == 0L){		Rect 			rDataBnds,theRect;		Point 		cellSize;		short			hor,ver;		char			text[100];		hor						= (thePictRect.right - thePictRect.left) * .25;		ver						= (thePictRect.bottom - thePictRect.top) * .25;			textBox				=	(TextBoxFree*)D_new(TextBoxFree);		SetRect(&rDataBnds,0,0,8,numSpots - 1);		SetRect(&theRect,thePictRect.left,thePictRect.top + 30,thePictRect.left + hor + 18,thePictRect.top + ver + 48);		cellSize.h = 80;		cellSize.v = 15;		textBox		-> DoInit(&theRect,&rDataBnds,cellSize,0,theWindow,false,true,true,true,true,true,geneva,9,0);		textBox		-> ResetCell();		textBox		->selected = true;		textBox		-> SetColumnWidth(0,80);		textBox		->selected = false;		 TMX_SetOptions(tmBorder,textBox		->theList);		 sprintf(gTheText,"hkl\tX\tY\tZ\tDspace\tw , s(Å-1)\tRel. Intensity\t");		 switch(g_StructureEV){		 		case 0:					sprintf(text,"S.F. R,Im Fg Å\t Intensity Å-2");					break;				case 1:					sprintf(text,"S.F. R,Im Vg eV\t Intensity eV2");					break;				case 2:					sprintf(text,"S.F. R,Im Ug\t Intensity Ug2");					break;			 }		 strcat(gTheText,text);		 textBox->SetColumnTitle(gTheText,0);		textBox		->DrawList();	}	D_HLock(theDataHandle);	theSpot = (SpotInfoPtr)*theDataHandle;	theIndex = (Index*)D_new(Index);	gTheText[0] = 0;	for(i = 0 ; i < numSpots;i++)	{			for(k = 1 ; k < 10;k++){				switch(k){					case 1:						theIndex			->CopyPtrToIndex((Ptr)(&(theSpot[i])));						theIndex			->IndexToSimpleText(gTheText);						break;					case 2:								sprintf					(gTheText,"%6.4f",theSpot[i].x);					break;					case 3:								sprintf					(gTheText,"%6.4f",theSpot[i].y);							break;					case 4:							sprintf						(gTheText,"%6.4f",theSpot[i].z);					break;					case 6:						if(!theSpot[i].direction){									double x1,y1,z1,d,rWave,sZ,electronMassRation,extDist,w;									x1 =	theSpot[i].x;									y1 =	theSpot[i].y;									z1 =	theSpot[i].z;									d = x1 * x1 + y1 * y1;									rWave = 1/wavelength;									sZ = rWave - sqrt((rWave * rWave) - d) - z1;									electronMassRation 	= 	1. + ( (double)energy / 511.);									extDist 			= 	theIndex->TheExtinctionDist(1./ wavelength,electronMassRation,theBeamFlag);									w = sZ;									sprintf						(gTheText,"%6.4f,%6.4f",w * extDist,sZ);						}else{							sprintf						(gTheText,"0");						}					break;					case 5:						if(!theSpot[i].direction){							d = sqrt(theSpot[i].z * theSpot[i].z + theSpot[i].x * theSpot[i].x + theSpot[i].y * theSpot[i].y);							if(d > .001) d = 1/d;							sprintf						(gTheText,"%6.4f",d);						}else							sprintf						(gTheText,"NA");					break;					case 7:							sprintf						(gTheText,"%6.4f",theSpot[i].intensity);										break;					case 8:					sF = theSpot[i].sF;					sF = ConvertStructureFactor(sF,g_StructureEV,theSpot[i].theCrystal->volume);					sprintf						(gTheText,"%6.4f , %6.4f",sF.r,sF.i);					break;					case 9:						sprintf						(gTheText,"%6.4f",Cabs(sF) * Cabs(sF) );					break;				}					textBox					->AddListText(gTheText);			}	}	D_HUnlock(theDataHandle);	textBox->SetDrawFlag(true);	theIndex			->DoClose();}void SpotObject::DoDblClick(Point thePoint)//Override{	if(textBox != 0L)textBox->DoDblClick(thePoint);	inherited::DoDblClick(thePoint);}#pragma segment Mainvoid SpotObject::DoAllSpots(Boolean flag){	short maxHKL = -1,theIdent = -2,theCrys;	SpotInfoPtr	thisSpot;	short i;		maxHKL = 3;	if(!IsPressed((unsigned short )58))/*optionkey*/return;	if(IsPressed( (unsigned short )56))/*shiftkey*/maxHKL = 0;	if(IsPressed( (unsigned short )17)){		theIdent 		= THE_CURRENT_SPOT.flags & CRYSTAL_MASK;	}else if(IsPressed( (unsigned short )0)){		theIdent = -1;	}	if(theIdent == -2)return;	thisSpot = (SpotInfoPtr)*theDataHandle;	for(i = 0 ; i < data_Count ; i++,thisSpot++){		if(objectType == KIKUCHI_OBJECT || objectType == KIKUCHI_OBJECT + 10 ||  objectType == KIKUCHI_OBJECT + 20)		{			if(!thisSpot->direction)continue;		}		if(maxHKL){			if(fabs((double)thisSpot->h) > 3 || fabs((double)thisSpot->k) > 3				|| fabs((double)thisSpot->l) > 3)continue;		}		theCrys = thisSpot->flags & CRYSTAL_MASK;		if(theIdent > -1 && (theCrys != theIdent)) continue;				if(flag){			if(!(thisSpot->flags & TEXT_MASK))			thisSpot->flags |= (TEXT_MASK);		}		else{			if(thisSpot->flags & TEXT_MASK)		 		thisSpot->flags -= (TEXT_MASK);		}	}	newPictReq = true;}#pragma segment Mainvoid SpotObject::ActionsOnSpot(short theIdent){		SpotInfoPtr theSpot;	/*MFTemp*/D_HLock(theDataHandle);			theSpot = (SpotInfoPtr)*theDataHandle;				//The Following Are Actions For Bloch Wave Calculations					switch(functionID){			case THRU_THICKNESS_DY:					 ThruThicknessRockingCurve(&theSpot[startCount[theIdent]]);					 if(THE_CURRENT_SPOT.flags & TEXT_MASK)THE_CURRENT_SPOT.flags -= TEXT_MASK;					break;			case THRU_TILT_DY:				 ThruTilt(&theSpot[startCount[theIdent]]);//Bloch				  if(THE_CURRENT_SPOT.flags & TEXT_MASK)THE_CURRENT_SPOT.flags -= TEXT_MASK;			break;			case FULL_TILT_DY:						nOut = 1; FullTilt(&nOut,&theSpot[startCount[theIdent]]);						if(THE_CURRENT_SPOT.flags & TEXT_MASK)THE_CURRENT_SPOT.flags -= TEXT_MASK;									break;			case CRITICAL_VOLTAGE_F:						CriticalVoltagePlot(&theSpot[startCount[theIdent]]);						 if(THE_CURRENT_SPOT.flags & TEXT_MASK)THE_CURRENT_SPOT.flags -= TEXT_MASK;			break;				//The Following Are Actions For Multislice actions on spots			case THRU_THICKNESS_MS:					 MS_ThruThicknessRockingCurve(&theSpot[startCount[theIdent]]);					 if(THE_CURRENT_SPOT.flags & TEXT_MASK)THE_CURRENT_SPOT.flags -= TEXT_MASK;					break;			case THRU_TILT_F_MS:				 MS_ThruTilt(&theSpot[startCount[theIdent]]);//Bloch				  if(THE_CURRENT_SPOT.flags & TEXT_MASK)THE_CURRENT_SPOT.flags -= TEXT_MASK;			break;			case FULL_TILT_F_MS:						nOut = 1; 						MultiSlice_Full(&nOut,&theSpot[startCount[theIdent]]);						if(THE_CURRENT_SPOT.flags & TEXT_MASK)THE_CURRENT_SPOT.flags -= TEXT_MASK;									break;			case CRITICAL_VOLTAGE_MS:						MS_CriticalVoltagePlot(&theSpot[startCount[theIdent]]);						 if(THE_CURRENT_SPOT.flags & TEXT_MASK)THE_CURRENT_SPOT.flags -= TEXT_MASK;			break;		}					/*MFTemp*/D_HUnlock(theDataHandle);}