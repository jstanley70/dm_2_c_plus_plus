#include	"a_DiffractObject.h"#include	"Diffract_INCs.h"#include	"Print_Special.h"#include	"crystalFaceObj.h"#include	"elementInfoObj.h"//#include	"a_ImageObject.h"#include	"KikuchiObject.h"#include 	"KosselObj.h"			/* Added by JT. Septemeber */#include	"Pict_Obj.h"#include  "ElasticConstant.h"  	/* Added by JT July 1991 */#include	"MenuDefs.h"			/* Jan 1993 by Eric */#include	"Dir_Paths.h"				/* Jan 1993 by Eric */#include 	"BEKPObj.h"#include 	"WindowMenu.h"#include	"GraphSpots.h"//#include	"Patterson.h"//#include	"HREM.h"#include 	"ML_BeamOrientation.h"#include 	"ML_FoilNormal.h"#include 	"GraphFunction.h"#include 	"UA2_Text_Box.h"#include 	"UextBoxFree.h"#include 	"nrutil.h"#include 	"mathRecipies.h"#include	"EveMacros.h"#include	"VectorLib.h"void		AboutDesktopMic(void);void		NormalizeTheVectors(void);void ConvertModeToText(short mode,char *aText);//pascal	voidPtr	DiffractObjThreadEntry( void *there);void	FitOrientationToData(float *xx,float*yy,float *rotation);#ifdef NETWORK_VERSION//1	#include			"MsgObject.h"	extern 	ComBlock*	theComBlock;	extern 	long		lastVerify;	extern 	NMRec		theNMRec;	extern 	char		theNMString1[128];#endif#define		KMAP_OBJ_1		2200//0:Sources.Jim:Diffract:DI_DiffractObject.cvoid	DiffractObject::DoDiffObjInit(void)	/*  Object Init method				*/{	return;}void	DiffractObject::DoInit(void)	/* Default Obj init					*/{	MenuHandle	theMenuHandle;	short				i;		Boolean			abort = false;	Rect				dummyRect;	RGBColor		**theColor;	double			spikingFactor;	long				lFreeBytes;	SetRect(&dummyRect,0,0,0,0);	lFreeBytes = FreeMem();	if(lFreeBytes < 250000){		D_FlagUser(29);	}	plotType = STANDARD_PLOT;	cbedSmear = 1;	crystalDialogFlag = false;//this is a real kludge!!!	sprintf((char*)fileInfo.sfFile.name,"Untitled %2d",gCount++);	c2pstr((char*)fileInfo.sfFile.name);	fileInfo.sfFile.vRefNum = 0;	fileInfo.sfFile.parID	= NUL;	SetTheCursor(0);	StartWatch();	textBox = 0L;	for(i = 0; i < 5;i++)startCount[i] = -1;	pictTransferMode		=		2;	forceOverlay				=		false;	gMode						=		47;	SetRect(&centerDisk,0,0,6000,6000);	toggleDraw					=		false;	gCurrentObj 		= 	(DiffractObject*)this;	/* this MUST precede PPT alloc	*/	delAngle				=		5;	selectRect			=	dummyRect;	theTextSystem 	= (TheTextSystem*)0L;	screenPict			=	NUL;	picObjList			=	NUL;	theDataHandle		=	0L;	thePictRect			=	dummyRect;	rulerRect				=	dummyRect;	printing				=	false;	greyFlag				= false;	gMyOffG					=	0L;	calcIntensities = 0L;	kLineMult				=	.4;	spotMult				=	 2.5;	beamAzimuth			=		0;	for(i = 0; i < 4;i++){		theCrystal[i]		=	(Crystal*)AllocCrystal(i);		if(i > 0){			the_PPT_Info[i - 1]		=	(PPT_Info*)AllocPPT_Info(theCrystal[i]);		}	}			theEBeam 			= 	(DefineElecObj*)D_new(DefineElecObj);	theXRay  			= 	(XRayDefObj*)D_new(XRayDefObj);	theIon				=		(IonDefObj*)D_new(IonDefObj);	theEBeam			->	DoInit((long)this);	theXRay				->	DoInit((long)this);	theIon				->	DoInit((long)this);	theAlloyObj 	=		(AlloyCompDef*)D_new(AlloyCompDef);	theAlloyObj		->	Init();		negWidth 			=	90;	negHeight			= 	90;	maxEnergy           =   energy              = theEBeam->energy;  wavelength          =   theEBeam->wavelength;	cameraConstant		= 24.;	convergenceAngle	= .2;	magnification		= 1.;	dyRange				= 3.0;	expoTime			= 1.5;	linking             =   0;		/* JIM ADDED THIS DECEMBER 91 */	for(i = 0; i <= 4;i++){		theCrysSymbols_P[i] = 0 ;		theCrysSymbols_D[i] = 0 ;	}	/* JIM ADDED THIS DECEMBER 91 */	SetScaleFactor();	theBeamFlag			=	1;	theRuler			=	(Ruler*)NUL;	graph					=	(GraphFunction*)0L;	theDataHandle		=	/*Temp*/D_NewHandle(10);//,&gTheOSError	data_Length			=	0;	data_Count			=	0;	data_Size			=	0;	data_Expand			=	10;	theCursorID			=	0;	functionID			=	-1;	portHeight			=	gScreenSize.bottom;	portWidth			=	gScreenSize.right;/*	theMenuBar			=	NUL;	*/	abortFlag			=	false;	refreshFlag			=	false;	newPictReq			=	false;	newPictEnable		=	false;	changedFlag			=	false;	saveDataFlag		=	false;	funcInit			=	true;	reSizeFlag			=	true;	resizeOK			=	true;	onScreen 			=	false;	isCalculating		=	false;	selectRectEnable	=	true;	theWindow				= 0L;	thePalette			= 0L;	watchQueue			=	(DiffractObject*)NUL;	drawRgn					=		D_NewRgn();	eventRgn				=   D_NewRgn();	picUpdateRgn		=   D_NewRgn();		/*Added For V2.0*/	absorpMean			=		.2;//bloch	dynamic_Calc		=		false;		x_001.x	= y_001.y = z_001.z	= 1.0;	x_001.y	= x_001.z = y_001.x	= 0.0;	y_001.z = z_001.x = z_001.y	= 0.0;	baseCrystal 		= 0;	setCrystal  = theCrystal[baseCrystal];	currentCrystal = theCrystal[baseCrystal];	theFNOffLaueDistance	=	.5;	theFNRotationAngle		=	.5;	calcIrrational 			= 	1;//this had to be moved see below.1997	theZoneAxis 				= 	(Index*)D_new(Index);	theRotationAxis 		=  	(Index*)D_new(Index);	g_Vector						=		(Index*)D_new(Index);	theFoilNormal 			=  	(Index*)D_new(Index);	theFNRotationAxis 	= 	(Index*)D_new(Index);	theFoilBragg				=	 	(Index*)D_new(Index);		theRotationAxis			->DoInit(true,theCrystal[0]);	theRotationAxis->h = 1;theRotationAxis->k = 0; theRotationAxis->l = 0;	theRotationAxis->x = 1;theRotationAxis->y = 0; theRotationAxis->z = 0;	theZoneAxis					->DoInit(true,theCrystal[0]);	g_Vector						->DoInit(false,theCrystal[0]);	g_Vector->h = 0;g_Vector->k = 2; g_Vector->l = 0;	g_Vector->x = 0;g_Vector->y = 2; g_Vector->z = 0;	rotationAngle				= 	0;	offLaueDistance 			= 	0;	theFoilNormal				->DoInit(true,theCrystal[0]);	theFoilBragg				->DoInit(false,theCrystal[0]);	theFNRotationAxis		->DoInit(true,theCrystal[0]);	trueThickness = theFoilThickness		= 	2200;	foilParallel				=	true;	rockZA = (Index*)D_new(Index);	rockGVect   = (Index*)D_new(Index);	rockRotVec = (Index*)D_new(Index);	theMSVariables.xShift = 0;	theMSVariables.yShift = 0;	theMSVariables.meshX = 16;	theMSVariables.meshY = 16;	theMSVariables.deltaZ = 3;	theMSVariables.noOfSlices = 1000;	theMSVariables.noOfDifSlices	=	1;	theMSVariables.y_Vector = (Index*)D_new(Index);	theMSVariables.y_Vector						->DoInit(false,theCrystal[0]);	theMSVariables.y_Vector->h = 1;theMSVariables.y_Vector->k = 0; theMSVariables.y_Vector->l = 0;	theMSVariables.y_Vector->x = 2;theMSVariables.y_Vector->y = 0; theMSVariables.y_Vector->z = 0;		theMSVariables.x_Vector = (Index*)D_new(Index);	theMSVariables.x_Vector	->DoInit(false,theCrystal[0]);	theMSVariables.x_Vector->h = 0;theMSVariables.x_Vector->k = 1; theMSVariables.x_Vector->l = 0;	theMSVariables.x_Vector->x = 0;theMSVariables.x_Vector->y = 2; theMSVariables.x_Vector->z = 0;				SetFoundation();	totalRot 						= 	0;	calcFoil						=	1;	temperature					=	25.45;	calcDW							=	false;	spikingFactor = GetSpikingFactor(theFoilNormal,theFNRotationAxis,theFoilBragg,theFNRotationAngle,theFNOffLaueDistance,theFoilThickness,calcFoil,theCrystal[0]);	for(i = 0 ; i < 4 ; i++){		theColor	=	(RGBColor**)GetResource('COLR',500 + i);		theCrystal[i]->crystalColor = **theColor;		ReleaseResource((Handle)theColor);	}	theColor	=	(RGBColor**)GetResource('COLR',504);	backgroundColor = **theColor;	ReleaseResource((Handle)theColor);		/*stage needed to be moved because values set in the DoInit are dependent on	the orientation of the beam,1997*/	gCurrentObj = this;	stage				=	(StageObj*)D_new(StageObj);	stage				->	DoInit(3);	stage		->enableBragg = false;		SetObjectMenu(); /*July 1992 */		InsertMenu(g_New_Menu,-1);	InsertMenu(g_Crystal_Menu,-1);	InsertMenu(g_Crystal_Menu2,-1);		InsertMenu(g_Crystal_Menu3,-1);		InsertMenu(g_PPT_Menu,-1);	InsertMenu(g_Crystal_Face_Menu,-1);		InsertMenu(g_Table_Menu,-1);	InsertMenu(g_el_Tech_Menu,-1);	InsertMenu(g_xRay_Tech_Menu,-1);	InsertMenu(g_Elastic_Constant,-1); /* Added by J.T. July 1991 */	InsertMenu(g_Microstruc_Tech_Menu,-1); /* Added by J.T. Nov 1992 */	InsertMenu (gTheWindowMenu,-1);			/* Added by Eric July 1993 */	InsertMenu(g_Apple_Menu,2);	InsertMenu(g_Hier_Pict_Mode,-1);		if(theCrystal[3] == (Crystal*)NUL){		abort = true;	} else {		theCrystal[3]->idNum = 3;	}	for(i = 0 ; i <= 2 ; i++){		if(theCrystal[i] == (Crystal*)NUL){			abort = true;		} else {			theCrystal[i]->idNum = i;		}		if(the_PPT_Info[i] == (PPT_Info*)NUL){			abort = true;		} else {			the_PPT_Info[i]->theCrystal = theCrystal[i + 1];		}	}		if(abort){		theCrystal[3]->DoClose();		for(i = 0 ; i <= 2 ; i++){			theCrystal[i]->DoClose();			the_PPT_Info[i]->DoClose();		}		if(theDataHandle != 0L)/*Temp*/KillHandle(&theDataHandle);		return;	}	theLens				=	(ObjectiveLens*)D_new(ObjectiveLens);	theLens				->	DoInit(this);			if(objectType != 0){		if(variSize){			short wide,high;			if(objectType == IMAGE_OBJ){				theWindow			= 	GetNewCWindow(2100,NULL,IN_FRONT);			}else {				theWindow			= 	GetNewCWindow(1000,NULL,IN_FRONT);			}			((WindowPeek)theWindow)->refCon = (long)this;			SetPort(theWindow);			gTheRect = (*(GetGDevice()))->gdRect;			wide = gTheRect.right - gTheWindowStart.h;			high = gTheRect.bottom - gTheWindowStart.v;			SizeWindow(theWindow,wide,high,false);						vScroll = (ScrollBar*)D_new(ScrollBar);			vScroll->DoInit(theWindow,VERTICAL);			hScroll = (ScrollBar*)D_new(ScrollBar);			hScroll->DoInit(theWindow,HORIZONTAL);			theVisRect = theWindow->portRect;			theVisRect.bottom 	-= 15;			theVisRect.right 	-= 15;			RectRgn(picUpdateRgn,&theVisRect);			SetWindowColors(2110);			if(rulerHeight > 0){				rulerRect			=	theVisRect;				theRuler 			= 	(Ruler*)D_new(Ruler);				theBeamFlag			=	gDefault->theBeamFlag;				theRuler->rulerOFF	=	false;				theRuler			->	DoInit((long)this);				theVisRect.top 		+= 	rulerHeight;				rulerRect.bottom 	= 	rulerRect.top + rulerHeight - 3;				{/* July 1992 */					Point thePoint;					thePoint.h = thePoint.v = 0;					theTextSystem = (TheTextSystem*)D_new(TheTextSystem);					theTextSystem->DoInit(thePoint,this);				}				DMBackColor(14);				theRuler->DrawRuler();			}			RectRgn(drawRgn,&theVisRect);					} else {			if(objectType == PICTURE_OBJ){				theWindow			= 	GetNewCWindow(2150,NUL,IN_FRONT);			} else {				theWindow			= 	GetNewCWindow(1002,NUL,IN_FRONT);//whoa nellie 2/99 was 1002			}			SetPort				(theWindow);			vScroll 		= 	hScroll	= (ScrollBar*)NUL;			SetWindowColors(0);			theVisRect 	= 	theWindow->portRect;			RectRgn				(picUpdateRgn,&theVisRect);			RectRgn				(drawRgn,&theVisRect);		}		SetPort(theWindow);						gDefault->CopyObjTo(this,true);								((WindowPeek)theWindow)->refCon = (long)this;		SetObjectDrawTransferMode();		objectSize.h = theWindow->portRect.right;		objectSize.v = theWindow->portRect.bottom;		SetRectRgn(eventRgn,-32000,-32000,32000,32000);		gTopWindow 			= theWindow;		SetTopWindow(theWindow);				InvalRgn(picUpdateRgn);		VerifyObjects();										EnableItem(GetMHandle(EDIT_MENU),PASTE);		EnableItem(GetMHandle(EDIT_MENU),DO_CLEAR);		EnableItem(GetMHandle(EDIT_MENU),SELECT_ALL);	/* Jim's Code End -- Ack */		theMenuHandle = GetMHandle(FILE_MENU);		EnableItem(theMenuHandle,CLOSE);		EnableItem(theMenuHandle,PLACE);		EnableItem(theMenuHandle,SAVE);		EnableItem(theMenuHandle,SAVE_AS);		EnableItem(theMenuHandle,PRINT);			} else {		theWindow 				= (WindowPtr)NUL;		gTheDefMatrix			= theCrystal[0];			variSize				= false;		thePalette				= (PaletteHandle)NUL;		thePalette 	= GetNewPalette(1000);//whoa nellie 2/99		DetachResource((Handle)thePalette);		CheckMode();		}		if(theWindow != (WindowPtr)NUL){		MoveWindow(theWindow,gTheWindowStart.h,gTheWindowStart.v,true);		gTheRect = (*(GetGDevice()))->gdRect;		gTheWindowStart.h += 15;		gTheWindowStart.v += 10;		if(gTheWindowStart.v >= 85)			gTheWindowStart.v = 50;		if(gTheWindowStart.h > 105)			gTheWindowStart.h = 10;	}			if(objectType == NUL && gDefault == 0L){		DisposeHandle(theMenuBar);		theMenuBar = GetMenuBar();		DrawMenuBar();	}	SetWindowMenu();	CheckMode();	StopWatch();	/*old2.0...rockZA = (Index*)D_new(Index);	rockGVect	= (Index*)D_new(Index);	rockRotVec = (Index*)D_new(Index);	SetFoundation();*/	return;}void	DiffractObject::SetObjectDrawTransferMode(void){	if((*((*(GetGDevice()))->gdPMap))->pixelSize >= 4){		unsigned long	total;		RGBColor		theColor;				gInColor = true;		total = backgroundColor.red +				backgroundColor.green +				backgroundColor.blue;		if(total > 32000){			//gMode = srcCopy + adMin;/*adMin*/			theColor.red = theColor.blue = theColor.green = 0;		} else {			//gMode = srcCopy + addMax;/*addMax,addPin,srcCopy*/			theColor.red = theColor.blue = theColor.green = (unsigned short)65535;		}		OpColor(&theColor);			} else {		gInColor = false;		//gMode = patCopy;	}	PenMode(gMode);}void DiffractObject::SetObjectMenu(void){//	ClearMenuBar();/* July 1992 */	theMenuBar = 		GetNewMBar(1000);//	SetMenuBar			(theMenuBar);}void			DiffractObject::SetPict(Boolean eraseFlag){	short			hRes,vRes;	OpenCPicParams	thePicParms;	Rect theRect;	if(isCalculating)		return;				SetTheCursor(WAIT_CURSOR);		if(erase || eraseFlag && !printing){		//theRgn = SetClipToPort(theWindow,0,rulerHeight,15,15);				if(!gMyOffG){			EraseRgn(drawRgn);		  InvalRgn(drawRgn);		}	}		D_SetClip(gUpdateAll);	//ObjRectToLocal(&theVisRect);	theRect = (*gUpdateAll)->rgnBBox;	InvalRect(&theRect); //Sept 18 1996	//LocalRectToObj(&theVisRect);	thePictRect 		=  theWindow->portRect;	if(!printing){		thePictRect.top		+= rulerHeight;		thePictRect.bottom	-= 15;		thePictRect.right	-= 15;			 	if(reSizeFlag){			objectSize.h = thePictRect.right;			objectSize.v = thePictRect.bottom - thePictRect.top;			hScroll->ReInit();			vScroll->ReInit();			reSizeFlag = false;		}else{			thePictRect.bottom	= thePictRect.top + objectSize.v;			thePictRect.right	= objectSize.h;			hScroll->DoResize();			vScroll->DoResize();		}	} else if(!(objectType == LATTICE_OBJ || objectType == PHASED_OBJ)){//if(objectType ==  KIKUCHI_OBJECT || objectType ==  STEREO_OBJ ){		thePictRect.left 		= centerX - objectSize.h * .5;		thePictRect.right 	= thePictRect.left + objectSize.h;		thePictRect.top 		= centerY - objectSize.v * .5;		thePictRect.bottom 	= thePictRect.top + objectSize.v;	}						if(screenPict != NUL){		KillPicture(screenPict);	}	ScreenRes(&hRes,&vRes);		thePicParms.srcRect = thePictRect;	thePicParms.hRes = hRes;	thePicParms.vRes = vRes;	thePicParms.version = -2;	PenMode(0);	ForeColor (blackColor);	BackColor (whiteColor);	DMBackColor		(BACKGROUND_COLOR);	PenMode(gMode);			screenPict = OpenPicture(&thePictRect);	if(theDataHandle)/*MFTemp*/D_HLock(theDataHandle);	DoPictDraw();	if(theDataHandle)/*MFTemp*/D_HUnlock(theDataHandle);		if(!printing)//Jim August 1993		DrawTheText();		ClosePicture();	RestoreTheCursor();	return;}void			DiffractObject::FastPictDraw(void){	CTabHandle	destCTab;	static Rect dOffBounds;	PaletteHandle	thisPalette;	Rect theRect;	RgnHandle theRgn;		if(screenPict == 0L && gMyOffG == 0L){		return;	}	theRgn	= SetClipToPort(theWindow,0,rulerHeight,15,15);	if(gMyOffG == 0L && theWindow != (WindowPtr)0L){		if(toggleDraw){				PenMode(gMode);			if(screenPict){				DrawPicture(screenPict,&thePictRect);			}			if((long)picObjList != NUL){				PenMode(pictTransferMode);				picObjList->DrawThePicts();				picObjList->DrawSelected();			}		}else{			if((long)picObjList != NUL){				PenMode(pictTransferMode);				picObjList->DrawThePicts();				picObjList->DrawSelected();			}			PenMode(gMode);			if(screenPict){				DrawPicture(screenPict,&thePictRect);			}		}		PenMode(gMode);		D_SetClip(theRgn);		D_DisposeRgn(&theRgn);		PenNormal();		if(graph != (GraphFunction*)NUL){			graph->PlotGraph();		}		if(textBox){			textBox->UpdateEvent();		}		return;	}		thisPalette = GetPalette(theWindow);	destCTab 	= GetCTable(2100);	Palette2CTab(thisPalette,destCTab);	CTabChanged(destCTab);	LockPixels (gMyOffG->portPixMap);	ForeColor (blackColor);	BackColor (whiteColor);	/*		if(screenPict != 0L){		//	frees the Pict memory		KillPicture(screenPict);		screenPict = 0L;	}*/	if(gMode){		PenMode(0);		dm_EraseRect(&thePictRect);	}	theRect = thePictRect;	//OffsetRect(&theRect,4000,4000);	if(toggleDraw){			PenMode(gMode);		CopyBits ( (BitMap *) (*(gMyOffG->portPixMap)),					&((GrafPtr)theWindow)->portBits, &theRect, &thePictRect,gMode,nil);//srcCopy		if((long)picObjList != NUL){			PenMode(pictTransferMode);			picObjList->DrawThePicts();			picObjList->DrawSelected();			PenMode(gMode);		}	}else{		if((long)picObjList != NUL){			PenMode(pictTransferMode);			picObjList->DrawThePicts();			picObjList->DrawSelected();		}		PenMode(gMode);		CopyBits ( (BitMap *) (*(gMyOffG->portPixMap)),					&((GrafPtr)theWindow)->portBits, &theRect, &thePictRect,gMode,nil);//srcCopy	}		if(gTheSelection->isValid){		gTheSelection->DoFrame();	}		UnlockPixels(gMyOffG->portPixMap);			DMBackColor(BACKGROUND_COLOR);	DisposCTable(destCTab);	D_SetClip(theRgn);	D_DisposeRgn(&theRgn);	PenNormal();	if(graph != (GraphFunction*)NUL){		graph->PlotGraph();	}	if(textBox){		textBox->UpdateEvent();	}		return;}void			DiffractObject::D_DrawPict(void){	CTabHandle		destCTab;	GWorldPtr 		currPort;	GDHandle 		currDev;	short 			err;	PaletteHandle	thisPalette;	Rect				theRect;		if(screenPict == 0L || forceOverlay){		return;	}		if(gMyOffG != 0L){		DisposeGWorld(gMyOffG);		gMyOffG 		= 0L;	}		theRect 		= thePictRect;	thisPalette		= GetPalette(theWindow);	destCTab 		= GetCTable(2100);	Palette2CTab(thisPalette,destCTab);	CTabChanged(destCTab);	GetGWorld(&currPort,&currDev);	//	err = NewGWorld(&gMyOffG, 8, &theRect,destCTab, nil, 0);// CreateOffscreen Graphics world.	err = NewGWorld(&gMyOffG, (*(currPort->portPixMap))->pixelSize,&theRect,destCTab, nil, 0);// Create Offscreen Graphics world.	if(err != noErr){		gMyOffG = 0L;		DisposCTable(destCTab);		return;	}		LockPixels(gMyOffG->portPixMap);	SetGWorld(gMyOffG, nil);				PenMode(0);	ForeColor(blackColor);	BackColor(whiteColor);	DMBackColor(BACKGROUND_COLOR);	dm_EraseRect (&theRect);	PenMode(gMode);	DrawPicture(screenPict,&theRect);	if(printing){		DrawTheText();	}		SetGWorld (currPort, currDev);	UnlockPixels (gMyOffG->portPixMap);// Now unlock Pixels.	DisposCTable(destCTab);	}void	DiffractObject::DoRefresh(void)				 // Object Refresh method			{	short			h,v;	GrafPtr			oldPort;		if(theWindow != (WindowPtr)NUL && !isCalculating && refreshFlag ){		//InvalRect(&(*gUpdateAll)->rgnBBox);		GetPort(&oldPort);		SetPort(theWindow);		//refreshFlag = true;		D_SetClip(gUpdateAll);				if(variSize && (screenPict == NUL && gMyOffG == NUL)){			BeginUpdate(theWindow);			EndUpdate(theWindow);			refreshFlag = false;			return;		}				SectRgn(theWindow->visRgn,drawRgn,gTheRgn);		if(EmptyRgn(gTheRgn)) {			BeginUpdate(theWindow);			EndUpdate(theWindow);			refreshFlag = false;			return;		}		ObjRectToLocal(&theVisRect);		InvalRect(&theVisRect);// Sept 18 1996		LocalRectToObj(&theVisRect);			BeginUpdate(theWindow);		{				if(hScroll != (ScrollBar*)NUL){				h = GetCtlValue(hScroll->theControl);				v = GetCtlValue(vScroll->theControl);			} else {				h = 0;				v = 0;			}						DoSetOrigin();			D_SetClip(gUpdateAll);			FastPictDraw();		// !!!!!!! -----> Picture is drawn to Off Screen pixmap here			PenNormal();			DoResetOrigin();			D_SetClip(eventRgn);						if(variSize && (screenPict != NUL || gMyOffG != NUL)){				DMBackColor(14);				D_SetClip(gUpdateAll);				if(this->rulerHeight > 0){		// July 1992					theRuler->DrawRuler();					if(theTextSystem){					 	theTextSystem->DrawMenu(); //Changed Dec 1992					}				}				DrawGrowIcon(theWindow);			}						UpdtControl(theWindow,theWindow->visRgn);			//was outside endupdate			//if(variSize){			//	D_SetClip(gUpdateAll);			//	DrawGrowIcon(theWindow);			//}			refreshFlag = false;		}		EndUpdate(theWindow);				if(((long)screenPict != NUL || gMyOffG != NUL) && theTextSystem){ // put outside of update to allow scrolled writes			D_SetClip(drawRgn);			theTextSystem->DoRefresh();		}		RestoreTheCursor();		SetPort(oldPort);	} else if(isCalculating){		unsigned char	*message;		short					len;		gTheRect = theWindow->portRect;						message = "\pCalculating";		SetPort(theWindow);		len	= StringWidth(message);		h	= (gTheRect.left + gTheRect.right - len) / 2;		v	= (gTheRect.top + gTheRect.bottom) / 2;		InvalRect(&gTheRect);		BeginUpdate(theWindow);		{			SetRect(&gCalcRect,h - 8,v - 16,h + len + 8,v + 10);			dm_EraseRect(&gTheRect);			MoveTo(h,v);			DrawDiffractString(message);			MoveTo(h - 3 , v + 4);			PenSize(2,2);			Line(len + 4, 0);			dm_FrameRect(&gCalcRect);			PenSize(1,1);		}		EndUpdate(theWindow);	}	return;}void	DiffractObject::DrawTheText(void){	return;}void	DiffractObject::DoPrint(void)				/*  Object Print method				*/{	GrafPtr thePort;	PrOpen();	if(screenPict == (PicHandle)NUL && gMyOffG == NULL){		SysBeep(30);		PrClose();		return;	}	GetPort(&thePort);		printing = true;/* Jim august 1993*/	if(resizeOK){		reSizeFlag = false;		if(Question(FIT_TO_PAGE)){			reSizeFlag = true;			dm_EraseRect(&theVisRect);			InvalRect(&theVisRect);		}	}	if(!gPrintRecHandle) gPrintRecHandle =(THPrint)GetResource('PREC',(short)1000);		if(GetHandleSize((Handle)gPrintRecHandle) != sizeof(TPrint)){		SetHandleSize((Handle)gPrintRecHandle,sizeof(TPrint));		ChangedResource((Handle)gPrintRecHandle);		WriteResource((Handle)gPrintRecHandle);	}	if(PrValidate(gPrintRecHandle))		SysBeep(30);	if(PrJobDialog(gPrintRecHandle)){		TPrStatus	theStatus;		TPPrPort	thePrintPort;		Rect		theRect;		Rect		thePrintRect;		Point		thePoint;		WindowPtr	theOldWindow;		long		oldCX,oldCY;		short		oldMode;		SetTheCursor(WATCH_CURSOR);						PenNormal();						thePrintPort = PrOpenDoc(gPrintRecHandle,NUL,NUL);		theOldWindow = theWindow;		SetPort(&thePrintPort->gPort);		thePrintRect = theRect = thePrintPort->gPort.portRect;				theWindow = NewCWindow (NUL, &theRect, "\p", false, plainDBox, IN_FRONT,								 false,GetWRefCon(theOldWindow));		SetPort(theWindow);		D_SetClip(gUpdateAll);		if(objectType == LATTICE_OBJ || objectType == PHASED_OBJ){			oldCX	= centerX;			oldCY	= centerY;			centerX = (theRect.right + theRect.left) / 2;			centerY = (theRect.bottom + theRect.top) / 2;		}		oldMode = gMode;		gMode = 0;		PenMode(0);		SetPict(false);		PrOpenPage(thePrintPort,NUL);						if(objectType == LATTICE_OBJ || objectType == PHASED_OBJ){			origin.h = oldCX - centerX;			origin.v = oldCY - centerY;		}else{			oldCX	= (theRect.right + theRect.left) / 2;			oldCY	= (theRect.bottom + theRect.top) / 2;			origin.h = centerX - oldCX;			origin.v = centerY - oldCY;		}		SetOrigin(origin.h,origin.v);			if((long)picObjList != NUL){				picObjList->DrawThePicts();			}			if(this->rulerHeight > 0 && this->theRuler != NUL){				thePoint.h = 0;				thePoint.v = 0;				if(theTextSystem)theTextSystem->DoPrint(&thePrintPort->gPort,thePoint);				}				PenMode(0);		if(objectType == LATTICE_OBJ || objectType == PHASED_OBJ)SetOrigin(0,0);		ClipRect(&thePictRect);		DrawPicture(screenPict,&thePictRect);		SetRect(&thePrintRect,0,0,4000,4000);		ClipRect(&thePrintRect);		DrawTheText();	/*august 1993 Jim, Eric moved it 11/93*/		SetOrigin (0,0);		PrClosePage(thePrintPort);		PrCloseDoc(thePrintPort);				if((*gPrintRecHandle)->prJob.bJDocLoop == bSpoolLoop){			PrPicFile(gPrintRecHandle,NUL,NUL,NUL,&theStatus);		}				DisposeWindow(theWindow);		theWindow = theOldWindow;		SetPort(theWindow);		newPictReq = true;		if(objectType == LATTICE_OBJ || objectType == PHASED_OBJ){			centerX	= oldCX;			centerY	= oldCY;		}		gMode = oldMode;	}	SetPort(thePort);	PenMode(gMode);	printing = false;	/*Jim august 1993*/	PrClose();	return;}void	DiffractObject::DoCut(void)					/*	Object Cut method				*/{	gTheSelection->DoCopy(this);	gTheSelection->Reset(theWindow);	return;}	void	DiffractObject::DoCopy(void)				/*	Object Copy method				*/{	gTheSelection->DoCopy(this);	return;}void	DiffractObject::DoPaste(void)				/*	Object Paste method				*/{	PictObj	*thePictObj;	Picture thePict;	short	delV,delH;	thePictObj = (PictObj*)D_new(PictObj);	thePictObj->DoInit((Handle)this);	thePict = **(gTheSelection->selectPict);		gTheRect = thePict.picFrame; /* Changed J.T. July 1991 */	delH = gTheRect.right - gTheRect.left;	delV = gTheRect.bottom - gTheRect.top;		gTheSelection->lastClick.h -= (short)(.5 * delH);	gTheSelection->lastClick.v -= (short)(.5 * delV);		ResetRect(&gTheRect,gTheSelection->lastClick.h,gTheSelection->lastClick.v);	thePictObj->AddPictObj(gTheSelection->selectPict,&gTheRect);	return;}void	DiffractObject::DoOpen(Boolean theEvtFlag)				/*	Object Open method				*/{	short			theObjectType,newObjectType;	long			retValue;	DiffractObject	*theWorkObj;		if(theEvtFlag){		gTheFile->FileOpen();	} else {		gTheFile->ReadFileOpen(DIF_OBJ);	}		if(!gTheFile->file_is_Open)		return;	switch(gTheFile->theFileInfo.sfType)	{		PicHandle	theNewPicture;		PictObj		*thePictObj;		case 'PICT':						if(variSize == false){gTheFile	->DoFileClose();return;}			theNewPicture = gTheFile->ReadPICT();						if(theNewPicture != (PicHandle)NUL){				thePictObj = (PictObj*)D_new(PictObj);				thePictObj->DoInit((Handle)this);				gTheRect = (*theNewPicture)->picFrame;/*centering the picture rect without														a call to DrawPicture results in the picture being drawn outof frame*/				CenterRects(theWindow->portRect,&gTheRect);				thePictObj->AddPictObj(theNewPicture,&gTheRect);				KillHandle((Handle*)&theNewPicture);				thePictObj->selected = true;			}			gTheFile	->DoFileClose();			return;		case 'TEXT':			if(variSize == false){gTheFile	->DoFileClose();return;}			OpenGeneral();			gTheFile	->DoFileClose();			return;		default:			break;			}		/* Jims Changes   */	if(gTheFile->theFileInfo.sfType == CRYST_OBJ_OLD ||			gTheFile		->theFileInfo.sfType == CRYST_OBJ_OLDEST			|| gTheFile		->theFileInfo.sfType == CRYST_OBJ){			//short i;			gCurrentObj->currentCrystal	->FileReadCrystal();//oritinally theCrystal[0]			gTheFile		->DoFileClose();										if(!crystalDialogFlag)				gCurrentObj->currentCrystal	->CrystalDef();						return;	}	theObjectType = gTheFile->ReadShort();			retValue = ((long)NEW_OBJECT) << 16;	switch(theObjectType){		case DEFAULT_OBJ:			theWorkObj = gDefault;			break;					case STEREO_OBJ:		case STEREO_OBJ_V1:			retValue += STEREO;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;				case SAD_OBJ:		case SAD_OBJ_V1:			retValue = El_SEL_HIER * 65536;			retValue += SADDIFF;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;						case D_SPACE_TABLE:		case D_SPACE_TABLE_V1:					/* Added by J.T. Ability to ooen tabels 12/1991 */			retValue = TAB_SEL_HEIR * 65536;			retValue += DSPACETAB;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;			case ANGLE_PLANE_TABLE:		case ANGLE_PLANE_TABLE_V1:			retValue = TAB_SEL_HEIR * 65536;			retValue += ANGLETAB;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;		case ANGLE_DIR_TABLE:		case ANGLE_DIR_TABLE_V1:			retValue = TAB_SEL_HEIR * 65536;			retValue += ANGLEBETDIR;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;		case PERIODICITY_TABLE:		case PERIODICITY_TABLE_V1:			retValue = TAB_SEL_HEIR * 65536;			retValue += STRUCTURE;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;					case USEFUL_INFO:		case USEFUL_INFO_V1:			retValue = TAB_SEL_HEIR * 65536;			retValue += EXTINCT;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;						case CBED_OBJ:		case CBED_OBJ_V1:			retValue = El_SEL_HIER * 65536;			retValue += CBEDDIFF;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;			case HOLZ_OBJ:		case HOLZ_OBJ_V1:			retValue = El_SEL_HIER * 65536;			retValue += HOLZPLOT;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;			case E_RING_OBJ:		case E_RING_OBJ_V1:			retValue = El_SEL_HIER * 65536;			retValue += EL_RING;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;										case LAUE_TRANS:		case LAUE_TRANS_V1:			retValue = X_SEL_HEIR * 65536;			retValue += LAUETRANS;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;			case LAUE_BACK:		case LAUE_BACK_V1:			retValue = X_SEL_HEIR * 65536;			retValue += BACK_REF_LAUE;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;		case DIFFRACT_METER:		case DIFFRACT_METER_V1:			retValue = X_SEL_HEIR * 65536;			retValue += DIFFRACTOMETER;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;		case DEB_SHERR_OBJ:		case DEB_SHERR_OBJ_V1:			retValue = X_SEL_HEIR * 65536;			retValue += DEB_SHERR;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;				case PHASED_OBJ:		case PHASED_OBJ_V1:			retValue += PHASE_DIAGRAM;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;	/*	case PICTURE_OBJ:		case PICTURE_OBJ_V1:			{				DiffractObject*	thePictureObj;								thePictureObj	= (DiffractObject*)AllocPictureObj();				if(thePictureObj != (DiffractObject*)NUL){					theWorkObj = gCurrentObj;				} else {					return;				}			}			break;	*/			case KMAP_OBJ_1:		case KMAP_OBJ_V1:		case	KIKUCHI_OBJECT:			retValue = El_SEL_HIER * 65536 + 1;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;		case KOSSEL_OBJECT:			case KOSSEL_OBJECT_V1:					/* This is added */			retValue = X_SEL_HEIR * 65536;			retValue += KOSSEL;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;		case BEKP_OBJECT:				case BEKP_OBJECT_V1:				/* This is added */			retValue = El_SEL_HIER * 65536;			retValue += BEKP;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;		case LATTICE_OBJ:		case LATTICE_OBJ_V1:			retValue += LATTICE;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;		case MICRO_OBJ:						/* This has been added Oct 1992 */			retValue = MICRO_SEL_HEIR * 65536;			retValue += ONE_DIS;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;		case MICRO_OBJ_2:			retValue = MICRO_SEL_HEIR * 65536;			retValue += TWO_DIS;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;		case MONTE_CARLO_OBJ:			retValue += MONTECARLO;			DoMenu(retValue);			theWorkObj = gCurrentObj;			break;				default:			SysBeep(30);			gTheFile	->DoFileClose();			return;			break;	}	newObjectType = theWorkObj->objectType;	theWorkObj->objectType = theObjectType;	theWorkObj	->DoFileRead();	theWorkObj	->fileInfo = gTheFile->theFileInfo;	gTheFile	->DoFileClose();	theWorkObj->objectType = newObjectType;	theWorkObj	->TitleTheWindow();	theWorkObj	->RationalizeData();	if(gDefault !=theWorkObj)theWorkObj	->CopyObjTo((DiffractObject*)gDefault,true);}				void	DiffractObject::DoFileRead(){	short 			numPicts;	PaletteHandle	tempPalette;	CTabHandle		theTempCTab;	short					i;	short					flag;	RGBColor	**aColor;	VerifyObjects();		fileInfo		= gTheFile->theFileInfo;	gTheFile->ReadHandle(theDataHandle);	data_Length		= gTheFile->ReadLong();	data_Count		= gTheFile->ReadLong();		newPictReq		= true;			gTheFile->ReadDataBlock((Ptr)&backgroundColor,sizeof(RGBColor));	aColor 		= 	(RGBColor**)GetResource('COLR',504);	**aColor 	= 	backgroundColor;	ChangedResource	((Handle)aColor);	WriteResource	((Handle)aColor);	ReleaseResource	((Handle)aColor);/*  The following block of code replaces the line that has been commentedout below *//*	That line wrote directly into the windows palette record and somehowtrashed it *//*	By copying the stored palette into a color table and then into thedestination  *//*  palette by using the Palette Manager Routines, we are able tocircumvent the 	*//*	problem while still having file compatibility with existing files				*/	if(objectType	!=	NUL){		tempPalette = (PaletteHandle)NewHandle(10L);		theTempCTab = (CTabHandle)NewHandle(10L);		gTheFile->ReadHandle((Handle)tempPalette);		Palette2CTab(tempPalette,theTempCTab);		CTabChanged(theTempCTab);		CTab2Palette(theTempCTab,thePalette,pmTolerant,5);		DisposHandle((Handle)tempPalette);		DisposHandle((Handle)theTempCTab);	}/*	gTheFile->ReadHandle((Handle)thePalette);  Bad !!!*/		theCrystal[0]->FileReadCrystal();	theCrystal[1]->FileReadCrystal();	theCrystal[2]->FileReadCrystal();	theCrystal[3]->FileReadCrystal();	the_PPT_Info[0]->FileReadPPTInfo();	the_PPT_Info[1]->FileReadPPTInfo();	the_PPT_Info[2]->FileReadPPTInfo();		/* Jim's Code Start  -- Ack*/	negWidth 		= gTheFile->ReadShort();	negHeight 		= gTheFile->ReadShort();	theBeamFlag 	= gTheFile->ReadShort();		energy 				= gTheFile->ReadFloat();	wavelength 			= gTheFile->ReadFloat();	cameraConstant 		= gTheFile->ReadFloat();	dyRange 			= gTheFile->ReadFloat();	expoTime 			= gTheFile->ReadFloat();	scaleFactor 		= gTheFile->ReadFloat();	maxEnergy 			= gTheFile->ReadFloat();	convergenceAngle 	= gTheFile->ReadFloat();	magnification 		= gTheFile->ReadFloat();		theEBeam->ReadBeam();	theXRay->ReadBeam();	theAlloyObj->ReadComposition();		/* Jim's Code End  -- Ack*/	numPicts = gTheFile->ReadShort();	if(numPicts){ /* July 1992 */		picObjList = (PictObj*)D_new(PictObj);		picObjList->DoInit((Handle)this);		picObjList->DoFileRead(numPicts);	}		greyFlag = gTheFile->ReadBoolean();									/* Needs to be Added 12/20/91 */	gTheFile->ReadDataBlock((Ptr)theCrysSymbols_P,(sizeof(short) * 5));	gTheFile->ReadDataBlock((Ptr)theCrysSymbols_D,(sizeof(short) * 5));		if(theTextSystem)		theTextSystem->ReadSystem(); /*added by jim july 1992 */	if(objectType	==	NUL || GetVersion(objectType)){		theIon->ReadBeam();		centerX = gTheFile		->ReadShort();		 centerY = gTheFile		->ReadShort();		/*Added for v2.0*/		linking = gTheFile		->ReadShort();/*linking indicator*/		baseCrystal = gTheFile		->ReadShort();		setCrystal  = theCrystal[baseCrystal];		currentCrystal  = theCrystal[0];		gTheFile		->ReadAxis(&x_001);		gTheFile		->ReadAxis(&y_001);		gTheFile		->ReadAxis(&z_001);		stage->DoRead();		cameraLength	= gTheFile		->ReadFloat();		projLengthScreen	=	gTheFile		->ReadFloat();		rotationAngle 	=	gTheFile		->ReadFloat();		offLaueDistance	=	gTheFile		->ReadFloat();		beamAzimuth			=	gTheFile		->ReadFloat();		theZoneAxis	->ReadIndex(theCrystal);		theRotationAxis->ReadIndex(theCrystal);		g_Vector->ReadIndex(theCrystal);		totalRot	=	gTheFile		->ReadFloat();		calcFoil	=	gTheFile		->ReadShort();				/*Added for v2.0*/	/* Jim's Code Ends */		/*  Watch  &  Multi_processing / background Stuff  */			calcIrrational	=	gTheFile		->ReadShort();		foilParallel		=	gTheFile		->ReadBoolean();		theFoilThickness	=	gTheFile		->ReadFloat();		theFoilNormal->ReadIndex(theCrystal);		theFNRotationAxis ->ReadIndex(theCrystal);		theFoilBragg ->ReadIndex(theCrystal);		theFNRotationAngle	=	gTheFile		->ReadFloat();		theFNOffLaueDistance	=	gTheFile		->ReadFloat();		trueThickness					=	gTheFile		->ReadFloat();	  toggleDraw						=	gTheFile		->ReadBoolean();		delAngle							=	gTheFile		->ReadFloat();		pictTransferMode			=	gTheFile		->ReadShort();		gMode									=	gTheFile		->ReadShort();		absorpMean						=	gTheFile		->ReadFloat();  //Bloch		temperature						=	gTheFile		->ReadFloat();		forceOverlay					=	gTheFile		->ReadBoolean();		calcDW								=	gTheFile		->ReadBoolean();		for(i = 0; i < 5;i++)startCount[i]	=	gTheFile		->ReadShort();		dynamic_Calc					=	gTheFile		->ReadBoolean();		spotLoc								=	gTheFile		->ReadShort();		numSpots							=	gTheFile		->ReadLong();		nOut									=	gTheFile		->ReadShort();//Bloch		delugeFlag						=	gTheFile		->ReadBoolean();//Bloch		numberOfSteps					=	gTheFile		->ReadShort();//Bloch		interval							=	gTheFile		->ReadFloat();//Bloch		flag = gTheFile		->ReadShort();		if(flag){			if(!calcIntensities)calcIntensities = (double**)D_NewHandle(sizeof(char) * 10);			gTheFile		->ReadHandle((Handle)calcIntensities);//Bloch		}		flag =  gTheFile		->ReadShort();		if(flag >= 0){			Rect theRect;			SetRect(&theRect,20,20,200,200);			if(graph)graph->DoClose(graph);			switch(flag){				case 0:					graph = (GraphFunction*)D_new(GraphFunction);					graph->DoInit(theRect,theCrystal[0]->crystalColor,true,true);					break;				case 1:					graph = (GraphSpots*)D_new(GraphSpots);					graph->DoInit(theRect,theCrystal[0]->crystalColor,true,true);					break;			}			graph->DoRead(graph);		}	}	kLineMult = gTheFile	->ReadFloat();	spotMult  = gTheFile	->ReadFloat();	DoAuxRead();	SetFoundation();/*new 1997*/	VerifyObjects();	return;}void	DiffractObject::DoFileWrite(void){	short					i;	gTheFile->WriteShort(objectType);	if(!theDataHandle)theDataHandle = D_NewHandle(10 * sizeof(SpotInfo));	gTheFile->WriteHandle(theDataHandle);	gTheFile->WriteLong(data_Length);	gTheFile->WriteLong(data_Count);			gTheFile->WriteDataBlock((Ptr)&backgroundColor,sizeof(RGBColor));		if(objectType	!=	NUL){		gTheFile->WriteHandle((Handle)thePalette);	}		theCrystal[0]->FileWriteCrystal();	theCrystal[1]->FileWriteCrystal();	theCrystal[2]->FileWriteCrystal();	theCrystal[3]->FileWriteCrystal();	the_PPT_Info[0]->FileWritePPTInfo();	the_PPT_Info[1]->FileWritePPTInfo();	the_PPT_Info[2]->FileWritePPTInfo();	/* Jim's Code end  -- Ack*/	gTheFile->WriteShort(negWidth);	gTheFile->WriteShort(negHeight);	gTheFile->WriteShort(theBeamFlag);						gTheFile->WriteFloat(energy);	gTheFile->WriteFloat(wavelength);	gTheFile->WriteFloat(cameraConstant);	gTheFile->WriteFloat(dyRange);	gTheFile->WriteFloat(expoTime);	gTheFile->WriteFloat(scaleFactor);	gTheFile->WriteFloat(maxEnergy);	gTheFile->WriteFloat(convergenceAngle);	gTheFile->WriteFloat(magnification);		theEBeam->WriteBeam();	theXRay->WriteBeam();		theAlloyObj->WriteComposition();	/* Jim's Code End  -- Ack*/	if(picObjList != (PictObj*)NUL){		picObjList->DoFileWrite(1);	} else {		gTheFile->WriteShort(0);	}		gTheFile->WriteBoolean(greyFlag);										/* Needs to be Added 12/20/91 */	gTheFile->WriteDataBlock((Ptr)theCrysSymbols_P,(sizeof(short) * 5));	gTheFile->WriteDataBlock((Ptr)theCrysSymbols_D,(sizeof(short) * 5));			if(theTextSystem)			theTextSystem->WriteSystem(); /* July 1992 */	if(objectType	==	NUL || GetVersion(objectType)){		theIon->WriteBeam();		gTheFile		->WriteShort(centerX);		gTheFile		->WriteShort(centerY);		/*Added for v2.0*/		gTheFile		->WriteShort(linking);/*linking indicator*/		gTheFile		->WriteShort(baseCrystal);		gTheFile		->WriteAxis(x_001);		gTheFile		->WriteAxis(y_001);		gTheFile		->WriteAxis(z_001);		stage->DoWrite();		gTheFile		->WriteFloat(cameraLength);		gTheFile		->WriteFloat(projLengthScreen);		gTheFile		->WriteFloat(rotationAngle);		gTheFile		->WriteFloat(offLaueDistance);		gTheFile		->WriteFloat(beamAzimuth);		theZoneAxis	->WriteIndex();		theRotationAxis->WriteIndex();		g_Vector->WriteIndex();		gTheFile		->WriteFloat(totalRot);		gTheFile		->WriteShort(calcFoil);				/*Added for v2.0*/	/* Jim's Code Ends */		/*  Watch  &  Multi_processing / background Stuff  */			gTheFile		->WriteShort(calcIrrational);		gTheFile		->WriteBoolean(foilParallel);		gTheFile		->WriteFloat(theFoilThickness);		theFoilNormal->WriteIndex();		theFNRotationAxis ->WriteIndex();		theFoilBragg ->WriteIndex();		gTheFile		->WriteFloat(theFNRotationAngle);		gTheFile		->WriteFloat(theFNOffLaueDistance);		gTheFile		->WriteFloat(trueThickness);	  gTheFile		->WriteBoolean(toggleDraw);		gTheFile		->WriteFloat(delAngle);		gTheFile		->WriteShort(pictTransferMode);		gTheFile		->WriteShort(gMode);		gTheFile		->WriteFloat(absorpMean);  //Bloch		gTheFile		->WriteFloat(temperature);		gTheFile		->WriteBoolean(forceOverlay);		gTheFile		->WriteBoolean(calcDW);		for(i = 0; i < 5;i++)gTheFile		->WriteShort(startCount[i]);		gTheFile		->WriteBoolean(dynamic_Calc);		gTheFile		->WriteShort(spotLoc);		gTheFile		->WriteLong(numSpots);		gTheFile		->WriteShort(nOut);//Bloch		gTheFile		->WriteBoolean(delugeFlag);//Bloch		gTheFile		->WriteShort(numberOfSteps);//Bloch		gTheFile		->WriteFloat(interval);//Bloch		if(calcIntensities){			gTheFile		->WriteShort(1);			gTheFile		->WriteHandle((Handle)calcIntensities);//Bloch		}else{			gTheFile		->WriteShort(0);		}				if(graph){			gTheFile		->WriteShort(graph->objectType);			graph->DoWrite();		}else{			gTheFile		->WriteShort(-1);		}			}	gTheFile	->WriteFloat(kLineMult);	gTheFile	->WriteFloat(spotMult);	DoAuxWrite();}void	DiffractObject::DoAuxRead(void)					/*	Stub for offspring read			*/{	return;}void	DiffractObject::DoAuxWrite(void)				/*	Stub for offspring write			*/{	return;}void	DiffractObject::DoSave(void)				/*	Object Save method				*/{	gTheFile->theFileInfo = fileInfo;	gTheFile->FileOpen();	if(!gTheFile->file_is_Open)		return;	DoFileWrite();		gTheFile->DoFileClose();	return;}void	DiffractObject::DoSaveAs(void)				/*	Object SaveAs method			*/{	GetWTitle(theWindow,gTheFile->theFileInfo.sfFile.name);	if(gShifted){		SysBeep(30);		gTheFile->SaveFileOpen('PICT');		if(!gTheFile->file_is_Open)			return;		fileInfo = gTheFile->theFileInfo;  			/* Save as a pict */		gTheFile->WritePICT((Ptr)this);		gTheFile->DoFileClose();	} else {		gTheFile->SaveFileOpen(DIF_OBJ);		if(!gTheFile->file_is_Open)			return;		fileInfo = gTheFile->theFileInfo;		DoFileWrite();		TitleTheWindow();		gTheFile->DoFileClose();	}	return;}void	DiffractObject::DoClose(void)				/*	Object Close method				*/{	short i;	//g_ThreadObj->DeleteLastThread();	for(i = 0 ; i <= 3 ; i++){						/*  Kill Crystals  & PPTs			*/		theCrystal[i]->DoClose();		if(i != 3)			the_PPT_Info[i]->DoClose();	}	D_DisposeRgn(&drawRgn);							/*  Kill drawing Rgn				*/	D_DisposeRgn(&picUpdateRgn);						/*  Kill Pic Update Rgn				*/	D_DisposeRgn(&eventRgn);							/*  Basically the Port rect			*/		if(screenPict != NUL)							/*  Kill Screen Picture				*/		KillPicture(screenPict);			if(picObjList != NUL)							/* Kill Background Pic list			*/		picObjList->DoClose();	if(graph != (GraphFunction*)NUL)graph->DoClose(graph);		graph = 0L;//Bloch				if(theDataHandle != NUL)						/*  Kill Data						*/		/*Temp*/KillHandle(&theDataHandle);	if(gMyOffG)DisposeGWorld(gMyOffG);	theLens->DoClose();	if(thePalette)DisposePalette(thePalette);//here it is	if(variSize){									/*  Kill scroll bars				*/		hScroll->DoClose();		vScroll->DoClose();		if(theTextSystem){/* Jim's Code  -- Ack*/			if(theTextSystem)theTextSystem->DoClose(); /* July 1992 */			theRuler->DoClose();		}	}	stage->DoClose();/*Added For V2.0*/	theEBeam->DoClose();	theXRay->DoClose();	theIon->DoClose();	theAlloyObj->Kill();	theMSVariables.y_Vector->DoClose();	theMSVariables.x_Vector->DoClose();	theZoneAxis->DoClose();	theRotationAxis->DoClose();		g_Vector->DoClose();		theFoilNormal->DoClose();	theFoilBragg->DoClose();	theFNRotationAxis->DoClose();		rockZA->DoClose();	rockGVect->DoClose();	rockRotVec->DoClose();		if(theMenuBar != NUL)							/*  Kill Menu Bar					*/		/*KillMBHandle*/DisposeHandle(theMenuBar);	if(theWindow != NUL)							/*  Kill Window						*/		DisposeWindow(theWindow);	D_delete(this);								/*  Kill Object						*/								}void	DiffractObject::DoQuit(void)				/*	Object Quit method				*/{	return;}void	DiffractObject::DoMenu(long theResult)			/*	Object Menu method				*/{	short 				theMenu,theItem;	Ptr 				theObj;	PutCrystalFaceObj	 *theCrystalFaceObj;	static Boolean 		alloyFlag = true;	Boolean  			aFlag = false;	ElementInfoObj		*elementInfoObj;	ElasticConstant 	*elasticConstants; /* Added by JT July 1991 */		VerifyObjects();	theMenu = HiWord(theResult);	theItem = LoWord(theResult);	SetTheCursor(0);	#if defined(_newkey_) && !defined(_DEMO_VERS_/*added _*/)		KEYTEST2(gShutdown);		gQuitFlag = gShutdown;	#endif		switch(theMenu){		case	APPLE_MENU:			if(theItem == 1){				AboutDesktopMic();				FlushEvents(0,0);			} else if(theItem > 2){				GetItem(GetMHandle(APPLE_MENU),theItem,pTheText);				OpenDeskAcc(pTheText);			}		break;				case 	FILE_MENU:			switch(theItem){				case NEW:			/*  Hierarchial selection  */					break;				case OPEN:					DoOpen(false);					break;				case PLACE:					DoPlace();					break;				case CLOSE:					CloseTheObject(gTopWindow);					break;				case PAGE_SETUP:					PrOpen();					SetupPage();					PrClose();					break;				case SAVE:					DoSave();					break;				case SAVE_AS:					DoSaveAs();					break;				case PRINT:					PrOpen();					DoPrint();					PrClose();					break;				case SEARCH_PATHS:					SetDirPaths();					break;				case QUIT:					gQuitFlag = true;					CloseAllObjects();										break;								default:					break;			}			break;				case EDIT_MENU:			if(theTextSystem){/* Jim's Code  -- Ack*/				if(theTextSystem->textOn || (long)theTextSystem->textObject->GetActive()) /* July 1992 */				{					if(theTextSystem->DoMenu(theResult)) break;				}			}			switch(theItem){				case UNDO:					break;									case CUT:					DoCut();					break;									case COPY:					DoCopy();					break;									case PASTE:					DoPaste();					break;									case DO_CLEAR:					if(picObjList != (PictObj*)NUL){						picObjList = picObjList->KillSelected();					}					break;									case SELECT_ALL:					if(picObjList != (PictObj*)NUL){						picObjList->SelectAll();					}					break;									case REFRESH:					if(objectType == 0)						break;					if(gShifted){						DrawPalette();					} else {						SetTheCursor(WATCH_CURSOR);						//dm_EraseRect(&theVisRect);						InvalRect(&theVisRect);						newPictReq = true;					}					break;									case SET_BACKGROUND:					SetDialogMenuBar(); /*dec 1992 */										{						Point		thePoint;						RGBColor	newColor;						RGBColor	**aColor;												thePoint.h = thePoint.v = 0;						if(GetColor(thePoint,"\pSelect Background Color",&backgroundColor,&newColor)){														backgroundColor = newColor;														InvertColor		(&newColor);							SetEntryColor	(thePalette,14,&backgroundColor);							SetEntryColor	(thePalette,15,&newColor);														if(theWindow != 0L)								ActivatePalette(theWindow);														SetObjectDrawTransferMode();							SetTheCursor(WATCH_CURSOR);														DMBackColor		(BACKGROUND_COLOR);							DMForeColor		(COMPLEMENT_COLOR);														aColor 		= 	(RGBColor**)GetResource('COLR',504);							**aColor 	= 	backgroundColor;							ChangedResource	((Handle)aColor);							WriteResource	((Handle)aColor);							ReleaseResource	((Handle)aColor);														if(theWindow != 0L){								newPictReq = true;							}						}					}					if(theWindow != 0L){						dm_EraseRect(&theVisRect);						InvalRect(&theVisRect);											}					KillDialogMenuBar(); /*dec 1992 */					break;											case SHOWINTTABLES:					 theObj = AllocShowIntTabObj();					 break;				case SHOWELEMENTINFO:					elementInfoObj = (ElementInfoObj*)D_new(ElementInfoObj);					elementInfoObj->Init();					elementInfoObj->DoDefine();					elementInfoObj->Kill();					break;			case	SET_TRANSFER_MODE_MENU:					break;					default:				break;					}				break;				case PARAMETER_MENU:						switch(theItem){				case SET_DEFAULTS:					DoDefine();//SetPlotParameters();					break;				case CRYSTAL_DEF:					break;				case OR_DEF:					break;				case CRYS_SHAPE:					break;				case ELASTIC_CONS:/* Added by JT July 1991 */					break;				case MICROSCOPE_DEF:					DefineBeamE();					break;				case DEFINE_BEAM_OR:					{						double x = 0,y = 0,z = 1;						DefineOrientation(true,&x,&y,&z);					}					break;				case LENS_CONTROL_DEF:					theLens->DoDefine();					break;					case DEFINE_FOIL_OR:					changedFlag = DefineFoilNormal();					break;				case STAGE_CONTROL_DEF:/*Added For V2*/					changedFlag = StageControl();					break;				case SET_STRUCTURE_FACTORS:					StructureFactorSetUp();//bloch		  		break;		  	case SET_PLOT_SHAPES:		  		SetPlotParameters();		  		break;		  	case SET_PLOT_MISC:		  		SetMiscParameters();		  		break;		  	case DEFAULT_TO_LOCAL:		  		DoSwitchDefault();		  		break;				default:					break;				}						break;					case NEW_OBJECT:			switch(theItem){				case TABLE_DEF:					break;				case STEREO:					theObj = AllocStereoObject();					break;									case E_DIFTECH:					break;									case X_DIFTECH:					break;									/* case N_DIFTECH:					break;					*/				case LATTICE:					theObj = AllocRealLatObject();					break;				case MICROSTRUCTURE:					break;				case PHASE_DIAGRAM:					theObj = AllocPhaseDObj();					break;			//	case DIGITIZE:				//	theObj = AllocImageObject();			//		break;								case MONTECARLO:					theObj = AllocMonteCarloObj();					break;							default:					theObj = AllocDiffractObj();					break;			}			break;				case	CRYSTAL_SEL:			switch(theItem){				case MATRIX:				case PPT_1:				case PPT_2:				case PPT_3:										theCrystal[theItem - 1]->CrystalDef();											if(thePalette != (PaletteHandle)NUL){						SetEntryColor(thePalette,theItem + 9,&(theCrystal[theItem - 1]->crystalColor));						ActivatePalette(theWindow);					}					break;				default:					SysBeep(120);					break;			}			break;		case	PPT_SEL:			theItem += 1;			switch(theItem){				case PPT_1:				case PPT_2:				case PPT_3:					the_PPT_Info[theItem - 2]->DoEdit();					break;				default:					SysBeep(120);					break;			}			break;		case	Crystal_Face_SEL:			switch(theItem){				case MATRIX:				case PPT_1:				case PPT_2:				case PPT_3:					theCrystalFaceObj = (PutCrystalFaceObj*)D_new(PutCrystalFaceObj);					theCrystalFaceObj->Init(theCrystal[theItem - 1]);					theCrystalFaceObj->DoLibrary();				break;			}			break;/******     Added by Jim July 1991 ****/		case CRYSTAL_ELASTIC_MENU:			switch(theItem){				case MATRIX:				case PPT_1:				case PPT_2:				case PPT_3:					elasticConstants = (ElasticConstant*)D_new(ElasticConstant);					elasticConstants->DoInit(theCrystal[theItem - 1]);					elasticConstants->DoDefine();					break;			}				break;/******     End Add by Jim July 1991 ****//*		case BEAM_SEL_HIER:								switch(theItem)				{					case 1:						aFlag = theEBeam->DoDefine();						break;					case 2:						aFlag = theXRay->DoDefine();						break;					case 3:						aFlag = theIon->DoDefine();						break;				}								break;*/						case	TAB_SEL_HEIR:				switch(theItem){					case  DSPACETAB:						theObj = AllocD_Spacing_TableObj();						break;					case ANGLETAB:						theObj = AllocAngleTabObj();						break;					case ANGLEBETDIR:						theObj = AllocAngleBetDirObj();						break;					case STRUCTURE:						theObj = AllocPeriodicityTabObj();						break;					case EXTINCT:						theObj = AllocUsefulInfoTabObj();						break;					default:						break;				}					break;			case 	El_SEL_HIER:				VerifyObjects();				switch(theItem){					case KIKUCHIMAP:						theObj = AllocKikuchiObject();						break;					case SADDIFF:						theObj = AllocSADObj();						break;					case CBEDDIFF:						theObj = AllocCBEDObj();						break;					case HOLZPLOT:						theObj = AllocHOLZObj();						break;					case EL_RING:						theObj = AllocERingObj();						break;					case BEKP:						theObj = AllocBEKPObj();						break;					case RHEED:						/* theObj = AllocRHEEDObj(); */						break;				}				break;										case	WINDOW_MENU:					ActivateMyWindow(theItem);				break;													break;		case	X_SEL_HEIR:					switch(theItem){					case KOSSEL:						theObj = AllocKosselObj();						break;					case DIFFRACTOMETER:						theObj = AllocDiffractometerObj();						break;					case LAUETRANS:						theObj = AllocLaueTransObj();						break;					case BACK_REF_LAUE:						theObj = AllocBackRefLaueObj();						break;					case DEB_SHERR:						theObj = AllocDebSheerObj();						break;					case SEEM_BOHL:						/* theObj = AllocSeemanObj(); */						break;					case SYM_BACK_REF:						/* theObj = AllocSymBackRefObj(); */						break;					case ROT_CRYSTAL:						/* theObj = AllocRotCrystalObj(); */						break;					case PRECESSION:						/* theObj = AllocPrecessionObj(); */						break;					default:						break;					}				break; /*added Jim dec 1992*/			case	MICRO_SEL_HEIR:					switch(theItem){					case ONE_DIS:						theObj = AllocOneDisObj();						break;					case TWO_DIS:						theObj = AllocTwoDisObj();						break;					/*Added For V2.0*/					case MICRO_GEN:					//	theObj = AllocHREMObj();						break;					case PATTERSON_GEN:					//	theObj = AllocPattersonObject();						break;					default:						break;										}				break; /*added Jim dec 1992*/			case HIER_PICT_MODE://bloch				functionID =  0;				SetPictMode(theItem);				if(this->theRuler != NUL && this->rulerHeight > 0){					if(functionID){					 theRuler->SetPrompt("Transfer Mode ");					 theRuler->SetHelp("arrow keys change transfer modes for picture vs plot, t changes order of plotting");					}				}				SetTransferModeText();				break;		default:			break;	}			//HiliteMenu(0);	if(linking && !gQuitFlag)CopyObjTo(gDefault,false);		return;}Boolean		DiffractObject::DoContent(Point thePoint)			/*	Object Contentmethod			*/{	Boolean		movedFlag = false;	Point		objPoint;			if(this->rulerHeight > 0 && this->theRuler != NUL &&PtInRect(thePoint,&rulerRect)){	/* Jim's Code  -- Ack*/		/*  Do the rulerstuff  */		theRuler->DoContent(thePoint);		if(theTextSystem)theTextSystem->DoContent(thePoint);			return true;/*added by jim july 92 */			}		if(theTextSystem){	/* Jim's Code  -- Ack*/		/*  Do the ruler stuff  */				if(theTextSystem->DoContent(thePoint))/*added by jim july 92 */			return true;	}		if(!selectRectEnable)		return false;		objPoint = thePoint;	LocalToObj(&objPoint);	if((long)theTextSystem != 0L && theTextSystem->textOn){		if(picObjList != (PictObj*)NUL){			picObjList->ClearSelects();			}	}else{		if(picObjList != (PictObj*)NUL){			if(picObjList->DoSelect(objPoint)){		/* Do Picture selects and moves */				Delay(15,&gLongScratch);				picObjList->DoMove(objPoint);				D_DrawPict();				return true;			}			picObjList->ClearSelects();				/* Unselect all objects         */		}	}	gTheSelection->Reset(theWindow);	gTheSelection->DoObjSelect(thePoint);		return true;}void			DiffractObject::ExpandMemory(void)	/*  Object memory expansion			*/{	Size	theSize;	Boolean	locked;	char	cMemTags;	if(!theDataHandle)return;	cMemTags = HGetState(theDataHandle);	if(MemError() != 0){		D_Debug_Message(19);		return;	}	if((cMemTags & 0x80) != 0){		locked = true;		/*MFTemp*/D_HUnlock(theDataHandle);	} else {		locked = false;	}		theSize	=	GetHandleSize(theDataHandle);	/*Added for V2.0*/	if(data_Count - data_Length > 0 ){		long j;		j = (data_Count - data_Length) + data_Expand ;		data_Length = data_Count;		theSize	+=	(j * data_Size);		SetHandleSize(theDataHandle,theSize);		if(MemError() != noErr){			WarnUser(1);			gNoBreak = false;			if(data_Count < 0)				data_Count = 0;			if(locked)				/*MFTemp*/D_HLock(theDataHandle);			return;		}	}	theSize	+=	(data_Expand * data_Size);	SetHandleSize(theDataHandle,theSize);	if(MemError() != noErr){		WarnUser(1);		data_Count -= data_Expand;		gNoBreak = false;		if(data_Count < 0)			data_Count = 0;		if(locked)			/*MFTemp*/D_HLock(theDataHandle);		return;	}	data_Length	+= data_Expand;	if(locked)		/*MFTemp*/D_HLock(theDataHandle);}void			DiffractObject::DoIdle(void){	if(theWindow == NULL){		#ifndef _DEMO_VERS_		NormalizeTheVectors();   /* Copy Protection for pulled Key */	#endif			if(picObjList != (PictObj*)NUL){			picObjList->DoIdle();		}		VerifyObjects();		return;	}	if(FrontWindow() == theWindow && functionID != TRANSFER_MODE_F && functionID !=  SET_ASPECT_RATIO_F		&& functionID != SETUP_LATTICE_F && functionID != ZONE_AXIS_FR_PT){		if(!picObjList || !picObjList->GetSelected()){			while(IsPressed( (unsigned short )123)) {UpdateOR(28);}			while(IsPressed( (unsigned short )124)) {UpdateOR(29);}			while(IsPressed( (unsigned short )125)) {UpdateOR(31);}			while(IsPressed( (unsigned short )126)) {UpdateOR(30);}		}	}	gTheSelection->Reset(theWindow);	if(linking == 1 && !SameObject(gDefault)){		gDefault->CopyObjTo(this,false);		changedFlag = true;	}			if(theWindow != NULL){		if(changedFlag && !isCalculating){			SetTheCursor(WATCH_CURSOR);							//g_ThreadObj->CreateCoopThread((ThreadEntryProcPtr)DiffractObjThreadEntry,(void*)this);//MyCalculate();			DoCalculate();			refreshFlag = true;			//DoCalculate();		//	newPictReq = true;			//changedFlag = false;		}		if(newPictReq && !changedFlag){				SetPict(true);				D_DrawPict();//change				newPictReq = false;				refreshFlag = true;		}	}	if(isCalculating)	refreshFlag = true;	if(refreshFlag){		DoRefresh();		refreshFlag = false;	}		if(rulerHeight > 0 && theRuler != NUL && theTextSystem){		theTextSystem->DoIdle();		if(!theTextSystem->textOn && gTheSelection != NULL){			gTheSelection->DoFrame();		}else{			if(picObjList != (PictObj*)NUL){				picObjList->ClearSelects();				}			gTheSelection->Reset(theWindow);		}	}#ifndef _DEMO_VERS_	NormalizeTheVectors();   /* Copy Protection for pulled Key */#endif		if(picObjList != (PictObj*)NUL){		picObjList->DoIdle();	}	VerifyObjects();	return;}void			DiffractObject::DoDblClick(Point where){	//this->DoContent(where);	if(this->rulerHeight > 0 && this->theRuler != NUL)			theRuler->DoDblClick(where);	FlushEvents(0,0);	return;}void ConvertModeToText(short mode,char *aText){		char theText[255];				aText[0] = 0;		if(mode  == srcCopy)	{sprintf(theText,"srcCopy");strcat(aText,theText);}		if(mode   == srcOr){sprintf(theText,"srcOr");strcat(aText,theText);}		if(mode  	 == srcXor){sprintf(theText,"srcXor");strcat(aText,theText);}		if(mode  	 == srcBic){sprintf(theText,"srcBic");strcat(aText,theText);}		if(mode  	 ==notSrcCopy){sprintf(theText,"notSrcCopy");strcat(aText,theText);}		if(mode  	 == notSrcXor){sprintf(theText,"notSrcXor");strcat(aText,theText);}		if(mode 	 == notSrcBic){sprintf(theText,"notSrcBic");strcat(aText,theText);}		if(mode 	 == patCopy){sprintf(theText,"patCopy");strcat(aText,theText);}		if(mode  	 == patOr){sprintf(theText,"patOr");strcat(aText,theText);}		if(mode  	 == patXor){sprintf(theText,"patXor");strcat(aText,theText);}		if(mode  	 == patBic){sprintf(theText,"patBic");strcat(aText,theText);}		if(mode  	 ==notPatCopy){sprintf(theText,"notPatCopy");strcat(aText,theText);}		if(mode 	 == notPatXor){sprintf(theText,"notPatXor");strcat(aText,theText);}		if(mode 	 == notPatBic){sprintf(theText,"notPatBic");strcat(aText,theText);}		if(mode 	 == notPatOr){sprintf(theText,"notPatOr");strcat(aText,theText);}				if(mode 	 == adMax){sprintf(theText,"adMax");strcat(aText,theText);}		if(mode 	 == blend){sprintf(theText,"notPatOr");strcat(aText,theText);}		if(mode 	 == addPin){sprintf(theText,"addPin");strcat(aText,theText);}		if(mode 	 == addOver){	sprintf(theText,"addOver");strcat(aText,theText);}		if(mode 	 == subPin){sprintf(theText,"subPin");strcat(aText,theText);}		if(mode 	 == addMax){sprintf(theText,"addMax");strcat(aText,theText);}		if(mode 	 == subOver){sprintf(theText,"subOver");strcat(aText,theText);}		if(mode 	 == adMin){sprintf(theText,"adMin");strcat(aText,theText);}		if(mode 	 == ditherCopy){sprintf(theText,"ditherCopy");strcat(aText,theText);}		if(mode 	 ==transparent){sprintf(theText,"transparent");strcat(aText,theText);}				/*		if((mode & srcCopy) ==srcCopy)	{sprintf(theText,"srcCopy");strcat(aText,theText);}		if((mode & srcOr)	 == srcOr){sprintf(theText,"srcOr");strcat(aText,theText);}		if((mode & srcXor)	 ==srcXor){sprintf(theText,"srcXor");strcat(aText,theText);}		if((mode & srcBic)	 ==srcBic){sprintf(theText,"srcBic");strcat(aText,theText);}		if((mode & notSrcCopy)	 ==notSrcCopy){sprintf(theText,"notSrcCopy");strcat(aText,theText);}		if((mode & notSrcXor)	 ==notSrcXor){sprintf(theText,"notSrcXor");strcat(aText,theText);}		if((mode & notSrcBic)	 ==notSrcBic){sprintf(theText,"notSrcBic");strcat(aText,theText);}		if((mode & patCopy)	 ==patCopy){sprintf(theText,"patCopy");strcat(aText,theText);}		if((mode & patOr)	 == patOr){sprintf(theText,"patOr");strcat(aText,theText);}		if((mode & patXor)	 ==patXor){sprintf(theText,"patXor");strcat(aText,theText);}		if((mode & patBic)	 ==patBic){sprintf(theText,"patBic");strcat(aText,theText);}		if((mode & notPatCopy)	 ==notPatCopy){sprintf(theText,"notPatCopy");strcat(aText,theText);}		if((mode & notPatXor)	 ==notPatXor){sprintf(theText,"notPatXor");strcat(aText,theText);}		if((mode & notPatBic)	 ==notPatBic){sprintf(theText,"notPatBic");strcat(aText,theText);}		if((mode & notPatOr)	 ==notPatOr){sprintf(theText,"notPatOr");strcat(aText,theText);}				if((mode & adMax)	 == adMax){sprintf(theText,"adMax");strcat(aText,theText);}		if((mode & blend)	 ==blend){sprintf(theText,"notPatOr");strcat(aText,theText);}		if((mode & addPin)	 ==addPin){sprintf(theText,"addPin");strcat(aText,theText);}		if((mode & addOver) ==addOver){	sprintf(theText,"addOver");strcat(aText,theText);}		if((mode & subPin)	 ==subPin){sprintf(theText,"subPin");strcat(aText,theText);}		if((mode & addMax)	 ==addMax){sprintf(theText,"addMax");strcat(aText,theText);}		if((mode & subOver)	 ==subOver){sprintf(theText,"subOver");strcat(aText,theText);}		if((mode & adMin)	 == adMin){sprintf(theText,"adMin");strcat(aText,theText);}		if((mode & ditherCopy)	 ==ditherCopy){sprintf(theText,"ditherCopy");strcat(aText,theText);}		if((mode & transparent)	 ==transparent){sprintf(theText,"transparent");strcat(aText,theText);}		*/						strcat(aText,")");		return;}void			DiffractObject::SetTransferModeText(void){	char theText[255],aText[355];		sprintf(theText,"Picture = %d (",pictTransferMode);	{		ConvertModeToText(pictTransferMode,aText);	}	strcat(theText,aText);	sprintf(aText,"Plot Transfer Mode =%d (",gMode);	strcat(theText,aText);	{		ConvertModeToText(gMode,aText);	}	strcat(theText,aText);	if(toggleDraw)	 sprintf(aText," Draw Pictures Second");	else		sprintf(aText," Draw Pictures First");	strcat(theText,aText);	if(this->theRuler != NUL && this->rulerHeight > 0){					theRuler->SetInfo(theText);		}	}		void			DiffractObject::DoKey(char	theChar){	if(theChar == ''){		Debugger();	}	if(theTextSystem){/* Jim's Code  -- Ack*/		if(theTextSystem->DoKey(theChar))return;	}	if(picObjList != (PictObj*)NUL){		if((theChar == (char)27 || theChar == (char)8)){			picObjList = picObjList->KillSelected();		} else {			switch(theChar){				case 0x1C:				case 0x34:					picObjList->NudgeLeft();					return;									case 0x1D:				case 0x36:					picObjList->NudgeRight();					return;									case 0x1E:				case 0x38:					picObjList->NudgeUp();					return;									case 0x1F:				case 0x32:					picObjList->NudgeDown();					return;									default:					break;			}		}	}	if(functionID == TRANSFER_MODE_F && (((theChar >= 28 && theChar <= 31) || theChar == 't'))){		if(theChar == 30) {			pictTransferMode++;			if(picObjList)picObjList->ConvertPictToNewTransferMode();		}		if(theChar == 31){		 pictTransferMode--;		  if(pictTransferMode < 0)pictTransferMode = 0;		 if(picObjList)picObjList->ConvertPictToNewTransferMode();		}		if(theChar == 't'){			if(toggleDraw) toggleDraw = false;			else toggleDraw = true;		}		if(theChar == 29) {			gMode++;		}		if(theChar == 28){		 gMode--;		 if(gMode < 0)gMode = 0;		}				SetTransferModeText();		if(this->theRuler != NUL && this->rulerHeight > 0){			newPictReq = true;				dm_EraseRect(&thePictRect);	//bloch		}		return;	}								/*July 1992 */	return;}void			DiffractObject::DoCalculate(void){		if(!isCalculating){		InvalRect(&(theWindow->portRect));		gNoBreak		=	true;  /*  Allows Calculations to procede  */		isCalculating	= 	true;		SetPort(theWindow);		DrawMenuBar();				StartWatch();		VerifyObjects();	/* ******** */				SetScaleFactor();/*Added for V2.0*/		MyCalculate();VerifyObjects();	/* ******** */		newPictReq = true;		changedFlag = false;		isCalculating	= 	false;		FlagUser();				StopWatch();	}	}/*pascal	voidPtr	DiffractObjThreadEntry( void *there){	DiffractObject		*t = (DiffractObject *)there;	t->DoCalculate();		return nil;}*/	void			DiffractObject::MyCalculate(void){	return;}void			DiffractObject::DoResize(void)				/*  Resize Object	Window			*/{	Rect	theRect;		if(!variSize)		return;		theVisRect = theWindow->portRect;	theVisRect.bottom 	-= 15;	theVisRect.right 	-= 15;	rulerRect			=	theVisRect;	RectRgn(picUpdateRgn,&theVisRect);	theVisRect.top 		+= rulerHeight;	RectRgn(drawRgn,&theVisRect);	rulerRect.bottom	= rulerRect.top + rulerHeight - 3;		vScroll->DoResize();	hScroll->DoResize();		InvalTheRect(&theVisRect);	/*************** set Grow Box for redraw **************/	theRect			= theWindow->portRect;	theRect.top 	= theRect.bottom - 15;	theRect.left 	= theRect.right - 15;		InvalRect(&theRect);	refreshFlag = true;}	void			DiffractObject::DoSetOrigin(void)				/*  Set the draw origin				*/{	short	h,v;	if(hScroll != (ScrollBar*)NUL){		h = GetCtlValue(hScroll->theControl);		v = GetCtlValue(vScroll->theControl);		if(h != 0 || v != 0){			SetOrigin(h,v);		}	}	return;}void			DiffractObject::DoResetOrigin(void)			/*  Set the draw origin				*/{	SetOrigin(0,0);	return;}void			DiffractObject::ObjRectToLocal(Rect*	theRect){		short	h,v;		if(hScroll != (ScrollBar*)NUL){		h = GetCtlValue(hScroll->theControl);		v = GetCtlValue(vScroll->theControl);		OffsetRect(theRect,-h,-v);	}}void	NormalizeTheVectors(){	static 	short 	count,i,testFreq;#ifdef NETWORK_VERSION		short			j,iErr;	static	short	errorCount;	EvQEl			*theQElement;#else	short			j,n,m;#endif	#ifdef _DEMO_VERS_	return;	#endif	if(testFreq++ < 800)		return;	testFreq = 0;	if(count <= 0)		count = 2;	j = testFreq;   // Kludge...suppress warning.					// variable j should avoid a mem stomp by RBREAD	#ifdef NETWORK_VERSION	if((TickCount() - lastVerify) > 10800){		if(lastVerify == 0){			errorCount = 0;		}				ap[RB_ACCESS_COMMAND_P] 		=  RB_ACCESS_QUERY;		qp[0]							= ((short*)(&queryValue))[0];		qp[1]							= ((short*)(&queryValue))[1];		iErr = rbaccess (mp, ap, qp, rp);		if(iErr != RB_SUCCESS || rp[0] != ((short*)(&respValue))[0] || rp[1] != ((short*)(&respValue))[1]){			switch(++errorCount){				case 1:					sprintf(theNMString1,"The KeyServer did not respond!");					c2pstr(theNMString1);					theNMRec.qType 		= nmType;					theNMRec.nmMark 	= 0;					theNMRec.nmIcon		= (Handle)0L;					theNMRec.nmSound 	= (Handle)-1L;					theNMRec.nmStr 		= (unsigned char*)theNMString1;					theNMRec.nmResp 	= (NMUPP)-1L;					iErr 				= NMInstall(&theNMRec);					lastVerify 			= TickCount() - 7200;					break;				case 2:					iErr 				= NMRemove(&theNMRec);					sprintf(theNMString1,"KeyServer is still not responding... Save your Data!");					c2pstr(theNMString1);					theNMRec.qType 		= nmType;					theNMRec.nmMark 	= 0;					theNMRec.nmIcon		= (Handle)0L;					theNMRec.nmSound 	= (Handle)-1L;					theNMRec.nmStr 		= (unsigned char*)theNMString1;					theNMRec.nmResp 	= (NMUPP)-1L;					iErr 				= NMInstall(&theNMRec);					lastVerify 			= TickCount() - 7200;					break;				default:					iErr 				= NMRemove(&theNMRec);				//	gQuitFlag 			= true;					lastVerify 			= TickCount() - 10000;					PPostEvent(keyDown,0x00000071L,&theQElement);					theQElement->evtQModifiers = cmdKey;					break;			}		} else {			lastVerify = TickCount();			errorCount = 0;		}	}#else#if defined(_newkey_)	m 		= RBEREAD(0x02,(unsigned short*)&n,2248,gTheKeyHandle);#else	n 		= EVEEnable(g_EVE_Read_Password);	n 		= EVEChallenge(2,2248);	m 		= EVEReset();#endifif(n != 67){	if(--count <= 0){		gQuitFlag = true;		gShutdown = true;	}} else {	count = 3;};				#endif}