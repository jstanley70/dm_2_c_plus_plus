#include	"a_DiffractObject.h"#include	"Diffract_INCs.h"#include	"Print_Special.h"#include	"crystalFaceObj.h"#include	"elementInfoObj.h"//#include	"a_ImageObject.h"#include	"KikuchiObject.h"#include 	"KosselObj.h"			/* Added by JT. Septemeber */#include	"Pict_Obj.h"#include  "ElasticConstant.h"  	/* Added by JT July 1991 */#include	"MenuDefs.h"			/* Jan 1993 by Eric */#include	"Dir_Paths.h"				/* Jan 1993 by Eric */#include 	"BEKPObj.h"#include 	"WindowMenu.h"#include	"GraphSpots.h"//#include	"Patterson.h"//#include	"HREM.h"#include 	"ML_BeamOrientation.h"#include 	"ML_FoilNormal.h"#include 	"GraphFunction.h"#include 	"UA2_Text_Box.h"#include 	"UextBoxFree.h"#include 	"nrutil.h"#include 	"mathRecipies.h"#include	"EveMacros.h"#include	"VectorLib.h"void			DiffractObject::LocalRectToObj(Rect*	theRect){		short	h,v;		if(hScroll != (ScrollBar*)NUL){		h = GetCtlValue(hScroll->theControl);		v = GetCtlValue(vScroll->theControl);		OffsetRect(theRect,h,v);	}}	void			DiffractObject::InvalTheRect(Rect*	theRect){		short	h,v;		if(hScroll != (ScrollBar*)NUL){		CopyRgn(drawRgn,gTheRgn);		h = GetCtlValue(hScroll->theControl);		v = GetCtlValue(vScroll->theControl);		DoSetOrigin();		OffsetRgn(gTheRgn,h,v);		D_SetClip(gTheRgn);			InvalRect(theRect);			DoResetOrigin();		D_SetClip(eventRgn);	} else {		InvalRect(theRect);		}}void			DiffractObject::EraseTheFrame(Rect*	theRect){	Rect 		thisRect;	RgnHandle	rgnA,rgnB;	rgnA 		= D_NewRgn();	rgnB 		= D_NewRgn();	thisRect	= *theRect;	ObjRectToLocal(&thisRect);	InsetRect 		(&thisRect,1,1);	RectRgn 		(rgnA, &thisRect);	InsetRect 		(&thisRect,-2,-2);	RectRgn 		(rgnB, &thisRect);	DiffRgn 		(rgnB, rgnA, rgnA);	EraseRgn 		(rgnA);	InvalRgn		(rgnA);	D_DisposeRgn	(&rgnA);	D_DisposeRgn	(&rgnB);}void			DiffractObject::EraseTheRect(Rect*	theRect){	STDTheRect(erase,theRect);}void			DiffractObject::InvertTheRect(Rect*	theRect){	STDTheRect(invert,theRect);}void			DiffractObject::FrameTheRect(Rect*	theRect){		STDTheRect(frame,theRect);	}void			DiffractObject::PaintTheRect(Rect*	theRect){		STDTheRect(paint,theRect);}void			DiffractObject::STDTheRect(GrafVerb	command,Rect*	theRect){		short	h,v;	Rect	aRect;	aRect = *theRect;	aRect.right += 1;	aRect.bottom  += 1;	if(hScroll != (ScrollBar*)NUL){		CopyRgn(drawRgn,gTheRgn);		h = GetCtlValue(hScroll->theControl);		v = GetCtlValue(vScroll->theControl);		DoSetOrigin();		OffsetRgn(gTheRgn,h,v);		D_SetClip(gTheRgn);			StdRect(command,&aRect);			DoResetOrigin();		D_SetClip(eventRgn);	} else {		StdRect(command,&aRect);		}}void			DiffractObject::STDTheRectMarquee(Rect*	theRect){		short	h,v;	DMForeColor(COMPLEMENT_COLOR);	DMBackColor(BACKGROUND_COLOR);	if(hScroll != (ScrollBar*)NUL){		CopyRgn(drawRgn,gTheRgn);		h = GetCtlValue(hScroll->theControl);		v = GetCtlValue(vScroll->theControl);		DoSetOrigin();		OffsetRgn(gTheRgn,h,v);		D_SetClip(gTheRgn);			StdRectMarquee(theRect);			DoResetOrigin();		D_SetClip(eventRgn);	} else {		StdRectMarquee(theRect);		}}void			DiffractObject::StdRectMarquee(Rect*	theRect){			SetMarqueePattern(NUL);	dm_FrameRect					(theRect);	Delay							(2,&gLongScratch);	dm_FrameRect					(theRect);	PenMode(gMode);}void			DiffractObject::StdOvalMarquee(Rect*	theRect){		DMForeColor(COMPLEMENT_COLOR);	DMBackColor(BACKGROUND_COLOR);	SetMarqueePattern	(NUL);	PenMode						(patXor);	dm_FrameOval					(theRect);	Delay							(2,&gLongScratch);	dm_FrameOval					(theRect);	PenNormal();	PenMode(gMode);	}void			DiffractObject::ObjToLocal(Point*	thePoint){	if(hScroll != (ScrollBar*)NUL){/*Jim Dec 1992 eliminated excess questionsHaving trouble missing scroll*/		thePoint->h -= GetCtlValue(hScroll->theControl);		thePoint->v -= GetCtlValue(vScroll->theControl);	}	return;}void			DiffractObject::LocalToObj(Point*	thePoint){	if(hScroll != (ScrollBar*)NUL){/*Jim Dec 1992 eliminated excess questions */		thePoint->h += GetCtlValue(hScroll->theControl);		thePoint->v += GetCtlValue(vScroll->theControl);	}	return;}void			DiffractObject::SetTheCursor(short	cursorID){	CursHandle theHandle;		if(cursorID != WATCH_CURSOR && cursorID != WAIT_CURSOR){		theCursorID = cursorID;	}	if(theCursorID != 0){		theHandle	= GetCursor(theCursorID);		if(theHandle == (CursHandle)NULL){			InitCursor();		} else {			SetCursor(*theHandle);			ReleaseResource((Handle)theHandle);		}	} else {		theHandle	= GetCursor(theCursorID);		if(theHandle){			SetCursor(*theHandle);			ReleaseResource((Handle)theHandle);		}else{			InitCursor();		}	}}	void			DiffractObject::RestoreTheCursor(void){	CursHandle theHandle;		if(theCursorID != 0){		theHandle	= GetCursor(theCursorID);		SetCursor(*theHandle);		ReleaseResource((Handle)theHandle);	} else {		theHandle	= GetCursor(theCursorID);		if(theHandle){			SetCursor(*theHandle);			ReleaseResource((Handle)theHandle);		}else{			InitCursor();		}	}}void DiffractObject::DoPictDraw(void){	return;}void DiffractObject::SetScaleFactor(void){	/*Added for v2.0*/	short hRes,vRes;	ScreenRes(&hRes,&vRes);	switch(theBeamFlag){		case 1:			cameraLength 	= theEBeam->cameraConstant;			theEBeam->ReturnCameraLength(&cameraLength);			break;		case 2:			cameraLength 	= theXRay->cameraConstant;			theXRay->ReturnCameraLength(&cameraLength);			break;		case 3:			cameraLength 	= theIon->cameraConstant;			theIon->ReturnCameraLength(&cameraLength);			break;	}	scaleFactor 	= (double)cameraConstant * (double)hRes * magnification/ 25.4;	projLengthScreen = cameraLength * (double)hRes * magnification/ 25.4;}void			DiffractObject::RationalizeData(void){	return;}void  DiffractObject::DoPlace(void){				if(!gCurrentObj->objectType || gCurrentObj->variSize == 0)		return;			gTheFile->ReadFileOpen('PICT');	}void  DiffractObject::OpenPICT(void){}void  DiffractObject::CenterRects(Rect theRect2, Rect *theRect1){	short del1,avg;		avg = (theRect2.bottom + theRect2.top) / 2;	del1 = (theRect1->bottom - theRect1->top) / 2;	theRect1->bottom = avg + del1;	theRect1->top = avg - del1;	avg = (theRect2.right + theRect2.left) / 2;	del1 = (theRect1->right - theRect1->left) / 2;	theRect1->right = avg + del1;	theRect1->left = avg - del1;}Boolean  DiffractObject::OpenTIFF(void){	return false;}Boolean  DiffractObject::OpenMCID(void){	return false;}void  DiffractObject::OpenGeneral(void){	OSErr 			theErr;	char	 		*theText;	char	 		theText1[82];	short			refNum;	long			sizeOfBlock;	long			posOff;	short			i,k,j;	short			sizeOfString = 1200;		SetPort(gCurrentObj->theWindow);		PenNormal();	TextFont(times);	TextSize(9);	k = 0;	if(gTheFile->theFileInfo.sfGood)	{		short theLeft,theTop;		theErr = FSpOpenDF(&gTheFile->theFileInfo.sfFile,fsRdWrPerm,&refNum);					theText = (char*)D_NewPtr(sizeof(char) * (sizeOfString + 1));			sizeOfBlock = sizeof(char)  * sizeOfString;		theLeft = 5;		theTop = 70;			AGAIN:			dm_EraseRect(&theWindow->portRect);				posOff = (sizeOfBlock * (long)k);		k++;		SetFPos(refNum,fsFromStart,posOff);		theErr = FSRead(refNum,&sizeOfBlock,(Ptr)(theText));		j = 0;		while( j < sizeOfString){			i = 0;			/* while(theText[j] == ' ' && j < sizeOfString){				j++;			}			while(i < 2 || (theText1[i] != ' ' && theText1[i - 2] != ' '&&theText1[i - 1] != ' ' && j < sizeOfString)){				theText1[i] = theText[j];				j++;				i++;			}			*/			while(i < 80 && j < sizeOfString){				theText1[i] = theText[j];				/*Added for v2.0*/				if(theText1[i] == ' ')theText1[i] = '!';				j++;				i++;			}			MoveTo(theLeft,theTop);			theText1[i] = 0;			c2pstr(theText1);			DrawDiffractString((unsigned char*)theText1);			theTop += 10;			if(theTop > 340){				while(!Button())					;				while(Button())					;				theTop = 70;				dm_EraseRect(&theWindow->portRect);			}		}		while(!Button())			;		while(Button())			;						if(IsPressed(56)){						goto AGAIN;		}		gTheFile->DoFileClose();		KillPtr(theText);		gCurrentObj->newPictReq = true;	}	TextFont(0);	TextSize(0);}void			DiffractObject::TitleTheWindow(void){	if(theWindow)SetWTitle(theWindow,gTheFile->theFileInfo.sfFile.name);//fileInfo.sfFile.name);}/*				This routine runs in the background and checks to be certain that the		key has not been removed.  If th ekey is not present on three consecutive		tests, the program terminates and the computer tries to shut down.*//*(void	NormalizeTheVectors(){	static 	short 	count,i,testFreq;#ifdef NETWORK_VERSION		short			j,iErr;	static	short	errorCount;	EvQEl			*theQElement;#else	short			j,n,m;#endif	#ifdef _DEMO_VERS_	return;	#endif	if(testFreq++ < 800)		return;	testFreq = 0;	if(count <= 0)		count = 2;	j = testFreq;   // Kludge...suppress warning.					// variable j should avoid a mem stomp by RBREAD	#ifdef NETWORK_VERSION	if((TickCount() - lastVerify) > 10800){		if(lastVerify == 0){			errorCount = 0;		}		if(theComBlock->msgPending){			if(theComBlock->TestMessage(&iErr)){				if(theComBlock->theInfo->response != CONFIRM_OK){					switch(++errorCount){						case 1:							sprintf(theNMString1,"The KeyServer did not respond!");							c2pstr(theNMString1);							theNMRec.qType 		= nmType;							theNMRec.nmMark 	= 0;							theNMRec.nmIcon		= (Handle)0L;							theNMRec.nmSound 	= (Handle)-1L;							theNMRec.nmStr 		= (unsigned char*)theNMString1;							theNMRec.nmResp 	= (NMUPP)-1L;							iErr 				= NMInstall(&theNMRec);							lastVerify 			= TickCount() - 7200;							break;						case 2:							iErr 				= NMRemove(&theNMRec);							sprintf(theNMString1,"KeyServer is still not responding... Save your Data!");							c2pstr(theNMString1);							theNMRec.qType 		= nmType;							theNMRec.nmMark 	= 0;							theNMRec.nmIcon		= (Handle)0L;							theNMRec.nmSound 	= (Handle)-1L;							theNMRec.nmStr 		= (unsigned char*)theNMString1;							theNMRec.nmResp 	= (NMUPP)-1L;							iErr 				= NMInstall(&theNMRec);							lastVerify 			= TickCount() - 7200;							break;						default:							iErr 				= NMRemove(&theNMRec);						//	gQuitFlag 			= true;							lastVerify 			= TickCount() - 10000;							PPostEvent(keyDown,0x00000071L,&theQElement);							theQElement->evtQModifiers = cmdKey;							break;					}				} else {					lastVerify = TickCount();					errorCount = 0;				}			}		} else {			theComBlock->DoConfirm();		}	}#else#if defined(_newkey_)	m 		= RBEREAD(0x02,(unsigned short*)&n,2248,gTheKeyHandle);#else	n 		= EVEEnable(g_EVE_Read_Password);	n 		= EVEChallenge(2,2248);	m 		= EVEReset();#endifif(n != 67){	if(--count <= 0){		gQuitFlag = true;		gShutdown = true;	}} else {	count = 3;};				#endif}	void DiffractObject::AddToQueue(DiffractObject*	newObj){	if(watchQueue == (DiffractObject*)NUL){		watchQueue 			= newObj;		newObj->watchQueue	= (DiffractObject*)NUL;	} else if(newObj != watchQueue){		watchQueue->AddToQueue(newObj);	}}*//*				This routine runs in the background and checks to be certain that the		key has not been removed.  If th ekey is not present on three consecutive		tests, the program terminates and the computer tries to shut down.*/void DiffractObject::RemoveFromQueue(DiffractObject*	oldObj){	if(watchQueue == oldObj){					/* in case of first element */		watchQueue = oldObj->watchQueue;	} else if(watchQueue->watchQueue == oldObj){		watchQueue->watchQueue = oldObj->watchQueue;	} else if(watchQueue != (DiffractObject*)NUL){		watchQueue->RemoveFromQueue(oldObj);	}	oldObj->theCursor = qd.arrow;}void DiffractObject::ModifyQueueCursor(Cursor*	newCursor){	theCursor = *newCursor;	if(watchQueue != (DiffractObject*)NUL){		watchQueue->ModifyQueueCursor(newCursor);	}}void DiffractObject::DMForeColor(short index){	RGBColor	theColor;		GetEntryColor(thePalette,index,&theColor);	RGBForeColor(&theColor);}void DiffractObject::DMBackColor(short index){	RGBColor	theColor;		GetEntryColor(thePalette,index,&theColor);	RGBBackColor(&theColor);}	void DiffractObject::DrawPalette(void){	short	i,j,entry,row,column;		row 	= rulerHeight + 2;	entry 	= 2;		for(i = 0 ; i < 16 ; i++){		column = 0;		for(j = 0 ; j < 16 ; j++){			gTheRect.top 	= row;			gTheRect.bottom = row + 12;			gTheRect.left 	= column;			gTheRect.right 	= column + 12;			DMForeColor(entry++);			dm_PaintRect(&gTheRect);			column += 12;		}		row += 12;	}}void DiffractObject::CalculateOrientation(Index *zone,Index *about,Index*bragg,double x1,double y1,double rotation,double az,short method,doublematrix[3][3]){	double 	x = 0,y = 0,z = 0;	IrrationalZoneAxis(zone,about,bragg,x1,y1,rotation,az,method,&x,&y,&z,matrix); 		}void DiffractObject::SetOrientation(double matrix1[3][3]){		CopyMatrixIntoAxes(matrix1);	if(foilParallel){		theZoneAxis		->		DoCopy(theFoilNormal);		theRotationAxis	->		DoCopy(theFNRotationAxis);		g_Vector		->		DoCopy(theFoilBragg);		theFNRotationAngle 		= 	rotationAngle;		theFNOffLaueDistance 	= 	offLaueDistance;		calcFoil 				=	calcIrrational;	}	if(linking){		CopyObjTo(gDefault,false);	}	}void DiffractObject::CopyAxesIntoMatrix(double matrix[3][3]){	matrix[0][0] = (double)x_001.x;	matrix[1][0] = (double)x_001.y;	matrix[2][0] = (double)x_001.z;		matrix[0][1] = (double)y_001.x;	matrix[1][1] = (double)y_001.y;	matrix[2][1] = (double)y_001.z;		matrix[0][2] = (double)z_001.x;	matrix[1][2] = (double)z_001.y;	matrix[2][2] = (double)z_001.z;	NormalizeRotationMatrix(matrix);}void DiffractObject::CopyMatrixIntoAxes(double matrix[3][3]){	NormalizeRotationMatrix(matrix);	x_001.x = matrix[0][0];	x_001.y = matrix[1][0] ;	 x_001.z = matrix[2][0];		y_001.x = matrix[0][1] ;	y_001.y = matrix[1][1] ;	y_001.z = matrix[2][1];		z_001.x = matrix[0][2];	z_001.y = matrix[1][2];	z_001.z = matrix[2][2];}void DiffractObject::GetOrientation(double matrix[3][3]){	if(linking){		x_001 = gDefault->x_001;		y_001 = gDefault->y_001;		z_001 = gDefault->z_001;		stage->DoCopy(gDefault->stage);	}	CopyAxesIntoMatrix(matrix);}void	DiffractObject::ZoneAxisFromMatrix(Boolean locked,double matrix[3][3],short *method,Index *zaIndex,Index *about,Index *gvector,float *xx,float *yy,float*rotation,float *rotation2){	Crystal			*setCrystal;	double			x,y,z;	double			aMatrix[3][3],bmatrix[3][3],xForm[3][3],centerM[3][3];	double			workingM[3][3],aboutC[3][3];	double			xH,yK,zL;	Boolean			zAF,flag;	short 			n;	short			h,k,l,combo = -1;	double			cameraLength;	double			x2,y2,z2,x3,y3,z3,length,x4,y4,z4;	short			i;	NormalizeRotationMatrix(matrix);START_OVER_2:	SetMatrixAEqB(aMatrix,matrix);	rotationAngle	=	0;	offLaueDistance = 	0;	setCrystal = theCrystal[baseCrystal];	zaIndex->theCrystal = setCrystal;	if(locked) goto ALREADY_IT;	zaIndex->x = 0;	zaIndex->y = 0;	zaIndex->z = 1;	InvertMatrix(aMatrix);	zaIndex->direction = true;	zaIndex->GetTheUVWFromXYZ(aMatrix);	xH = zaIndex->x;	yK = zaIndex->y;	zL = zaIndex->z;	zaIndex->ConvertXYZToHKLReduce();	x 	= 	zaIndex->h;	y 	= 	zaIndex->k;	z	=	zaIndex->l;	if(IsPressed(58))return;	while(fabs(x) > 3 || fabs(y) > 3 || fabs(z) > 3){			x /= 1.333333;			y /= 1.333333;			z /= 1.333333;	}	zaIndex->h = Round(x);	zaIndex->k = Round(y);	zaIndex->l = Round(z);		if(zaIndex->theCrystal->idNum > 3 || zaIndex->theCrystal->idNum < 0)		zaIndex->theCrystal->idNum = baseCrystal;			zAF = false;		n = 2;	if(!(gvector->h * zaIndex->h + gvector->k * zaIndex->k + zaIndex->l * gvector->l)){			zAF = true;				goto ALREADY_IT;	}	START_OVER:		for(h = n;h >= -n;h -= 2)	{		for(k = n;k >= -n;k -= 2){			for(l = n;l >= -n;l -= 2){				if(h == 0 && k == 0 && l == 0)continue;				if(!(h * zaIndex->h + k * zaIndex->k + zaIndex->l * l)){					zAF = true;					goto FOUND_IT;				}			}		}	}	FOUND_IT:	if(!zAF && n <= 12){		n += 4;		goto START_OVER;	}	if(!zAF){		*method = 1;		return;	}	gvector->h = h;	gvector->k = k;	gvector->l = l;ALREADY_IT:	*method = 5;	cameraLength = cameraConstant / wavelength;	x = zaIndex->h;	y = zaIndex->k;	z = zaIndex->l;		setCrystal->Get001XForm(xForm);	TransFormVector(&xH,&yK,&zL,xForm);//transform hkl to xyz for pole of interest	NormalizeVector(&xH,&yK,&zL);			TransFormVector(&x,&y,&z,xForm);//trnsform hkl to xyz for closest zone axis	FIND_CENTER_XFORM(x,y,z,aMatrix);//rotate zone axis to center from a 001position		gvector->DirOfPlaneNormal(&x2,&y2,&z2);		TransFormVector(&x2,&y2,&z2,xForm);//transform hkl to xyz for g-vector	NormalizeVector(&x2,&y2,&z2);	TRANSFORM_VECTOR(x2,y2,z2,aMatrix);//rotate so g-vector oriented with zone axis is down center		FIND_VERT_XFORM(x2,y2,bmatrix);//get rotation matrix to take g-vector to vertical	MatrixMultiply(aMatrix,bmatrix,aMatrix);//full orientation matrix	x = xH;	y = yK;	z = zL;	TransFormVector(&xH,&yK,&zL,aMatrix);//transform exact zone axis to position after rotating close zone to center and rotating g to vertical	NormalizeVector(&xH,&yK,&zL);	length = sqrt((xH * xH) + (yK * yK));	if(length < .00001){//essentially down zone		*xx = 0;		*yy = 0;		*method = 1;	}else{			double temp,xt,yt,zt,lambda,mu,factor;			if(zL < 0){				zL = fabs(zL);			}			factor	= 1 / (1.0 + zL);			xH *= factor;			yK *= factor;			length = sqrt((xH * xH) + (yK * yK));			xt 		= yK;			yt 		= xH;			temp 	= 2.0 * atan2(length,1);					zt 		= cos(temp);			temp 	= sin(temp) / length;			xt 		*= temp;			yt 		*= temp;						NormalizeVector(&xt,&yt,&zt);			lambda		= asin(xt);			mu    = asin(yt / cos(lambda));			*xx 	= lambda * (180. / PI);			*yy 	= -(cameraLength/* * 2.*/) * sin(mu);//-	}	zaIndex->DirOfPlaneNormal(&x3,&y3,&z3);	TransFormVector(&x3,&y3,&z3,xForm);//transform hkl to xyz for g-vector	NormalizeVector(&x3,&y3,&z3);		IrrationalZoneAxis(zaIndex,about,gvector,*xx,*yy,0,0,*method,&x2,&y2,&z2,workingM);//get current location	x4 = x3;	y4 = y3;	z4 = z3;	TransFormVector(&x3,&y3,&z3,workingM);//transform xyz to current orientation(unknown rotation about center	TransFormVector(&x4,&y4,&z4,matrix);//desired final location	*rotation = atan2(-y3,x3) - atan2(-y4,x4);	*rotation *=  180 / PI;	RotatateMatrixAxis(aboutC,*rotation * PI / 180,2);	MatrixMultiply(workingM,aboutC,workingM);	zaIndex->DirOfPlaneNormal(&x3,&y3,&z3);	TransFormVector(&x3,&y3,&z3,xForm);//transform hkl to xyz for g-vector	NormalizeVector(&x3,&y3,&z3);	TransFormVector(&x3,&y3,&z3,workingM);		FIND_CENTER_XFORM(x3,y3,z3,centerM);		gvector->DirOfPlaneNormal(&x4,&y4,&z4);	gvector->DirOfPlaneNormal(&x3,&y3,&z3);	TransFormVector(&x4,&y4,&z4,xForm);//transform hkl to xyz for g-vector	TransFormVector(&x3,&y3,&z3,xForm);	NormalizeVector(&x4,&y4,&z4);	NormalizeVector(&x3,&y3,&z3);	TransFormVector(&x3,&y3,&z3,workingM);	TransFormVector(&x4,&y4,&z4,matrix);//transform xyz to final orientation	TransFormVector(&x3,&y3,&z3,centerM);	TransFormVector(&x4,&y4,&z4,centerM);		*rotation2 = atan2(-y3,x3) - atan2(-y4,x4);	*rotation2 *=  180 / PI;	SetMatrixAEqB(workingM,matrix);	switch(combo){		case 0:		case -1:		break;		case 1:		*xx *= -1;		break;			case 2:		*yy *= -1;		break;			case 3:		*rotation *= -1;		break;			case 4:		*rotation2 *= -1;		break;				case 5:		*xx *= -1;		*yy *= -1;		break;			case 6:		*xx *= -1;		*rotation *= -1;		break;			case 7:		*xx *= -1;		*rotation2 *= -1;		break;					case 8:		*yy *= -1;		*rotation *= -1;		break;			case 9:		*yy *= -1;		*rotation2 *= -1;		break;				case 10:		*rotation *= -1;		*rotation2 *= -1;		break;				case 11:		*xx		*= -1;		*yy 	*= -1;		*rotation *= -1;		break;				case 12:		*xx		*= -1;		*yy 	*= -1;		*rotation2 *= -1;		break;				case 13:		*xx		*= -1;		*rotation 	*= -1;		*rotation2 *= -1;		break;		case 14:		*yy		*= -1;		*rotation 	*= -1;		*rotation2 *= -1;		break;				case 15:		*xx		*= -1;		*yy		*= -1;		*rotation 	*= -1;		*rotation2 *= -1;		break;	}		IrrationalZoneAxis(zaIndex,about,gvector,*xx,*yy,*rotation,*rotation2,*method,&x2,&y2,&z2,matrix);		/*new code 1997*/	flag = false;		for(i = 0; i < 3;i++){		for(k = 0; k < 3;k++){			if(fabs(matrix[i][k] - workingM[i][k]) > .0001){				flag = true;			}		}	}	if(flag && combo < 15){				combo++;		SetMatrixAEqB(matrix,workingM);		if(combo == 0){						if(stage->rockDialog){				stage->RenormalizeToFoundation();				CopyAxesIntoMatrix(matrix);			}else{				//NormalizeMatrixRows(matrix);				//NormalizeRotationMatrix(matrix);				RenormalizeToFoundation();				CopyAxesIntoMatrix(matrix);			}		}		goto START_OVER_2;	}	if(flag){		Message(NO_BEAMOR_ROTMAT_NOT);	}	/*end new code 1997*/	return;}		