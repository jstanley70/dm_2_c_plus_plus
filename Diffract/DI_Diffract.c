//0:Sources.Jim:Diffract:DI_Diffract.c#define		DIF_MAIN	10#include	"Diffract_INCs.h"#include	<shutdown.h>#include	<Gestalt.h>#include "ML_Multilog.h"#define		KEY_VERSION	2  /* For comparing Key Version Numbers 2*/#include	"EveMacros.h"//#include "bughunt.h"// IMT 10Sep95  Declare jump buffer used to recover from exception exits & aborts //#if defined(TPM_F2C) || defined(SPM_F2C) || defined(CW_F2C_MAC) 	#include <setjmp.h>	#ifdef __cplusplus	extern "C" {	#endif	jmp_buf gRecoverToConsole;	#ifdef __cplusplus	}	#endif//#endif /* Macintosh C compilers */extern short OpenResourceFile(void);MenuHandle KillAMenu(MenuHandle aMenu);extern void	TestNumObjects(void);Boolean			WrongSN(unsigned long);void			SetSN(void);void			SetGPR(long);void			main(void);long			restartProc(void);void			DoInits(void);extern	OSErr	InstallAppleEvents(void);char*			InitPrams(void);void			KillPrams(void);void			test(void);void			DisplayMessage(Rect	theRect,char* theMessage);ProcPtr			DecodeRes(ResType,short);//void			SetPrefFiles(void);extern	PicHandle 	DoUserInfo(Rect*	thePicRect);void	main(){	short			n = 0,m,progID;	PicHandle		thePicture;	char			theText[256];	char			*dummyCharPtr;	unsigned short	theResp;	WindowPtr		startupWindow;	PicHandle		startupPict;	unsigned long	theSN;	Rect			msgRect;	#ifdef NETWORK_VERSION	unsigned char 	**theName;	Handle			theRes;	short			sNum;//iErr;	unsigned long			wait;#endif	//g_AppResFile	= CurResFile();	m = sizeof(int);	MaxApplZone();	n = 0;	dummyCharPtr 	= (char*)0L;/*	SetApplLimit((Ptr)ApplicZone() + 512000);  */			DoInits();	D_HandleInit();	//	n = OpenResourceFile();	gDefault = gCurrentObj = (DiffractObject*)NUL;	gTheText = theText;	pTheText = (unsigned char*)theText;	startupWindow 	= GetNewCWindow(129,0L,(WindowPtr)-1L);	SetPort(startupWindow);	msgRect			= startupWindow->portRect;	startupPict 	= GetPicture(129);	DetachResource((Handle)startupPict);	DrawPicture(startupPict,&startupWindow->portRect);	KillPicture (startupPict);	DisplayMessage(msgRect,"Starting up");	WatchInstall();#ifndef NETWORK_VERSION	#ifndef _DEMO_VERS_		StartWatch();		gTheKeyHandle = (Handle)RBEHANDLE();		SetSN();		theResp =  RBEFINDFIRST(0x8802,&theSN,gTheKeyHandle);	#endif#endif	#ifdef NETWORK_VERSION	lastVerify 	= 0;	progID		= 67;	m 			= 17;	theResp 	= 0;	dummyCharPtr = InitPrams();	DisplayMessage(msgRect,"Configuring Key.");		ip [RB_INIT_COMMAND_P] =		RB_INIT_DATA;	ip [RB_INIT_KEYTYPE_P] =		RB_MACNET_KEY;	ip [RB_INIT_LENGTH_P] =			RB_MEMORY_ARRAY_LEN;	theResp = rbinitialize (mp, ip, RBP_NULL, RBP_NULL);	if(theResp != RB_SUCCESS){		progID = 0;	}		cp[RB_CONFIG_COMMAND_P] 		= RB_CONFIG_SET_ACCESS_TIMEOUT;		// Set 7 minute time out	cp[RB_CONFIG_ACCESS_TIMEOUT_P] 	=  7;	theResp = rbconfigure (mp, cp, qp, RBP_NULL);		cp[RB_CONFIG_COMMAND_P] 		= RB_CONFIG_SET_OPEN_TIMEOUT;		// wait 10 seconds for key	cp[RB_CONFIG_OPEN_TIMEOUT_P] 	=  5000;	theResp = rbconfigure (mp, cp, qp, RBP_NULL);	cp[RB_CONFIG_COMMAND_P] 		= RB_CONFIG_SET_XMIT_RETRY;			// retry 3 times	cp[RB_CONFIG_XMIT_RETRY_P] 		=  3;	theResp = rbconfigure (mp, cp, qp, RBP_NULL);	cp[RB_CONFIG_COMMAND_P] 		= RB_CONFIG_SET_XMIT_TIMEOUT;		// 5 sec for server reponse before retry	cp[RB_CONFIG_XMIT_TIMEOUT_P] 	=  5000;	theResp = rbconfigure (mp, cp, qp, RBP_NULL);		cp[RB_CONFIG_COMMAND_P] = RB_CONFIG_SET_XPORT_RETRY;					cp[RB_CONFIG_XPORT_RETRY_P] =  3;	theResp = rbconfigure (mp, cp, qp, RBP_NULL);	cp[RB_CONFIG_COMMAND_P] = RB_CONFIG_SET_XPORT_TIMEOUT;	cp[RB_CONFIG_XPORT_TIMEOUT_P] = 5000;	theResp = rbconfigure (mp, cp, qp, RBP_NULL);		gCurrentObj	 =	gDefault = (DiffractObject*)AllocDiffractObj();			SetRect(&gTheRect,0,0,300,200);	StopWatch();	thePicture = DoUserInfo(&gTheRect);	StartWatch();	KillPicture(thePicture);	theName		= (unsigned char**)GetResource('DATA',128); /* users Name */	if(ResError() != 0 || (Handle)theName == NUL){		theName = (unsigned char**)NewHandle(128L * sizeof(char));		AddResource((Handle)theName,'DATA',128,"\pUser Name");		ChangedResource((Handle)theName);		WriteResource((Handle)theName);		theName = (unsigned char**)GetResource('DATA',128);	}	//strcpy(gTheRoutine,"main");	strcpy(g_Routine,"main");	D_HLock(theName);	p2cstr(*theName);	if(**theName == (char)0){		strcpy((char*)*theName,"Unknown User");	}		theRes 		= GetResource('ERIC',500);	sNum 		=  **((short**)(theRes));	sNum 		^= 0x7F29;									/* Program Serial Number */	ReleaseResource(theRes);//	theComBlock->DoInit((char*)*theName,sNum,KEY_VERSION);	D_HUnlock(theName);	ReleaseResource((Handle)theName);			DisplayMessage(msgRect,"Looking for key.");			theResp = rbopen (mp, op, RBP_NULL, RBP_NULL);		if(theResp == RB_KEY_INUSE_ELSEWHERE){		Delay(120L,&wait);		theResp = rbopen (mp, op, RBP_NULL, RBP_NULL);	}		if(theResp == RB_KEY_INUSE_ELSEWHERE){		Delay(120L,&wait);		theResp = rbopen (mp, op, RBP_NULL, RBP_NULL);	}		if(theResp != RB_SUCCESS){		progID = 0;		goto KeyErrors;	} else {		gSecure = 17;	}	#else	DisplayMessage(msgRect,"Checking Key");	#ifdef _DEMO_VERS_		//added			n = 0;	#else		theResp =  RBEFINDFIRST(0x8802,&theSN,gTheKeyHandle);		n = theResp;		if(theResp == E3_SUCCESS){		while(n == E3_SUCCESS && WrongSN(theSN)){			n =  RBEFINDNEXT(&theSN,gTheKeyHandle);		}		theResp = 101;	} else {		theResp = 100;		goto KeyErrors;	}	#endif		if(n != 0){		#if defined(_newkey_)			DisposHandle(gTheKeyHandle);			goto KeyErrors;		#else			n = EVEReset();		#endif		gCurrentObj	=	gDefault = (DiffractObject*)AllocDiffractObj(); // keeps cursor alive		StopWatch();		gCurrentObj->DoClose();		StopAlert(COPY_PROTECT,NUL);		WatchRemove();		ExitToShell();	}	n = -1957;	#ifndef _DEMO_VERS_	n = RBEREAD(0x0000,(unsigned short*)&m,0xf85b,gTheKeyHandle);	#endif	dummyCharPtr = InitPrams();		gCurrentObj	=	gDefault = (DiffractObject*)AllocDiffractObj();	gSecure 	= m;#endif		DisplayMessage(msgRect,"Setting Up.");		gDefault->SetObjectDrawTransferMode();	gDefault->SetPictMode(5);	g_Monitor = gInColor;#ifdef NETWORK_VERSION	ap[RB_ACCESS_COMMAND_P] 		=  RB_ACCESS_READ;	ap[RB_ACCESS_CRYPT1_P] 			=  ENCSEED1;	ap[RB_ACCESS_CRYPT2_P] 			=  ENCSEED2;	ap[RB_ACCESS_READ_ADDRESS_P] 	=  0;	theResp = rbaccess (mp, ap, qp, rp);	if(theResp != RB_SUCCESS){		goto KeyErrors;	}	if(KEY_VERSION > rp[0]){		theResp = 2 + 4 * (short)sqrt(625.0);		goto KeyErrors;	}	ap[RB_ACCESS_READ_ADDRESS_P] 	=  2;	theResp = rbaccess (mp, ap, qp, rp);	if(theResp != RB_SUCCESS){		goto KeyErrors;	}	progID	= rp[0];	#else	#ifndef _DEMO_VERS_	n 	= RBEREAD(0x02,(unsigned short*)&progID,2248,gTheKeyHandle);	#endif#endif		#ifndef _DEMO_VERS_		/*progID = 67;	copy protect*/		if(progID != 67){							/* If Not D.M. Key */			goto AbortProc;		}	#endif		gTheWindowStart.h = 5;	gTheWindowStart.v = 45;		gCurrentObj->DoIdle();	/*m = 17;copy protect*/	#ifndef _DEMO_VERS_	if(gSecure != 17){		gQuitFlag = gShutdown = true;	}	#endif	#ifdef NETWORK_VERSION	ap[RB_ACCESS_COMMAND_P] 		=  RB_ACCESS_QUERY;	queryValue						= TickCount();	qp[0]							= ((short*)(&queryValue))[0];	qp[1]							= ((short*)(&queryValue))[1];	theResp = rbaccess (mp, ap, qp, rp);	if(theResp != RB_SUCCESS){		goto KeyErrors;	}	((short*)(&respValue))[0]		= rp[0];	((short*)(&respValue))[1]		= rp[1];	lastVerify						= 0;#else	SetRect(&gTheRect,0,0,300,200);	StopWatch();	thePicture = DoUserInfo(&gTheRect);	StartWatch();	KillPicture(thePicture);		#ifndef _DEMO_VERS_		KEYTEST(gQuitFlag);		if(gQuitFlag){			theResp = 2 + 4 * (short)sqrt(625.0);			goto KeyErrors;		}	#endif			#endif		DisplayMessage(msgRect,"Reading Preferences.");	gDefault->GetPreferenceFile();	gDefault->CheckMode();	StopWatch();	DisplayMessage(msgRect,"Bye!");	DisposeWindow(startupWindow);	//	SetPrefFiles();	//	#if defined(_newkey_)					//	#endif			FlushEvents(everyEvent,0L);	while(!gQuitFlag){		gDebugVar = 0;		CSwitchboard();	}		QuitHere:	;								/* "return" address of @AbortProc */	if(gCurrentObj != (DiffractObject*)NUL){		CloseAllObjects();#ifdef NETWORK_VERSION		StartWatch();		cp [RB_CLOSE_COMMAND_P] 	=	RB_CLOSE_BASE_LICENSE;		cp [RB_CLOSE_BL_CRYPT1_P] 	=	ENCSEED1;		cp [RB_CLOSE_BL_CRYPT2_P] 	=	ENCSEED2;		tp [RB_TERM_COMMAND_P] 		=	RB_TERM_CONNECTION;		theResp = rbclose (mp, cp, RBP_NULL, RBP_NULL);		theResp = rbterminate (mp, tp, RBP_NULL, RBP_NULL);		StopWatch();#endif		WatchRemove();			gDefault->DoClose();	}		KillPrams();		TestNumObjects();		DeleteMenu(1001);	//DeleteMenu(WINDOW_MENU);	ReleaseResource((Handle)g_Apple_Menu);	//DisposeMenu(gTheWindowMenu);		if(gShutdown)		ShutDwnPower();	#ifdef __powerc__		DisposHandle(gTheKeyHandle);	#endif	WatchRemove();	ExitToShell();AbortProc:	;								/* Dummy routine address */	StopWatch();	StopAlert(COPY_PROTECT + 1,NUL);		/* Display message */	goto QuitHere;	KeyErrors:	;	gCurrentObj	=	gDefault = (DiffractObject*)AllocDiffractObj(); // keeps cursor alive	switch(theResp){		case 100:			StopWatch();			StopAlert(COPY_PROTECT + 1,NUL);			WatchRemove();			gDefault->DoClose();			ExitToShell();			break;		case 101:			StopWatch();			ParamText("\pThe serial number of the key and the program do not match.","\p","\p","\p");			StopAlert(1506,NUL);			WatchRemove();			gDefault->DoClose();			ExitToShell();			break;		case 102:			StopWatch();			ParamText("\pThe key does not support this software version.","\p","\p","\p");			StopAlert(1506,NUL);			WatchRemove();			gDefault->DoClose();			break;			#ifdef NETWORK_VERSION		case RNBO_APPLT_SERVER_NOT_IN_NBP_NAMES_TBL:			StopWatch();			ParamText("\pThe Key Server application cannot be found.","\p","\p","\p");			StopAlert(1506,NUL);			WatchRemove();			gDefault->DoClose();			ExitToShell();			break;		case RB_LICENSE_MAX_REACHED:		case RB_KEY_INUSE_ELSEWHERE:			StopWatch();			ParamText("\pMaximum number of users already logged on.","\p","\p","\p");			StopAlert(1506,NUL);			WatchRemove();			gDefault->DoClose();			ExitToShell();			break;#endif		default:			gDefault->DoClose();			goto QuitHere;			break;	}	goto QuitHere;}long restartProc()			{#ifdef NETWORK_VERSION	short	theResp;	cp [RB_CLOSE_COMMAND_P] 	=	RB_CLOSE_BASE_LICENSE;	cp [RB_CLOSE_BL_CRYPT1_P] 	=	ENCSEED1;	cp [RB_CLOSE_BL_CRYPT2_P] 	=	ENCSEED2;	tp [RB_TERM_COMMAND_P] 		=	RB_TERM_CONNECTION;	theResp = rbclose (mp, cp, RBP_NULL, RBP_NULL);	theResp = rbterminate (mp, tp, RBP_NULL, RBP_NULL);#endif	StopWatch();	WatchRemove();	ExitToShell();	return(0L);}void DoInits(){		short 	i;	Handle theMenuBar;	OSErr	iErr;	iErr = 0;		for(i = 0 ; i <= 40 && !iErr; i++){		MoreMasters();		iErr = MemError();	}	gTheHandle 	= GetResource('ERIC',500);  // This was added back in	InitGraf(&qd.thePort);		InitFonts();	//FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(NUL);	InitCursor();	InitPalettes();	//InitBugHunt();	//	CheckMessages		();  Not presently used	gShutdown		= false;	gAppleEvtsOK	= false;		UseResFile		(HomeResFile(gTheHandle));	iErr = ResError();	ReleaseResource(gTheHandle);	g_AppResFile	= CurResFile();	iErr = ResError();		theMenuBar = GetNewMBar(1000);	ClearMenuBar	();/* July 1992 */	SetMenuBar		(theMenuBar);		DrawMenuBar		();	KillMBHandle	(&theMenuBar);		 		g_Apple_Menu 		= GetMenu(1001);	//DetachResource((Handle)g_Apple_Menu);	iErr = ResError();	AddResMenu			(g_Apple_Menu,'DRVR');	iErr = ResError();	iErr = MemError();	gTheWindowMenu 		= NewMenu (WINDOW_MENU, "\pWindows");		iErr = ResError();	iErr = MemError();	//InsertMenu			(g_Apple_Menu,0);	g_Group_ID 			= 0;	TheFilterUPP 		= NewModalFilterProc((ProcPtr)TheFilter);	SmallFilterUPP 		= NewModalFilterProc((ProcPtr)SmallFilter);	MLogFilterUPP       = NewModalFilterProc((ProcPtr)MLogFilter);//ericnew	}char* InitPrams(){		GrafPtr 	thePort;#if !defined(powerc) && !defined(__powerc)	//MenuHandle	fileMenuHandle;	long		result;#endif	GetWMgrPort(&thePort);	InitDialogSetUpParams();	strcpy(g_Routine,"Desktop Microscopist");	//g_Routine				= "Desktop Microscopist";	g_PatchCount			= 0;	//g_threadObj			=	(ThreadsObj*)D_new(ThreadsObj);//g_threadObj->InitThreads();	gTheFile				= (FileObj*)D_new(FileObj);	gTheFile->file_is_Open 	= false;	g_MenuNums				=	8000; /*dec 1992 One More Attempt to solve the menu problem*/	gWaitTime 				= 2;	gInBackground			= false;	gVBL_Flag				= true;	gSkip_Menu_Init			= false;	gTopWindow				= NUL;	gMouseRgn				= D_NewRgn();	gTheRgn					= D_NewRgn();	gUpdateAll				= D_NewRgn();	gScreenSize 			= thePort->portRect;	gNotificationFlag		= false;	SetDAFont(1123);	g_New_Menu 				= DM_GetMenu(10);	g_Crystal_Menu 			= DM_GetMenu(11);	g_PPT_Menu				= DM_GetMenu(13);	g_Crystal_Menu2 		= DM_GetMenu(14);	#ifdef 	NETWORK_VERSION	op [RB_OPEN_COMMAND_P] =			RB_OPEN_FIRST_LICENSE;	op [RB_OPEN_FL_DEVID1_P] =			0x2ce4;	op [RB_OPEN_FL_DEVID2_P] =			0x0000;	op [RB_OPEN_FL_CRYPT1_P] =			0x4cd1;	op [RB_OPEN_FL_CRYPT2_P] =			0xc4b9;#endif		g_Crystal_Face_Menu		= DM_GetMenu(15);	g_el_Tech_Menu			= DM_GetMenu(17);	g_xRay_Tech_Menu		= DM_GetMenu(18);	g_Table_Menu			= DM_GetMenu(20);	g_Elastic_Constant		= DM_GetMenu(26);   /* Added Jim July */	g_Palette_Menu			= DM_GetMenu(177);	g_theFontMenu 			= DM_GetMenu(FONT);/* July 1992 28 */	g_theStyleMenu 			= DM_GetMenu(STYLE);/* July 1992 29*/	g_theSizeMenu 			= DM_GetMenu(SIZE);/* July 1992 30*/		g_theJustifyMenu 		= DM_GetMenu(JUSTIFY);/* July 1992 31*/		g_Microstruc_Tech_Menu  = DM_GetMenu(32); /* Added by J.T. Nov 1991 */	g_theColorMenu 			= DM_GetMenu(COLOR_TEXT_MENU);/* feb 1993 33*/		g_Crystal_Menu3         = DM_GetMenu(52);	g_Base_Crystal_Menu		= DM_GetMenu(53);	g_Exp_Man_Menu			= DM_GetMenu(149);	g_Exp_Lat_Menu			= DM_GetMenu(140);	g_Exp_Vol_Meth_Menu		= DM_GetMenu(139);	g_Exp_Line_Meth_Menu	= DM_GetMenu(138);	g_Pole_Figure_Menu		= DM_GetMenu(153);	g_Hier_Pict_Mode		= DM_GetMenu(HIER_PICT_MODE);//bloch	InsertResMenu			(g_theFontMenu,'FONT',0);		g_Group_ID      = 0;	g_DebyeWaller   = false;	g_StructureEV   = 0;	g_Beam_Type				= 1;	gCount					= 0;	g_Hex_Four				=	true; /* Added by Jim in October */	gTheSelection 			= (SelectRect*)D_new(SelectRect);		gTheSelection->DoInit((WindowPtr)NUL);			g_Window_Number = 1;	g_EVE_Read_Password = D_NewPtr(17 * sizeof(char));	SetRect		(&gTheRect,-32000,-32000,32000,32000);	RectRgn		(gUpdateAll,&gTheRect);	gPrintRecHandle	= (THPrint)GrabResource('PREC',1000,"\pPage Setup",sizeof(TPrint));	//PrOpen();	sprintf((char*)g_EVE_Read_Password,"OjTzhppFdwpozeTx");	theSearchObj = 0L;#if defined(powerc) || defined(__powerc)		InstallAppleEvents();		gAppleEvtsOK = true;#else	if(Gestalt(gestaltVersion,&result) == 0){		#ifdef code68881			 if(Gestalt(gestaltFPUType,&result) == 0){			if(result == gestaltNoFPU){				result = StopAlert(NO_FPU,NUL);				gQuitFlag = true;				return(gTheText);			}else			{				result = 333;			}		}		#endif		if(Gestalt(gestaltSystemVersion,&result) == 0){			if(result >= 0x00000700){				InstallAppleEvents();				gAppleEvtsOK = true;			} else {				//fileMenuHandle = (MenuHandle)GetResource('MENU',10);				//DisableItem (fileMenuHandle, 9);			}		}	} else {		StopWatch();		AlertUser(3);	}#endif	theSearchObj = (SearchObject*)D_new(SearchObject);		theSearchObj->Init();	return((char*)g_EVE_Read_Password);	}void	KillPrams(){	D_delete(gTheFile);	if(gTheSelection->selectPict != (PicHandle)NUL){/*dec 1992*/		KillPicture(gTheSelection->selectPict);		gTheSelection->selectPict = 0L;	}	D_delete(gTheSelection);		FlushEvents(everyEvent,0);	D_DisposeRgn(&gMouseRgn);	D_DisposeRgn(&gTheRgn);	D_DisposeRgn(&gUpdateAll);	KillPtr(g_EVE_Read_Password);	gTheWindowMenu = KillAMenu(gTheWindowMenu);	g_New_Menu = KillAMenu		(g_New_Menu);	g_Crystal_Menu = KillAMenu		(g_Crystal_Menu);	g_Crystal_Menu2 = KillAMenu		(g_Crystal_Menu2);	g_Crystal_Menu3 = KillAMenu		(g_Crystal_Menu3);	g_PPT_Menu = KillAMenu		(g_PPT_Menu);	g_Crystal_Face_Menu = KillAMenu		(g_Crystal_Face_Menu);	g_el_Tech_Menu = KillAMenu		(g_el_Tech_Menu);	g_xRay_Tech_Menu = KillAMenu		(g_xRay_Tech_Menu);	g_Table_Menu = KillAMenu			(g_Table_Menu);	g_Elastic_Constant = KillAMenu		(g_Elastic_Constant);/* added Jim July 1991 */	g_Palette_Menu = KillAMenu			(g_Palette_Menu);	g_Base_Crystal_Menu = KillAMenu		(g_Base_Crystal_Menu);/*dec 1992*/	g_Exp_Man_Menu = KillAMenu			(g_Exp_Man_Menu);/*Aug 1995*/	g_Exp_Lat_Menu = KillAMenu			(g_Exp_Lat_Menu);/*Aug 1995*/	g_Exp_Vol_Meth_Menu = KillAMenu		(g_Exp_Vol_Meth_Menu);/*Aug 1995*/	g_Exp_Line_Meth_Menu = KillAMenu	(g_Exp_Line_Meth_Menu);/*Aug 1995*/	g_Hier_Pict_Mode = KillAMenu		(g_Hier_Pict_Mode);//bloch	g_Pole_Figure_Menu = KillAMenu		(g_Pole_Figure_Menu);	//The following menus cannot be released as resources since they have been detached!!	g_theFontMenu = KillAMenu			(g_theFontMenu);	g_theSizeMenu = KillAMenu			(g_theSizeMenu);	g_theColorMenu = KillAMenu			(g_theColorMenu);	g_theStyleMenu = KillAMenu			(g_theStyleMenu);	g_theJustifyMenu = KillAMenu		(g_theJustifyMenu);	g_Microstruc_Tech_Menu = KillAMenu	(g_Microstruc_Tech_Menu);		//g_Apple_Menu			=	KillAMenu	(g_Apple_Menu);			if(theSearchObj)theSearchObj->Kill();	ReleaseResource((Handle)gPrintRecHandle);	D_HandleReport();	}MenuHandle KillAMenu(MenuHandle aMenu){		if(aMenu == 0L)return 0L;	DeleteMenu			((*aMenu)->menuID);	DisposeMenu			(aMenu);	return 0L;}	void	SetSN(void)	{		unsigned short	**theRes,theResp,i;		unsigned long	**theRes2,sNum;		DialogPtr		theDialog;		Boolean			dQuit = false;		short			resFile,type,theSelect;		Rect			theRect;		KeyMap			keyArray;							theRes 		= (unsigned short**)GetResource('ERIC',500);		if(theRes == NUL || ResError() != 0){			ParamText("\pEric's Resource Error.","\p","\p","\p");			StopWatch();			StopAlert(1506,NUL);			WatchRemove();			ExitToShell();		}		theRes2 		= (unsigned long**)GetResource('ERIC',501);		if(theRes2 == NUL || ResError() != 0){			ReleaseResource((Handle)theRes);			ParamText("\pEric's Resource Error 2.","\p","\p","\p");			StopWatch();			StopAlert(1506,NUL);			WatchRemove();			ExitToShell();		}		GetKeys(keyArray);		if(keyArray[1] == 4 && (*theRes2)[0] == 0x1EEB687D){			#ifndef _DEMO_VERS_			theResp			=  RBEFINDFIRST(0x8802,&sNum,gTheKeyHandle);			#endif			theDialog = GetNewDialog(710,NUL,(WindowPtr)-1L);			sprintf			(gTheText,"%ld",sNum);			GetDItem		(theDialog,3,&type,&gTheHandle,&theRect);			c2pstr			(gTheText);			SetIText		(gTheHandle,pTheText);			SelIText 		(theDialog,3,0,32767);			while(!dQuit){				ModalDialog(NUL,&theSelect);				switch(theSelect){					case DLOG_ENTER_OR_CR:					case 1:						GetIText(gTheHandle,pTheText);						p2cstr(pTheText);						sNum = atol(gTheText);						dQuit = true;						break;					case 2:						dQuit = true;						break;					default:						break;				}			}			DisposeDialog(theDialog);				sNum 			^= 0x7F29D51A;			(*theRes2)[0] 	= 0x5e6a4c5d;			(*theRes2)[1] 	= sNum;			**theRes 		= 0;			resFile			= HomeResFile((Handle)theRes2);			ChangedResource((Handle)theRes2);			WriteResource((Handle)theRes2);			ReleaseResource((Handle)theRes2);			ChangedResource((Handle)theRes);			WriteResource((Handle)theRes);			ReleaseResource((Handle)theRes);			gTheHandle = GetResource('DATA',128);			if(gTheHandle != NUL && ResError() == 0){				if(HomeResFile(gTheHandle) == resFile){					RmveResource(gTheHandle);					DisposHandle(gTheHandle);				} else {					ReleaseResource(gTheHandle);				}			}			for(i = 721 ; i <= 725 ; i++){				gTheHandle = GetResource('DATA',i);				if(gTheHandle != NUL && ResError() == 0){					if(HomeResFile(gTheHandle) == resFile){						RmveResource(gTheHandle);						DisposHandle(gTheHandle);					} else {						ReleaseResource(gTheHandle);					}				}			}			UpdateResFile(resFile);		} else {			ReleaseResource((Handle)theRes2);			ReleaseResource((Handle)theRes);		}	}		Boolean			WrongSN(unsigned long sNum)	{		unsigned long	**theRes,theNum;		return false;			theRes 		= (unsigned long**)GetResource('ERIC',501);		if(theRes == NUL || ResError() != 0){			ParamText("\pEric's Resource Error2.","\p","\p","\p");			StopWatch();			StopAlert(1506,NUL);			WatchRemove();			ExitToShell();		}		HLock((Handle)theRes);		theNum 	= (*theRes)[1];		HUnlock((Handle)theRes);		ReleaseResource((Handle)theRes);		theNum	^= 0x7F29D51A;		return false;		// This cuts out the SN Check for online updates				if(theNum == sNum){			return false;		}		return true;	}void			DisplayMessage(Rect	theRect,char* theMessage){	RGBColor		theColor;	static	Rect	lastRect;	char			theString[128];	short			width,x,y;		TextFont(times);	TextSize(9);	strcpy(theString,theMessage);	c2pstr(theString);	width			= StringWidth((unsigned char*)theString);	x				= theRect.right - 4 - width;	y				= theRect.top + 10;		theColor.red	= 0;	theColor.green	= 0;	theColor.blue	= 0;	RGBForeColor(&theColor);	dm_PaintRect(&lastRect);		theColor.green	= 65535;	RGBForeColor(&theColor);	MoveTo(x,y);	DrawString((unsigned char*)theString);		lastRect.left	= x - 2;	lastRect.bottom = y + 2;	lastRect.top	= theRect.top;	lastRect.right	= theRect.right - 2;}				/*void	SetPrefFiles(void){short 			vRefNum = 1;	HFileInfo		myCPB;	unsigned char	fName[255];	short			index=1;										OSErr			err;               							FInfo			aFilesInfo;		err = GetVol(0,&vRefNum);	myCPB.ioNamePtr = fName;    do    {		myCPB.ioFDirIndex 	= index;         									myCPB.ioDirID 		= theFSSpec.parID;  									myCPB.ioVRefNum 	= vRefNum;     									err 				= PBGetCatInfo((CInfoPBPtr)&myCPB,false);				if (err == noErr){         	if (((myCPB.ioFlAttrib>>4) & 0x01) == 1){	         		theFSSpec.parID = myCPB.ioDirID;         		sprintf(gTheText,"Preference");         		ptocstr(theFSSpec.name);         		if(strcmp(theFSSpec.name,gTheText){         			done = true;         		}         		HFSEnumerateCat(theFSSpec,done);				err = 0;  											} else {				BlockMove((Ptr)&(myCPB.ioFlFndrInfo),(Ptr)&aFilesInfo,sizeof(FInfo));				if(aFilesInfo.fdType ==  'pref' && aFilesInfo.fdCreator == OWNER){                 	gTheFile->fileError =HOpen(myCPB.ioVRefNum,theFSSpec.parID,(unsignedchar*)fName,(SignedByte)fsRdPerm,&gTheFile->pathRefNum);                  	goto FOUNDIT;				}			}        	index += 1;     											        } 															    } while (err == noErr);    sprintf(gTheText,"Preference D.M.");    ctopstr(gTheText);    iErr = Create(pTheText,vRefNum,OWNER,'pref');    return;	FOUNDIT:			}*/