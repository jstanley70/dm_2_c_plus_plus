//0:Sources.Jim:Diffract:DI_AddToDiffractObj.c#include	"Diffract_INCs.h"#include	"Print_Special.h"#include	"crystalFaceObj.h"#include 	"alloyCompEnt.h"#include	"elementInfoObj.h"#include	"UT_VectorMacros.c"#include	"DI_SpotMacros.c"void 			DiffractObject::GetRotPptwrtoMatrixBase(ORel	*theOR,double xForm[][3]){	double theta,x,y,xForm1[3][3],theXForm[3][3],restore[3][3];	double x1,y1,z1;	double x2,y2,z2;	double x3,y3,z3;		theOR->thePPT1->theCrystal->Get001XForm(xForm1);	x2 = (double)theOR->thePPT2->h;	y2 = (double)theOR->thePPT2->k;	z2 = (double)theOR->thePPT2->l;	if(!(theOR->thePPT2->direction))	{		theOR->thePPT2->theCrystal->PlaneToDir(&x2,&y2,&z2);	}		x1 = (double)theOR->thePPT1->h;	y1 = (double)theOR->thePPT1->k;	z1 = (double)theOR->thePPT1->l;	if(!(theOR->thePPT1->direction))	{		theOR->thePPT1->theCrystal->PlaneToDir(&x1,&y1,&z1);	}	//convert ppt1 miller to xyz	TransFormVector(&x1,&y1,&z1,xForm1);	//rotate xyz to current orientation	TransFormVector(&x1,&y1,&z1,xForm);	NormalizeVector(&x1,&y1,&z1);	//convert ppt2 miller to xyz	TransFormVector(&x2,&y2,&z2,xForm1);	//rotate xyz to current orientation	TransFormVector(&x2,&y2,&z2,xForm);	NormalizeVector(&x2,&y2,&z2);	theta = theOR->rot1 * PI / 180.;	if(fabs(theta) > .00001){		x = cos(theta);		y = sin(theta);		FindRotateAboutPoleXform(x2,y2,z2,x,y,theXForm,restore);//now get the rotation		//now apply this rotation to the current orientation matrix.		MatrixMultiply(xForm,theXForm,xForm); 		MatrixMultiply(xForm,restore,xForm); 	}	//now take crossproduct of ppt1 vector and ppt 2 vector, this gives next rotation pole	CrossProduct(&x3,&y3,&z3,x2,y2,z2,x1,y1,z1);	theta = theOR->rot1b * PI / 180.;	if(fabs(theta) > .00001){		x = cos(theta);		y = sin(theta);		FindRotateAboutPoleXform(x3,y3,z3,x,y,theXForm,restore);//now get the rotation		MatrixMultiply(xForm,theXForm,xForm); 		MatrixMultiply(xForm,restore,xForm); 	}	//now apply this rotation to the current orientation matrix.	//now recalculate the postion of ppt1 to the new orientation	x1 = (double)theOR->thePPT1->h;	y1 = (double)theOR->thePPT1->k;	z1 = (double)theOR->thePPT1->l;	if(!(theOR->thePPT1->direction))	{		theOR->thePPT1->theCrystal->PlaneToDir(&x1,&y1,&z1);	}	//convert ppt1 miller to xyz	TransFormVector(&x1,&y1,&z1,xForm1);	//rotate xyz to current orientation	TransFormVector(&x1,&y1,&z1,xForm);//now get rotation about this axis.	NormalizeVector(&x1,&y1,&z1);	theta = theOR->rot2 * PI / 180.;	if(fabs(theta) > .00001){		x = cos(theta);		y = sin(theta);		FindRotateAboutPoleXform(x1,y1,z1,x,y,theXForm,restore);//now get the rotation		MatrixMultiply(xForm,theXForm,xForm); 		MatrixMultiply(xForm,restore,xForm); 	}	//now apply this rotation to the current orientation matrix.	}void	DiffractObject::GetPPTXFormMatrixBase(double theYForm[][3],Crystal *thisCrystal,short variant){	double um1,vm1,wm1,up1,vp1,wp1,um2,vm2,wm2,up2,vp2,wp2;	double pptXForm[3][3],matrixRotation[3][3],pptRotation[3][3],matrixXform[3][3];	double x,y,z,sVals[6],A[3][3],B[3][3],sVals2[6];	short	i,j,k=0;		Crystal	*theMatrix;	ORel	*thisOR;	Index	*matrix1,*matrix2,*ppt1,*ppt2;			for(i = 0 , j = -1; i <= 3 ; i++){							/*  Who am I???  */		if(thisCrystal == theCrystal[i]){			j = i;		}	}		if(j < 0)													/*  ERROR  no such crystal	*/		return;		if(j == baseCrystal || the_PPT_Info[j - 1]->lastOR < 0){				 /* Matrix or no ORs */		thisCrystal->Get001XForm(theYForm);		return;	}		if(variant > the_PPT_Info[j - 1]->lastOR || variant < 0){	/*  No such variant	*/		thisCrystal->Get001XForm(theYForm);		return;	}			thisCrystal->Get001XForm(pptXForm);	theMatrix = theCrystal[0];	theMatrix->Get001XForm(matrixXform);	thisOR 	= the_PPT_Info[j - 1]->theORs[variant];	matrix1 = thisOR->theMatrix1;	ppt1 	= thisOR->thePPT1;	matrix2 = thisOR->theMatrix2;	ppt2 	= thisOR->thePPT2;		um1 		= (double)matrix1->h;	vm1 		= (double)matrix1->k;	wm1 		= (double)matrix1->l;		um2 		= (double)matrix2->h;	vm2 		= (double)matrix2->k;	wm2 		= (double)matrix2->l;		up1 		= (double)ppt1->h;	vp1 		= (double)ppt1->k;	wp1 		= (double)ppt1->l;		up2 		= (double)ppt2->h;	vp2 		= (double)ppt2->k;	wp2 		= (double)ppt2->l;		BlockMove((Ptr)(theMatrix->sVals),(Ptr)sVals,6 * sizeof(double));	BlockMove((Ptr)(thisCrystal->sVals),(Ptr)sVals2,6 * sizeof(double));		if(!matrix1->direction){		x = um1 * sVals[0] + vm1 * sVals[3] + wm1 * sVals[5];		y = um1 * sVals[3] + vm1 * sVals[1] + wm1 * sVals[4];		z = um1 * sVals[5] + vm1 * sVals[4] + wm1 * sVals[2];		um1 = x;		vm1 = y;		wm1 = z;				x = up1 * sVals2[0] + vp1 * sVals2[3] + wp1 * sVals2[5];		y = up1 * sVals2[3] + vp1 * sVals2[1] + wp1 * sVals2[4];		z = up1 * sVals2[5] + vp1 * sVals2[4] + wp1 * sVals2[2];		up1 = x;		vp1 = y;		wp1 = z;	}		if(!matrix2->direction){		x = um2 * sVals[0] + vm2 * sVals[3] + wm2 * sVals[5];		y = um2 * sVals[3] + vm2 * sVals[1] + wm2 * sVals[4];		z = um2 * sVals[5] + vm2 * sVals[4] + wm2 * sVals[2];		um2 = x;		vm2 = y;		wm2 = z;				x = up2 * sVals2[0] + vp2 * sVals2[3] + wp2 * sVals2[5];		y = up2 * sVals2[3] + vp2 * sVals2[1] + wp2 * sVals2[4];		z = up2 * sVals2[5] + vp2 * sVals2[4] + wp2 * sVals2[2];		up2 = x;		vp2 = y;		wp2 = z;	}		TRANSFORM_VECTOR(um1,vm1,wm1,matrixXform);	TRANSFORM_VECTOR(um2,vm2,wm2,matrixXform);	TRANSFORM_VECTOR(up1,vp1,wp1,pptXForm);	TRANSFORM_VECTOR(up2,vp2,wp2,pptXForm);		FIND_CENTER_XFORM(um1,vm1,wm1,A);		FindCenterXform(um1,vm1,wm1,A);			/* Get xform for centering matrix vector #1 */	TRANSFORM_VECTOR(um2,vm2,wm2,A);		/* Rotate matrix vector #2	*/	FIND_HORIZ_XFORM(um2,vm2,B);				/* Get Horiz xform for matrix vector #2 */	MATRIX_MULTIPLY(A,B,matrixRotation); 	INVERT_MATRIX(matrixRotation);	FIND_CENTER_XFORM(up1,vp1,wp1,A);	TRANSFORM_VECTOR(up2,vp2,wp2,A);		FIND_HORIZ_XFORM(up2,vp2,B); 					/* Get Horiz xform for PPT vector #2 			*/	MATRIX_MULTIPLY(A,B,pptRotation);			MATRIX_MULTIPLY(pptRotation,matrixRotation,pptRotation);		MATRIX_MULTIPLY(pptXForm,pptRotation,pptXForm);//the pptXForm orients ppt crystal to orientation relation + beam orientation	if(j > 0 && (thisOR->rot1 != 0.0 || thisOR->rot2 != 0.0)){		GetRotPptwrtoMatrixBase(thisOR,pptXForm);	}	for(i = 0 ; i <= 2 ; i++){		for(j = 0 ; j <= 2 ; j++){			theYForm[i][j] = pptXForm[i][j];		}	}}void	DiffractObject::DM_DrawRect(Rect theRect,short theCrystal,short theIntensity,Boolean direction){	short aValue,bValue,value;	RgnHandle theRgn;	if(direction) 		value = theCrysSymbols_D[theCrystal];	else		value = theCrysSymbols_P[theCrystal];	if(g_Monitor)	{				if(greyFlag)		{			DMForeColor(theIntensity + 15);		}else{			if(theCrystal == 4)theCrystal++;			DMForeColor(theCrystal + 10);		}	}else	{		PenNormal();		DMForeColor(BLACK);		/*FrameOval(&theRect);Feb 1993*/		if(greyFlag)		{			short patID;			double theValue;			PatHandle hPat;			theValue = theIntensity;			patID = Round(theValue);			patID += 300;			hPat = GetPattern(patID);			HLock((Handle)hPat);			PenPat(*hPat); 			HUnlock((Handle)hPat);			ReleaseResource((Handle)hPat);		}	}		switch(value)	{		case 0:			dm_PaintOval(&theRect);			break;		case 1:			dm_FrameOval(&theRect);			break;		case 2:			dm_PaintRect(&theRect);			break;		case 3:			dm_FrameRect(&theRect);			break;		case 4:			aValue = (theRect.top + theRect.bottom )/ 2;			bValue = (theRect.left + theRect.right )/ 2;			MoveTo(theRect.left,aValue);			LineTo(bValue,theRect.top);			LineTo(theRect.right,aValue);			LineTo(bValue,theRect.bottom);			LineTo(theRect.left,aValue);			break;		case 5:			theRgn = D_NewRgn();			aValue = (theRect.top + theRect.bottom )/ 2;			bValue = (theRect.left + theRect.right )/ 2;			OpenRgn();				MoveTo(theRect.left,aValue);				LineTo(bValue,theRect.top);				LineTo(theRect.right,aValue);				LineTo(bValue,theRect.bottom);				LineTo(theRect.left,aValue);			CloseRgn(theRgn);			PaintRgn(theRgn);			D_DisposeRgn(&theRgn);			break;		case 6:						aValue = (theRect.left + theRect.right )/ 2;			MoveTo(aValue,theRect.bottom -1);			LineTo(aValue,theRect.top);			dm_FrameRect(&theRect);			break;		case 7:						aValue = (double)(theRect.top + theRect.bottom ) / 2;			MoveTo(theRect.left,aValue);			LineTo(theRect.right - 1,aValue);			dm_FrameRect(&theRect);			break;					case 8:			aValue = (theRect.left + theRect.right )/ 2;			MoveTo(aValue,theRect.top);			LineTo(aValue,theRect.bottom);			aValue = (theRect.top + theRect.bottom )/ 2;			MoveTo(theRect.left,aValue);			LineTo(theRect.right,aValue);			break;					case 9:			MoveTo(theRect.left,theRect.top);			LineTo(theRect.right,theRect.bottom);			MoveTo(theRect.left,theRect.bottom);			LineTo(theRect.right,theRect.top);			break;				case 10:						aValue = (theRect.left + theRect.right )/ 2;			MoveTo(aValue,theRect.bottom - 1);			LineTo(aValue,theRect.top);			dm_FrameOval(&theRect);			break;		case 11:									aValue = (theRect.top + theRect.bottom )/ 2;			MoveTo(theRect.left,aValue);			LineTo(theRect.right - 1,aValue);			dm_FrameOval(&theRect);			break;	}	PenPat(&qd.black);}void DiffractObject::CopyObjTo(DiffractObject *theObj,Boolean all){	short		i;	RGBColor	**theColor;	if(this == theObj) return;	if(all){		for(i = 500 ; i <= 503 ; i++){			theColor = (RGBColor**)GetResource('COLR',i);			**theColor = theCrystal[i - 500]->crystalColor;			ChangedResource((Handle)theColor);			WriteResource((Handle)theColor);			ReleaseResource((Handle)theColor);		}		theColor = (RGBColor**)GetResource('COLR',i);		**theColor = backgroundColor;		ChangedResource((Handle)theColor);		WriteResource((Handle)theColor);		ReleaseResource((Handle)theColor);		for(i = 0; i <= 4;i++){			theObj->theCrysSymbols_P[i] = theCrysSymbols_P[i] ;			theObj->theCrysSymbols_D[i] = theCrysSymbols_P[i] ;		}		theObj->backgroundColor = backgroundColor;		theEBeam->DoCopy(theObj->theEBeam);		theXRay->DoCopy(theObj->theXRay);		theObj->energy				= 	energy;		theObj->wavelength			= 	wavelength;		theObj->cameraConstant 		= 	cameraConstant;		theObj->dyRange 				= 	dyRange;		theObj->expoTime				= 	expoTime;		theObj->negWidth 				= 	negWidth;		theObj->negHeight 			= 	negHeight;		theObj->maxEnergy 			= 	maxEnergy;		theObj->convergenceAngle 		= 	convergenceAngle;		theObj->magnification 		= 	magnification;		theObj->cameraLength			=	cameraLength;		theObj->projLengthScreen		=	projLengthScreen;		theObj->temperature					=	temperature;		theObj->calcDW							=	calcDW;		theObj->dynamic_Calc				=	dynamic_Calc;		theObj->pictTransferMode 		= pictTransferMode;		theObj->gMode 							= gMode;		theObj->toggleDraw 					= toggleDraw;		theObj->forceOverlay 				= forceOverlay;		theObj->kLineMult  = kLineMult;		theObj->spotMult   = spotMult;	}		for(i = 0; i <= 3; i++){		theCrystal[i]->CopyCrystal(theObj->theCrystal[i]);	}	for(i = 0; i <= 2;i++)	{		the_PPT_Info[i]->DoCopy(theObj->the_PPT_Info[i]);	}		theObj->linking				=	linking;	theObj->x_001				=	x_001;	theObj->y_001				=	y_001;	theObj->z_001				=	z_001;	theObj->baseCrystal			=	baseCrystal;	theObj->delAngle				=	delAngle;			theObj->rotationAngle			=	rotationAngle;	theObj->offLaueDistance		=	offLaueDistance;	theObj->beamAzimuth				=	beamAzimuth;	theObj->stage->DoCopy(stage);	theZoneAxis->DoCopy(theObj->theZoneAxis);	theRotationAxis->DoCopy(theObj->theRotationAxis);	g_Vector	->DoCopy(theObj->g_Vector);	theObj->totalRot				=	totalRot;	theObj->calcIrrational	=	calcIrrational;	theObj->foilParallel		=	foilParallel;	theFoilNormal		->		DoCopy(theObj->theFoilNormal);	theFNRotationAxis	->	DoCopy(theObj->theFNRotationAxis);	theFoilBragg		->		DoCopy(theObj->theFoilBragg);	theObj->theFNRotationAngle 		= theFNRotationAngle;	theObj->theFNOffLaueDistance 	= theFNOffLaueDistance;	theObj->calcFoil				=	calcFoil;	theObj->trueThickness 	= trueThickness;	theObj->theFoilThickness		= 	theFoilThickness;	theObj->absorpMean			=		absorpMean;//bloch		theObj->delAngle 				= delAngle;	CopyFoundation(theObj);	theObj->CheckMode();	}double DiffractObject::GetSpikingFactor(Index *theIndex,Index *aIndex,Index *bIndex,double rot1,double rot2,double thick,short method,Crystal *thisCrystal){	double chx,chy,chz,ckx,cky,ckz,clx,cly,clz,length,length1;	short i,H,K,L;	double xForm[3][3],xFormMatrix[3][3];	double val3;	double zMax = 0;	double zMin = 0;	double	z = 0;	double	value;	if(thisCrystal->idNum == baseCrystal){		value = fabs(cos(AngleBetFoilAndBeam(theIndex,aIndex,bIndex,rot1,rot2,z,method)));		if(value < .01 || value > 1)value = 1;		trueThickness = thick / value;				return spotMult * 100. / (double)trueThickness;  	}	GetOrientation(xFormMatrix);//	InvertMatrix(xFormMatrix);	GetPPTXFormMatrixBase(xForm,thisCrystal,0);	MatrixMultiply(xForm,xFormMatrix,xForm); 	ConverttoReciprocal(xForm,(double)thisCrystal->volume,true);		chx = xForm[0][0];	chy = xForm[1][0];	chz = xForm[2][0];	ckx = xForm[0][1];	cky = xForm[1][1];	ckz = xForm[2][1];	clx = xForm[0][2];	cly = xForm[1][2];	clz = xForm[2][2];			for(i = 0; i <= thisCrystal->face_Count; i++){			H = (*thisCrystal->theFaces)[i].h;			K = (*thisCrystal->theFaces)[i].k;			L = (*thisCrystal->theFaces)[i].l;		    length = (*thisCrystal->theFaces)[i].length ;		    length1 = sqrt((double)(H * H + K * K + L * L));			z = length * (H * chz + K * ckz + L * clz) / length1;									if(z > zMax) zMax = z;			if(z < zMin) zMin = z;				}	val3 = (zMax - zMin);	/*if(val3 < 20) val3 = 20;*/	if(val3 < .000001)value = 10000;	return fabs(1/val3);}