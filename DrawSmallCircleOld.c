void	StereoObject::DrawSmallCircle(SpotInfo *thisPole,Boolean erase){	double				theXForm[3][3],								theRadius,								theAngle,								x,y,z,								x1,y1,z1,								factor;	double				theX2,								theY2,								theX1,								theY1,								cx,cy,dx,								dy,inc,								start,end;	double				projRad2,centX,centY,aInc,bInc;	RgnHandle			oldClip,circleClip,screenClip;	short					theValue,i,count,h1,h2,v1,v2;	double 			angle,py,px,rad,inc2;	Boolean				plotOK = false,initFlag = true;	Point					thePoint;	double 			xMin,xMax,yMin,yMax,a1,a2;	Boolean				loopFlag = true,plotFlag = false;	Rect					clipRect;	theAngle	= thisPole->angle;	theRadius	= fabs(sin(theAngle));		if(objectType !=  KIKUCHI_OBJECT || objectType !=  KIKUCHI_OBJECT + 10){		if(thisPole->z < 0.0 && thisPole->z < -theRadius)			return;	}		centX		= centerX;	centY		= centerY;		x = thisPole->x;	y = thisPole->y;	z = thisPole->z;	FIND_CENTER_XFORM(x,y,z,theXForm);	z			= fabs(cos(theAngle));	theAngle	= atan2((double)thisPole->y,(double)thisPole->x) + PI;	x 			= theRadius * cos(theAngle);	y 			= theRadius * sin(theAngle);		z1			= x * theXForm[2][0] + y * theXForm[2][1] + z * theXForm[2][2];	x1			= x * theXForm[0][0] + y * theXForm[0][1] + z * theXForm[0][2];	y1			= x * theXForm[1][0] + y * theXForm[1][1] + z * theXForm[1][2];		factor		= 1.0 + z1;	if(factor != 0.0){		factor		= radius / factor;		theX2		= centX - factor * y1;		theY2		= centY - factor * x1;	} else {		theX2		= 30000;		theY2		= 30000;	}		x 			= -x;	y 			= -y;		z1			= x * theXForm[2][0] + y * theXForm[2][1] + z * theXForm[2][2];	x1			= x * theXForm[0][0] + y * theXForm[0][1] + z * theXForm[0][2];	y1			= x * theXForm[1][0] + y * theXForm[1][1] + z * theXForm[1][2];		factor		= 1.0 + z1;	if(factor != 0.0){		factor		= radius / factor;		theX1		= centX - factor * y1;		theY1		= centY - factor * x1;	} else {		theX1		= 30000;		theY1		= 30000;	}	oldClip 	= NewRgn();	circleClip 	= NewRgn();	screenClip 	= NewRgn();	GetClip(oldClip);	h1	= centerX - radius;	v1	= centerY - radius;	h2	= centerX + radius;	v2	= centerY + radius;	SetRect(&gTheRect,h1,v1,h2,v2);		OpenRgn();	FrameOval(&gTheRect);	CloseRgn(circleClip);	SetClip(circleClip);		PenNormal();	PenPat(&qd.black);	if(erase){		DMForeColor(BACKGROUND_COLOR);	} else {		if(g_Monitor){			if(greyFlag){				theValue = 220 * pow((double)thisPole->intensity,1/dyRange);				DMForeColor(theValue + 15);			} else {				thisPole->theCrystal->SetColor();			}		} else {			DMForeColor(BLACK);		}	}		cx 			= (theX1 + theX2) / 2.0;	cy 			= (theY1 + theY2) / 2.0;	dx 			= theX1 - cx;	dy 			= theY1 - cy;	theRadius 	= sqrt(dx * dx + dy * dy);		x 			= cx - theRadius;	x1			= cx + theRadius;	y 			= cy - theRadius;	y1			= cy + theRadius;		projRad2 	= radius;	projRad2 	*= projRad2;  /* here */			if(theRadius > 75000){		start 	= atan2((cy - centY),(centX - cx));		end 	= start + PI * .5;		x		= cx + theRadius * cos(start);		y		= cy - theRadius * sin(start);		dx		= 5000. * cos(end);		dy		= 5000. * sin(end);		MoveTo((short)(x + dx),(short)(y + dy));		LineTo((short)(x - dx),(short)(y - dy));	} else if(x < -25000. || x1 > 25000. || y < -25000. || y1 > 25000 || (printing && theRadius < radius)){				rad		= theRadius;		start 	= atan2((cy - centY),(centX - cx)) - PI; 				/* Begin off screen */		end 	= start + 2.0 * PI; 									/* One full rotation */		aInc	= 2.0  / rad;											/* 2 pixel arc length  */		bInc	= aInc * 32;											/* 64 pixel search arc length  */				inc		= bInc;																		for(angle = start ; angle <= end ; angle += inc){			px = cx + rad * cos(angle);			py = cy - rad * sin(angle);						x 	= px - centX;			x	*= x;			y	= py - centY;			y	*= y;									if((x + y) <= projRad2){				if(initFlag){					if(px >= 0.0){						thePoint.h = (short)(px + .5);					} else {						thePoint.h = (short)(px - .5);					}									if(py >= 0.0){						thePoint.v = (short)(py + .5);					} else {						thePoint.v = (short)(py - .5);					}										MoveTo(thePoint.h,thePoint.v);					initFlag = false;				}								if(!plotOK){					inc2 = inc * .5;					angle -= inc2;										for(i = 1 ; i <= 9 ; i++){						px = cx + rad * cos(angle);						py = cy - rad * sin(angle);									x 		 = px - centX;						x		*= x;						y		 = py - centY;						y		*= y;						inc2 	*= .5;												if((x + y) <= projRad2){							angle -= inc2;						} else {							angle += inc2;						}					}										if(px >= 0.0){						thePoint.h = (short)(px + .5);					} else {						thePoint.h = (short)(px - .5);					}									if(py >= 0.0){						thePoint.v = (short)(py + .5);					} else {						thePoint.v = (short)(py - .5);					}										MoveTo(thePoint.h,thePoint.v);					plotOK 	= true;					inc		= aInc;				} else {					if(px >= 0.0){						thePoint.h = (short)(px + .5);					} else {						thePoint.h = (short)(px - .5);					}									if(py >= 0.0){						thePoint.v = (short)(py + .5);					} else {						thePoint.v = (short)(py - .5);					}					LineTo(thePoint.h,thePoint.v);				}			} else if(plotOK){				inc2 	 = inc * .5;				angle -= inc2;									for(i = 1 ; i <= 5 ; i++){					px = cx + rad * cos(angle);					py = cy - rad * sin(angle);										x 	 = px - centX;					x	*= x;					y	 = py - centY;					y	*= y;										inc2 *= .5;										if((x + y) <= projRad2){						angle += inc2;					} else {						angle -= inc2;					}									}				if(px >= 0.0){					thePoint.h = (short)(px + .5);				} else {					thePoint.h = (short)(px - .5);				}							if(py >= 0.0){					thePoint.v = (short)(py + .5);				} else {					thePoint.v = (short)(py - .5);				}				LineTo(thePoint.h,thePoint.v);				plotOK 	= false;					inc		= bInc;				} 			initFlag = false;		}	} else {			if(x > 0){			x += .5;		} else {			x -= .5;		}			if(x1 > 0){			x1 += .5;		} else {			x1 -= .5;		}			if(y > 0){			y += .5;		} else {			y -= .5;		}			if(y1 > 0){			y1 += .5;		} else {			y1 -= .5;		}				SetRect(&gTheRect,(short)x,(short)y,(short)x1,(short)y1);		if(objectType ==  KIKUCHI_OBJECT || objectType ==  KIKUCHI_OBJECT + 10)			thisPole->spotRect = gTheRect;				start 		= atan2((cy - centY),(centX - cx)); 					/* Begin on screen */		end 		= start + 2.0 * PI;		rad			= theRadius;		aInc		= PI / 2.;							inc			= aInc;				xMin		= 32000;		yMin		= 32000;		xMax		= -32000;		yMax		= -32000;		count		= 0;		angle 		= start;		px			= -projRad2;				while(fabs(px - projRad2) > 1.0){			x 	= cx + rad * cos(angle);			y 	= y - rad * sin(angle);/*py =*/			px	= x - centX;			py	= y - centY;			px	= px * px + py * py;						a2 	= angle;			if(px <= projRad2){				angle += inc;			} else {				angle -= inc;			}			inc *= .51;			if(count++ > 40){				a2 =  2.0 * PI;				break;			}		}						if(x < xMin){			xMin = x;		}		if(x > xMax){			xMax = x;		}		if(y < yMin){			yMin = y;		}		if(y > yMax){			yMax = y;		}				angle 	= start;		px			= -projRad2;		inc			= aInc;		count 	= 0;		while(fabs(px - projRad2) > 1.0){			x 	= cx + rad * cos(angle);			y 	= cy - rad * sin(angle);/*= py*/			px	= x - centX;			py	= y - centY;			px	= px * px + py * py;						a1 = angle;			if(px <= projRad2){				angle -= inc;			} else {				angle += inc;			}			inc *= .51;			if(count++ > 40){				a1 = 0.0;				break;			}		}				if(x < xMin){			xMin = x;		}		if(x > xMax){			xMax = x;		}		if(y < yMin){			yMin = y;		}		if(y > yMax){			yMax = y;		}				aInc = PI / 90.0;		inc  = aInc;				for(angle = a1 ; angle <= a2 ; angle += inc){			x 	= 	cx + rad * cos(angle);			y 	=  	cy - rad * sin(angle);/*py =*/			px	= x - centX;			py	= y - centY;			px	= px * px + py * py;					loopFlag = false;						if(px <= projRad2){							if(x < xMin){					xMin = x;					loopFlag = true;				}				if(x > xMax){					xMax = x;					loopFlag = true;				}				if(y < yMin){					yMin = y;					loopFlag = true;				}				if(y > yMax){					yMax = y;					loopFlag = true;				}			}						if(loopFlag && count < 8){				angle -= inc;				inc *= .51;				count++;			} else {				count = 0;				inc = aInc;			}		}								clipRect.left 	= xMin - 1;		clipRect.top 		= yMin - 1;		clipRect.right 	= xMax + 1;		clipRect.bottom = yMax + 1;		RectRgn						(circleClip,&clipRect);				clipRect.left 	= (short)(centX - radius);		clipRect.top 		= (short)(centY - radius);		clipRect.right 	= (short)(centX + radius);		clipRect.bottom = (short)(centY + radius);		OpenRgn		();		FrameOval	(&clipRect);		CloseRgn	(screenClip);		SectRgn		(circleClip,screenClip,screenClip);		SetClip		(screenClip);					if(greyFlag){			theValue = 220 * pow((double)thisPole->intensity,1/dyRange);			DMForeColor		(theValue + 15);		}						FrameOval	(&gTheRect);		}	SetClip		(oldClip);	DisposeRgn(oldClip);	DisposeRgn(circleClip);	DisposeRgn(screenClip);	return;}