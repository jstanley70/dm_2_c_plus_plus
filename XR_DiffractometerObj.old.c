#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"SF_MathLib.h"#include	"DiffractometerObj.h"#include	"GraphSpots.h"void DiffractometerObj::DoInit() {	graph = 0L;	spectralDataHdn = 0L;	inherited::DoInit();	}void DiffractometerObj::SetObjectMenu(){	theMenuBar = GetNewMBar(320);	SetMenuBar(theMenuBar);	}  void	DiffractometerObj::SetObjectWindowTitle(void){	short k;	SetRect(&graphBox,80,80,516,350);	graph	= (GraphSpots*)D_new(GraphSpots);	graph->DoInit(graphBox);	/*	graphBox = thePictRect;	SetRect(&graphBox,80,80,516,350);	maxPlottedX = maxX = 100;	minPlottedX = minX = 0;	maxPlottedY = maxY = 1.0;	minPlottedY = minY = 0;	tickIntervalY = .1;	tickIntervalX = 10;	centerX = graphBox.left;	centerY = graphBox.bottom;	SetPlotScales();		sprintf(gTheText,"2 Theta in Degrees");	k = strlen(gTheText);	xAxisTitle = D_NewPtr((long)(k + 1) * sizeof(char));	strcpy(xAxisTitle,gTheText);		sprintf(gTheText,"Intensity as Percentage");	k = strlen(gTheText);	yAxisTitle = D_NewPtr((long)(k + 1) * sizeof(char));	strcpy(yAxisTitle,gTheText);			xAxisTStart.h = (graphBox.right - graphBox.left) / 2 ;	xAxisTStart.v = centerY + 40;	yAxisTStart.v = (graphBox.bottom - graphBox.top) / 2 ;	yAxisTStart.h = centerX - 60;	*/	sprintf(gTheText,"2 Theta in Degrees");	graph->SetTitleX(gTheText);	sprintf(gTheText,"Intensity as Percentage");	graph->SetTitleY(gTheText);	sprintf(gTheText,"Diffractometer");	graph->SetTitleGraph(gTheText);	SetRect(&theCourserRect,graphBox.left,graphBox.top,graphBox.left + 2,graphBox.bottom);		theBeamFlag = 2;	energy =  theXRay->energy;	wavelength = theXRay->wavelength;	maxEnergy = energy;		theRuler->SetBeamButton(theBeamFlag);		if(gTheFile->file_is_Open){		SetWTitle(theWindow,fileInfo.sfFile.name);		return;	}	sprintf(gTheText,"Diffractometer %d",g_Window_Number);	SetWTitle(theWindow,c2pstr(gTheText));	g_Window_Number++;}void 	DiffractometerObj::DoClose			(void){	/*KillPtr((Ptr)yAxisTitle);	KillPtr((Ptr)xAxisTitle);*/	graph->DoClose();	inherited::DoClose();}void DiffractometerObj::SetPlotScales(void){	/*	scaleFactor 	= (graphBox.right - graphBox.left) / (maxPlottedX - minPlottedX);	scaleFactorY 	= (graphBox.bottom - graphBox.top) / (maxPlottedY - minPlottedY);	sFChannels 		= scaleFactor * delXperChannel;	sFPhotons 		= (graphBox.bottom - graphBox.top) / ((double)maxPhotons);	*/}void DiffractometerObj::SetDLogNames(DialogPtr theDialog){	HideDItem(theDialog,9);	HideDItem(theDialog,10);}void DiffractometerObj::DoDefine(void){	DialogPtr 		theDialog;	short			theSelect,i;	Boolean			quit,calculateFlag;	GrafPtr			theOldPort;	Boolean oldPlotFlag;		GetPort(&theOldPort);	SetDialogMenuBar(); /*July 1992 */	theDialog	= GetNewDialog(DIFMET_DEFINE_OBJ,NUL,IN_FRONT);		SetPort(theDialog);	HiliteOK(theDialog);	calculateFlag = quit = false;		for(i = 3; i <= 6;i++){			GetDItem(theDialog,i,&gType,&gTheHandle,&gTheRect);			SetCtlValue((ControlHandle)gTheHandle,plotFlags[i - 3]);	}	SetDLogNames(theDialog);			GetDItem(theDialog,7,&gType,&gTheHandle,&gTheRect);	sprintf(gTheText,"%6.2f",minX);	SetIText(gTheHandle,c2pstr(gTheText));			GetDItem(theDialog,8,&gType,&gTheHandle,&gTheRect);	sprintf(gTheText,"%6.2f",maxX);	SetIText(gTheHandle,c2pstr(gTheText));				while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case -1:			case 2:				quit = true;				break;			case DLOG_ENTER_OR_CR:				calculateFlag = true;					quit = true;				break;			case 3:			case 4:			case 5:			case 6:			case 9:			case 10:				GetDItem(theDialog,theSelect,&gType,&gTheHandle,&gTheRect);				if(GetCtlValue((ControlHandle)gTheHandle) == 0){					SetCtlValue((ControlHandle)gTheHandle,1);				} else {					SetCtlValue((ControlHandle)gTheHandle,0);				}				break;			default:				break;		}	}			if(calculateFlag){		calculateFlag = false;		oldPlotFlag = plotFlags[4];		calculateFlag  = DialogRead(theDialog);		for(i = 3; i <= 6;i++){			GetDItem(theDialog,i,&gType,&gTheHandle,&gTheRect);			if(GetCtlValue((ControlHandle)gTheHandle) == 0){				plotFlags[i - 3] = false;			} else {				if(i <= 6 && !calculateFlags[i - 3]) calculateFlag = true;				plotFlags[i - 3] = true;			}		}		baseCrystal = 0;		while(!plotFlags[baseCrystal] && baseCrystal < 4){			baseCrystal++;		}		if(baseCrystal == 4){			calculateFlag = false;			baseCrystal = 1;		}else{			if(screenPict == NUL)				calculateFlag = true;		}		DisposDialog(theDialog);		SetPort(theOldPort);		KillDialogMenuBar(); /*July 1992 */		if(calculateFlag)			DoCalculate();		ResizeGraphBox();		newPictEnable = true;		newPictReq 	= 	true;			} else if(screenPict == NUL){		DisposDialog(theDialog);		SetPort(theOldPort);		KillDialogMenuBar(); /*July 1992 */		CloseTheObject(theWindow);	}else{		DisposDialog(theDialog);		SetPort(theOldPort);		KillDialogMenuBar(); /*July 1992 */		newPictEnable = true;		newPictReq 	= 	true;	}		return;}Boolean DiffractometerObj::DialogRead(DialogPtr theDialog){	double oldValue;	GetDItem(theDialog,7,&gType,&gTheHandle,&gTheRect);	GetIText(gTheHandle,pTheText);	minPlottedX = atof((p2cstr(pTheText)));	minX = minPlottedX;	GetDItem(theDialog,8,&gType,&gTheHandle,&gTheRect);	GetIText(gTheHandle,pTheText);	oldValue = maxX;	maxPlottedX = atof((p2cstr(pTheText)));	maxX = maxPlottedX;	if(oldValue < maxX) return true;	return false;}double DiffractometerObj::SetRecpSize(void){	return 2. * sin(.5 * maxX * PI / 180) / wavelength;}void	DiffractometerObj::MyCalculate(void){		long 		thehMax,thekMax,thelMax,i;		long		hmax,kmax,lmax;				double 		theDist,reciprocalLatticeSize,intens;		SpotInfoPtr	theSpots,thisSpot;		short double 		maxIntensity[4];		short		plotCrystal,h,k,l,atom_Count;		Crystal 	*thisCrystal;			Atom 		 *theAtoms;				double 		*theUs,*theVs,*theWs,					*theZs,					inverseVol,inverseVolSqr;							double  	dH,dK,dL;		double 		sh2 , sk2 , sl2 , skl , shl , shk,theta;					D_MFTempHLock(theDataHandle);	theSpots = (SpotInfoPtr)*theDataHandle;	data_Count = 0;					for(i = 0; i <= 3;i++)calculateFlags[i] = false;		thisSpot	= (SpotInfoPtr)*theDataHandle;	data_Count++;	thisSpot->intensity = (short double)0.0;	thisSpot->x =  0.0;	thisSpot->y = 0.0;	thisSpot->z =  0.0;	thisSpot->angle = 0.0;	thisSpot->h = 0;	thisSpot->k = 0;	thisSpot->l = 0;	thisSpot->direction = true;	thisSpot->theCrystal = theCrystal[baseCrystal];	thisSpot->flags = baseCrystal;			for(plotCrystal  = baseCrystal; plotCrystal <= 3 && gNoBreak ; plotCrystal++){			double sV0,sV1,sV2,sV3,sV4,sV5;		if(!plotFlags[plotCrystal] )			continue;				thisCrystal = 	theCrystal[plotCrystal];				D_HLock			((Handle)thisCrystal->theAtoms);		theAtoms 	= 	*thisCrystal->theAtoms;		atom_Count 	= 	thisCrystal->atom_Count + 1;		theUs 		= 	(double*)D_NewPtr(4L * atom_Count * sizeof(double));		if(!theUs)			return;					sV0	= thisCrystal->sVals[0];		sV1	= thisCrystal->sVals[1];		sV2	= thisCrystal->sVals[2];		sV3	= thisCrystal->sVals[3];		sV4	= thisCrystal->sVals[4];		sV5	= thisCrystal->sVals[5];				theVs 		= &theUs[atom_Count];		theWs 		= &theVs[atom_Count]; 		theZs 		= &theWs[atom_Count];		for(i = 0; i < atom_Count; i++,theAtoms++)		{			theUs[i] 		= (double)theAtoms->x;			theVs[i] 		= (double)theAtoms->y;			theWs[i] 		= (double)theAtoms->z;			theZs[i]		= 10;		}		D_HUnlock			((Handle)thisCrystal->theAtoms);							calculateFlags[plotCrystal] = true;					reciprocalLatticeSize = SetRecpSize();		hmax = SizeofReciprocalLattice(1.,0.,0.,reciprocalLatticeSize,thisCrystal);		kmax = SizeofReciprocalLattice(0.,1.,0.,reciprocalLatticeSize,thisCrystal);		lmax = SizeofReciprocalLattice(0.,0.,1.,reciprocalLatticeSize,thisCrystal);				hmax++;		kmax++;		lmax++;		if(lmax > 12){			hmax = 12;			kmax = 12;			lmax = 12;		}						thehMax = -hmax;		thekMax = -kmax;		thelMax = -lmax;		/************** Removed a switch statement from here ***************/				inverseVol = 1. / thisCrystal->volume;		inverseVolSqr = inverseVol * inverseVol;	 		 for(h = thehMax ; h <= hmax && gNoBreak ; h++)		{						sh2 = h *  h * sV0;			for(k = thekMax; k <= kmax && gNoBreak ; k++)			{								sk2 = k * k * sV1;				shk = 2 * k * h * sV3;				for(l =  thelMax; l <= lmax && gNoBreak ; l++)				{					if(h == 0 && k == 0 && l == 0)						continue;					skl = 2 * k * l * sV4;					shl = 2 * h * l * sV5;					sl2 = l  * l * sV2;					theDist = sqrt((sh2 + sk2 + sl2 + skl + shl + shk) * inverseVolSqr);					if(theDist >  reciprocalLatticeSize) continue;										theta = asin(wavelength * theDist * .5);															dH = (double)h;					dK = (double)k;					dL = (double)l;					AllowBackground();										thisCrystal->AtomicScatteringByD(theBeamFlag,theDist,theZs);					intens = (double)StructureFactorOld(dH,dK,dL,theUs,theVs,theWs,atom_Count,theZs);										if(intens < 0.0015) continue;					intens = intens * (1 + cos( 2 * theta) * cos(2 * theta)) / (sin(theta) * sin(theta) * cos(theta)); 										if(OverlapSpotExists(theDist,intens,h,k,l,thisCrystal)) continue;																					if(data_Count >= data_Length){						ExpandMemory();						theSpots = (SpotInfoPtr)*theDataHandle;					}										thisSpot 			= &(theSpots[data_Count++]);					thisSpot->intensity = (short double)intens;					thisSpot->x 		=  (short double)theDist;					thisSpot->y 		=  (short double)(theta * 360./PI);					thisSpot->z 		=  (short double)0;					thisSpot->h 		= (short)h;					thisSpot->k 		= (short)k;					thisSpot->l 		= (short)l;					thisSpot->direction = false;					thisSpot->theCrystal = thisCrystal;					thisSpot->angle = 0.0;					thisSpot->flags = (long)(plotCrystal);										}			}		}		KillPtr((Ptr)theUs);	}	CreateCompositeSpots();	D_MFTempHUnlock			((Handle)theDataHandle);	if(data_Length >  data_Count){		D_RecoverMemory		(theDataHandle,data_Size,data_Count);	}	data_Length 	= 	data_Count;		thisSpot = (SpotInfoPtr)*theDataHandle;	thisSpot++;	for(i = 0 ; i <= 3; i++)		maxIntensity[i] = 0;	for(i = 1; i < data_Count;i++,thisSpot++){		if(thisSpot->intensity > maxIntensity[thisSpot->flags])			 maxIntensity[thisSpot->flags] = thisSpot->intensity;	}		thisSpot = (SpotInfoPtr)*theDataHandle;	thisSpot++;	for(i = 1;i < data_Count;thisSpot++,i++){		if(thisSpot->flags != baseCrystal)			thisSpot->intensity /= (maxIntensity[thisSpot->flags] / the_PPT_Info[thisSpot->flags - 1]->intensity);		else			thisSpot->intensity /= maxIntensity[thisSpot->flags];	}}Boolean	DiffractometerObj::OverlapSpotExists(double theDist,double intens,short h,short k,short l,Crystal *aCrystal){	short i;	SpotInfoPtr thisSpot;		if(data_Count <= 1) return false;	thisSpot = (SpotInfoPtr)*theDataHandle;	thisSpot++;	for(i = 1; i < data_Count; i++,thisSpot++){		if(fabs((double)theDist - (double)thisSpot->x) < 0.00001){			if(thisSpot->theCrystal != aCrystal)				continue;			theIndex->CopyPtrToIndex((Ptr)thisSpot);			if(!theIndex->CompareTo(h,k,l))continue;			thisSpot->intensity += intens;			if(thisSpot->h + thisSpot->k + thisSpot->l < (short)h + (short)k + (short)l){				thisSpot->h = h;				thisSpot->k = k;				thisSpot->l = l;			}			return true;		}	}	return false;}void	DiffractometerObj::CreateCompositeSpots(void){	SpotInfoPtr	theSpots,thisSpot,aSpot;	short	i;	double	x;	thisSpot = (SpotInfoPtr)*theDataHandle;	thisSpot->x = .00001;		qsort(*theDataHandle,(short)(data_Count),sizeof(SpotInfo),(_Cmpfun *)InverseDSpaceCompare);		thisSpot = (SpotInfoPtr)*theDataHandle;	thisSpot->x = .01;		thisSpot++;	theSpots = (SpotInfoPtr)*theDataHandle;	for(i = 1; i < data_Count;i++,thisSpot++){		x = thisSpot->x;		if(fabs(thisSpot->x - thisSpot[1].x) < .0001){			if(data_Count >= data_Length){				ExpandMemory();				theSpots = (SpotInfoPtr)*theDataHandle;				thisSpot = &(theSpots[i]);			}			aSpot 			= &(theSpots[data_Count++]);			aSpot->intensity = thisSpot->intensity;			aSpot->x = thisSpot->x;			aSpot->y = thisSpot->y;			aSpot->z = thisSpot->z;			aSpot->h = thisSpot->h;			aSpot->k = thisSpot->k;			aSpot->l = thisSpot->l;			aSpot->direction = thisSpot->direction;			aSpot->theCrystal = thisSpot->theCrystal;			aSpot->angle = thisSpot->angle;			aSpot->flags = thisSpot->flags;				thisSpot++;			i++;			while(fabs(thisSpot->x - x) < .0001 && i < data_Count - 1){				aSpot->intensity += thisSpot->intensity;				thisSpot++;				i++;			}			thisSpot--;			i--;		}	}}void	DiffractometerObj::DoPrint(void){	inherited::DoPrint();	ResizeGraphBox();}void	DiffractometerObj::DoPictDraw(void){	Rect 		oldOval;	long 		theX,theY;	SpotInfoPtr thisSpot;	short 		theIdent,i;	Handle		theValue;//	if(printing)		/*august 1993*///		ResizeGraphBox();	SetDrawEnviron();	theValue	= D_NewHandle(sizeof(long) * 2);	**theValue = (long)data_Count;	if(graph == 0L || theDataHandle == 0L) return;	graph->SetValues(theDataHandle,(Handle)theValue);	graph->PlotGraph();	KillHandle((Handle*)&theValue);/*		SetPlotScales();	theIndex->DoInit(false,theCrystal[0]);	DrawGraphBox();		thisSpot = (SpotInfoPtr)*theDataHandle;	thisSpot++;	for(i = 1; i < data_Count; i++,thisSpot++){			theIdent = thisSpot->flags & CRYSTAL_MASK;			if(!plotFlags[theIdent]){				if(thisSpot->flags & TEXT_MASK)					thisSpot->flags -= TEXT_MASK;				continue;			}		if(	minPlottedX <= thisSpot->y && maxPlottedX >= thisSpot->y){								theIdent = thisSpot->flags & CRYSTAL_MASK;			theX	= centerX + (short)(scaleFactor * (thisSpot->y - minPlottedX));			theY	= centerY - (short)(scaleFactorY * thisSpot->intensity);			if(g_Monitor){				DMForeColor(theIdent + 10);				}else{				PenPat(&qd.black);				PenNormal();				DMForeColor(BLACK);					}					SetRect(&oldOval,theX,theY,theX + 1,centerY);				thisSpot->spotRect = oldOval;			PaintRect(&oldOval);		}														 	}	if(channels > 0){		double theLeft;		double *spectralData;				MoveTo(graphBox.left,graphBox.bottom);		theLeft = graphBox.left;		spectralData = (double*)*spectralDataHdn;		i = startChannel;		theLeft = startSpectra - minPlottedX + delXperChannel;		while(i < channels && theLeft < maxPlottedX )		{			double 	theValue;			short	pointLoc;			theValue = spectralData[i] - minPlottedY;			theValue *= sFPhotons;			pointLoc = (theLeft * sFChannels) + graphBox.left;			if(theLeft >= 0)				LineTo((short)(pointLoc),graphBox.bottom - (short)theValue);			theLeft += delXperChannel;			i++;		}			}	*/	theSearchObj->PlotRings(scaleFactor,scaleFactorY,centerX,centerY,minPlottedX, maxPlottedX);	ClearDrawEnviron();}void	DiffractometerObj::DrawGraphBox(void){	DMForeColor(COMPLEMENT_COLOR);	FrameRect(&graphBox);	DrawTicks();	DrawLabels();}void	DiffractometerObj::DrawTicks(void){	short tickLocation;	double tickValue;	short stringWidth,charHeight;	FontInfo theFont;	TextFont(courier); /* courier */	TextSize(9);	tickValue = minPlottedX;	tickIntervalX = (maxPlottedX - minPlottedX) / 10;	GetFontInfo(&theFont);	charHeight = theFont.ascent + theFont.descent + theFont.leading;	while(tickValue <= maxPlottedX){		tickLocation = centerX + (short)(scaleFactor * (tickValue - minPlottedX));		MoveTo(tickLocation,centerY);		LineTo(tickLocation,centerY + 5);		sprintf(gTheText,"%5.2f",tickValue);		GetFontInfo(&theFont);		stringWidth = StringWidth(c2pstr(gTheText));		MoveTo(tickLocation - (stringWidth * .5),centerY + 8 + charHeight);		DrawDiffractString((unsigned char*)gTheText);		tickValue += tickIntervalX;	}	tickValue = minPlottedY;	tickIntervalY = (maxPlottedY - minPlottedY) / 10;	while(tickValue <= maxPlottedY + .0005){		double n;		if(maxPlottedY == 1) n = 100;		else n = 1;		tickLocation = centerY - (short)(scaleFactorY * tickValue);		MoveTo(centerX,tickLocation);		LineTo(centerX - 5,tickLocation);		sprintf(gTheText,"%5.2f",tickValue * n);		GetFontInfo(&theFont);		stringWidth = StringWidth(c2pstr(gTheText));		MoveTo(centerX - 8 - stringWidth,tickLocation);		DrawDiffractString((unsigned char*)gTheText);		tickValue += tickIntervalY;	}	TextFont(0); /* courier */	TextSize(12);}void	DiffractometerObj::DrawLabels(void){	short theWidth;	strcpy(gTheText,xAxisTitle);	theWidth = StringWidth(c2pstr(gTheText)) / 2;	MoveTo(xAxisTStart.h - theWidth,xAxisTStart.v);	DrawDiffractString((unsigned char*)gTheText);				}void	DiffractometerObj::ResizeGraphBox(void){		thePictRect = theWindow->portRect;	objectSize.h = thePictRect.right;	objectSize.v = thePictRect.bottom;	thePictRect.right	-= 15;	thePictRect.left	+= 15;	thePictRect.bottom	-= 15;	thePictRect.top		+= rulerHeight;	hScroll->ReInit();	vScroll->ReInit();	graphBox = thePictRect;	graphBox.top += 10;	graphBox.left += 60;	graphBox.bottom -= 60;	graphBox.right -= 15;	centerX = graphBox.left;	centerY = graphBox.bottom;	xAxisTStart.h = centerX + (graphBox.right - graphBox.left) / 2 ;	xAxisTStart.v = centerY + 40;	yAxisTStart.v = centerY + (graphBox.bottom - graphBox.top) / 2 ;	yAxisTStart.h = centerX - 60;		SetRect(&theCourserRect,graphBox.left,graphBox.top,graphBox.left + 2,graphBox.bottom);	SetPlotScales();}PicHandle	DiffractometerObj::SetPrintPicture(void){	PicHandle megaPicture;			megaPicture = OpenPicture(&thePictRect);		if((long)picObjList != NUL){			PenMode(transparent+addPin);			picObjList->DrawThePicts();		}				DrawPicture(screenPict,&thePictRect);	ClosePicture();		return megaPicture;}void	DiffractometerObj::SetTicks(void){}void	DiffractometerObj::ZoomPlot(Boolean zoomInFlag,Point thePoint){	short midPoint;	double xValue;	LocalToObj(&thePoint);	if(zoomInFlag){		if(thePoint.h < graphBox.left || thePoint.h > graphBox.right) return;		midPoint = thePoint.h - centerX;				xValue = (double)midPoint / (double)scaleFactor;		minPlottedX = minPlottedX + xValue - ((maxPlottedX - minPlottedX) / 4);		if(minX > minPlottedX){			minPlottedX = minX;			maxPlottedX = ((maxPlottedX + minPlottedX) / 2) + minX;			SetPlotScales();			SetPict(true);			return;		}		maxPlottedX = minPlottedX + xValue + ((maxPlottedX - minPlottedX) / 4);		if(maxX < maxPlottedX){			maxPlottedX = maxX;			minPlottedX = maxX - ((maxPlottedX - minPlottedX) / 2);		}		SetPlotScales();		SetPict(true);		return;	}	minPlottedX = minX;	maxPlottedX = maxX;	SetPlotScales();	SetPict(true);}void		DiffractometerObj::DoDblClick(Point thePoint){	GetMouse(&thePoint);	switch(functionID){				case ZOOM_PLOT:			theRuler->SetPrompt("Zoom Plot:"); 								ZoomPlot(false,thePoint);			break;	}	DoCourser(thePoint);		inherited::DoDblClick(thePoint);}Boolean	DiffractometerObj::DoContent(Point thePoint){	GetMouse(&thePoint);	switch(functionID){				case ZOOM_PLOT:			theRuler->SetPrompt("Zoom Plot:"); 								ZoomPlot(true,thePoint);			DoCourser(thePoint);			return(true);			break;		default:			return (inherited::DoContent(thePoint));			break;	}	return false;}void		DiffractometerObj::DoIdle(void){	Point thePoint;		GetMouse(&thePoint);	DoCourser(thePoint);	inherited::DoIdle();		}void		DiffractometerObj::DoCourser(Point thePoint){	double 		theValue,thetaSine,dspace;	static Point 		oldPoint;		GetMouse(&thePoint);	if(!PtInRect(thePoint,&graphBox))		return;	if(oldPoint.h == thePoint.h)		return;	theRuler->SetPrompt("Cursor Info:"); 	theValue = ((double)(thePoint.h - centerX)/scaleFactor) + minPlottedX;	thetaSine = 2 * sin(theValue * PI / 360);	if(thetaSine <= .005)dspace = 0.0;	else dspace = wavelength / thetaSine;		sprintf(gTheText,"2 Theta = %6.2f ¡,D-Spacing = %7.3f ",theValue,dspace);		theRuler			->SetInfo(gTheText);	oldPoint 		= 	thePoint;	}void	DiffractometerObj::DoMenu(long theResult){	short theMenu,theItem;	static Boolean searchFlag = true;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);	switch(theMenu){		case DIFDEFINE:			switch(theItem){				case 1:					DoDefine();					break;				case 2:					DoCalculate();					ResizeGraphBox();					newPictEnable = true;					break;			}			break;			case DIFINFO:			switch(theItem){				case ZOOM_FUNCTION:					functionID = ZOOM_PLOT;					theRuler->SetPrompt("Zoom In");					theRuler->SetHelp("Zoom-In (x2) each click, Around click point. Dbl-Click to Zoom Out to original graph.");					SetTheCursor(TARGET_CURSOR);					break;				case RESIZE_GRAPH:					ResizeGraphBox();					SetPict(true);					break;				default:					theResult = INFO_MENU * 65536 + theItem;					inherited::DoMenu(theResult); 					break;			}			break;						case DIFEXPINFO:						break;		case 52:			CheckItem(base_Crystal_Menu,referenceCrystal + 1,false);			referenceCrystal = theItem - 1;				CheckItem(base_Crystal_Menu,theItem,true);			break;		case SADSEARCH:			if(theItem > 5){				theSearchObj->wavelength = wavelength;				theSearchObj->requiredFOM = TWO_THETA_SEARCH;				theSearchObj->DoMenu(theResult);			}else					inherited::DoMenu(theResult);			break;				default:			inherited::DoMenu(theResult); 			break;	}		HiliteMenu(0);	return;}void  DiffractometerObj::OpenGeneral(void){	SFTypeList 		myFileTypes;	short 			numFileTypes;	OSErr 			theErr;	StandardFileReply		theFileInfo;	short			refNum;	long			sizeOfBlock;	long			posOff;	short			i,k,j;	short			sizeOfString = 64;	short			*spectralData;		numFileTypes = -1;	StandardGetFile((FileFilterUPP)NUL,numFileTypes,myFileTypes,&theFileInfo);	if(spectralDataHdn != 0L) KillTempHandle((Handle*)&spectralDataHdn);	spectralDataHdn		= 	D_TempNewHandle(16000 * sizeof(short),&gTheOSError);	D_MFTempHLock			((Handle)spectralDataHdn);	k = 0;		if(theFileInfo.sfGood)	{		theErr = FSpOpenDF(&theFileInfo.sfFile,fsRdWrPerm,&refNum);				sizeOfBlock = sizeof(short)  * sizeOfString;		posOff = 1024;		spectralData = (short*)*spectralDataHdn;		SetFPos(refNum,fsFromStart,posOff);		theErr = FSRead(refNum,&sizeOfBlock,(Ptr)(spectralData));		j = 0;				while(spectralData[j] == 0 && j < sizeOfString)		{			j++;		}		posOff += sizeof(short)  * (j - 1);		channels = 0;		while(!theErr){			SetFPos(refNum,fsFromStart,posOff);			theErr = FSRead(refNum,&sizeOfBlock,(Ptr)(&spectralData[channels]));			channels += sizeOfString;			posOff += (sizeOfBlock);		}	}	channels -= sizeOfString;	posOff -= (sizeOfBlock);	sizeOfBlock = sizeof(short);	while(!theErr){		SetFPos(refNum,fsFromStart,posOff);		theErr = FSRead(refNum,&sizeOfBlock,(Ptr)(&spectralData[channels]));		channels++;		posOff += (sizeOfBlock);	}	channels--;	maxPhotons = 0;	for(i = 0; i < channels;i++)	{		if(spectralData[i] > maxPhotons){			maxPhotons = spectralData[i];		}	}	D_MFTempHUnlock			((Handle)spectralDataHdn);	if(16000 >  channels){		D_RecoverMemory		(spectralDataHdn,sizeof(short),channels);	}	ConvertDataToStandard();	startChannel = 0;	startSpectra = minX;	delXperChannel = (maxX - minX) / (double)(channels);	theErr = FSClose(refNum);	TextFont(0); 	TextSize(0);	newPictReq = true;	newPictEnable = true;}void	DiffractometerObj::DoAuxRead(void){	yAxisTitle  = (char*)gTheFile->ReadPtr((Ptr)yAxisTitle);  	xAxisTitle  = (char*)gTheFile->ReadPtr((Ptr)xAxisTitle);	gTheFile->ReadDataBlock((Ptr)&absissaFont,sizeof(FontInfo));	gTheFile->ReadDataBlock((Ptr)&ordinateFont,sizeof(FontInfo));	gTheFile->ReadDataBlock((Ptr)&titleFont,sizeof(FontInfo));	gTheFile->ReadDataBlock((Ptr)&xAxisTStart,sizeof(Point));	gTheFile->ReadDataBlock((Ptr)&yAxisTStart,sizeof(Point));		tickIntervalX = gTheFile->ReadFloat();	tickIntervalY = gTheFile->ReadFloat();	gTheFile->ReadDataBlock((Ptr)&graphBox,sizeof(Rect));	gTheFile->ReadDataBlock((Ptr)&theCourserRect,sizeof(Rect));	minPlottedX = gTheFile->ReadFloat();	minPlottedY = gTheFile->ReadFloat();	maxPlottedX = gTheFile->ReadFloat();	maxPlottedY = gTheFile->ReadFloat();	maxX = gTheFile->ReadFloat();	maxY = gTheFile->ReadFloat(); 	minX = gTheFile->ReadFloat();	minY = gTheFile->ReadFloat();	scaleFactorY 	= gTheFile->ReadFloat();	channels 		= gTheFile->ReadShort();	if(channels > 0)	gTheFile		->ReadHandle((Handle)spectralDataHdn);		maxPhotons 		= gTheFile->ReadShort();	sFChannels 		= gTheFile->ReadFloat();	sFPhotons 		= gTheFile->ReadFloat();	delXperChannel 	= gTheFile->ReadFloat();	startSpectra 	= gTheFile->ReadFloat();	startChannel 	= gTheFile->ReadShort();		inherited::DoAuxRead();}void	DiffractometerObj::DoAuxWrite(void){ 	gTheFile->WritePtr((Ptr)yAxisTitle);  	gTheFile->WritePtr((Ptr)xAxisTitle);	gTheFile->WriteDataBlock((Ptr)&absissaFont,sizeof(FontInfo));	gTheFile->WriteDataBlock((Ptr)&ordinateFont,sizeof(FontInfo));	gTheFile->WriteDataBlock((Ptr)&titleFont,sizeof(FontInfo));	gTheFile->WriteDataBlock((Ptr)&xAxisTStart,sizeof(Point));	gTheFile->WriteDataBlock((Ptr)&yAxisTStart,sizeof(Point));		gTheFile->WriteFloat(tickIntervalX);	gTheFile->WriteFloat(tickIntervalY);	gTheFile->WriteDataBlock((Ptr)&graphBox,sizeof(Rect));	gTheFile->WriteDataBlock((Ptr)&theCourserRect,sizeof(Rect));	gTheFile->WriteFloat(minPlottedX);	gTheFile->WriteFloat(minPlottedY);	gTheFile->WriteFloat(maxPlottedX);	gTheFile->WriteFloat(maxPlottedY);	gTheFile->WriteFloat(maxX);	gTheFile->WriteFloat(maxY); 	gTheFile->WriteFloat(minX);	gTheFile->WriteFloat(minY);	gTheFile->WriteFloat(scaleFactorY);	gTheFile->WriteShort(channels);	if(channels > 0)	gTheFile		->WriteHandle((Handle)spectralDataHdn);		gTheFile->WriteShort(maxPhotons);	gTheFile->WriteFloat(sFChannels);	gTheFile->WriteFloat(sFPhotons);	gTheFile->WriteFloat(delXperChannel);	gTheFile->WriteFloat(startSpectra);	gTheFile->WriteShort(startChannel);		inherited::DoAuxWrite();}void DiffractometerObj::SetMinMax(double Xlow,double XHigh){	switch(dataType){		case 0:		case 1:			maxPlottedX = maxX = XHigh;			minPlottedX = minX = Xlow;			startSpectra = minX;			delXperChannel = (maxX - minX) / (double)channels;						GetMinMax();			maxPlottedY = maxY;			minPlottedY = minY ;		break;	}	}void DiffractometerObj::ConvertDataToStandard(void){	double **convertData,*dataPtr;	short i;	short *shortPtr;	if(spectralDataHdn == 0L || dataType == 1)return;	convertData = (double**)D_NewHandle(sizeof(double) * channels);	switch(dataType){		case 0:			HLock((Handle)convertData);			HLock((Handle)spectralDataHdn);			shortPtr = (short*)*spectralDataHdn;			dataPtr = *convertData;			for(i = 0; i < channels;i++,shortPtr++,dataPtr++){				*dataPtr = (double)*shortPtr;			}		break;	}	HUnlock((Handle)convertData);	HUnlock((Handle)spectralDataHdn);	KillHandle((Handle*)&spectralDataHdn);	spectralDataHdn = (Handle)convertData;}void DiffractometerObj::GetMinMax(){	double *convertData;	short	i;	if(spectralDataHdn == 0L){		minY = maxY = 0;	 	return;	 }	 D_HLock(spectralDataHdn);	 convertData = (double*)*spectralDataHdn;	switch(dataType){		case 0:		case 1:			minY = maxY = *convertData;			for(i = 0; i < channels;i++,convertData++){				if(*convertData < minY)minY = *convertData;				else				if(*convertData > maxY)maxY = *convertData;			}		break;	}	 D_HUnlock(spectralDataHdn);	}void	DiffractometerObj::SetXY(long *theX,long *theY,SpotInfoPtr theSpot){	*theX	= centerX + (short)(scaleFactor * (theSpot->y - minPlottedX));	*theY	= centerY - (short)(scaleFactorY * ((theSpot->intensity * maxPlottedY) - minPlottedY));}