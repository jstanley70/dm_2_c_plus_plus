#include	"Diffract_INCs.h"#include	"Dir_Paths.h"#include 	"JCPDFCrystal.h"#include	<Aliases.h>char	gLastName[256];Boolean	gDirSelectFlag;	void pStrcat(unsigned char* s1,unsigned char* s2);void pStrcpy(unsigned char* s1,unsigned char* s2);pascal	short	TheDialogHook(short item,DialogPtr theDialog,Ptr dataPtr);pascal	void 	TheActivateProc(DialogPtr theDialog,short item,Boolean activate,Ptr dataPtr);pascal	short 	TheDirDLOGHook(short item, DialogPtr	theDialog, Ptr theData);pascal	Boolean	TheDirFileFilter(CInfoPBPtr pramBlock,Ptr	someData);void			SetButtonTitle(ControlHandle theButton,unsigned char* theName,Rect theRect);void 			SetPathNameBox	(DialogPtr theDialog,FSSpec theFSSpec);void SetDirPaths(void){	FSSpec 				theFileSpecs[NUM_FSS_RECS],theFSSpec;	DialogPtr			theDialog;	short				i,j,theSelect,err,type,**theName,sNum;	Boolean				quit = false;	GrafPtr				theOldWindow;	StandardFileReply	theFileReply;	unsigned char		**theUserName;	Point				where;	AliasHandle			theAlias;	Boolean				changed,validFlags[NUM_FSS_RECS];	Rect				theRect;	Handle				theHandle;	DlgHookYDUPP		TheDialogHookUPP;	ActivateYDUPP		TheActivateProcUPP;	SFTypeList			theTypes;	char				*theNewName;	FileFilterYDUPP		TheFileFilterYDUPP;	CInfoPBRec			thePBInfo;	PopUpMenu*			popUpMenu;	short				currentDataBase = 0;		if(!gAppleEvtsOK)		return;		TheDialogHookUPP	= NewDlgHookYDProc(TheDialogHook);	TheActivateProcUPP	= NewActivateYDProc(TheActivateProc);	TheFileFilterYDUPP	= NewFileFilterYDProc(TheDirFileFilter);	UseResFile(g_AppResFile);	where.h = where.v = -1;	GetPort(&theOldWindow);	theDialog = GetNewDialog(720,NUL,(WindowPtr)-1L);	SetPort(theDialog);		popUpMenu = (PopUpMenu*)D_new(PopUpMenu);	popUpMenu->Init( theDialog, 4,37,currentDataBase + 1);			for(i = 0,j = ALIAS_BASE ; i < NUM_FSS_RECS ; i++,j++){		validFlags[i]				= true;		theFileSpecs[i].vRefNum 	= 0;		theFileSpecs[i].parID		= NUL;		theFileSpecs[i].name[0]		= (char)0;		theAlias 					= (AliasHandle)GetResource('DATA',j);		if(ResError() != 0 || theAlias == NUL || HomeResFile((Handle)theAlias) !=g_AppResFile){			err = NewAlias(NUL,&theFileSpecs[i],&theAlias);			AddResource((Handle)theAlias,'DATA',j,"\pSearch Path Alias");			if(ResError() != noErr){				DisposHandle((Handle)theAlias);				return;			}			WriteResource((Handle)theAlias);		} else {			err = ResolveAlias(NUL,theAlias,&theFileSpecs[i],&changed);			if(err != noErr){				AlertUser(7);				theFileSpecs[i].vRefNum 	= 0;				theFileSpecs[i].parID		= NUL;				theFileSpecs[i].name[0]		= (char)0;				RmveResource((Handle)theAlias);				err = NewAlias(NUL,&theFileSpecs[i],&theAlias);				AddResource((Handle)theAlias,'DATA',j,"\pSearch Path Alias");				changed = true;			}			if(changed){				ChangedResource((Handle)theAlias);				WriteResource((Handle)theAlias);			}						thePBInfo.dirInfo.ioCompletion 	= NUL;			thePBInfo.dirInfo.ioNamePtr		= theFileSpecs[i].name;			thePBInfo.dirInfo.ioVRefNum		= theFileSpecs[i].vRefNum;			thePBInfo.dirInfo.ioDrDirID		= theFileSpecs[i].parID;			thePBInfo.dirInfo.ioFDirIndex	= 0;			err 							= PBGetCatInfo(&thePBInfo,false);			theFileSpecs[i].parID			= thePBInfo.dirInfo.ioDrDirID;			theFileSpecs[i].name[0]			= (char)0;					}		ReleaseResource((Handle)theAlias);			}	SetPathNameBox(theDialog,theFileSpecs[0]);		theUserName = (unsigned char**)GetResource('DATA',128);	if((Handle)theUserName == NUL || ResError() != 0){		theUserName = (unsigned char**)NewHandle(256L * sizeof(char));		theName = (short**)GetResource('ERIC',500);				sNum 		=  **theName ^ 0x7F29;		for(i = 1 ; i <= 100 ; i++){			(*theName)[i] ^= sNum;		}		theNewName		= &(((char*)(*theName))[2]);		p2cstr	((unsigned char*)theNewName);		strcpy	(g_Routine,"SetDirPaths");		D_HLock	(theUserName);		strcpy	((char*)*theUserName,theNewName);		c2pstr	((char*)*theUserName);		D_HUnlock(theUserName);		ReleaseResource	((Handle)theName);		AddResource		((Handle)theUserName,'DATA',128,"\pUser Name");		WriteResource	((Handle)theUserName);	}			GetDItem	(theDialog,6,&type,&theHandle,&theRect);	D_HLock		(theUserName);	SetIText	(theHandle,*theUserName);	D_HUnlock	(theUserName);	ReleaseResource((Handle)theUserName);		while(!quit){		ModalDialog((ModalFilterUPP)NUL,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:						BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			case DLOG_ENTER_OR_CR:			case 1:				StartWatch();				for(i = 0, j = ALIAS_BASE ; i < NUM_FSS_RECS ; i++, j++){					if(validFlags[i]){						short rID;						ResType rType;												theAlias 	= (AliasHandle)GetResource('DATA',j);												err 		= ResError();												thePBInfo.dirInfo.ioCompletion 	= NUL;						thePBInfo.dirInfo.ioNamePtr		= theFileSpecs[i].name;						thePBInfo.dirInfo.ioVRefNum		= theFileSpecs[i].vRefNum;						thePBInfo.dirInfo.ioDrDirID		= theFileSpecs[i].parID;						thePBInfo.dirInfo.ioFDirIndex	= -1;												err 							= PBGetCatInfo(&thePBInfo,false);						theFileSpecs[i].parID			= thePBInfo.dirInfo.ioDrParID;						err 							= UpdateAlias(NUL,&theFileSpecs[i],theAlias,&changed);						if(changed){							ChangedResource((Handle)theAlias);							err 	= ResError();							WriteResource((Handle)theAlias);							err 	= ResError();						}						GetResInfo((Handle)theAlias,&rID,&rType,(unsigned char*)gTheText);						DetachResource((Handle)theAlias);						#if defined(_newkey_)						gDefault->SetPreferenceFile((Handle)theAlias,j,'DATA',(char*)gTheText);						#endif						DisposHandle((Handle)theAlias);						err 		= ResError();					}				}				UpdateResFile(g_AppResFile);				FlushVol(0L,0);				theUserName = 	(unsigned char**)GetResource('DATA',128);				GetDItem		(theDialog,6,&type,&theHandle,&theRect);				strcpy			(g_Routine,"SetDirPaths");				D_HLock			(theUserName);				GetIText		(theHandle,*theUserName);				D_HUnlock		(theUserName);				ChangedResource	((Handle)theUserName);				WriteResource	((Handle)theUserName);				ReleaseResource	((Handle)theUserName);				StopWatch();				quit = true;				break;			case 2:				quit = true;				break;						case 4: 				short ip;				ip = popUpMenu->DoPopUp();				if(ip > NUM_FSS_RECS){					TextFont(geneva);					TextSize(10);					switch(ip){						case NUM_FSS_RECS_1:						JCPDFCrystal  *jcpdfCrystal;						jcpdfCrystal = (JCPDFCrystal*)D_new(JCPDFCrystal);						jcpdfCrystal->InitCrystal(0);							jcpdfCrystal->MakeElementKey(3,theDialog);						jcpdfCrystal->DoClose();						break;						case NUM_FSS_RECS_2:						jcpdfCrystal = (JCPDFCrystal*)D_new(JCPDFCrystal);						jcpdfCrystal->InitCrystal(0);							jcpdfCrystal->MakeElementKey(4,theDialog);						jcpdfCrystal->DoClose();						break;						default:						break;					}					TextFont(0);					TextSize(12);				}else{					currentDataBase = ip;					currentDataBase--;					theFSSpec = theFileSpecs[currentDataBase];					theFSSpec.name[0] = (char)0;					SetPathNameBox(theDialog,theFSSpec);				}				break;			case 3:				gDirSelectFlag = false;							TheDialogHookUPP	= NewDlgHookYDProc(TheDirDLOGHook);				TheFileFilterYDUPP	= NewFileFilterYDProc(TheDirFileFilter);							err = GetDirPath(currentDataBase,&theFileReply.sfFile);				CustomGetFile(TheFileFilterYDUPP,-1,theTypes,&theFileReply,722,where,TheDialogHookUPP,NUL,NUL,NUL,&theFileReply);											if(gDirSelectFlag){					if(theFileReply.sfIsVolume){						theFileReply.sfFile.name[0]++;						theFileReply.sfFile.name[(short)theFileReply.sfFile.name[0]] = ':';					}									validFlags[currentDataBase] 	= true;					theFileSpecs[currentDataBase] = theFileReply.sfFile;					theFSSpec				=	theFileSpecs[currentDataBase];//					err 	=FSMakeFSSpec(theFileReply.sfFile.vRefNum,theFileReply.sfFile.parID,"\p",&theFileSpecs[theSelect - 3]);					SetPathNameBox(theDialog,theFSSpec);				}				popUpMenu->SetPopUp();				break;			default:				break;		}	}	popUpMenu->DoClose();	SetPort(theOldWindow);	DisposDialog(theDialog);}void SetPathNameBox(DialogPtr theDialog,FSSpec theFSSpec){		TextFont(geneva);	TextSize(10);	PathNameFromFSSpec(theFSSpec,pTheText);	GetDItem(theDialog,5,&gType,&gTheHandle,&gTheRect);	SetIText(gTheHandle,pTheText);	TextFont(0);	TextSize(0);}	pascal Boolean TheDirFileFilter(CInfoPBPtr pramBlock,Ptr	someData){	Ptr	dummy;		dummy	= someData;   // Suppresses a warning		if(pramBlock->dirInfo.ioFlAttrib & 0x10){		return false;	}		return true;}pascal short TheDirDLOGHook(short item, DialogPtr	theDialog, Ptr theData){	short						type;	ControlHandle				theButton;	Rect						theRect;	unsigned char				theName[256];	CInfoPBRec					thePBInfo;	StandardFileReply			*theSFRPtr;	OSErr						theErr;		if(GetWRefCon(theDialog) != (long)sfMainDialogRefCon){		return(item);	}		GetDItem(theDialog,10,&type,(Handle*)&theButton,&theRect);		if(item == -1){		theSFRPtr	= (StandardFileReply*)theData;		p2cstr(theSFRPtr->sfFile.name);		strcpy(gLastName,(char*)theSFRPtr->sfFile.name);		strcpy((char*)theName,(char*)theSFRPtr->sfFile.name);		c2pstr((char*)theSFRPtr->sfFile.name);		c2pstr((char*)theName);				(thePBInfo.dirInfo).ioCompletion 	= NUL;		thePBInfo.dirInfo.ioNamePtr			= theName;		thePBInfo.dirInfo.ioVRefNum			= theSFRPtr->sfFile.vRefNum;		thePBInfo.dirInfo.ioDrDirID			= theSFRPtr->sfFile.parID;		thePBInfo.dirInfo.ioFDirIndex		= -1;				theErr	= PBGetCatInfo(&thePBInfo,false);				strcpy(gLastName,(char*)theName);		c2pstr((char*)theName);		SetButtonTitle(theButton,theName,theRect);		return sfHookChangeSelection;	} else {		theSFRPtr	= (StandardFileReply*)theData;		if(theSFRPtr->sfIsFolder || theSFRPtr->sfIsVolume){			p2cstr(theSFRPtr->sfFile.name);			strcpy((char*)theName,(char*)theSFRPtr->sfFile.name);			c2pstr((char*)theName);			c2pstr((char*)theSFRPtr->sfFile.name);		} else {			(thePBInfo.dirInfo).ioCompletion 	= NUL;			thePBInfo.dirInfo.ioNamePtr			= theName;			thePBInfo.dirInfo.ioVRefNum			= theSFRPtr->sfFile.vRefNum;			thePBInfo.dirInfo.ioDrDirID			= theSFRPtr->sfFile.parID;			thePBInfo.dirInfo.ioFDirIndex		= -1;						theErr	= PBGetCatInfo(&thePBInfo,false);		}					p2cstr(theName);				if(strcmp((char*)theName,gLastName) != 0){			strcpy(gLastName,(char*)theName);			c2pstr((char*)theName);			SetButtonTitle(theButton,theName,theRect);		} else {			c2pstr((char*)theName);		}				switch(item){			case 10:				gDirSelectFlag = true;				(thePBInfo.dirInfo).ioCompletion 	= NUL;				thePBInfo.dirInfo.ioNamePtr			= theName;				thePBInfo.dirInfo.ioVRefNum			= theSFRPtr->sfFile.vRefNum;				thePBInfo.dirInfo.ioDrDirID			= theSFRPtr->sfFile.parID;				thePBInfo.dirInfo.ioFDirIndex		= 0;				theErr = PBGetCatInfo(&thePBInfo,false);								p2cstr(theName);				strcpy((char*)theSFRPtr->sfFile.name,(char*)theName);				c2pstr((char*)theSFRPtr->sfFile.name);				theSFRPtr->sfFile.parID		= thePBInfo.dirInfo.ioDrDirID;				theSFRPtr->sfFile.vRefNum	= thePBInfo.dirInfo.ioVRefNum;								return(sfItemCancelButton);				break;			case sfItemCancelButton:				gDirSelectFlag = false;				return(item);				break;			default:				return(item);				break;		}	}	return(item);			}							void	SetButtonTitle(ControlHandle theButton,unsigned char* theName,Rect theRect){	short	result,width;	unsigned char*	thePrompt;	char			theText[256];		thePrompt		= (unsigned char*)theText;	sprintf(theText,"Select PP");	theText[7]	= '"';	theText[8]	= '"';	c2pstr(theText);		width 			= theRect.right - theRect.left - StringWidth(thePrompt) -CharWidth(' ');	p2cstr(thePrompt);	theText[8]		= (char)0;		result			= TruncString(width,theName,smTruncMiddle);	theName[0]++;	theName[(short)theName[0]] = '"';	p2cstr(theName);		strcat(theText,(char*)theName);	c2pstr(theText);	SetCTitle(theButton,thePrompt);		ValidRect(&theRect);}	void pStrcat(unsigned char* s1,unsigned char* s2){	char*	s3;	p2cstr(s1);	p2cstr(s2);	s3 = strcat((char*)s1,(char*)s2);	c2pstr((char*)s1);	c2pstr((char*)s2);}void pStrcpy(unsigned char* s1,unsigned char* s2){	char*	s3;	p2cstr(s1);	p2cstr(s2);	s3 = strcpy((char*)s1,(char*)s2);	c2pstr((char*)s1);	c2pstr((char*)s2);}short GetDirPath(short dirID,FSSpec*	dir){	Handle		theHandle;	AliasHandle	theAlias;	short		err;	Boolean		wasChanged;	CInfoPBRec	thePBInfo;		if(!gAppleEvtsOK)		return -1;		UseResFile(g_AppResFile);		theHandle 	= GetResource('DATA',ALIAS_BASE + dirID);	theAlias 	= (AliasHandle)theHandle;	err			= ResolveAlias(NUL,theAlias,dir,&wasChanged);		if(err != noErr){		AlertUser(7);		RmveResource(theHandle);		dir->vRefNum 		= 0;		dir->parID			= NUL;		dir->name[0]		= (char)0;		err 				= NewAlias(NUL,dir,&theAlias);		theHandle			= (Handle)theAlias;		AddResource((Handle)theAlias,'DATA',ALIAS_BASE + dirID,"\pSearch Path Alias");		ChangedResource((Handle)theAlias);		WriteResource((Handle)theAlias);	}		thePBInfo.dirInfo.ioCompletion 	= NUL;	thePBInfo.dirInfo.ioNamePtr		= dir->name;	thePBInfo.dirInfo.ioVRefNum		= dir->vRefNum;	thePBInfo.dirInfo.ioDrDirID		= dir->parID;	thePBInfo.dirInfo.ioFDirIndex	= 0;		err 		= PBGetCatInfo(&thePBInfo,false);		dir->parID						= thePBInfo.dirInfo.ioDrDirID;	dir->vRefNum					= thePBInfo.dirInfo.ioVRefNum;		if(err == 0){		if(wasChanged){			ChangedResource(theHandle);			WriteResource(theHandle);		}	}	ReleaseResource(theHandle);	return(err);}short	OpenNamedFile(short dirID,char* theFileName,short*	vRefNum,short* fRefNum){	FSSpec			theFileSpec;		short			fileError;		if(!gAppleEvtsOK){		char 	fullName[256];		Handle	theHandle;				theHandle = GetResource('ERIC',501);		if(theHandle == 0 || ResError() == resNotFound){			theHandle = NewHandle(10);			**((short**)theHandle) = 0;			UseResFile(LMGetCurApRefNum());			AddResource(theHandle, 'ERIC', 501, "\pSys 6 support");			WriteResource(theHandle);		}				*vRefNum = **((short**)theHandle);		strcpy(fullName,theFileName);		c2pstr(fullName);		fileError = HOpen (*vRefNum, 0, (unsigned char*)fullName, fsRdPerm, fRefNum);		ReleaseResource(theHandle);	} else {		fileError 			= GetDirPath(dirID,&theFileSpec); 		/* Gets FSSpec for dir */		if(fileError != 0)			return(fileError);					strcpy((char*)theFileSpec.name,theFileName);				/* Sets file name */		c2pstr((char*)theFileSpec.name);			*vRefNum 	= theFileSpec.vRefNum;							/* Returns vref num */		fileError 	= FSpOpenDF(&theFileSpec,fsRdPerm,fRefNum);	}	return fileError;}void	FileErrorMessages_DirPath(short fileError){	short	theID;	unsigned char*	message;		switch(fileError){			case noErr:				return ;			case nsvErr:				message = "\pSpecified search volume was not found.";				break;			case fnfErr:				message = "\pSearch File was not found.";				break;			case volOffLinErr:				message = "\pSpecified search volume is off line.";				break;			default:				sprintf(gTheText,"File error %5d on open",fileError);				c2pstr(gTheText);				message = pTheText;				break;		}	ParamText(message,"\pSearch path (File Menu) may be incorrect.","\p","\p");	theID = StopAlert(FILE_ERROR,(ModalFilterUPP)NUL);	return;}	 void PathNameFromFSSpec(FSSpec theFSSpec,unsigned char* namePtr){	CInfoPBRec	block;	Str255		directoryName;	short 		err;	Boolean		gHaveAUX = false;	*namePtr = 0;	block.dirInfo.ioNamePtr = directoryName;	block.dirInfo.ioDrParID = theFSSpec.parID;	err = 0;	do {		block.dirInfo.ioVRefNum = theFSSpec.vRefNum;		block.dirInfo.ioFDirIndex = -1;		block.dirInfo.ioDrDirID = block.dirInfo.ioDrParID;		err = PBGetCatInfo(&block,false);		if(err == 0){			if (gHaveAUX) {				if (directoryName[1] != '/')					/* If this isn't root (i.e. '/'), append a slash ('/') */					pStrcat(directoryName,"\p/");			} else {				/* Append a Macintosh style colon (':') */				pStrcat(directoryName,"\p:");				pStrcat(directoryName,namePtr);				pStrcpy(namePtr,directoryName);			}		}	} while (block.dirInfo.ioDrDirID != fsRtDirID && err == 0);	pStrcat(namePtr,theFSSpec.name);	return;}short	SetSearchVol(OSType fileType,FSSpec	*theFSSpec){	short	err;		UseResFile(g_AppResFile);		switch(fileType){		case 'UnC2':			err = GetDirPath(SEARCH_DMCRYSTALS,theFSSpec);			break;		case 'DifO':		case 'PICT':			err = GetDirPath(SEARCH_DOCS,theFSSpec);			break;		case 'Phas':			err = GetDirPath(SEARCH_PHASED,theFSSpec);			break;		default:			return(-1);			break;	}	if(err == noErr){		LMSetSFSaveDisk((short)(-1 * theFSSpec->vRefNum));		LMSetCurDirStore((long)theFSSpec->parID);	}	return(err);}short	OpenNamedFileEM(short dirID,char* theFileName,short*	vRefNum,short* sfRefNum){	short fileError;	fileError = OpenNamedFile( dirID,theFileName,vRefNum,sfRefNum);	if(fileError){		FileErrorMessages_DirPath( fileError);			}	return fileError;}pascal	short	TheDialogHook(short item,DialogPtr theDialog,Ptr dataPtr){	short			iType;	ControlHandle	theControl,myControl;	Rect			theRect;	Ptr				dummyPtr;		dummyPtr = dataPtr;		/* This line prevents a warning */		switch(item){		case sfItemNewFolderUser:			SysBeep(30);			return(sfHookNullEvent);			break;					case -234:			GetDItem(theDialog,1,&iType,(Handle*)&theControl,&theRect);			GetDItem(theDialog,13,&iType,(Handle*)&myControl,&theRect);			if((*theControl)->contrlTitle[2] != (*myControl)->contrlTitle[2]){				(*myControl)->contrlTitle[0] = (*theControl)->contrlTitle[0];				(*myControl)->contrlTitle[1] = (*theControl)->contrlTitle[1];				(*myControl)->contrlTitle[2] = (*theControl)->contrlTitle[2];				(*myControl)->contrlTitle[3] = (*theControl)->contrlTitle[3];				(*myControl)->contrlTitle[4] = (*theControl)->contrlTitle[4];				Draw1Control(myControl);			}			return(sfHookNullEvent);			break;		case 13:			return (1);			break;		default:			return(item);			break;	}}	void	InitDirPaths(void){	FSSpec 				theFileSpecs[NUM_FSS_RECS];	short				i,j,err,iFileRef,iErr;	AliasHandle			theAliases[NUM_FSS_RECS];	Boolean				validFlags[NUM_FSS_RECS],changed;	FCBPBRec			pb;	unsigned char		theName[256];		if(!gAppleEvtsOK)		return;			gTheHandle 		= GetResource('ERIC',500);	pb.ioRefNum 	= HomeResFile (gTheHandle);	err 			= GetVRefNum (pb.ioRefNum, &pb.ioVRefNum);	pb.ioFCBIndx	= 0;	pb.ioNamePtr	= theName;	iErr 			= PBGetFCBInfo (&pb,false);		ReleaseResource(gTheHandle);			for(i = 0,j = ALIAS_BASE ; i < NUM_FSS_RECS ; i++,j++){		gTheHandle = GetResource('DATA',j);		iFileRef = HomeResFile (gTheHandle);		RmveResource (gTheHandle);		DisposHandle(gTheHandle);	}	UpdateResFile (iFileRef);		for(i = 0,j = ALIAS_BASE ; i < NUM_FSS_RECS ; i++,j++){		validFlags[i]				= true;		theFileSpecs[i].vRefNum 	= pb.ioVRefNum;		theFileSpecs[i].parID		= pb.ioFCBParID;		theFileSpecs[i].name[0]		= (char)0;		theAliases[i] = (AliasHandle)GetResource('DATA',j);		if(ResError() != 0 || theAliases[i] == NUL){			err = NewAlias(NUL,&theFileSpecs[i],&theAliases[i]);			AddResource((Handle)theAliases[i],'DATA',j,"\pSearch Path Alias");			if(ResError() != noErr){				DisposHandle((Handle)theAliases[i]);				return;			}			WriteResource((Handle)theAliases[i]);		} else {			err = ResolveAlias(NUL,theAliases[i],&theFileSpecs[i],&changed);			if(err == usrCanceledErr){				validFlags[i] = false;			} else if(changed){				ChangedResource((Handle)theAliases[i]);				WriteResource((Handle)theAliases[i]);			}			ReleaseResource((Handle)theAliases[i]);		}	}}			void	GetSearchFSSPec(OSType fileType,FSSpec	*theFSSpec){	short	err;		switch(fileType){		case 'UnC2':			err = GetDirPath(SEARCH_DMCRYSTALS,theFSSpec);			break;		case 'DifO':		case 'PICT':			err = GetDirPath(SEARCH_DOCS,theFSSpec);			break;		case 'Phas':			err = GetDirPath(SEARCH_PHASED,theFSSpec);			break;		default:			break;	}}		pascal	void TheActivateProc(DialogPtr theDialog,short item,Booleanactivate,Ptr dataPtr){	DialogPtr	dummyDlog;	Boolean		dummyactivate;	Ptr			dummyPtr;		dummyDlog		= theDialog;	/* these three lines prevent warnings */	dummyactivate	= activate;	dummyPtr		= dataPtr;				if(item == 1){		SysBeep(20);	}}