#include	"Diffract_INCs.h"#include	"Dir_Paths.h"/*dec 1992 I haven't done much here...just speeded it up & straighted somefromatting */enum {	START_TBL = 185,		END_TBL = START_TBL + 26,		LINE_1,		LINE_2,		LINE_3,		LINE_4,		LINE_5,		USER_INFO	};void		AboutDesktopMic	(void);void		Fade			(WindowPtr	theWindow,short	colorID,RGBColor*	finalColor,shortsteps);void		CloseCurtain	(WindowPtr theWindow);void		OpenCurtain		(WindowPtr theWindow,PicHandle	thePicture);void		ShiftCTab		(CTabHandle		theCTab);void		BackShiftCTab	(CTabHandle		theCTab);PicHandle	DistributionPic	(Rect*	thePicRect);PicHandle	AcknowledgePic	(Rect*	thePicRect);PicHandle 	DoUserInfo		(Rect*	thePicRect);void		DoBandWCredits(WindowPtr	theWindow);void		DisplayPict(WindowPtr theWindow,short resID);void		DoAbout2(void);void		Splash(Rect*	theRect);void 		DoUserInfo2(Rect*	thePicRect);void	AboutDesktopMic(void){	WindowPtr		theWindow;	GrafPtr			theOldPort;	unsigned long			delay;	short			cx,cy,x,y;	Rect			theRect;	PaletteHandle	thePalette;	RGBColor		theColor;	PicHandle		thePicture;		GetPort(&theOldPort);	DoAbout2();	SetPort(theOldPort);	return;		if(!gInColor){		theWindow = GetNewWindow(1111,NUL,IN_FRONT);		SetPort(theWindow);		DoBandWCredits(theWindow);		SetPort(theOldPort);		FlushEvents(everyEvent,0);		DisposeWindow(theWindow);		SetPort(theOldPort);		return;	}			theWindow = GetNewCWindow(1111,NUL,IN_FRONT);	SetPort(theWindow);		thePalette = GetPalette(theWindow);		PmForeColor(1);	theRect = theWindow->portRect;	dm_PaintRect(&theRect);	cx	= (theRect.left + theRect.right) / 2;	cy	= (theRect.top + theRect.bottom) / 2;	sprintf(gTheText,"Desktop Microscopist");	c2pstr(gTheText);	TextFont(newYork);	TextSize(24);	TextFace(bold);	x = cx - StringWidth(pTheText) / 2;	y = cy / 2;	PmForeColor(LINE_1);	MoveTo(x,y);	DrawString(pTheText);	theColor.red 	= 65535;	theColor.blue 	= 0;	theColor.green 	= 65535;	Fade(theWindow,LINE_1,&theColor,45);		sprintf(gTheText,"Written By");	c2pstr(gTheText);	TextSize(12);	TextFace(0);	x = cx - StringWidth(pTheText) / 2;	y = cy - 30;	PmForeColor(LINE_2);	MoveTo(x,y);	DrawString(pTheText);	theColor.red 	= 0;	theColor.blue 	= 65535;	theColor.green 	= 65535;	Fade(theWindow,LINE_2,&theColor,20);		sprintf(gTheText,"Eric Schlienger");	c2pstr(gTheText);	TextSize(14);	TextFace(bold);	x = cx - StringWidth(pTheText) / 2;	y = cy + 10;	PmForeColor(LINE_3);	MoveTo(x,y);	DrawString(pTheText);	sprintf(gTheText,"James T. Stanley");	c2pstr(gTheText);	x = cx - StringWidth(pTheText) / 2;	y = cy + 30;	MoveTo(x,y);	DrawString(pTheText);	theColor.red 	= 65535;	theColor.blue 	= 0;	theColor.green 	= 65535;	Fade(theWindow,LINE_3,&theColor,30);	theColor.red 	= 0;	theColor.blue 	= 65535;	theColor.green 	= 0;	Fade(theWindow,LINE_3,&theColor,30);	theColor.red 	= 65535;	theColor.blue 	= 65535;	theColor.green 	= 0;	Fade(theWindow,LINE_3,&theColor,30);	theColor.red 	= 65535;	theColor.blue 	= 0;	theColor.green 	= 65535;	Fade(theWindow,LINE_3,&theColor,30);		sprintf(gTheText,"with");	c2pstr(gTheText);	TextSize(12);	TextFace(0);	x = cx - StringWidth(pTheText) / 2;	y = cy + 50;	PmForeColor(LINE_4);	MoveTo(x,y);	DrawString(pTheText);	theColor.red 	= 0;	theColor.blue 	= 65535;	theColor.green 	= 65535;	Fade(theWindow,LINE_4,&theColor,20);		sprintf(gTheText,"Hamish L. Fraser");	c2pstr(gTheText);	TextSize(12);	TextFace(0);	x = cx - StringWidth(pTheText) / 2;	y = cy + 70;	PmForeColor(LINE_5);	MoveTo(x,y);	DrawString(pTheText);	theColor.red 	= 65535;	theColor.blue 	= 0;	theColor.green 	= 65535;	Fade(theWindow,LINE_5,&theColor,30);		Delay(30,&delay);	CloseCurtain(theWindow);	Delay(5,&delay);	thePicture = DistributionPic(&theWindow->portRect);	OpenCurtain(theWindow,thePicture);	Delay(30,&delay);	KillPicture(thePicture);	CloseCurtain(theWindow);	Delay(5,&delay);		thePicture = DoUserInfo(&theWindow->portRect);	OpenCurtain(theWindow,thePicture);	Delay(30,&delay);	KillPicture(thePicture);	CloseCurtain(theWindow);	Delay(5,&delay);		thePicture = AcknowledgePic(&theWindow->portRect);	OpenCurtain(theWindow,thePicture);	Delay(30,&delay);	KillPicture(thePicture);	CloseCurtain(theWindow);	Delay(5,&delay);	SetPort(theOldPort);	FlushEvents(everyEvent,0);		DisposeWindow(theWindow);		SetPort(theOldPort);}void	Fade(WindowPtr	theWindow,short	colorID,RGBColor *finalColor,short steps){	PaletteHandle	thePalette;	RGBColor		theColor;	double			red,green,blue,deltaRed,deltaGreen,deltaBlue,numSteps;	short			i;	unsigned long	time;	return;	thePalette = GetPalette(theWindow);		GetEntryColor(thePalette,colorID,&theColor);	numSteps	= steps;	red			= theColor.red;	green		= theColor.green;	blue		= theColor.blue;	deltaRed	= ((double)finalColor->red - red) / numSteps;	deltaGreen	= ((double)finalColor->green - green) / numSteps;	deltaBlue	= ((double)finalColor->blue - blue) / numSteps;		for(i = 1 ; i <= steps ; i++){		red 	+= deltaRed;		green 	+= deltaGreen;		blue 	+= deltaBlue;		theColor.red 	= (unsigned short)(red + .5);		theColor.green 	= (unsigned short)(green + .5);		theColor.blue 	= (unsigned short)(blue + .5);		AnimateEntry(theWindow,colorID,&theColor);		Delay(1,&time);	}	AnimateEntry(theWindow,colorID,finalColor);}	void	CloseCurtain(WindowPtr	theWindow){	short			width,i,end,cx,x1,x2,count,j;	Rect			theRect;	RGBColor		theColor;	long			number,inc;	PaletteHandle	thePalette;	CTabHandle		theCTab;	return;	theCTab		= (CTabHandle)D_NewHandle(10);/*dec 1992*/	theRect 	= theWindow->portRect;	width		= theRect.right;	end 		= width;	cx 			= 1 + width / 2;	x1 			= theRect.left;	x2 			= theRect.right;		number = 8738;	inc	= 4369;	theColor.blue = 0;	count = START_TBL;	while(number <= 65535){		theColor.red = theColor.green = (unsigned short)number;		AnimateEntry(theWindow,count++,&theColor);		number += 4369;	}	number -= 8738;	while(number >= 8738){		theColor.red = theColor.green = (unsigned short)number;		AnimateEntry(theWindow,count++,&theColor);		number -= 4369;	}	thePalette 	= GetPalette(theWindow);	Palette2CTab(thePalette,theCTab);	CTabChanged(theCTab);	for(i = 1 , j = START_TBL ; i <= cx ; i++){					ShiftCTab(theCTab);		AnimatePalette(theWindow,theCTab,START_TBL,START_TBL,1 + END_TBL - START_TBL);				PmForeColor(j++);		if(j > END_TBL)			j = START_TBL;		MoveTo(x1,theRect.top);		LineTo(x1,theRect.bottom);		MoveTo(x2,theRect.top);		LineTo(x2,theRect.bottom);		x1++;		x2--;		/*Delay(1,&time);*/	}	KillHandle((Handle*)&theCTab);/* dec 1992*/}	void	OpenCurtain(WindowPtr theWindow,PicHandle	thePicture){	short			width,i,end,cx,x1,x2,j;	Rect			theRect;	PaletteHandle	thePalette;	CTabHandle		theCTab;		//if(!gInColor){		InvalRect(&theWindow->portRect);		BeginUpdate(theWindow);		dm_EraseRect(&theWindow->portRect);		DrawPicture(thePicture,&(*thePicture)->picFrame);		EndUpdate(theWindow);		return;	//}	theCTab		= (CTabHandle)D_NewHandle(10);/*dec 1992*/	theRect 	= theWindow->portRect;	width		= theRect.right;	end 		= width;	cx 			= 1 + width / 2;	x1 			= (theRect.left + theRect.right) / 2;	x2 			= x1;	BeginUpdate(theWindow);	EndUpdate(theWindow);		thePalette 	= GetPalette(theWindow);	Palette2CTab(thePalette,theCTab);	CTabChanged(theCTab);	for(i = 1 , j = 10 ; i <= cx ; i++){		theRect.left 	= x1;		theRect.right 	= ++x1;		InvalRect(&theRect);		theRect.right 	= x2;		theRect.left 	= --x2;		InvalRect(&theRect);		/*Delay(1,&time);*/		BeginUpdate(theWindow);		DrawPicture(thePicture,&(*thePicture)->picFrame);		EndUpdate(theWindow);		BackShiftCTab(theCTab);		AnimatePalette(theWindow,theCTab,START_TBL,START_TBL,1 + END_TBL - START_TBL);	}	KillHandle((Handle*)&theCTab);/*dec 1992*/}	void	ShiftCTab(CTabHandle		theCTab){	RGBColor theColor,lastColor;		short	i;		lastColor = (*theCTab)->ctTable[END_TBL].rgb;	for(i = START_TBL ; i <= END_TBL ; i++){		theColor = (*theCTab)->ctTable[i].rgb;		(*theCTab)->ctTable[i].rgb = lastColor;		lastColor = theColor;	}	CTabChanged(theCTab);}void	BackShiftCTab(CTabHandle		theCTab){	RGBColor theColor,lastColor;		short	i;		lastColor = (*theCTab)->ctTable[START_TBL].rgb;	for(i = END_TBL ; i >= START_TBL ; i--){		theColor = (*theCTab)->ctTable[i].rgb;		(*theCTab)->ctTable[i].rgb = lastColor;		lastColor = theColor;	}	CTabChanged(theCTab);}		PicHandle	DistributionPic(Rect*	thePicRect){	PicHandle			thePicture,rsrcPic;	short				cx,x,cy,y;	Rect				theRect;		cx 		= (thePicRect->left + thePicRect->right) / 2;	cy 		= (thePicRect->top + thePicRect->bottom) / 2;	rsrcPic	= (PicHandle)GetResource('PICT',128);			theRect	= (*rsrcPic)->picFrame;	x 		= cx - theRect.right / 2;	y		= cy - theRect.bottom / 2;	OffsetRect(&theRect,x,y);		thePicture 	= OpenPicture(thePicRect);	PmForeColor(1);	dm_PaintRect(thePicRect);	DrawPicture(rsrcPic,&theRect);	ClosePicture();		ReleaseResource((Handle)rsrcPic);	return(thePicture);}		PicHandle	AcknowledgePic(Rect*	thePicRect){	PicHandle			thePicture,rsrcPic;	short				cx,x,cy,y;	Rect				theRect;		cx 		= (thePicRect->left + thePicRect->right) / 2;	cy 		= (thePicRect->top + thePicRect->bottom) / 2;	rsrcPic	= (PicHandle)GetResource('PICT',130);	theRect	= (*rsrcPic)->picFrame;	x 		= cx - theRect.right / 2;	y		= cy - theRect.bottom / 2;	OffsetRect(&theRect,x,y);		thePicture 	= OpenPicture(thePicRect);	PmForeColor(1);	dm_PaintRect(thePicRect);	DrawPicture(rsrcPic,&theRect);	ClosePicture();		ReleaseResource((Handle)rsrcPic);	return(thePicture);}PicHandle 	DoUserInfo(Rect*	thePicRect){	short 			sNum,type,i,*array,y,x,nums[10];	char 			info[50];	Handle			theRes;	Handle			theHandle;	DialogPtr		theDialog;	Rect			theRect;	char*			theText,numText[2];	unsigned char	*tempText,**theUserName;	Boolean			quit,retValue,snOK;	PicHandle		thePicture;		theRes 		= GetResource('ERIC',500);	HLock(theRes);		retValue 	= true;	sNum 		=  **((short**)(theRes));	sNum 		^= 0x7F29;	array		= &((short*)(*theRes))[1];	for(i = 1 ; i <= 100 ; i++,array++){		*array ^= sNum;	}	theText		= &(((char*)(*theRes))[2]);	snOK 		= false;	if(sNum == 0 || sNum ==  0x7F29){		#ifndef _DEMO_VERS_		gQuitFlag = true;		#endif		/*gQuitFlag = false;copy protect*/		/*gShutdown = false;copy protect*/		theText[0] = (char)0;		if(theText[0] == ' '  || theText[0] == (char)0){			theDialog = DM_GetNewDialog(505,0L,(WindowPtr)-1L);			quit = false;			while(!quit){				ModalDialog((ModalFilterUPP)NUL,&i);				switch(i){					case DLOG_ENTER_OR_CR:					case 1:						snOK = true;						GetDItem(theDialog,8,&type,&theHandle,&theRect);						GetIText(theHandle,pTheText);						numText[1] = (char)0;						for(i = 0 ; i <= 9 ; i++){							numText[0] = pTheText[i + 1];							nums[i] = atoi(numText);						}						p2cstr(pTheText);						gTheText[8] = (char)0;						sNum = atoi(&gTheText[3]);												x = 2 + ((nums[3] + nums[4] + nums[5] + nums[6] + nums[7]) % 7);						if(x != nums[0])							snOK = false;													x = 957 % (1 + nums[6]);						if(x != nums[1])							snOK = false;													x = (459 + nums[0] + nums[1]) % ( 1 + nums[7]);						if(x != nums[2])							snOK = false;													x = (523 + nums[2] + nums[5]) % ( 1 + nums[2]);						if(x != nums[8])							snOK = false;													x = (215 + nums[0] + nums[1] + nums[2] + nums[8]) % 9;						if(x != nums[9])							snOK = false;													if(snOK){							for(i = 3 ; i <= 7 ; i++){								GetDItem(theDialog,i,&type,&theHandle,&theRect);								GetIText(theHandle,(unsigned char*)theText);								if(theText[0] > 39)									theText[0] = (char)39;								theText += 40;							}							array		= &((short*)(*theRes))[1];							for(i = 1 ; i <= 100 ; i++,array++){								*array ^= sNum;							}							**((short**)(theRes)) = sNum ^ 0x7F29;							ChangedResource(theRes);							WriteResource(theRes);							theText		= &(((char*)(*theRes))[2]);							quit = true;							gQuitFlag = false;							InitDirPaths();							theUserName = (unsigned char**)GetResource('DATA',128);							if(ResError() != 0 || (Handle)theUserName == NUL){								theUserName = (unsigned char**)NewHandle(128L * sizeof(char));								AddResource((Handle)theUserName,'DATA',128,"\pUser Name");								ChangedResource((Handle)theUserName);								WriteResource((Handle)theUserName);								theUserName = (unsigned char**)GetResource('DATA',128);							}							GetDItem(theDialog,3,&type,&theHandle,&theRect);							//strcpy(gTheRoutine,"DoUserInfo");							D_HLock(theUserName);							GetIText(theHandle,*theUserName);							D_HUnlock(theUserName);							ChangedResource((Handle)theUserName);							WriteResource((Handle)theUserName);							ReleaseResource((Handle)theUserName);						} else {							AlertUser(2);						}						break;					case 2:						quit = true;						retValue = false;						break;					default:						break;				}			}			DM_DisposDialog(&theDialog);		}	}	thePicture = OpenPicture(thePicRect);	if(!gInColor){		ForeColor(whiteColor);		BackColor(blackColor);		dm_EraseRect(thePicRect);	} else {		PmForeColor(1);		dm_PaintRect(thePicRect);	}	TextSize(12);	TextFont(newYork);	y = 50;			for(i = 1 ; i <= 7 ; i++){		switch(i){			case 1:				if(gInColor){					PmForeColor(LINE_2);				}				tempText = "\pThis copy of Desktop Microscopist is licensed to:";				x = (thePicRect->left + thePicRect->right - StringWidth(tempText)) / 2;				MoveTo(x,y);				DrawString(tempText);				y += 20;				break;			case 7:				y += 20;				if(gInColor){					PmForeColor(LINE_1);				}				TextSize(12);				sprintf(info,"Serial Number: %5d",sNum);				c2pstr(info);				x = (thePicRect->left + thePicRect->right - StringWidth((unsignedchar*)info)) / 2;				MoveTo(x,y);				DrawString((unsigned char*)info);				y += 3;				break;			default:				TextSize(14);				if(gInColor){					PmForeColor(USER_INFO);				}				x = (thePicRect->left + thePicRect->right -StringWidth((ConstStr255Param)theText)) / 2;				MoveTo(x,y);				DrawString((ConstStr255Param)theText);				theText += 40;				break;		}		y += 20;	}	ClosePicture();	HUnlock(theRes);	ReleaseResource(theRes);	TextFont(0);	TextSize(12);	PmForeColor(1);	if(snOK){		SetDirPaths();	}	return(thePicture);}void	DoBandWCredits(WindowPtr	theWindow){	ForeColor(whiteColor);	BackColor(blackColor);	DisplayPict(theWindow,1129);	DisplayPict(theWindow,1128);	DisplayPict(theWindow,-1);	DisplayPict(theWindow,1130);	ForeColor(blackColor);	BackColor(whiteColor);}	void	DisplayPict(WindowPtr theWindow,short resID){	PicHandle	thePicture;	Rect		theRect,picFrame;	short		x,y;		theRect 	= theWindow->portRect;	if(resID != -1){		thePicture 	= (PicHandle)GetResource('PICT',resID);	} else {		thePicture 	= DoUserInfo(&theRect);	}	picFrame = (*thePicture)->picFrame;	x = ((theRect.right - theRect.left) - (picFrame.right - picFrame.left)) / 2;	y = ((theRect.bottom - theRect.top) - (picFrame.bottom - picFrame.top)) / 2;	OffsetRect(&picFrame,x,y);	dm_EraseRect(&theRect);	dm_PaintRect(&picFrame);	DrawPicture(thePicture,&picFrame);	while(!Button())		;	dm_EraseRect(&theRect);	while(Button())		;	FlushEvents(everyEvent,0L);	if(resID != -1){		ReleaseResource((Handle)thePicture);	} else {		KillPicture(thePicture);	}}					void	DoAbout2(void){	PicHandle	thePict;	WindowPtr	theWindow;	Rect		theRect,updateArea;	RGBColor	blackColor,textColor;	RgnHandle	leftRgn,resultRgn,thisRgn;	short		pictID;	EventRecord	theEvent;	Boolean		flag;				theWindow			= GetNewWindow(2950,0L,(WindowPtr)-1L);	thePict				= GetPicture(2950);	SetPort(theWindow);		SizeWindow(theWindow,366,303,false);				leftRgn				= D_NewRgn();	thisRgn				= D_NewRgn();	resultRgn			= D_NewRgn();	SetRect(&theRect,0,0,36,36);	SetRect(&updateArea,16,107,347,298);	RectRgn(leftRgn,&updateArea);	blackColor.red		= 0;	blackColor.green	= 0;	blackColor.blue		= 0;	RGBBackColor(&blackColor);	textColor.red		= 30000;	textColor.green		= 65535;	textColor.blue		= 65535;	InvalRect(&theWindow->portRect);	EraseRect(&theWindow->portRect);	BeginUpdate(theWindow);	EraseRect(&theWindow->portRect);	DrawPicture(thePict,&theWindow->portRect);	EndUpdate(theWindow);					for(pictID	= 2951 ; pictID <= 2954 ; pictID++){			SetRect(&theRect,0,0,36,36);		SetRect(&updateArea,16,107,347,298);		RectRgn(leftRgn,&updateArea);			flag	= true;			while(flag){			if(GetNextEvent(mDownMask + keyDownMask,&theEvent)){				if(theEvent.what == mouseDown){					flag = false;				} else if(theEvent.what == keyDown){					if(((char)(theEvent.message & charCodeMask)) == '\r' ){						flag = false;					}				}			}		}				FlushEvents(everyEvent,0L);			ReleaseResource((Handle)thePict);		thePict		= GetPicture(pictID);		SizeWindow(theWindow,(*thePict)->picFrame.right,(*thePict)->picFrame.bottom,false);			/*	while(!EmptyRgn(leftRgn)){			thisRect	= theRect;			h			= 0;			v			= 0;			while(h < 16){				h 	= abs(Random() % 332);			}						while(v < 107){				v	= abs(Random() % 282);			}						OffsetRect(&thisRect,h,v);			RectRgn(thisRgn,&thisRect);			SectRgn(leftRgn,thisRgn,resultRgn);			BeginUpdate(theWindow);			EndUpdate(theWindow);			if(!EmptyRgn(resultRgn)){				DiffRgn(leftRgn,resultRgn,leftRgn);				Splash(&thisRect);				BeginUpdate(theWindow);				DrawPicture(thePict,&theWindow->portRect);				if(pictID == 2954){					RGBForeColor(&textColor);					DoUserInfo2(&(*thePict)->picFrame);				}				EndUpdate(theWindow);				count	= 0;			} else if(++count > 10){				InsetRect(&theRect,-2,-2);				count = 0;			}			if(GetNextEvent(keyDownMask,&theEvent)){				if(((char)(theEvent.message & charCodeMask)) == '.' && theEvent.modifiers & cmdKey){					SetEmptyRgn(leftRgn);				}			}		}		*/		InvalRect(&theWindow->portRect);		EraseRect(&theWindow->portRect);		BeginUpdate(theWindow);		DrawPicture(thePict,&theWindow->portRect);		if(pictID == 2954){			RGBForeColor(&textColor);			DoUserInfo2(&(*thePict)->picFrame);		}		EndUpdate(theWindow);	}		FlushEvents(everyEvent,0L);	flag	= true;		while(flag){		if(GetNextEvent(mDownMask + keyDownMask,&theEvent)){			if(theEvent.what == mouseDown){				flag = false;			} else if(theEvent.what == keyDown){				if(((char)(theEvent.message & charCodeMask)) == '\r' ){					flag = false;				}			}		}	}		FlushEvents(everyEvent,0L);	D_DisposeRgn(&thisRgn);	D_DisposeRgn(&leftRgn);	D_DisposeRgn(&resultRgn);		ReleaseResource((Handle)thePict);	DisposeWindow(theWindow);}		void	Splash(Rect*	theRect){	Rect			tempRect,lastRect,veryLastRect;	short			x,end,h,v;	unsigned short	colorStep;	RGBColor		theColor;	unsigned long			time;		SetRect(&lastRect,0,0,0,0);	veryLastRect	= lastRect;	end				= (theRect->right - theRect->left) >> 1;	h				= (theRect->right + theRect->left) >> 1;	v				= (theRect->top + theRect->bottom) >> 1;	colorStep		= 65535 / (unsigned short)end;	theColor.red	= 65535;	theColor.green	= 0;	theColor.blue	= 0;	for(x = 1 ; x <= end ; x += 2){		tempRect.left	= h - x;		tempRect.right	= h + x;		tempRect.top	= v - x;		tempRect.bottom	= v + x;		RGBForeColor(&theColor);		PaintOval(&tempRect);		EraseOval(&veryLastRect);		Delay(1L,&time);		veryLastRect 	= lastRect;		lastRect		= tempRect;		theColor.green	+= colorStep;	}	EraseOval(theRect);	InvalRect(theRect);}					void 	DoUserInfo2(Rect*	thePicRect){	short 			sNum,i,*array,y,x;//nums[10],type;	char 			info[50];	Handle			theRes;//	Handle			theHandle;//	DialogPtr		theDialog;	//Rect			theRect;	char*			theText;//numText[2];//	unsigned char	*tempText;//**theUserName;	Boolean			retValue,snOK;//quit//	PicHandle		thePicture;		theRes 		= GetResource('ERIC',500);	HLock(theRes);		retValue 	= true;	sNum 		=  **((short**)(theRes));	sNum 		^= 0x7F29;	array		= &((short*)(*theRes))[1];	for(i = 1 ; i <= 100 ; i++,array++){		*array ^= sNum;	}	theText		= &(((char*)(*theRes))[2]);	snOK 		= false;		TextSize(12);	TextFont(newYork);	y = 170;			for(i = 1 ; i <= 6 ; i++){		switch(i){			case 6:				y += 20;								TextSize(12);				sprintf(info,"Serial Number: %5d",sNum);				c2pstr(info);				x = (thePicRect->left + thePicRect->right - StringWidth((unsignedchar*)info)) / 2;				MoveTo(x,y);				DrawString((unsigned char*)info);				y += 3;				break;			default:				TextSize(18);				x = (thePicRect->left + thePicRect->right -StringWidth((ConstStr255Param)theText)) / 2;				MoveTo(x,y);				DrawString((ConstStr255Param)theText);				theText += 40;				break;		}		y += 20;	}	HUnlock(theRes);	ReleaseResource(theRes);	TextFont(0);	TextSize(12);}										