 #include	"Diffract_INCs.h"#include	"MenuDefs.h"#include "AbsorptionLabels.h"//s.Jim:Event/Memory:EV_FileObject.c#include	"EveMacros.h"#include	"Dir_Paths.h"#ifdef __POWERPC__	#include	"Navigation.h"	#include	"NavServices.h"#endifshort		theFileRefNum;long		thePictureSize;pascal short DefaultDirHook(short item, DialogPtr	theDialog, Ptr theData);static	short navFound = -1;void		FileObj::ReadFileOpen(OSType	fileType)		/*  Modified for StandardGetFile  */	{	Point	where;	SFTypeList		theList;	short	listLength;	short	err;	DlgHookYDUPP		TheDialogHookUPP;	#ifdef __POWERPC__ 		if(navFound == -1){			if(NavServicesAvailable ()) navFound = 1;			else			navFound = 0;		}		if(navFound){			OSErr			oserr;						oserr = ReadNavOpen(0L,fileType);			//if(!oserr)				//file_is_Open = true;			return;		}	#endif	#if defined(_newkey_) && !defined(_DEMO_VERS_/*added _*/)					// Copy Protect for illegal version		KEYTEST2(file_is_Open);	#endif		if(file_is_Open){		fileError = -1958; 		DoFileError();		return;	}	TheDialogHookUPP	= NewDlgHookYDProc(DefaultDirHook);		listLength 	= 1;	fileError = 0;	where.v = where.h = 40;	theList[0] = fileType;		/* Jim's Code  -- Ack*/	if(CRYST_OBJ == fileType){		theList[2] = CRYST_OBJ_OLDEST;		theList[1] = CRYST_OBJ_OLD;		listLength = 3;	}else{		theList[1] = CRYST_OBJ;		theList[3] = CRYST_OBJ_OLDEST;		theList[2] = CRYST_OBJ_OLD;		listLength = 4;	}	if(fileType == 'PICT'){		theList[1] = 'TEXT';		listLength = 2;/*important to prevent improper file access*/	}	/* Jim's Code -- End */			if(gAppleEvtsOK){		theFileInfo.sfGood			= true;		theFileInfo.sfType			= fileType;		theFileInfo.sfScript		= smSystemScript;		theFileInfo.sfIsFolder		= true;		err = SetSearchVol(fileType,&theFileInfo.sfFile);		theFileInfo.sfFile.vRefNum 	= -LMGetSFSaveDisk();		theFileInfo.sfFile.parID 	= LMGetCurDirStore();		CustomGetFile(NUL,listLength,theList,&theFileInfo,-6042,where,TheDialogHookUPP,NUL,NUL,NUL,&theFileInfo);					//	StandardGetFile(NUL,listLength,theList,&theFileInfo);				if(!theFileInfo.sfGood)			return;					fileError = FSpOpenDF(&theFileInfo.sfFile,fsRdWrPerm,&pathRefNum);		} else {		SFReply	reply;		SFGetFile(where,"\pSelect File",(FileFilterUPP)NUL,listLength,theList,(DlgHookUPP)NUL,&reply);		if(!reply.good){			return;		}		BlockMove((Ptr)reply.fName,(Ptr)theFileInfo.sfFile.name,63);		theFileInfo.sfFile.vRefNum	= reply.vRefNum;		theFileInfo.sfGood 			= reply.good;		theFileInfo.sfType			= reply.fType;		fileError = FSOpen(theFileInfo.sfFile.name,theFileInfo.sfFile.vRefNum,&pathRefNum);	}			if(fileError != 0){		DoFileError();		return;	}		file_is_Open = true;}#define CRYST_OBJ_2  2	/*void		FileObj::SaveFileOpen(OSType	fileType){	Point			where;	DlgHookYDUPP	TheDialogHookUPP;	FSSpec			theFileSpec;		if(file_is_Open){		fileError = -1958;		DoFileError();		return;	}	#ifdef __POWERPC__		if(navFound == -1){			if(NavServicesAvailable ()) navFound = 1;			else			navFound = 0;		}		if(navFound){			OSErr			oserr;			WindowPeek   theWindow;			theWindow = (WindowPeek)FrontWindow();			oserr = SaveNavOpen((GrafPort*)theWindow,fileType);			SaveNavOpen(WindowPtr theDocument,OSType	fileTypeToSave)			return;		}	#endif	if(fileType == CRYST_OBJ_2){		fileType = CRYST_OBJ;	}		theFileSpec			= theFileInfo.sfFile;	TheDialogHookUPP	= NewDlgHookYDProc(DefaultDirHook);	where.v = where.h = 40;	fileError = 0;		if(gAppleEvtsOK){				theFileInfo.sfGood			= true;		theFileInfo.sfType			= fileType;		theFileInfo.sfScript		= smSystemScript;		theFileInfo.sfIsFolder		= true;		fileError = SetSearchVol(fileType,&theFileInfo.sfFile);		theFileInfo.sfFile.vRefNum 	= -LMGetSFSaveDisk();		theFileInfo.sfFile.parID 	= LMGetCurDirStore();//		StandardPutFile((StringPtr)"\pFile Name:",theFileInfo.sfFile.name,&theFileInfo);				CustomPutFile((StringPtr)"\pFile Name:",theFileSpec.name,&theFileInfo,sfPutDialogID,where,TheDialogHookUPP,NUL,NUL,NUL,&theFileInfo);								if(!theFileInfo.sfGood)			return;				if(theFileInfo.sfReplacing){			fileError = FSpDelete(&theFileInfo.sfFile);			if(fileError != 0){				DoFileError();				return;			}		}		if(fileType == 'TEXT'){			fileError = FSpCreate(&theFileInfo.sfFile,'ttxt',fileType,theFileInfo.sfScript);		}else{			fileError = FSpCreate(&theFileInfo.sfFile,OWNER,fileType,theFileInfo.sfScript);		}		if(fileError != 0){			DoFileError();			return;		}				fileError = FSpOpenDF(&theFileInfo.sfFile,fsRdWrPerm,&pathRefNum);			} else {		SFReply	reply;		SFPutFile(where,(StringPtr)"\pFile Name:",theFileInfo.sfFile.name,(DlgHookUPP)NUL,&reply);		if(!reply.good){			return;		}		BlockMove((Ptr)reply.fName,(Ptr)theFileInfo.sfFile.name,63);		theFileInfo.sfFile.vRefNum	= reply.vRefNum;		theFileInfo.sfGood 			= reply.good;		theFileInfo.sfType			= reply.fType;		fileError = FSDelete(theFileInfo.sfFile.name,theFileInfo.sfFile.vRefNum);		if(fileError != noErr && fileError != bdNamErr && fileError != fnfErr){			DoFileError();			return;		}		fileError = Create(theFileInfo.sfFile.name,theFileInfo.sfFile.vRefNum,OWNER,fileType);		if(fileError != 0){			DoFileError();			return;		}		fileError = FSOpen(theFileInfo.sfFile.name,theFileInfo.sfFile.vRefNum,&pathRefNum);	}	if(fileError != 0){		DoFileError();		return;	}	file_is_Open = true;}*/void		FileObj::SaveFileOpen(OSType	fileType){	Point			where;	DlgHookYDUPP	TheDialogHookUPP;	FSSpec			theFileSpec;		if(file_is_Open){		fileError = -1958;		DoFileError();		return;	}	#ifdef __POWERPC__		if(navFound == -1){			if(NavServicesAvailable ()) navFound = 1;			else			navFound = 0;		}		if(navFound){			OSErr			oserr;			WindowPeek   theWindow;			theWindow = (WindowPeek)FrontWindow();			oserr = SaveNavOpen((GrafPort*)theWindow,fileType);			//if(!oserr)				file_is_Open = false;			return;		}	#endif	if(fileType == CRYST_OBJ_2){		fileType = CRYST_OBJ;	}		theFileSpec			= theFileInfo.sfFile;	TheDialogHookUPP	= NewDlgHookYDProc(DefaultDirHook);	where.v = where.h = 40;	fileError = 0;		if(gAppleEvtsOK){				theFileInfo.sfGood			= true;		theFileInfo.sfType			= fileType;		theFileInfo.sfScript		= smSystemScript;		theFileInfo.sfIsFolder		= true;		fileError = SetSearchVol(fileType,&theFileInfo.sfFile);		theFileInfo.sfFile.vRefNum 	= -LMGetSFSaveDisk();		theFileInfo.sfFile.parID 	= LMGetCurDirStore();//		StandardPutFile((StringPtr)"\pFile Name:",theFileInfo.sfFile.name,&theFileInfo);				CustomPutFile((StringPtr)"\pFile Name:",theFileSpec.name,&theFileInfo,sfPutDialogID,where,TheDialogHookUPP,NUL,NUL,NUL,&theFileInfo);								if(!theFileInfo.sfGood)			return;				if(theFileInfo.sfReplacing){			fileError = FSpDelete(&theFileInfo.sfFile);			if(fileError != 0){				DoFileError();				return;			}		}		if(fileType == 'TEXT'){			fileError = FSpCreate(&theFileInfo.sfFile,'ttxt',fileType,theFileInfo.sfScript);		}else{			fileError = FSpCreate(&theFileInfo.sfFile,OWNER,fileType,theFileInfo.sfScript);		}		if(fileError != 0){			DoFileError();			return;		}				fileError = FSpOpenDF(&theFileInfo.sfFile,fsRdWrPerm,&pathRefNum);			} else {		SFReply	reply;		SFPutFile(where,(StringPtr)"\pFile Name:",theFileInfo.sfFile.name,(DlgHookUPP)NUL,&reply);		if(!reply.good){			return;		}		BlockMove((Ptr)reply.fName,(Ptr)theFileInfo.sfFile.name,63);		theFileInfo.sfFile.vRefNum	= reply.vRefNum;		theFileInfo.sfGood 			= reply.good;		theFileInfo.sfType			= reply.fType;		fileError = FSDelete(theFileInfo.sfFile.name,theFileInfo.sfFile.vRefNum);		if(fileError != noErr && fileError != bdNamErr && fileError != fnfErr){			DoFileError();			return;		}		fileError = Create(theFileInfo.sfFile.name,theFileInfo.sfFile.vRefNum,OWNER,fileType);		if(fileError != 0){			DoFileError();			return;		}		fileError = FSOpen(theFileInfo.sfFile.name,theFileInfo.sfFile.vRefNum,&pathRefNum);	}	if(fileError != 0){		DoFileError();		return;	}	file_is_Open = true;}void		FileObj::FileOpen(void){		if(file_is_Open){		fileError = -1958;		DoFileError();		return;	}	fileError = 0;	if(!theFileInfo.sfGood)		return;			if(gAppleEvtsOK){		fileError = FSpOpenDF(&theFileInfo.sfFile,fsRdWrPerm,&pathRefNum);	} else {		fileError = FSOpen(theFileInfo.sfFile.name,theFileInfo.sfFile.vRefNum,&pathRefNum);		}		if(fileError != 0){		DoFileError();		return;	}		file_is_Open = true;}void FileObj::WriteConstStr255(ConstStr255Param theData){		ConstStr255Param	theInfo;		if(fileError != 0 || !file_is_Open)		return;	theInfo = theData;			xferLength = sizeof(ConstStr255Param);	fileError = FSWrite(pathRefNum,&xferLength,(Ptr)&theInfo);	if(fileError != 0){		DoFileAlert();	}}ConstStr255Param FileObj::ReadConstStr255(void){	ConstStr255Param	theData;	if(fileError != 0 || !file_is_Open)		return 0L;			xferLength = sizeof(ConstStr255Param);	fileError = FSRead(pathRefNum,&xferLength,(Ptr)&theData);	if(fileError != 0){		DoFileAlert();		return 0L;	}	return theData;}void FileObj::WriteResType(ResType theData){		ResType	theInfo;		if(fileError != 0 || !file_is_Open)		return;	theInfo = theData;			xferLength = sizeof(ResType);	fileError = FSWrite(pathRefNum,&xferLength,(Ptr)&theInfo);	if(fileError != 0){		DoFileAlert();	}}Boolean  FileObj::CreatePref(void){		if(file_is_Open){		fileError = -1958;		DoFileError();		return false;	}	fileError = 0;	sprintf((char*)theFileInfo.sfFile.name,"Desktop Microscopist Prefs");	c2pstr((char*)theFileInfo.sfFile.name);	if(gAppleEvtsOK){					fileError = FSpCreate(&theFileInfo.sfFile,OWNER,'pref',theFileInfo.sfScript);		if(fileError != 0){			DoFileError();			return false;		}				fileError = FSpOpenDF(&theFileInfo.sfFile,fsRdWrPerm,&pathRefNum);			} else {		fileError = Create(theFileInfo.sfFile.name,theFileInfo.sfFile.vRefNum,OWNER,'pref');		if(fileError != 0){			DoFileError();			return false;		}		fileError = FSOpen(theFileInfo.sfFile.name,theFileInfo.sfFile.vRefNum,&pathRefNum);	}	if(fileError != 0){		DoFileError();		return false;	}	file_is_Open = true;	return true;}ResType FileObj::ReadResType(void){	ResType	theData;	if(fileError != 0 || !file_is_Open)		return false;			xferLength = sizeof(ResType);	fileError = FSRead(pathRefNum,&xferLength,(Ptr)&theData);	if(fileError != 0){		DoFileError();		return false;	}	return theData;}Boolean		FileObj::ReadBoolean(void){	short	theData;	if(fileError != 0 || !file_is_Open)		return false;			xferLength = sizeof(short);	fileError = FSRead(pathRefNum,&xferLength,(Ptr)&theData);	if(fileError != 0){		DoFileError();		return false;	}	if(theData == 0)		return false;	return true;}void		FileObj::WriteBoolean(Boolean theData){	short	theInfo;	if(fileError != 0 || !file_is_Open)		return;	if(theData)		theInfo = 1;	else		theInfo = 0;			xferLength = sizeof(short);	fileError = FSWrite(pathRefNum,&xferLength,(Ptr)&theInfo);	if(fileError != 0){		DoFileAlert();	}	return;}short double		FileObj::ReadShortDouble(void){	short double	theData;	if(fileError != 0 || !file_is_Open)		return 0L;			xferLength = sizeof(short double);	fileError = FSRead(pathRefNum,&xferLength,(Ptr)&theData);	if(fileError != 0){		DoFileAlert();		theData = 0;	}	return(theData);}void		FileObj::WriteShortDouble(short double theData){	short double	theInfo;		if(fileError != 0 || !file_is_Open)		return;	theInfo = theData;			xferLength = sizeof(short double);	fileError = FSWrite(pathRefNum,&xferLength,(Ptr)&theInfo);	if(fileError != 0){		DoFileAlert();		theData = 0;	}	return;}short		FileObj::ReadShort(void){	short	theData;	if(fileError != 0 || !file_is_Open)		return 0;			xferLength = sizeof(short);	fileError = FSRead(pathRefNum,&xferLength,(Ptr)&theData);	if(fileError != 0){		DoFileAlert();		theData = 0;	}	return(theData);}void		FileObj::WriteShort(short theData){	short	theInfo;		if(fileError != 0 || !file_is_Open)		return;	theInfo = theData;			xferLength = sizeof(short);	fileError = FSWrite(pathRefNum,&xferLength,(Ptr)&theInfo);	if(fileError != 0){		DoFileAlert();	}	return;}long		FileObj::ReadLong(void){	long	theData;		if(fileError != 0 || !file_is_Open)		return 0L;			xferLength = sizeof(long);	fileError = FSRead(pathRefNum,&xferLength,(Ptr)&theData);	if(fileError != 0){		DoFileAlert();		theData = 0;	}	return(theData);}void		FileObj::WriteLong(long theData){	long	theInfo;	if(fileError != 0 || !file_is_Open)		return;	theInfo = theData;			xferLength = sizeof(long);	fileError = FSWrite(pathRefNum,&xferLength,(Ptr)&theInfo);	if(fileError != 0){		DoFileAlert();	}	return;}float		FileObj::ReadFloat(void){	float	theData;		if(fileError != 0 || !file_is_Open)		return 0.0;			xferLength = sizeof(float);	fileError = FSRead(pathRefNum,&xferLength,(Ptr)&theData);	if(fileError != 0){		DoFileAlert();		theData = 0.0;	}	return(theData);}void		FileObj::WriteFloat(float theData){	float	theInfo;	if(fileError != 0 || !file_is_Open)		return;	theInfo = theData;			xferLength = sizeof(float);	fileError = FSWrite(pathRefNum,&xferLength,(Ptr)&theInfo);	if(fileError != 0){		DoFileAlert();	}	return;}void		FileObj::WritePtr(void* theData){	long	ptrSize;		if(fileError != 0 || !file_is_Open)		return;			xferLength 	= sizeof(long);	ptrSize 	= GetPtrSize((Ptr)theData);	fileError 	= FSWrite(pathRefNum,&xferLength,(Ptr)&ptrSize);	if(ptrSize <=  0){		DoFileAlert();		return;	}	if(fileError != 0){		DoFileAlert();		return;	}	fileError 	= FSWrite(pathRefNum,&ptrSize,theData);	if(fileError != 0){		DoFileAlert();	}	return;}void		FileObj::WriteTextPtr(Ptr theData){	long	ptrSize;		if(fileError != 0 || !file_is_Open)		return;			//ptrSize 	= GetPtrSize((Ptr)theData);	xferLength 	= sizeof(long);	ptrSize = (strlen(theData) + 1) * sizeof(char);	fileError 	= FSWrite(pathRefNum,&xferLength,(Ptr)&ptrSize);	fileError 	= FSWrite(pathRefNum,&ptrSize,theData);	if(fileError != 0){		DoFileAlert();	}	return;}void*			FileObj::ReadPtr(void*  oldPtr){	long	ptrSize;	Ptr		theData;	long	filePos;	long	curEOF;		if(fileError != 0 || !file_is_Open)		return oldPtr;	if(oldPtr != 0L && GetPtrSize((Ptr)oldPtr) != 0){				KillPtr(oldPtr);	}	xferLength 	= sizeof(long);	fileError 	= FSRead(pathRefNum,&xferLength,(Ptr)&ptrSize);	if(fileError != 0){		DoFileAlert();		return(NUL);	}	if(ptrSize <= 0){		fileError = -40;		DoFileAlert();		return(NUL);	}	fileError = GetEOF(pathRefNum, &curEOF);	fileError = GetFPos(pathRefNum, &filePos);	if(filePos + ptrSize > curEOF || fileError){		fileError = -40;		DoFileAlert();		return 0L;	}		theData = D_NewPtr(ptrSize);	if(MemError() != noErr){		fileError = -108;		return (Ptr)NUL;	}	fileError 	= FSRead(pathRefNum,&ptrSize,theData);	if(fileError != 0){		DoFileAlert();		KillPtr(theData);		return(NUL);	}	return(theData);}void		FileObj::WriteHandle(Handle	theData){	long	handleSize;			if(fileError != 0 || !file_is_Open)		return;		xferLength 	= sizeof(long);	handleSize	= GetHandleSize(theData);		fileError 	= FSWrite(pathRefNum,&xferLength,(Ptr)&handleSize);		if(handleSize == 0){		DoFileAlert();		return;	}		if(fileError != 0){		DoFileAlert();		return;	}	D_HLock(theData);	fileError 	= FSWrite(pathRefNum,&handleSize,*theData);	D_HUnlock(theData);	if(fileError != 0){		DoFileAlert();	}	return;}void		FileObj::WriteTextHandle(Handle	theData){	long	handleSize;			if(fileError != 0 || !file_is_Open)		return;		handleSize	= GetHandleSize(theData);		D_HLock(theData);	fileError 	= FSWrite(pathRefNum,&handleSize,*theData);	D_HUnlock(theData);	if(fileError != 0){		DoFileAlert();	}	return;}void		FileObj::ReadHandle(Handle	theData){	long	handleSize;	long	curEOF;	long	filePos;		if(fileError != 0 || !file_is_Open)		return;			xferLength 	= sizeof(long);	fileError 	= FSRead(pathRefNum,&xferLength,(Ptr)&handleSize);	if(fileError != 0){		DoFileAlert();		return;	}	if(handleSize == 0){		fileError = -40;  		DoFileAlert();		return;	}	fileError = GetEOF(pathRefNum, &curEOF);	fileError = GetFPos(pathRefNum, &filePos);	if(handleSize + filePos > curEOF || fileError){		fileError = -40;  		DoFileAlert();		return;	}			SetHandleSize(theData,handleSize);	if(MemError() != noErr){		fileError = -108;		DoFileAlert();		return;	}	D_HLock(theData);	fileError 	= FSRead(pathRefNum,&handleSize,*theData);	D_HUnlock(theData);	if(fileError != 0){		DoFileAlert();	}	return;}void		FileObj::WriteDataBlock(void*	theData,long	ptrSize){	long	dataLength;	if(fileError != 0 || !file_is_Open)		return;		xferLength 	= sizeof(long);	dataLength	= ptrSize;	fileError 	= FSWrite(pathRefNum,&xferLength,(Ptr)&dataLength);	if(fileError != 0){		DoFileAlert();		return;	}	fileError 	= FSWrite(pathRefNum,&dataLength,theData);	if(fileError != 0){		DoFileAlert();	}	return;}void		FileObj::ReadDataBlock(void*	theData,long	dataLength){	long	ptrSize;	long	filePos;	long	curEOF;		if(fileError != 0 || !file_is_Open)		return;		xferLength 	= sizeof(long);	fileError = GetFPos(pathRefNum, &filePos);	fileError 	= FSRead(pathRefNum,&xferLength,(Ptr)&ptrSize);	if(ptrSize < 1){		fileError = -40;		DoFileAlert();		//SetFPos(pathRefNum,fsFromStart,filePos);		ptrSize = dataLength;	}	//	fileError = -1959;//	if(fileError != 0){//		DoFileAlert();//		return;//	}	fileError = GetEOF(pathRefNum, &curEOF);	fileError = GetFPos(pathRefNum, &filePos);	if(filePos + ptrSize > curEOF || fileError){		fileError = -40;  		DoFileAlert();		return;	}	fileError 	= FSRead(pathRefNum,&ptrSize,theData);	if(fileError != 0){		DoFileAlert();	}	return;}void		FileObj::DoFileClose(void){	unsigned char	volName[10];		if(!file_is_Open)		return;		FSClose(pathRefNum);	pathRefNum = 0;	volName[0] = (char)0;	FlushVol(volName,theFileInfo.sfFile.vRefNum);	file_is_Open = false;	return;}void		FileObj::DoFileError(void){	DoFileAlert();	DoFileClose();	return;}void		FileObj::DoFileAlert(void){	short	theErr,theID;	unsigned char	emptyString[5];	theErr = -fileError;	if(theErr == 0)		return;	theID = 36;	if(theErr >= 33 && theErr <= 40)		theID = theErr - 32;	if(theErr >= 42 && theErr <= 61)		theID = theErr - 33;	if(theErr >= 120 && theErr <= 123)		theID = theErr - 90;	if(theErr == 108)		theID = 29;	if(theErr == 127)		theID = 33;	if(theErr == 1958)		theID = 34;	if(theErr == 1959)		theID = 35;	GetIndString(pTheText,FILE_MGR_ERRORS,theID);	emptyString[0] = (char)0;	ParamText(pTheText,emptyString,emptyString,emptyString);	theID = StopAlert(FILE_ERROR,(ModalFilterUPP)NUL);	//DoFileClose();	return;}void		FileObj::WriteStructureBlock(void*	theData,long	ptrSize){	long	dataLength;	if(fileError != 0 || !file_is_Open)		return;		dataLength	= ptrSize;	fileError 	= FSWrite(pathRefNum,&dataLength,theData);	if(fileError != 0){		DoFileAlert();	}	return;}void		FileObj::ReadStructureBlock(void*	theData,long	dataLength){		if(fileError != 0 || !file_is_Open)		return;		fileError 	= FSRead(pathRefNum,&dataLength,theData);	if(fileError != 0){		DoFileAlert();	}	return;}	/*  Note: Using apples reccomended method could allow for clipped images...smaller */	/*  Picture utilities in IM VI shows how to make a type 2 PICT File...Color will work */void		FileObj::WritePICT(Ptr owner){	long			theSize,temp;	short			i;	Handle			thePic;	Rect			saveRect,oldRect;	Boolean			flag = false;	Point			thePoint;				if(fileError != 0 || !file_is_Open)		return;	if(!((DiffractObject*)owner)->screenPict){		((DiffractObject*)owner)->SetPict(true);	}	if(gTheSelection->isValid){		saveRect = gTheSelection->theRect;		if((saveRect.right - saveRect.left + saveRect.bottom - saveRect.top) > 40){			oldRect = (*(((DiffractObject*)owner)->screenPict))->picFrame;			(*(((DiffractObject*)owner)->screenPict))->picFrame = saveRect;			flag = true;			thePoint.h = thePoint.v = 0;			gTheSelection->DoSelect(thePoint);		}	}		thePic		= (Handle)((DiffractObject*)owner)->screenPict;	theSize		= sizeof(long);	temp		= 0;	for( i = 1 ; i <= 128 ; i++){		fileError 	= FSWrite(pathRefNum,&theSize,(Ptr)&temp);	}	HLock(thePic);	theSize 	= GetHandleSize(thePic);	fileError 	= FSWrite(pathRefNum,&theSize,*thePic);	HUnlock(thePic);	if(flag){		(*(((DiffractObject*)owner)->screenPict))->picFrame = oldRect;	}}pascal short DefaultDirHook(short item, DialogPtr	theDialog, Ptr theData){	Ptr	dummy;	DialogPtr dumDial;	dummy 		= theData;   // Suppresses a warning	dumDial		=	theDialog; // Suppresses a warning//	if(GetWRefCon(theDialog) != (long)sfMainDialogRefCon){//		return(item);//	}		if(item == sfHookFirstCall){		return sfHookChangeSelection;	}		return item;}/*void		FileObj::WritePICT(Ptr owner){	long			theSize,temp;	short			i;	Handle			thePic;	Rect			saveRect,oldRect;	Boolean			flag = false;	Point			thePoint;	AbsorptionLabel	*line;	Ptr				theText;		if(fileError != 0 || !file_is_Open)		return;	line	= (AbsorptionLabel*)D_new(AbsorptionLabel);	line	->	DoInit();	theText = line->GetTextualInfo(&theSize);	fileError 	= FSWrite(pathRefNum,&theSize,theText);	KillPtr(theText);	line	->DoClose();}*/PicHandle		FileObj::ReadPICT(void){	long			theSize;	Handle			picHandle;		if(!file_is_Open)		return (PicHandle)NUL;		fileError = GetEOF(pathRefNum,&theSize); 	if(theSize <= 512)		fileError = -39;	if(fileError != 0){		DoFileError();		return (PicHandle)NUL;	}		fileError = SetFPos(pathRefNum,fsFromStart,512); 	if(fileError != 0){		DoFileError();		return (PicHandle)NUL;	}		theSize -= 512;	picHandle = (Handle)D_NewHandle(theSize);		fileError = FSRead(pathRefNum,&theSize,*picHandle);	if(fileError != 0){		DoFileError();		return (PicHandle)NUL;	}	DoFileClose();	return((PicHandle)picHandle);}		/******************************************Apple reccomended way********		void		FileObj::WritePICT(Ptr owner){	long			theSize,temp;	short			i;	QDProcs			theProcs,*oldQDProcs;	Picture			thePicture;	PicHandle		currentPic;	DiffractObject* theObj;		if(fileError != 0 || !file_is_Open)		return;		theObj				= (DiffractObject*)owner;	oldQDProcs 			= ((GrafPtr)(theObj->theWindow))->grafProcs;	currentPic			= theObj->screenPict;		SetStdProcs(&theProcs);	theProcs.putPicProc = (QDPtr)SavePICTData;	((GrafPtr)(theObj->theWindow))->grafProcs = &theProcs;			theObj->screenPict	= (PicHandle)NUL;			thePicture.picFrame = (*currentPic)->picFrame;	theFileRefNum 		= pathRefNum;	thePictureSize		= sizeof(Picture);				theSize		= sizeof(long);	temp		= 0;	for( i = 1 ; i <= 128 ; i++){		fileError 	= FSWrite(pathRefNum,&theSize,(Ptr)&temp);	}		theSize 			= sizeof(Picture);	fileError 			= FSWrite(pathRefNum,&theSize,(Ptr)&thePicture);	theObj->SetPict(false);		while((thePictureSize % 4) != 0){		theSize 		= thePictureSize % 4;		temp			= 0;				fileError 		= FSWrite(pathRefNum,&theSize,(Ptr)&temp);		thePictureSize	+= theSize;	}			thePicture.picSize 	= (short)(thePictureSize & 0x0000FFFF);	fileError 			= SetFPos(pathRefNum,fsFromStart,512);	theSize 			= sizeof(Picture);	fileError 			= FSWrite(pathRefNum,&theSize,(Ptr)&thePicture);		((GrafPtr)(theObj->theWindow))->grafProcs = oldQDProcs;		if(theObj->screenPict != NUL){		KillPicture(theObj->screenPict);	}		theObj->screenPict	= currentPic;	return;} pascal void SavePICTData(Ptr theData, short length) { 	long	byteCount; 	OSErr	fileError; 	short	dummy; 	 	byteCount 		= (long)length; 	thePictureSize	+= byteCount; 	fileError = FSWrite(theFileRefNum,&byteCount,theData);	if((thePictureSize % 2) != 0){		dummy 		= 0;		byteCount 	= 1;		fileError 	= FSWrite(theFileRefNum,&byteCount,(Ptr)&dummy);		thePictureSize++;	}}*/void FileObj::WriteMatrix(double matrix[3][3]){	short i,j;	for(i = 0; i < 3; i++){		for(j = 0;j < 3;j++){			gTheFile		->WriteFloat(matrix[i][j]);		}	}}void FileObj::ReadMatrix(double matrix[3][3]){	short i,j;	for(i = 0; i < 3; i++){		for(j = 0;j < 3;j++){			matrix[i][j] = gTheFile		->ReadFloat();		}	}}void FileObj::WriteVector(Vector vector){	gTheFile		->WriteFloat(vector.x);	gTheFile		->WriteFloat(vector.y);	gTheFile		->WriteFloat(vector.z);}void FileObj::ReadVector(Vector *vector){	vector->x = gTheFile		->ReadFloat();	vector->y = gTheFile		->ReadFloat();	vector->z = gTheFile		->ReadFloat();}void FileObj::WriteAxis(Axis vector){	gTheFile		->WriteFloat(vector.x);	gTheFile		->WriteFloat(vector.y);	gTheFile		->WriteFloat(vector.z);}void FileObj::ReadAxis(Axis *vector){	vector->x = gTheFile		->ReadFloat();	vector->y = gTheFile		->ReadFloat();	vector->z = gTheFile		->ReadFloat();}void FileObj::ReadRect(Rect* theRect){	theRect->left = gTheFile		->ReadShort();	theRect->right = gTheFile		->ReadShort();	theRect->top = gTheFile		->ReadShort();	theRect->bottom = gTheFile		->ReadShort();}void FileObj::WriteRect(Rect theRect){	 gTheFile		->WriteShort(theRect.left);	 gTheFile		->WriteShort(theRect.right);	 gTheFile		->WriteShort(theRect.top);	 gTheFile		->WriteShort(theRect.bottom);}Boolean  FileObj::CreateNewFile(OSType	fileType,char *theText){		if(file_is_Open){		fileError = -1958;		DoFileError();		return false;	}	fileError = 0;	strcpy((char*)theFileInfo.sfFile.name,theText);	c2pstr((char*)theFileInfo.sfFile.name);	if(gAppleEvtsOK){		theFileInfo.sfGood			= true;		theFileInfo.sfType			= fileType;		theFileInfo.sfScript		= smSystemScript;		theFileInfo.sfIsFolder		= true;		fileError = SetSearchVol(fileType/*'DifO'*//*fileType*/,&theFileInfo.sfFile);				strncpy((char*)theFileInfo.sfFile.name,theText,31);		c2pstr((char*)theFileInfo.sfFile.name);				theFileInfo.sfFile.vRefNum 	= -LMGetSFSaveDisk();		theFileInfo.sfFile.parID 	= LMGetCurDirStore();			fileError = FSpCreate(&theFileInfo.sfFile,OWNER,fileType,theFileInfo.sfScript);		if(fileError != 0){			//DoFileError();			return false;		}				fileError = FSpOpenDF(&theFileInfo.sfFile,fsRdWrPerm,&pathRefNum);			} else {		fileError = Create(theFileInfo.sfFile.name,theFileInfo.sfFile.vRefNum,OWNER,fileType);		if(fileError != 0){			//DoFileError();			return false;		}		fileError = FSOpen(theFileInfo.sfFile.name,theFileInfo.sfFile.vRefNum,&pathRefNum);	}	if(fileError != 0){		DoFileError();		return false;	}	file_is_Open = true;	return true;}