#include		"Diffract_INCs.h"//s.Jim:Event/Memory:EV_ProcessEvent.c#ifdef NETWORK_VERSION	#include	"MsgObject.h"	extern 	ComBlock*	theComBlock;	extern 	long		  	lastVerify;#endifvoid		DispatchCursor(Point,RgnHandle);void		AdjustCursor(RgnHandle);long		MenuSelectList(long);long		DoNew(short);void		CSwitchboard()#define		MouseMovedEvt		0xFA	/* Mouse moved event code			*/#define		SuspendResumeEvt	0x01	/* Suspend/Resume event code		*/#define		ResumeEvtMask		0x1	/* Supend or Resume selector		*/#define		ConvertScrapMask	0x2	/* Scrap conversion flag			*/{	char				theKey;	WindowPtr			theWindow;	DiffractObject		*thisObject;	short				size;	long				result,value;			/* Make sure our cursor shape and mouse region are set properly	*/		/* before calling WaitNextEvent. We don't want to be stuck with	*/		/* the wrong cursor shape if a minor switch occurs (i.e., a		*/		/* background process get some cpu time). We also set the		*/		/* cursor shape before handling an event. This ensures that the	*/		/* the shape is correct even if the user performs some rapid	*/		/* mouse movement and clicking.									*/	OSEventAvail(NOTHING, &gTheEvent);				/* This returns a NULL event */	DispatchCursor(gTheEvent.where,gMouseRgn);	//g_ThreadObj->YieldToThreads(0L);/* update any thread action*/	if(WaitNextEvent(everyEvent, &gTheEvent,gWaitTime, gMouseRgn)){			DispatchCursor(gTheEvent.where, gMouseRgn);		if(gCurrentObj->linking == 2)gCurrentObj->DynamicLinking();				switch(gTheEvent.what){										/** USER ACTIONS **/						case mouseDown:				DoMouseDown(&gTheEvent);				gDebugVar = 2;				break;							case mouseUp:								break;							case keyDown:				if(gTheEvent.modifiers & shiftKey){					gShifted = true;				} else {					gShifted = false;				}				theKey = (char)(gTheEvent.message & charCodeMask);				if(gTheEvent.modifiers & cmdKey){					if((gTheEvent.message & 0xFFFF0000) == 0x789A0000){						gCurrentObj->DoMenu(gTheEvent.message);					} else if(theKey == 'n'){						value = (long)((long)FILE_MENU << 16) + 1;						result = MenuSelectList(value);					} else {						result = MenuKey(theKey);					}					if(!SystemEdit(LoWord(result) - 1)){						gCurrentObj->DoMenu(result);						}				} else {					if(gTheEvent.modifiers & optionKey){						switch(theKey){							case 'Á':								gTheEvent.message = (gTheEvent.message & 0xff00) + 218;								break;							case 'ª':								gTheEvent.message = (gTheEvent.message & 0xff00) + 219;								break;							case '£':								gTheEvent.message = (gTheEvent.message & 0xff00) + 220;								break;							case '¢':								gTheEvent.message = (gTheEvent.message & 0xff00) + 221;								break;							case '°':								gTheEvent.message = (gTheEvent.message & 0xff00) + 222;								break;							case '¤':								gTheEvent.message = (gTheEvent.message & 0xff00) + 223;								break;							case '¦':								gTheEvent.message = (gTheEvent.message & 0xff00) + 224;								break;							case '¥':								gTheEvent.message = (gTheEvent.message & 0xff00) + 245;								break;							case '»':								gTheEvent.message = (gTheEvent.message & 0xff00) + 225;								break;							default:								break;						}						theKey = (char)(gTheEvent.message & charCodeMask);					}					gCurrentObj->DoKey(theKey);				}				break;						case keyUp:								case autoKey:							/*	DoKeyEvent(&gTheEvent); */				break;							case diskEvt:							/*	DoDiskEvent(&gTheEvent);	*/				break;												/** WINDOW MANAGER EVENTS **/							case updateEvt:		/* Update all window contents			*/							size = (*((*(GetGDevice()))->gdPMap))->pixelSize;				theWindow = (WindowPtr)gTheEvent.message;				thisObject = (DiffractObject*)(((WindowPeek)theWindow)->refCon);				if(size != gLastPixelSize){					gLastPixelSize = size;					if(IsValidObj(thisObject))						thisObject->SetObjectDrawTransferMode();					else{						gDefault->SetObjectDrawTransferMode();					}				}								if(IsValidObj(thisObject)){					thisObject->refreshFlag = true;					//if(thisObject->refreshFlag)						thisObject->DoRefresh();				}									if(gCurrentObj->theWindow != (WindowPtr)NUL){					SetPort(gCurrentObj->theWindow);				}				FlushEvents(everyEvent,0);				break;							case activateEvt:					if (gTheEvent.modifiers & activeFlag)					DoActivate();				else					DoDeactivate();				break;						case app2Evt:				switch(gTheEvent.message){/*					case 0:#ifdef NETWORK_VERSION						lastVerify = TickCount();#endif						break;*/					case 1:						SysBeep(30);						break;					case  1957:					case  -1957:					#ifndef _DEMOVERS_						gQuitFlag = true;						SysBeep(30);						SysBeep(30);						SysBeep(30);						SysBeep(30);						SysBeep(30);					#endif						break;					default:						break;				}				break;						case	kHighLevelEvent:			{				OSErr	theError;				if(gAppleEvtsOK){					theError = AEProcessAppleEvent(&gTheEvent);				}				break;			}							break;												/** MULTIFINDER EVENTS **/			case app4Evt:													/* Event type is stored in the		*/										/*   high byte of the event message	*/										/*   Typecast to unsigned long so	*/										/*   we won't get sign extension	*/										/*   when the bits are shifted		*/				switch ((unsigned long)gTheEvent.message >> 24) {									case MouseMovedEvt:										/* Since we adjust the cursor shape	*/										/*   before handling an event, we	*/										/*   can just idle here				*/						SystemTask();						break;											case SuspendResumeEvt:						if(gTheEvent.message & ResumeEvtMask)							DoResume();						else							DoSuspend();						break;				}				break;							default:					/* Some other event					*/			/*	DoOtherEvent(&gTheEvent);	*/				break;		}	} else {							/* No action required				*/		SystemTask();	}		gCurrentObj->DoIdle();}void	DispatchCursor(Point where,RgnHandle gMouseRgn)					/* Mouse location in Global coords	*/			/* Region containing the mouse		*/{	WindowPtr			theWindow;				short					thePart;				Rect					mbarRect;	ControlHandle		theControl;	DiffractObject*	ownerObj;		if (gInBackground) {				/* Do nothing if we are not the		*/		return;							/*   foreground process				*/	}		thePart = FindWindow(where, &theWindow);		if ( (thePart == inContent) || (thePart == inGrow) ) {			if(theWindow == FrontWindow()) {	/* Window containing the mouse is active	*/								GlobalToLocal(&where);				ownerObj = (DiffractObject*)(((WindowPeek)theWindow)->refCon);								if(FindControl(where,theWindow,&theControl)){					SetCursor(&qd.arrow);				} else if(thePart == inGrow){					SetCursor(&qd.arrow);					//ownerObj->newPictReq = true;				} else if(ownerObj->variSize && where.v <= ownerObj->rulerHeight){					SetCursor(&qd.arrow);				} else {					ownerObj->RestoreTheCursor();				}				/*I wonder about this*/				//gMouseRgn = ((WindowPeek)theWindow)->contRgn;				CopyRgn(((WindowPeek)theWindow)->contRgn,gMouseRgn);				return;								}					} else if (thePart == inMenuBar) {		SetCursor(&qd.arrow);		mbarRect = qd.screenBits.bounds;		mbarRect.bottom = mbarRect.top + GetMBarHeight();		RectRgn(gMouseRgn, &mbarRect);		return;								}					AdjustCursor(gMouseRgn);		}	void	AdjustCursor(RgnHandle gMouseRgn)				/* Mouse location in global coords	*/				/* Region containing the mouse		*/{		SetCursor(&qd.arrow);		if (gTopWindow != NULL) {											/* A Window is active*/		DiffRgn(GetGrayRgn(),((WindowPeek)gTopWindow)->contRgn,gMouseRgn);	} else {																	/* There's no active window*/		CopyRgn(GetGrayRgn(),gMouseRgn);	}}void	DoResume(void){	gWaitTime = 2;	gInBackground = false;	DoActivate();	if(gTopWindow != (WindowPtr)NUL)		HiliteWindow(gTopWindow,true);	return;}	void	DoSuspend(void){	gWaitTime = 20;	gInBackground = true;	DoDeactivate();	if(gTopWindow != (WindowPtr)NUL)		HiliteWindow(gTopWindow,false);	return;}long	MenuSelectList(long	theMenuInfo){	MenuHandle	theMenu;	short		theItem;	short		theCmd;		theMenu = GetMHandle(HiWord(theMenuInfo));	theItem = LoWord(theMenuInfo);		GetItemCmd(theMenu,theItem,&theCmd);	if(theCmd != (char)0x1B){		return(theMenuInfo);	}		GetItemMark(theMenu,theItem,&theCmd);	return(MenuSelectList(DoNew((short)theCmd)));}	long	DoNew(short	menuID){	ListHandle		theList;	Rect				rView,dataBounds,windowBounds;	Cell				theCell;	MenuHandle		theMenu;	short				i,total,width,textHeight,theSelect,menuMap[50];	FontInfo 		theFont;	Point				cellSize,thePoint;	DialogPtr		theDialog;	Boolean			quitFlag = false;	long				retValue;	short				numOfItems;	GrafPtr			oldPort;		/*dec 1992  eric i have implemented a longer technique to deterine menu widts*/	TextFont(0);	TextSize(0);	GetFontInfo(&theFont);		textHeight 	= theFont.ascent + theFont.descent + theFont.leading;	GetPort(&oldPort);	width 		= 	0;	gTheText[0] = 	0;	theMenu 		= 	(MenuHandle)GetMHandle(menuID);	if(theMenu == 0L) return 0L;	numOfItems = CountMItems(theMenu);	for(i = 1,total = width = 0 ; i <=  numOfItems; i++){		short j;		GetItem(theMenu,i,pTheText);		j = StringWidth(pTheText);		if(j > width) width = j;		if(gTheText[1] != '-')			menuMap[total++] = i;	}	/*width = (*theMenu)->menuWidth;*/	cellSize.h		= width + 6;	cellSize.v		= textHeight + 4;	rView.top		= 0;	rView.left 		= 0;	rView.right		= cellSize.h;	rView.bottom	= cellSize.v * total;	SetRect			(&dataBounds,0,0,1,total);	OffsetRect		(&rView,0,2);	windowBounds 			= rView;	windowBounds.right	+= 74;		gTheText[0] 	= (char)0;	theDialog		= DM_GetNewDialog(703,NUL,IN_FRONT);		MoveWindow			(theDialog,33,20,true);	SizeWindow			(theDialog,windowBounds.right,windowBounds.bottom,true);		GetDItem				(theDialog,3,&gType,&gTheHandle,&gTheRect);	SetDItem				(theDialog,3,gType,gTheHandle,&rView);		GetDItem				(theDialog,1,&gType,&gTheHandle,&gTheRect);	width 		= 		gTheRect.right - gTheRect.left; 	gTheRect.left 	= 	rView.right + 9;	gTheRect.right = 	gTheRect.left + width;	SetDItem				(theDialog,1,gType,gTheHandle,&gTheRect);	MoveControl			((ControlHandle)gTheHandle,rView.right + 9,gTheRect.top);	HiliteControl		((ControlHandle)gTheHandle,255);	GetDItem				(theDialog,2,&gType,&gTheHandle,&gTheRect);	width 			= 	gTheRect.right - gTheRect.left; 	gTheRect.left 	= 	rView.right + 9;	gTheRect.right = 	gTheRect.left + width;		SetDItem				(theDialog,2,gType,gTheHandle,&gTheRect);	MoveControl			((ControlHandle)gTheHandle,rView.right + 9,gTheRect.top);			width 		= 		rView.right + 1;	MoveTo				(width,0);	LineTo				(width,theDialog->portRect.bottom);	width 		+= 	2;	MoveTo				(width,0);	LineTo				(width,theDialog->portRect.bottom);			theList 		= 		LNew(&rView,&dataBounds,cellSize,0,theDialog,true,false,false,false);	LDoDraw				(true,theList);	(*theList)->selFlags = lOnlyOne;		theCell.h	 = theCell.v = 0;		for(i = 1 ; i <= CountMItems(theMenu) ; i++){		GetItem		(theMenu,i,pTheText);		if(gTheText[1] != '-'){			width 	= 	(short)gTheText[0];			LSetCell		(&(gTheText[1]),(short)(gTheText[0]),theCell,theList);			theCell.v++;		}	}	retValue = NUL;	while(!quitFlag){		ModalDialog(SmallFilterUPP,&theSelect);		switch(theSelect){			case DLOG_ENTER_OR_CR:			case 1:				quitFlag = true;				break;						case 2:				quitFlag = true;				retValue = NUL;				break;			case 3:				thePoint 	= 	gTheEvent.where;				GlobalToLocal	(&thePoint);				quitFlag 	= 	LClick(thePoint,gTheEvent.modifiers,theList);				theCell 		= 	LLastClick(theList);				retValue 	= 	((long)menuID) << 16;				retValue 	|= menuMap[theCell.v];				GetDItem			(theDialog,1,&gType,&gTheHandle,&gTheRect);				HiliteControl	((ControlHandle)gTheHandle,0);				break;			default:				break;		}	}	LDispose			(theList);	DM_DisposDialog	(&theDialog);	HiliteMenu(0);		gCurrentObj->DoRefresh();		return(retValue);}	