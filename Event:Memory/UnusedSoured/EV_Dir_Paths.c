 #include	"Diffract_INCs.h"//s.Jim:Event/Memory:EV_Dir_Paths.c#include	"Dir_Paths.h"#include	<Aliases.h>void pStrcat		(unsigned char* s1,unsigned char* s2);void pStrcpy		(unsigned char* s1,unsigned char* s2);void SetPathNameBox	(DialogPtr theDialog,FSSpec theFSSpec);pascal	short	TheDialogHook(short item,DialogPtr theDialog,Ptr dataPtr);pascal	void 	TheActivateProc(DialogPtr theDialog,short item,Boolean activate,Ptr dataPtr);void SetDirPaths(void){	FSSpec 						theFileSpecs[NUM_FSS_RECS],theFSSpec;	DialogPtr					theDialog;	short							i,j,theSelect,err,type,**theName,sNum;	Boolean						quit = false;	GrafPtr						theOldWindow;	StandardFileReply	theFileReply;	unsigned char		**theUserName;	Point						where;	AliasHandle			theAliases[NUM_FSS_RECS];	Boolean					changed,validFlags[NUM_FSS_RECS];	Rect						theRect;	Handle					theHandle;	DlgHookYDUPP		TheDialogHookUPP;	ActivateYDUPP		TheActivateProcUPP;	char					 *theNewName;	PopUpMenu*			popUpMenu;		if(!gAppleEvtsOK)		return;		TheDialogHookUPP	= NewDlgHookYDProc(TheDialogHook);	TheActivateProcUPP	= NewActivateYDProc(TheActivateProc);	where.h = where.v = -1;	theDialog = DM_GetNewDialog(720,NUL,IN_FRONT);		popUpMenu = (PopUpMenu*)D_new(PopUpMenu);	popUpMenu->Init( theDialog, 4,37,1);		for(i = 0,j = ALIAS_BASE ; i < NUM_FSS_RECS ; i++,j++){		validFlags[i]				= true;		theFileSpecs[i].vRefNum 	= 0;		theFileSpecs[i].parID		= NUL;		theFileSpecs[i].name[0]		= (char)0;		theAliases[i] = (AliasHandle)GetResource('DATA',j);		HNoPurge((Handle)theAliases[i]);		if(ResError() != 0 || theAliases[i] == NUL){			err = NewAlias(NUL,&theFileSpecs[i],&theAliases[i]);			AddResource((Handle)theAliases[i],'DATA',j,"\pSearch Path Alias");			if(ResError() != noErr){				DisposHandle((Handle)theAliases[i]);				return;			}			WriteResource((Handle)theAliases[i]);		} else {			err = ResolveAlias(NUL,theAliases[i],&theFileSpecs[i],&changed);			if(err == usrCanceledErr){				validFlags[i] = false;			} else if(changed){				ChangedResource((Handle)theAliases[i]);				WriteResource((Handle)theAliases[i]);			}		}	}	SetPathNameBox(theDialog,theFileSpecs[0]);		theUserName = (unsigned char**)GetResource('DATA',128);	if((Handle)theUserName == NUL || ResError() != 0){		theUserName = (unsigned char**)NewHandle(256L * sizeof(char));		theName = (short**)GetResource('ERIC',500);				sNum 		=  **theName ^ 0x7F29;		for(i = 1 ; i <= 100 ; i++){			(*theName)[i] ^= sNum;		}		theNewName		= &(((char*)(*theName))[2]);		p2cstr				((unsigned char*)theNewName);		D_HLock				(theUserName);		strcpy				((char*)*theUserName,theNewName);		c2pstr				((char*)*theUserName);		D_HUnlock			(theUserName);		ReleaseResource		((Handle)theName);		AddResource			((Handle)theUserName,'DATA',128,"\pUser Name");		WriteResource		((Handle)theUserName);	}			GetDItem(theDialog,6,&type,&theHandle,&theRect);	D_HLock(theUserName);	SetIText(theHandle,*theUserName);	D_HUnlock(theUserName);	ReleaseResource((Handle)theUserName);		while(!quit){		ModalDialog((ModalFilterUPP)NUL,&theSelect);		switch(theSelect){			case DLOG_ENTER_OR_CR:				for(i = 0 ; i < NUM_FSS_RECS ; i++){					if(validFlags[i]){						err = UpdateAlias(NUL,&theFileSpecs[i],theAliases[i],&changed);						if(!err /*changed*/){							ChangedResource((Handle)theAliases[i]);							err = ResError();							if(!err)							WriteResource((Handle)theAliases[i]);						}					}					HPurge((Handle)theAliases[i]);					ReleaseResource((Handle)theAliases[i]);									}				theUserName 	= (unsigned char**)GetResource('DATA',128);				GetDItem			(theDialog,6,&type,&theHandle,&theRect);				D_HLock				(theUserName);				GetIText			(theHandle,*theUserName);				D_HUnlock			(theUserName);				ChangedResource		((Handle)theUserName);				WriteResource		((Handle)theUserName);				ReleaseResource		((Handle)theUserName);				UpdateResFile		(CurResFile());				quit = true;				break;			case 2:				for(i = 0 ; i < NUM_FSS_RECS ; i++){					HPurge((Handle)theAliases[i]);					ReleaseResource((Handle)theAliases[i]);									}				quit = true;				break;						case 3:				theFSSpec = theFileSpecs[popUpMenu->lastResult - 1];				err 	= FSpDelete (&theFSSpec);				//CustomPutFile("\pSelect a default directory.","\pDM_DirPath",&theFileReply,721,where,TheDialogHookUPP,NUL,NUL,TheActivateProcUPP,NUL);				SFTypeList theList;				theList[0] = 'xxxx';				StandardGetFile(0L,0,theList,&theFileReply);				SetPort(theDialog);				/*if(theFileReply.sfGood){					validFlags[popUpMenu->lastResult - 1] = true;					err 	= FSpDelete (&theFSSpec);					err 	= FSMakeFSSpec(theFileReply.sfFile.vRefNum,theFileReply.sfFile.parID,"\pDM_DirPath",&theFSSpec);					if(err == -43){						err = FSpCreate (&theFSSpec,'DtM1','aDir',theFileReply.sfScript);					}									} else {					err = FSpCreate (&theFSSpec,'DtM1','aDir',theFileReply.sfScript);				}*/				theFSSpec = theFileReply.sfFile;//theFSSpec;				//theFSSpec.name[0] = (char)0;				SetPathNameBox(theDialog,theFSSpec);				theFileSpecs[popUpMenu->lastResult - 1] = theFSSpec;				popUpMenu->SetPopUp();				break;			case 4: 				theSelect = popUpMenu->DoPopUp();				theFSSpec = theFileSpecs[popUpMenu->lastResult - 1];				theFSSpec.name[0] = (char)0;				SetPathNameBox(theDialog,theFSSpec);				break;						}	}	popUpMenu->DoClose();	DM_DisposDialog(theDialog);}	void SetPathNameBox(DialogPtr theDialog,FSSpec theFSSpec){		TextFont(geneva);	TextSize(10);	PathNameFromFSSpec(theFSSpec,pTheText);	GetDItem(theDialog,5,&gType,&gTheHandle,&gTheRect);	SetIText(gTheHandle,pTheText);	TextFont(0);	TextSize(0);}	void pStrcat(unsigned char* s1,unsigned char* s2){	char*	s3;	p2cstr(s1);	p2cstr(s2);	s3 = strcat((char*)s1,(char*)s2);	c2pstr((char*)s1);	c2pstr((char*)s2);}void pStrcpy(unsigned char* s1,unsigned char* s2){	char*	s3;	p2cstr(s1);	p2cstr(s2);	s3 = strcpy((char*)s1,(char*)s2);	c2pstr((char*)s1);	c2pstr((char*)s2);}short GetDirPath(short dirID,FSSpec*	dir){	Handle		theHandle;	AliasHandle	theAlias;	short		err;	Boolean		wasChanged;		if(!gAppleEvtsOK)		return -1;		theHandle 	= GetResource('DATA',ALIAS_BASE + dirID);	theAlias 	= (AliasHandle)theHandle;	err			= ResolveAlias(NUL,theAlias,dir,&wasChanged);		if(err == 0){		if(wasChanged){			ChangedResource(theHandle);			WriteResource(theHandle);		}	}	ReleaseResource(theHandle);	return(err);}short	OpenNamedFile(short dirID,char* theFileName,short*	vRefNum,short* fRefNum){	FSSpec			theFileSpec;	short			fileError;		if(!gAppleEvtsOK){		char 	fullName[256];		Handle	theHandle;				theHandle = GetResource('ERIC',501);		if(theHandle == 0 || ResError() == resNotFound){			theHandle = NewHandle(10);			**((short**)theHandle) = 0;			UseResFile(LMGetCurApRefNum());			AddResource(theHandle, 'ERIC', 501, "\pSys 6 support");			WriteResource(theHandle);		}				*vRefNum = **((short**)theHandle);		strcpy(fullName,theFileName);		c2pstr(fullName);		fileError = HOpen (*vRefNum, 0, (unsigned char*)fullName, fsRdPerm, fRefNum);	/*	if(fileError != noErr){			Point		where;			SFTypeList	theList;			SFReply		reply;						strcpy(gTheText,"Where is ");			strcat(gTheText,theFileName);			strcat(gTheText,"?");			c2pstr(gTheText);			ParamText("\pEDD files not found.",pTheText,"\p","\p");			theID = StopAlert(FILE_ERROR,(ModalFilterUPP)NUL);						where.h = where.v = 50;						theList[0] = 'TEXT';						SFGetFile (where, NUL, NUL, 1, theList, NUL, &reply);			theHandle = GetResource('ERIC',501);			if(!reply.good){				ReleaseResource(theHandle);				return(fnfErr);			}			**((short**)theHandle) = reply.vRefNum;			ChangedResource(theHandle);			WriteResource(theHandle);			ReleaseResource(theHandle);			*vRefNum = reply.vRefNum;			fileError = HOpen (*vRefNum, 0, (unsigned char*)fullName, fsRdPerm, fRefNum);		}*/		ReleaseResource(theHandle);	} else {		Boolean		gHaveAUX = false;		fileError 			= GetDirPath(dirID,&theFileSpec); 	/* Gets FSSpec for dir */		/*theFileSpec.parID 	= GetDirIDFromFSSpec(theFileSpec);*/ 	/* Gets Dir ID num from FSSpec */		if(fileError != 0)			return(fileError);	/*	p2cstr(theFileSpec.name);			strcat((char*)theFileSpec.name,theFileName);					c2pstr((char*)theFileSpec.name);*/		if (gHaveAUX) {				if (theFileSpec.name[1] != '/')					/* If this isn't root (i.e. '/'), append a slash ('/') */					pStrcat(theFileSpec.name,"\p/");		} else {			/* Append a Macintosh style colon (':') */			PathNameFromFSSpec(theFileSpec,pTheText);			pStrcat(pTheText,"\p:");			c2pstr(theFileName);			pStrcat(pTheText,(unsigned char*)theFileName);		}		*vRefNum = theFileSpec.vRefNum;							/* Returns vref num */			/*fileError 	= FSpOpenDF(&theFileSpec,fsRdPerm,fRefNum);*/		fileError 	= FSOpen(pTheText,*vRefNum,fRefNum);	}		return fileError;}short	OpenNamedFileEM(short dirID,char* theFileName,short*	vRefNum,short* fRefNum){	short fileError;	fileError = OpenNamedFile( dirID,theFileName,vRefNum,fRefNum);	if(fileError){		FileErrorMessages_DirPath( fileError);			}	return fileError;}void	FileErrorMessages_DirPath(short fileError){	short	theID;	unsigned char*	message;	switch(fileError){			case noErr:				break;			case nsvErr:				message = "\pSpecified search volume was not found.";				break;			case fnfErr:				message = "\pSearch File was not found.";				break;			case volOffLinErr:				message = "\pSpecified search volume is off line.";				break;			default:				sprintf(gTheText,"File error %5d on open",fileError);				c2pstr(gTheText);				message = pTheText;				break;		}	ParamText(message,"\pSearch path (File Menu) may be incorrect.","\p","\p");	theID = StopAlert(FILE_ERROR,(ModalFilterUPP)NUL);	return;}void	StandardPutFileToPath(short dirPath,Str255 prompt,Str255 defaultName,StandardFileReply *reply){	short	err;	err = GetDirPath(dirPath,&reply->sfFile);	LMSetSFSaveDisk((short)(-1 * reply->sfFile.vRefNum));	LMSetCurDirStore((long)reply->sfFile.parID);	StandardPutFile(prompt,defaultName,reply);}	 void PathNameFromFSSpec(FSSpec theFSSpec,unsigned char* namePtr){	CInfoPBRec	block;	Str255		directoryName;	short 		err;	Boolean		gHaveAUX = false;	*namePtr = 0;	block.dirInfo.ioNamePtr = directoryName;	block.dirInfo.ioDrParID = theFSSpec.parID;	err = 0;	do {		block.dirInfo.ioVRefNum = theFSSpec.vRefNum;		block.dirInfo.ioFDirIndex = -1;		block.dirInfo.ioDrDirID = block.dirInfo.ioDrParID;		err = PBGetCatInfo(&block,false);		if(err == 0){			if (gHaveAUX) {				if (directoryName[1] != '/')					/* If this isn't root (i.e. '/'), append a slash ('/') */					pStrcat(directoryName,"\p/");			} else {				/* Append a Macintosh style colon (':') */				pStrcat(directoryName,"\p:");				pStrcat(directoryName,namePtr);				pStrcpy(namePtr,directoryName);			}		}	} while (block.dirInfo.ioDrDirID != fsRtDirID && err == 0);	pStrcat(namePtr,theFSSpec.name);	return;}short	SetSearchVol(OSType fileType){	FSSpec	theFSSpec;	short	err;		switch(fileType){		case 'UnC2':			err = GetDirPath(SEARCH_DMCRYSTALS,&theFSSpec);			break;		case 'DifO':		case 'PICT':			err = GetDirPath(SEARCH_DOCS,&theFSSpec);			break;		case 'Phas':			err = GetDirPath(SEARCH_PHASED,&theFSSpec);			break;		default:			return(-1);			break;	}	if(err == noErr){		LMSetSFSaveDisk((short)(-1 * theFSSpec.vRefNum));		LMSetCurDirStore((long)theFSSpec.parID);	}	return(err);}long	GetDirIDFromFSSpec(FSSpec	theFSSpec){	CInfoPBRec	theInfoRec;	short		err;	if(!gAppleEvtsOK){		AlertUser(3);		return 0L;	}	theInfoRec.dirInfo.ioNamePtr 	= theFSSpec.name;	theInfoRec.dirInfo.ioVRefNum	= theFSSpec.vRefNum;	theInfoRec.dirInfo.ioCompletion	= NUL;	theInfoRec.dirInfo.ioDrDirID 	= theFSSpec.parID;	theInfoRec.dirInfo.ioFDirIndex 	= NUL;		err = PBGetCatInfo(&theInfoRec,false);		return(theInfoRec.dirInfo.ioDrDirID);}pascal	short	TheDialogHook(short item,DialogPtr theDialog,Ptr dataPtr){	Ptr				dummyPtr;			dummyPtr = dataPtr;		/* This line prevents a warning */		switch(item){		case sfItemNewFolderUser:			SysBeep(30);			return(sfHookNullEvent);			break;					case sfHookNullEvent:						return(sfHookNullEvent);			break;		case 13:			return (1);			break;		default:			return(item);			break;	}}	void	InitDirPaths(void){	FSSpec 				theFileSpecs[NUM_FSS_RECS];	short				i,j,err,iFileRef,iErr;	AliasHandle			theAliases[NUM_FSS_RECS];	Boolean				validFlags[NUM_FSS_RECS],changed;	FCBPBRec			pb;	unsigned char		theName[256];		if(!gAppleEvtsOK)		return;			gTheHandle 		= GetResource('ERIC',500);	pb.ioRefNum 	= HomeResFile (gTheHandle);	err 			= GetVRefNum (pb.ioRefNum, &pb.ioVRefNum);	pb.ioFCBIndx	= 0;	pb.ioNamePtr	= theName;	iErr 			= PBGetFCBInfo (&pb,false);		ReleaseResource(gTheHandle);			for(i = 0,j = ALIAS_BASE ; i < NUM_FSS_RECS ; i++,j++){		gTheHandle = GetResource('DATA',j);		iFileRef = HomeResFile (gTheHandle);		RmveResource (gTheHandle);		DisposHandle(gTheHandle);	}	UpdateResFile (iFileRef);		for(i = 0,j = ALIAS_BASE ; i < NUM_FSS_RECS ; i++,j++){		validFlags[i]				= true;		theFileSpecs[i].vRefNum 	= pb.ioVRefNum;		theFileSpecs[i].parID		= pb.ioFCBParID;		theFileSpecs[i].name[0]		= (char)0;		theAliases[i] = (AliasHandle)GetResource('DATA',j);		if(ResError() != 0 || theAliases[i] == NUL){			err = NewAlias(NUL,&theFileSpecs[i],&theAliases[i]);			AddResource((Handle)theAliases[i],'DATA',j,"\pSearch Path Alias");			if(ResError() != noErr){				DisposHandle((Handle)theAliases[i]);				return;			}			WriteResource((Handle)theAliases[i]);		} else {			err = ResolveAlias(NUL,theAliases[i],&theFileSpecs[i],&changed);			if(err == usrCanceledErr){				validFlags[i] = false;			} else if(changed){				ChangedResource((Handle)theAliases[i]);				WriteResource((Handle)theAliases[i]);			}		}	}}			pascal	void TheActivateProc(DialogPtr theDialog,short item,Boolean activate,Ptr dataPtr){	DialogPtr	dummyDlog;	Boolean		dummyactivate;	Ptr			dummyPtr;		dummyDlog		= theDialog;	/* these three lines prevent warnings */	dummyactivate	= activate;	dummyPtr		= dataPtr;				if(item == 1){		SysBeep(20);	}}