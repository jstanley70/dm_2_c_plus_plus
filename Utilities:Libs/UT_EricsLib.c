#include	"Diffract_INCs.h"//ects:D.M. v2.0:Sources.Jim:Utilities/Libs:UT_EricsLib.c#include 	"EricsLib.h"MenuHandle	DM_GetMenu(short	menuResID){	MenuHandle	theHandle;	short	error;	SetResLoad(false);	theHandle = (MenuHandle)GetResource('MENU',menuResID);	error = ResError();	SetResLoad(true);	if(theHandle == (MenuHandle)NUL || error != 0 || (long)(*theHandle) == NUL){		theHandle = GetMenu(menuResID);			}	DetachResource((Handle)theHandle);	return(theHandle);}Boolean		Do_Break(void){	KeyMap	keyArray;	GetKeys(keyArray);	if(keyArray[1] == 0x00808000){		return(true);	}	return (false);}PicHandle	OpenTempMemPicture(Rect	*theRect){	PicHandle	tempHandle;	long		size;	 	size					= sizeof(Rect) + 20;	tempHandle				= (PicHandle)/*Temp*/D_NewHandle(size);//,&gTheOSError	(*tempHandle)->picSize	= size;	(*tempHandle)->picFrame	= *theRect;	return(tempHandle);}	pascal Boolean SmallFilter(DialogPtr theDLog,EventRecord* theEvent,short* theItem){	char			theKeyValue;	unsigned long			time;	OSErr			theError;	Boolean			doneByStd;	WindowPtr 		theWindow;	ModalFilterUPP	theStdFilterProc;		gTheEvent	= *theEvent;	*theItem	= 0;	if(gAppleEvtsOK){		theError	= GetStdFilterProc(&theStdFilterProc);		doneByStd 	= CallModalFilterProc(theStdFilterProc,theDLog,theEvent,theItem);	} else {		doneByStd = false;	}		switch(gTheEvent.what){		case keyDown:			if(doneByStd){				return true;				break;			}			theKeyValue = theEvent->message &  charCodeMask;			if(theKeyValue == (char)13){				GetDItem(theDLog,1,&gType,&gTheHandle,&gTheRect);				if((*((ControlHandle)gTheHandle))->contrlHilite == 0){					*theItem = 1;					HiliteControl((ControlHandle)gTheHandle,1);					Delay(8L,&time);					HiliteControl((ControlHandle)gTheHandle,0);					return true;				}			}			if(theEvent->modifiers & optionKey){				switch(theKeyValue){					case 'Á':						theEvent->message = (theEvent->message & 0xff00) + 218;						break;					case 'ª':						theEvent->message = (theEvent->message & 0xff00) + 219;						break;					case '£':						theEvent->message = (theEvent->message & 0xff00) + 220;						break;					case '¢':						theEvent->message = (theEvent->message & 0xff00) + 221;						break;					case '°':						theEvent->message = (theEvent->message & 0xff00) + 222;						break;					case '¤':						theEvent->message = (theEvent->message & 0xff00) + 223;						break;					case '¦':						theEvent->message = (theEvent->message & 0xff00) + 224;						break;					case '¥':						theEvent->message = (theEvent->message & 0xff00) + 245;						break;					case '»':						theEvent->message = (theEvent->message & 0xff00) + 225;						break;					default:						break;				}				return false;				break;			}			break;				case mouseDown:														/* if event was a mousedown 	*/			switch (FindWindow(theEvent->where,&theWindow)){				/* find out where it occured */				case inGoAway:												/* if in the go away box 	 */					if(TrackGoAway(theWindow,theEvent->where)){				/* And mouse up still in it  */						*theItem = -1;										/* set Go away flag			 */						return (true);										/* return true to bypass     */					}															/* ModalDialog               */					break;				deafult:					break;			}	}	return(false);}void HiliteOK(DialogPtr theDialog){	if(gAppleEvtsOK){		OSErr	theError;		theError =  SetDialogDefaultItem(theDialog,1);		theError =  SetDialogCancelItem(theDialog,2);		theError =  SetDialogTracksCursor(theDialog,true);	} else {		short 	type;		Handle 	theHandle;		Rect 	theRect;		GrafPtr	thePort;				((DialogPeek)theDialog)->aDefItem = 1;				GetPort(&thePort);		SetPort(theDialog);				GetDItem(theDialog,1,&type,&theHandle,&theRect);				InsetRect(&theRect,-4,-4);		PenSize(3,3);		FrameRoundRect(&theRect,12,12);		PenNormal();				SetPort(thePort);	}}Boolean	MemoryIsOK(Ptr  thePtr){	if(MemError() != 0 || thePtr == (Ptr)NUL){		StopAlert(OUT_OF_MEM,NUL);		return(false);	}	return(true);}Boolean	HandleIsOK(Handle  theHandle){	if(MemError() != 0 || theHandle == (Handle)NUL){		StopAlert(OUT_OF_MEM,NUL);		return(false);	}	return(true);}Boolean	PtrIsOK(Ptr  thePtr){	if(MemError() != 0 || thePtr == (Ptr)NUL){		StopAlert(OUT_OF_MEM,NUL);		return(false);	}	return(true);}enum{	THE_MESSAGE_DATA = 3,		RES_NAME,		RES_NUM,		PROMPT	};void	AddMessage(short	messageNum){	Boolean 	quit = false;	DialogPtr	theDialog;	short		type,theSelect,resNum;	long		length;	GrafPtr		thePort;	Rect		theRect;	Handle		newMessage;		if(messageNum >= LAST_MESSAGE)		return;		GetPort(&thePort);	theDialog = GetNewDialog(NEW_MESSAGE,NUL,IN_FRONT);	SetPort(theDialog);		sprintf(gTheText,(char*)"\pMessage #%4d is undefined...Add it?",messageNum);	GetDItem(theDialog,PROMPT,&type,&gTheHandle,&theRect);	SetIText(gTheHandle,pTheText);		resNum = messageNum;	sprintf(gTheText,"%4d",resNum);	c2pstr(gTheText);	GetDItem(theDialog,RES_NUM,&type,&gTheHandle,&theRect);	SetIText(gTheHandle,pTheText);		while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;			case DLOG_OK:				GetDItem(theDialog,THE_MESSAGE_DATA,&type,&gTheHandle,&theRect);				GetIText(gTheHandle,pTheText);				length = (unsigned long)gTheText[0] + 1;				if(PtrToHand((Ptr)gTheText,&newMessage,length) == noErr){					GetDItem(theDialog,RES_NAME,&type,&gTheHandle,&theRect);					GetIText(gTheHandle,pTheText);					AddResource(newMessage,'STR ',resNum,pTheText);					WriteResource(newMessage);					ReleaseResource(newMessage);				}				quit = true;				break;			case DLOG_CANCEL:				quit = true;				break;			default:				break;		}	}		SetPort(thePort);	DisposDialog(theDialog);}void	CheckMessages(){	if(DEVELOPER){			short i;		Handle theHandle;							for(i = FIRST_MESSAGE + 1 ; i < LAST_MESSAGE ; i++){			theHandle = GetResource('STR ',i);			if(theHandle == (Handle)NUL || ResError() != noErr){				AddMessage(i);			} else {				ReleaseResource(theHandle);			}		}	}}							void	Message(short	messageNum){	Boolean 	quit = false;	DialogPtr	theDialog;	short		type,theSelect;	GrafPtr		thePort;	Rect		theRect;	Handle		theMessage;		if(messageNum >= LAST_MESSAGE || messageNum <= FIRST_MESSAGE)		return;				theMessage = GetResource('STR ',messageNum);	if(theMessage == (Handle)NUL || ResError() != noErr){		NoteAlert(MSG_NOT_FOUND,NUL);		return;	}		GetPort(&thePort);	theDialog = GetNewDialog(MESSAGE,NUL,IN_FRONT);	SetPort(theDialog);	GetDItem(theDialog,2,&type,&gTheHandle,&theRect);	D_HLock(theMessage);	SetIText(gTheHandle,(unsigned char*)(*theMessage));	D_HUnlock(theMessage);	ReleaseResource(theMessage);		theSelect = 0;		while(theSelect != 1){		ModalDialog((ModalFilterUPP)NUL,&theSelect);	}		SetPort(thePort);	DisposDialog(theDialog);}		Boolean		Question(short	messageNum){	Boolean 	quit = false,retVal;	DialogPtr	theDialog;	short		type,theSelect;	GrafPtr		theOldPort;	Rect		theRect;	Handle		theMessage;		if(messageNum >= LAST_MESSAGE || messageNum <= FIRST_MESSAGE)		return(false);				theMessage = GetResource('STR ',messageNum);	if(theMessage == (Handle)NUL || ResError() != noErr){		NoteAlert(MSG_NOT_FOUND,NUL);		return(false);	}		GetPort(&theOldPort);	theDialog = GetNewDialog(QUESTION,NUL,IN_FRONT);	SetPort(theDialog);	HiliteOK(theDialog);	GetDItem(theDialog,2,&type,&gTheHandle,&theRect);	SetCTitle((ControlHandle)gTheHandle,"\pNo");	GetDItem(theDialog,3,&type,&gTheHandle,&theRect);	D_HLock(theMessage);	SetIText(gTheHandle,(unsigned char*)(*theMessage));	D_HUnlock(theMessage);	ReleaseResource(theMessage);		theSelect = 0;		while(!quit){		ModalDialog((ModalFilterUPP)NUL,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;			case DLOG_OK:				retVal = quit = true;				break;			case DLOG_CANCEL:				retVal = false;				quit = true;				break;		}	}	SetPort(theOldPort);	InvalRect(&(theDialog->portRect));	DisposDialog(theDialog);	return(retVal);}Boolean		TooManyBeams(short	beams){	Boolean 		quit = false,retVal;	DialogPtr	theDialog;	short			theSelect;	GrafPtr		theOldPort;	double		value;			GetPort(&theOldPort);	theDialog = GetNewDialog(666,NUL,IN_FRONT);	SetPort(theDialog);	HiliteOK(theDialog);	value = beams;	SetItemValue(theDialog,3,value,0);	theSelect = 0;	if(beams < 150){		sprintf(gTheText,"Although, this should work.It is going to take awhile. You might want to take a nap.cmd-. will get you out of calc.");		c2pstr(gTheText);		SetItemText(theDialog,5,pTheText);	} 	while(!quit){		ModalDialog((ModalFilterUPP)NUL,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;			case DLOG_OK:				retVal = quit = true;				break;			case DLOG_CANCEL:				retVal = false;				quit = true;				break;		}	}	SetPort(theOldPort);	InvalRect(&(theDialog->portRect));	DisposDialog(theDialog);	return(retVal);}	/*pascal	Boolean	TheFileFilter(fileParam*	theParamBlckPtr){	if(theParamBlckPtr->ioFlFndrInfo.fdCreator != OWNER)		return true;			switch(theParamBlckPtr->ioFlFndrInfo.fdType){		case DIF_OBJ:			return false;			break;		default:			return true;			break;	}}*/		Boolean		Ask(char*	theQuestion){	char	localString[256];		strcpy(localString,theQuestion);	c2pstr(localString);	ParamText((unsigned char*)localString,"\p","\p","\p");	if(CautionAlert(ASK_QUESTION,NUL) == 1)		return true;	return false;	}void		Tell(short	alertType,char*	theStatement){	c2pstr(strcpy(gTheText,theStatement));	ParamText(pTheText,(char)0,(char)0,(char)0);	switch(alertType){		case	STOP_ALERT:			gType =  StopAlert(705,(ModalFilterUPP)NUL);			break;		case	NOTE_ALERT:			gType =  NoteAlert(705,(ModalFilterUPP)NUL);			break;		case	CAUTION_ALERT:			gType =  CautionAlert(705,(ModalFilterUPP)NUL);			break;		default:			gType =	 Alert(705,(ModalFilterUPP)NUL);			break;	}}	void	PostTheEvent(void){	EvQEl*	theEntry;	PostEvent(app1Evt,17L);		theEntry = (EvQEl*)GetEvQHdr();		while(theEntry->qLink != (QElemPtr)NUL){		if(((EvQEl*)theEntry)->evtQWhat == app1Evt){			((EvQEl*)theEntry)->evtQWhen = TickCount() + 3;			return;		}		theEntry = (EvQEl*)theEntry->qLink;	}}	void	DoDebug(short count){		Rect	theRect;	char	theText[120];	GrafPtr	thePort;	unsigned long	time;	GetPort(&thePort);	theRect.top = 40;	theRect.bottom = 80;	theRect.right = thePort->portRect.right;	theRect.left = theRect.right - 100;	sprintf(theText,"%4d",count++);	c2pstr(theText);	dm_EraseRect(&theRect);	MoveTo(theRect.left+5,70);	DrawString((unsigned char*)theText);	SystemTask();	Delay(60,&time);}	void	FlagUser(void)  /*** Cough -- No Text  ***/{	DisplayMessage(0,0,500);	if(gD_Handle_Debug_Flag)		SysBreak();}	void	AlertUser(short stringResId)  /*** Uh Oh ***/{	DisplayMessage(1004,stringResId,502);	if(gD_Handle_Debug_Flag)		SysBreak();}	void	WarnUser(short stringResId)  /*** Clint ***/{	DisplayMessage(1005,stringResId,501);	if(gD_Handle_Debug_Flag)		SysBreak();}void	ResetRect(Rect*	theRect,short h,short v){	Rect aRect;	h -= theRect->left;	v -= theRect->top;	OffsetRect(theRect,h,v);	if(!SectRect(theRect,&(gCurrentObj->theWindow->portRect),&aRect)) {		OffsetRect(theRect,-theRect->left,-theRect->top);		OffsetRect(theRect,((gCurrentObj->theWindow->portRect).left + (gCurrentObj->theWindow->portRect).right) * .5,			((gCurrentObj->theWindow->portRect).top + (gCurrentObj->theWindow->portRect).bottom) * .5);	}}void	DisplayMessage(short	strNumResID,short	strIndex,short	sndResID){	CursHandle arrow;	StopWatch();		if(gInBackground){		short	error;		gWaitTime = 60;		//InitCursor		arrow	= GetCursor(0);		SetCursor(*arrow);		ReleaseResource((Handle)arrow);		while(gInBackground){			if(!gNotificationFlag){				gNotificationFlag = true;				gNotificationReq.nmMark			= 1;				gNotificationReq.nmIcon			= GetResource('SICN',300);				gNotificationReq.qType			= nmType;				HNoPurge(gNotificationReq.nmIcon);				if(sndResID == 0){					gNotificationReq.nmSound	= NUL;				} else {					gNotificationReq.nmSound	= GetResource('snd ',sndResID);					HNoPurge(gNotificationReq.nmSound);				}				if(strIndex <= 0 || strNumResID <= 0){					gNotificationReq.nmStr		= (StringPtr)NUL;				} else {					GetIndString(pTheText,strNumResID,strIndex);					gNotificationReq.nmStr		= (StringPtr)gTheText;				}				gNotificationReq.nmResp		= /*(NMUPP)*/NUL;				gNotificationReq.nmRefCon	= NUL;				error = NMInstall(&gNotificationReq);				if(error != 0){					gNotificationFlag = false;				}			}			MiniSwitchboard();		}		gWaitTime = 1;	} else if(!gInBackground){		SndChannelPtr	myChan = 0L;		Handle			mySound;		OSErr			err;		char			theText[40];				gNotificationFlag = false;				if(sndResID != 500){			mySound = GetResource('snd ',sndResID);			err		= SndNewChannel(&myChan,0,0,NUL);			HLock(mySound);		//	err		= SndPlay(myChan,mySound,false);/* Problem Jan 1995*/			err		= SndDisposeChannel(myChan,false);						strcpy(theText,g_Routine);			c2pstr(theText);			GetIndString(pTheText,strNumResID,strIndex);			ParamText(pTheText,(unsigned char*)theText,"\p","\p");			switch(sndResID){				case 501:						err 	= StopAlert(709,(ModalFilterUPP)NUL);						break;				case 502:						err 	= CautionAlert(709,(ModalFilterUPP)NUL);						break;				default:						err 	= NoteAlert(709,(ModalFilterUPP)NUL);						break;			}						HUnlock(mySound);			ReleaseResource(mySound);		}				}	if(gNotificationFlag){		if(NMRemove(&gNotificationReq) == 0){			gNotificationFlag = false;			HPurge(gNotificationReq.nmIcon);			ReleaseResource(gNotificationReq.nmIcon);			if(gNotificationReq.nmSound != NUL){				HPurge(gNotificationReq.nmSound);				ReleaseResource(gNotificationReq.nmSound);			}		}	}	//GetKeys(keyArray);	//if(keyArray[1] == 5){	//	gD_Handle_Debug_Flag = true;	//}}		