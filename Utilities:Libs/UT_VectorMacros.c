//ects:D.M. v2.0:Sources.Jim:Utilities/Libs:UT_VectorMacros.c#define	IDENTITY_MATRIX(theMatrix)					\{													\	theMatrix[0][0] = theMatrix[1][1] = theMatrix[2][2] = 1.0;	\	theMatrix[0][1] = theMatrix[0][2] = 0.0;				\	theMatrix[1][0] = theMatrix[1][2] = 0.0;				\	theMatrix[2][0] = theMatrix[2][1] = 0.0;				\}													\#define MATRIX_MULTIPLY(A,B,C)									\{																\	register double b0_M,b1_M,b2_M,a0_M,a1_M;					\	double	D_M[3][3];											\															\	a0_M = A[0][0];												\	a1_M = A[1][0];												\	b0_M = B[0][0];												\	b1_M = B[0][1];												\	b2_M = B[0][2];												\															\	D_M[0][0] = a0_M * b0_M + a1_M * b1_M + A[2][0] * b2_M;		\	D_M[0][1] = A[0][1] * b0_M + A[1][1] * b1_M + A[2][1] * b2_M;	\	D_M[0][2] = A[0][2] * b0_M + A[1][2] * b1_M + A[2][2] * b2_M;	\															\	b0_M = B[1][0];												\	b1_M = B[1][1];												\	b2_M = B[1][2];												\	D_M[1][0] = a0_M * b0_M + a1_M * b1_M + A[2][0] * b2_M;		\	D_M[1][1] = A[0][1] * b0_M + A[1][1] * b1_M + A[2][1] * b2_M;	\	D_M[1][2] = A[0][2] * b0_M + A[1][2] * b1_M + A[2][2] * b2_M;	\															\	b0_M = B[2][0];												\	b1_M = B[2][1];												\	b2_M = B[2][2];												\	D_M[2][0] = a0_M * b0_M + a1_M * b1_M + A[2][0] * b2_M;		\	D_M[2][1] = A[0][1] * b0_M + A[1][1] * b1_M + A[2][1] * b2_M;	\	D_M[2][2] = A[0][2] * b0_M + A[1][2] * b1_M + A[2][2] * b2_M;	\															\	C[0][0] = D_M[0][0];										\	C[0][1] = D_M[0][1];										\	C[0][2] = D_M[0][2];										\	C[1][0] = D_M[1][0];										\	C[1][1] = D_M[1][1];										\	C[1][2] = D_M[1][2];										\	C[2][0] = D_M[2][0];										\	C[2][1] = D_M[2][1];										\	C[2][2] = D_M[2][2];										\}																\#define	TRANSFORM_VECTOR(a,b,c,xForm)								\{																	\	register double	x_M,y_M,z_M;									\	x_M = a;														\	y_M = b;														\	z_M = c;														\	a = x_M * xForm[0][0] + y_M * xForm[0][1] + z_M * xForm[0][2];	\	b = x_M * xForm[1][0] + y_M * xForm[1][1] + z_M * xForm[1][2];	\	c = x_M * xForm[2][0] + y_M * xForm[2][1] + z_M * xForm[2][2];	\}																	\#define FIND_CENTER_XFORM(x,y,z,xForm)							\{																\	double	A_M[3][3],B_M[3][3],C_M[3][3];						\	double	r_M;												\	double	Z_FABS,Y_FABS,X_FABS;								\	NORMALIZE_VECTOR(x,y,z);									\	r_M	= sqrt(x * x + y * y);									\	Z_FABS = fabs(z);											\	Y_FABS = fabs(y);											\	X_FABS = fabs(x);											\	if(r_M < .0000000001){										\		if(Z_FABS < .0000000001)								\			xForm[0][0] = xForm[1][1] = xForm[2][2] = 1.0;		\		else{													\			 xForm[1][1] = 1.0;									\			xForm[0][0] = xForm[2][2] = z/Z_FABS;				\		}														\		xForm[0][1] = xForm[0][2] = 0.0;						\		xForm[1][0] = xForm[1][2] = 0.0;						\		xForm[2][0] = xForm[2][1] = 0.0;						\	} else {													\		A_M[0][0] = A_M[1][1] = x / r_M;						\		A_M[0][1] = y / r_M;									\		A_M[1][0] = -y / r_M;									\		A_M[2][2] = 1.;											\		A_M[0][2] = A_M[1][2] = A_M[2][0] = A_M[2][1] = 0.0;	\		B_M[0][0] = B_M[2][2] = z;								\		B_M[0][2] = -r_M;										\		B_M[2][0] = r_M;										\		B_M[1][1] = 1;											\		B_M[0][1] = B_M[1][0] = B_M[1][2] = B_M[2][1] = 0.0;	\		MATRIX_MULTIPLY(A_M,B_M,C_M);							\		A_M[0][1] = -y / r_M;									\		A_M[1][0] = y / r_M;									\		MATRIX_MULTIPLY(C_M,A_M,xForm);							\	}															\}																\#define FIND_HORIZ_XFORM(x,y,xForm)					\{														\	register double r_M;											\												\	r_M 		= sqrt(x * x + y * y);					\												\	if(r_M == 0.){										\		xForm[0][0] = xForm[1][1] = xForm[2][2] = 1.0;	\		xForm[0][1] = xForm[0][2] = 0.0;				\		xForm[1][0] = xForm[1][2] = 0.0;				\		xForm[2][0] = xForm[2][1] = 0.0;				\		return;											\	}													\	xForm[0][2] = xForm[1][2] = xForm[2][1] = xForm[2][0] = 0.0;	\	xForm[0][0] = xForm[1][1] = y / r_M;				\	xForm[0][1] = -x / r_M;								\	xForm[1][0] = -xForm[0][1];							\	xForm[2][2] = 1.0;									\}														\#define FIND_VERT_XFORM(x,y,xForm)						\{														\	register double r_M;											\													\	r_M	=	sqrt(x * x + y * y);						\											\	if(r_M == 0.){										\		xForm[0][0] = xForm[1][1] = xForm[2][2] = 1.0;	\		xForm[0][1] = xForm[0][2] = 0.0;				\		xForm[1][0] = xForm[1][2] = 0.0;				\		xForm[2][0] = xForm[2][1] = 0.0;				\		return;											\	}													\	xForm[0][2] = xForm[1][2] = xForm[2][1] = xForm[2][0] = 0.0;	\	xForm[0][0] = xForm[1][1] = -x / r_M;				\	xForm[0][1] = -y / r_M;								\	xForm[1][0] = -xForm[0][1];							\	xForm[2][2] = 1.0;									\}														\#define INVERT_MATRIX(theMatrix)		\{										\	register double x_M;				\								\	x_M = theMatrix[0][1];				\	theMatrix[0][1] = theMatrix[1][0];	\	theMatrix[1][0] = x_M;				\								\	x_M = theMatrix[0][2];				\	theMatrix[0][2] = theMatrix[2][0];	\	theMatrix[2][0] = x_M;				\								\	x_M = theMatrix[1][2];				\	theMatrix[1][2] = theMatrix[2][1];	\	theMatrix[2][1] = x_M;				\}										\#define NORMALIZE_VECTOR(x,y,z)						\{													\	register double length_M;						\												\	length_M = sqrt( x * x + y * y + z * z);		\	if(length_M < .0000001){						\		length_M = 0.0;								\		x = 0.0;									\		y = 0.0;									\		z = 0.0;									\	} else {										\		length_M = 1.0 / length_M;					\		x *= length_M;								\		y *= length_M;								\		z *= length_M;								\	}												\}													\