#include	"Diffract_INCs.h"#include	"SF_MathLib.h"#include	"JimsLib.h"Boolean IsPressed(unsigned short k){	unsigned char *km;	KeyMap kMap;	GetKeys(kMap);	km = (unsigned char*)kMap;	return ((km[k>>3] >> (k & 7)) & 1);	//58 optionkey	//56 shiftkey	//46 m	//0  a	//1	s	//2	d	//51	delete	//123	arrow	//124	arrow	//125	arrow	//126	arrow}MenuHandle	DMJ_GetMenu(short resID){		MenuHandle theStoredMenu;		MenuHandle theMenu;		short	menuID;				menuID 	= g_MenuNums++;						theStoredMenu 	= 	GetMenu(resID);		DetachResource((Handle)theStoredMenu);		theMenu			=	(MenuHandle)theStoredMenu;		(*theMenu)			->menuID = menuID;/*added for uniqueness*/				return theMenu;		}void	CubicPermutate(short *face_CountPtr,CrystalFace theFace,CrystalFace *theFaces,					Boolean completeFlag,short latticeType){	short x[3],perFace[3],face_Count;	float	length;	short	j,l,m,n,jj,ll,mm;	Boolean flag;	short startH = 0,endH = 2,startK = 0,endK = 2,startL = 0,endL = 2;	switch(latticeType){		case CUBIC:			startH = 0;endH = 2;startK = 0;endK = 2;startL = 0;endL = 2;			break;		case TETRAGONAL:			startH = 0;endH = 1;startK = 0;endK = 1;startL = 2;endL = 2;			break;		case ORTHORHOMBIC:		case MONOCLINIC:		case TRICLINIC:			startH = 0;endH = 0;startK = 0;endK = 1;startL = 2;endL = 2;			break;		case TRIGHEX:			startH = 0;endH = 2;startK = 0;endK = 2;startL = 0;endL = 2;			break;		case HEXAGONAL:		case TRIGONAL:			HexagonalPermutate( face_CountPtr, theFace, theFaces, completeFlag); 			return;				}	face_Count = *face_CountPtr;	x[0] = theFace.h;	x[1] = theFace.k;	x[2] = theFace.l;	length = theFace.length;	for(j = startH; j <= endH; j++){		for(l = startK; l <= endK; l++){			if(l == j)				continue;			for(m = startL; m <= endL; m++){				if(m == j || m == l)					continue;				perFace[0] = x[j];				perFace[1] = x[l];				perFace[2] = x[m];				for(jj = 0; jj <= 1; jj++){					for(ll = 0; ll <= 1; ll++){						for(mm = 0; mm <= 1; mm++){							n = 0;							flag = true;							while(flag == true && n <= face_Count){								if(pow(-1,(double)jj) * perFace[0] == theFaces[n].h  && 									pow(-1,(double)ll) * perFace[1] == theFaces[n].k  &&										pow(-1,(double)mm) * perFace[2] == theFaces[n].l 										) 										flag = false;										n++;							}							n = 0;							while(flag == true && !completeFlag && n <= face_Count){								if(pow(-1,(double)jj) * perFace[0] == -theFaces[n].h  && 									pow(-1,(double)ll) * perFace[1] == -theFaces[n].k  &&										pow(-1,(double)mm) * perFace[2] == -theFaces[n].l 										) 										flag = false;										n++;							}							if(flag == true){								face_Count++;								theFaces[face_Count].h = perFace[0] * pow(-1,(double)jj);								theFaces[face_Count].k = perFace[1] * pow(-1,(double)ll);								theFaces[face_Count].l = perFace[2] * pow(-1,(double)mm);								theFaces[face_Count].length = length;								theFaces[face_Count].theCrystal = theFace.theCrystal;								theFaces[face_Count].direction = theFace.direction;								theFaces[face_Count].flags = theFace.flags;								theFaces[face_Count].area = theFace.area;							}						}					}				}							}		}	}	*face_CountPtr = face_Count;}void HexagonalPermutate(short *face_CountPtr,CrystalFace theFace,CrystalFace *theFaces,Boolean completeFlag){	Index *theIndex;	short i,j,m,n,p,H,K,I,L,x[3],a,startL,t,face_Count;	double length;	Boolean placeFlag;	Crystal *theCrystal;		theIndex = (Index*)D_new(Index);	theCrystal = (Crystal*)D_new(Crystal);	theCrystal->InitCrystal(0);	theCrystal->lattice_Type = HEXAGONAL;	theIndex->DoInit(theFace.direction,theCrystal);	theIndex->h = theFace.h;	theIndex->k = theFace.k;	theIndex->l = theFace.l;		placeFlag = g_Hex_Four;	g_Hex_Four = true;	theIndex->IndexToHex(&H,&K,&I,&L);	face_Count = *face_CountPtr;	x[0] = H;	x[1] = K;	x[2] = I;	a = L;	length = theFace.length;	if(completeFlag == true)		startL = -1;	else		startL = 1;	for(j = startL; j <= 1; j+= 2){		L = j * a;		for(i = startL; i <= 1; i += 2){			for(m = 0; m <= 2; m++){				for(n = 0; n <= 2;n++){					if(m == n)						continue;					H = i * x[m];					K = i * x[n];					t = -H - K;										theIndex->IndexFromHex( H, K, t, L);					for(p = 0; p <= face_Count; p++)					{						if(theFaces[p].h == theIndex->h &&							theFaces[p].k == theIndex->k &&							theFaces[p].l == theIndex->l)							goto  NEXT;					}					face_Count++;					theFaces[face_Count].h = theIndex->h;					theFaces[face_Count].k = theIndex->k;					theFaces[face_Count].l = theIndex->l;					theFaces[face_Count].length = length;					theFaces[face_Count].theCrystal = theFace.theCrystal;					theFaces[face_Count].direction = theFace.direction;					theFaces[face_Count].flags = theFace.flags;					theFaces[face_Count].area = theFace.area;					NEXT:;				}			}		}	}	*face_CountPtr = face_Count;	g_Hex_Four = placeFlag;	theIndex->DoClose();	theCrystal->DoClose();}void ConverttoReciprocal(double crystalvector[][3],double volume,Boolean leftHanded){	double crystalvector1[3],crystalvector2[3],crystalvector3[3],A,					vector0[3],vector1[3],vector2[3];		vector0[0] = crystalvector[0][0];	vector0[1] = crystalvector[0][1];	vector0[2] = crystalvector[0][2];	vector1[0] = crystalvector[1][0];	vector1[1] = crystalvector[1][1];	vector1[2] = crystalvector[1][2];	vector2[0] = crystalvector[2][0];	vector2[1] = crystalvector[2][1];	vector2[2] = crystalvector[2][2];		crossprod(vector1,vector2,crystalvector1);	crossprod(vector2,vector0,crystalvector2);		if(leftHanded){		crossprod(vector1,vector0,crystalvector3);//change	}else{		crossprod(vector0,vector1,crystalvector3);//change	}	A = 1. /  volume;	crystalvector[0][0] = crystalvector1[0] * A ;	crystalvector[0][1] = crystalvector1[1] * A ;	crystalvector[0][2] = crystalvector1[2] * A ;	crystalvector[1][0] = crystalvector2[0] * A ;	crystalvector[1][1] = crystalvector2[1] * A ;	crystalvector[1][2] = crystalvector2[2] * A ;	crystalvector[2][0] = crystalvector3[0] * A ;	crystalvector[2][1] = crystalvector3[1] * A ;	crystalvector[2][2] = crystalvector3[2] * A ;	return;}void Hold(short zval)			{	short itemType;	Handle itemHndl;	Rect testRect;	DialogPtr theDlog;	char *text;	text = (char*)D_NewPtr(255 * (long)sizeof(char));	sprintf(text,"%d",zval);	c2pstr(text);	theDlog = GetNewDialog(999,NUL,IN_FRONT);	GetDItem(theDlog,1,&itemType,&itemHndl,&testRect);	SetIText(itemHndl,(unsigned char*)text);	while (!Button())			/* while button not being pushed */		;	while(Button())					/* wait for button up */		;	DisposDialog(theDlog);	KillPtr((Ptr)text);} 	void HoldLong(long zval)			{	short 			itemType;	Handle 			itemHndl;	Rect 			testRect;	DialogPtr 		theDlog;	char 			*text;		text = (char*)D_NewPtr(255 * (long)sizeof(char));	sprintf(text,"%ld",zval);	c2pstr(text);	theDlog = GetNewDialog(999,NUL,IN_FRONT);	GetDItem(theDlog,1,&itemType,&itemHndl,&testRect);	SetIText(itemHndl,(unsigned char*)text);	while (!Button())			/* while button not being pushed */		;	while(Button())					/* wait for button up */		;	DisposDialog(theDlog);	KillPtr((Ptr)text);} 				void HoldText(char *zval)			{	short itemType;	Handle itemHndl;	Rect testRect;	DialogPtr theDlog;	theDlog = GetNewDialog(999,NUL,IN_FRONT);	GetDItem(theDlog,1,&itemType,&itemHndl,&testRect);	c2pstr(zval);	SetIText(itemHndl,(unsigned char*)zval);	p2cstr((unsigned char*)zval);	while (!Button())			/* while button not being pushed */		;	while(Button())					/* wait for button up */		;	DisposDialog(theDlog);} 				  	 					void HoldDouble(double zval){	short itemType;	Handle itemHndl;	Rect testRect;	DialogPtr theDlog;	char *text;	text = (char*)D_NewPtr(255 * (long)sizeof(char));	sprintf(text,"%lf",zval);	c2pstr(text);	theDlog = GetNewDialog(999,NUL,IN_FRONT);	GetDItem(theDlog,1,&itemType,&itemHndl,&testRect);	SetIText(itemHndl,(unsigned char*)text);	while (!Button())			/* while button not being pushed */		;	while(Button())					/* wait for button up */		;	DisposDialog(theDlog);	KillPtr((Ptr)text);} void HoldMatrix(double matrix[][3])			{	short itemType;	Handle itemHndl;	Rect testRect;	DialogPtr theDlog;	char *text;	text = (char*)D_NewPtr(255 * (long)sizeof(char));	sprintf(text,"%4.2lf %4.2lf %4.2lf \r %4.2lf %4.2lf %4.2lf \r %4.2lf %4.2lf %4.2lf",matrix[0][0],matrix[0][1],matrix[0][2],matrix[1][0],		matrix[1][1],matrix[1][2],matrix[2][0],matrix[2][1],matrix[2][2]);	c2pstr(text);	theDlog = GetNewDialog(999,NUL,IN_FRONT);	GetDItem(theDlog,1,&itemType,&itemHndl,&testRect);	SetIText(itemHndl,(unsigned char*)text);	while (!Button())			/* while button not being pushed */		;	while(Button())					/* wait for button up */		;	DisposDialog(theDlog);	KillPtr((Ptr)text);} Handle SubCalcDSpacings(Crystal *theCrystal,short h,short k,short l,short theBeamFlag,double minSF){	SpotInfo 	*dspace,*thisDspace;	long 		sizeOf;	double 		intensity;	short 		maxH,minH,maxK,minK,maxL,minL,data_Length;	double 		dspaceN;	short 		mNum;	double 		*theUs,*theVs,*theWs,*theZs,*theBs;	double  	dH,dK,dL;	short 		atom_Count;	SpotInfoHandle		theDataBlock;	double		electronMassRation;	Ptr*		theHandle;	double 		sh2 , sk2 , sl2 , skl , shl , shk;	double 		sV0,sV1,sV2,sV3,sV4,sV5,volumeSqr;	dcomplex	cAb;	dcomplex sF;/*Temp*/	theDataBlock = (SpotInfoHandle)D_NewHandle(350L * sizeof(SpotInfo));//,&i/*Temp*/	D_HLock(theDataBlock);			maxH = abs(h);	minH = -maxH;	maxK = abs(k);	minK = -maxK;	maxL = abs(l);	minL = -maxL;	data_Length = 349L;	dspace = *theDataBlock;		if(!SetScatteringPosAIntensity(theCrystal,&theUs,&theVs,&theWs,&theZs,&theBs,&atom_Count)){//Timebomb!!//*atom_Count cannot be the same address as *crystal->Atom_Couynt  or you will continually increase the number			gCount = -1;		return (Handle)theDataBlock;	}	if(theCrystal->lattice_Type == 0)		theCrystal->lattice_Type = CUBIC;	switch(theCrystal->lattice_Type){		case CUBIC:		case TETRAGONAL:		case ORTHORHOMBIC:		case HEXAGONAL:		case TRIGONAL:		case TRIGHEX:			minH = 0;minK = 0;minL = 0;			break;		default:			break;	}	gCount = -1;		sizeOf = sizeof(SpotInfo);	gNoBreak = true;	if(gCurrentObj->energy > 5000)gCurrentObj->energy = 100;	if(gCurrentObj)		electronMassRation =   1. + ( (double)gCurrentObj->energy / 511.);	else		electronMassRation = 1;	theHandle = theCrystal->AtomicScatteringSet(electronMassRation,theBeamFlag);	sV0	= theCrystal->sVals[0];	sV1	= theCrystal->sVals[1];	sV2	= theCrystal->sVals[2];	sV3	= theCrystal->sVals[3];	sV4	= theCrystal->sVals[4];	sV5	= theCrystal->sVals[5];	volumeSqr	= theCrystal->volume * theCrystal->volume;	AtomicScatterForDFromSet(0,theHandle,theZs,atom_Count);	sF	= TotalStructureFactor(0,0,0,theUs,theVs,theWs,atom_Count,theZs,theBs,theCrystal->volume,10000,theCrystal,&cAb);	minSF *= sF.r * sF.r * .01;	for(h = maxH; h >= minH && gNoBreak ; h--){		sh2 = h *  h * sV0;		for(k = maxK ;k >= minK && gNoBreak ;k--){			sk2 = k * k * sV1;			shk = 2 * k * h * sV3;			for(l = maxL ;l >= minL && gNoBreak;l--){								if(l == 0 && k == 0 &&  h == 0)					continue;				//dspaceN = TheDSpacing();								skl = 2 * k * l * sV4;				shl = 2 * h * l * sV5;				sl2 = l  * l * sV2;				dspaceN = sqrt(volumeSqr / (sh2 + sk2 + sl2 + skl + shl + shk));								dH = h;				dK = k;				dL = l;				AtomicScatterForDFromSet(1/dspaceN,theHandle,theZs,atom_Count);				sF	= TotalStructureFactor(dH,dK,dL,theUs,theVs,theWs,atom_Count,theZs,theBs,theCrystal->volume,dspaceN,theCrystal,&cAb);				intensity = (double)Cabs(sF);				if(intensity < minSF)					continue;				thisDspace 				= &(dspace[++gCount]);				thisDspace->x  			= dspaceN;				if(fabs(dspaceN) > 0.0001)				thisDspace->y  			= 1/dspaceN;				else				thisDspace->y = 10000;				thisDspace->z  			= 0;				thisDspace->angle  	= 0;				thisDspace->h 			= h;				thisDspace->k 			= k;				thisDspace->l 			= l;				thisDspace->direction 	= false;				thisDspace->intensity 	= intensity;				thisDspace->theCrystal 	= theCrystal;				thisDspace->sF			=	sF;				thisDspace->flags		=	theCrystal->idNum;				AllowBackground();								if(gCount >= (data_Length - 1)){					Size	theSize;					Boolean	locked;					char	cMemTags;										cMemTags = HGetState((Handle)theDataBlock);					if(MemError() != 0){						D_Debug_Message(19);						return NUL;					}					if((cMemTags & 0x80) != 0){						locked = true;						/*Temp*/D_HUnlock((Handle)theDataBlock);					} else {						locked = false;					}										theSize	=	GetHandleSize((Handle)theDataBlock);					theSize	+=	(sizeof(SpotInfo) * 25L);					SetHandleSize((Handle)theDataBlock,theSize);					if(MemError() != noErr){						WarnUser(1);						gCount -= 5;						gNoBreak = false;						if(gCount < 0)							gCount = 0;						if(locked)							/*MFTemp*/D_HLock((Handle)theDataBlock);					} else {						data_Length	+= 25;						if(locked)							/*MFTemp*/D_HLock((Handle)theDataBlock);						}					dspace = *theDataBlock;				}THESPOT:		intensity = 0;			}		}	}	mNum = (gCount + 1);	/*MFTemp*/D_HUnlock((Handle)theDataBlock);	KillPtr((Ptr)theUs);	theCrystal->ClearAtomicScatSet(theHandle);	theDataBlock = (SpotInfoHandle)EliminateHKLRedundancy(&mNum,(Handle)theDataBlock);	gCount = mNum - 1;		return (Handle)theDataBlock;}Handle EliminateHKLRedundancy(short *data_Count,Handle theDataHandle){	SpotInfoPtr nonRedundantSpots,theSpots;	short j,i;	long data_Count_Value;	Index	*theIndex;		if(*data_Count < 2)return theDataHandle;		data_Count_Value = *data_Count;	/*MFTemp*/D_HLock(theDataHandle);		qsort(*theDataHandle,(long)(data_Count_Value),sizeof(SpotInfo),(_compare_function/*__cmp_func_Cmpfun**/)DspaceCompare);				nonRedundantSpots = (SpotInfoPtr)D_NewPtr((long)data_Count_Value * sizeof(SpotInfo));	theSpots = (SpotInfoPtr)*theDataHandle;	theIndex = (Index*)D_new(Index);	theIndex->DoInit(false,theSpots->theCrystal);	j = 0;	nonRedundantSpots[j] = theSpots[0];	for(i = 1; i < data_Count_Value;i++){		SpotInfo theSpot;		theSpot = theSpots[i];		if((short)(theSpot.intensity * 10) == (short)(10 * nonRedundantSpots[j].intensity)			&& (short)(theSpot.x * 100) == (short)(100 * nonRedundantSpots[j].x)){			theIndex->h = theSpot.h;			theIndex->k = theSpot.k;			theIndex->l = theSpot.l;			if(theIndex->CompareTo(nonRedundantSpots[j].h,nonRedundantSpots[j].k,					nonRedundantSpots[j].l))				continue;		}		j++;		nonRedundantSpots[j] = theSpot;	}	for(i = 0; i <= j;i++)	{		theSpots[i] = nonRedundantSpots[i];	}	data_Count_Value = j+ 1;	KillPtr(nonRedundantSpots);	/*MFTemp*/D_HUnlock(theDataHandle);	if(*data_Count >  data_Count_Value){		D_RecoverMemory		(theDataHandle,sizeof(SpotInfo),(long)data_Count_Value);	}	*data_Count = data_Count_Value;	theIndex->DoClose();	return theDataHandle;}int	InverseDSpaceCompare(const void* spot1,const void* spot2)//short	InverseDSpaceCompare(SpotInfo* spot1,SpotInfo* spot2){	double z1,z2;		z1 = fabs((double)((SpotInfo*)spot1)->x);	z2 = fabs((double)((SpotInfo*)spot2)->x);		return((short)((z1 < z2) ? -1 : ((z1 == z2) ? 0 : 1)));}int	FloatCompare(const void* x,const void* y)//short	FloatCompare(float* x,float* y){	double z1,z2;		z1 = *(float*)x;	z2 = *(float*)y;		return((short)((z1 > z2) ? -1 : ((z1 == z2) ? 0 : 1)));}int	DspaceCompare(const void* spot1,const void* spot2)//short	DspaceCompare(SpotInfo* spot1,SpotInfo* spot2){	double z1,z2;		z1 = fabs((double)((SpotInfo*)spot1)->x);	z2 = fabs((double)((SpotInfo*)spot2)->x);		return((short)((z1 > z2) ? -1 : ((z1 == z2) ? 0 : 1)));}int	JimsStructFactCompare(const void* spot1,const void* spot2)//short	JimsStructFactCompare(SpotInfo* spot1,SpotInfo* spot2){	double z1,z2;		z1 = fabs((double)((SpotInfo*)spot1)->intensity);	z2 = fabs((double)((SpotInfo*)spot2)->intensity);		return((short)((z1 > z2) ? -1 : ((z1 == z2) ? 0 : 1)));}void	SetPopUp(MenuHandle theMenu,Rect theRect,short theItem){	dm_EraseRect(&theRect);	dm_FrameRect(&theRect);	MoveTo(theRect.left + 1,theRect.bottom);	LineTo(theRect.right,theRect.bottom);	LineTo(theRect.right,theRect.top);	MoveTo(theRect.left + 4,theRect.bottom - 2);	GetItem(theMenu,theItem,pTheText);	DrawDiffractString(pTheText);}short SizeofReciprocalLattice(float h,float k,float l,double x,Crystal *aCrystal){	double 	dspacing,testD;	short hklMax;	Index *theIndex;	theIndex = (Index*)D_new(Index);		dspacing = 0.0;	hklMax = 0;	testD = 0.0;		theIndex->h = h;	theIndex->k = k;	theIndex->l = l;	theIndex->direction = false;	theIndex->theCrystal = aCrystal;	dspacing = 1./ theIndex->TheDSpacing();		while( testD < x)	{		hklMax++;		testD += dspacing;	}	D_delete(theIndex);	if(hklMax <= 2)		return 2;	return hklMax;}Boolean CheckHandleSize(Handle theDataHandle,long *data_Length,long data_Count,long sizeOf){	long 	size,freeSize;	long	j,L;	short	error;		if(data_Count < *data_Length) return true;	j 			= 		data_Count - *data_Length;	freeSize 	= 		FreeMem();	D_HUnlock			(theDataHandle);	L			= 		*data_Length * .3;	if(L < 10)L = 10;	size 		= 		GetHandleSize(theDataHandle) + (L * sizeOf) + (j * sizeOf);	SetHandleSize		(theDataHandle,size);	error 		= 		MemError();	if(error == 0 && freeSize > 32000L){		*data_Length += L;	}else{		StopAlert(OUT_OF_MEM,NUL);		D_HLock(theDataHandle);		return false;	}	D_HLock(theDataHandle);	return true;}Boolean CheckPtrSize(Ptr thePointer,short *data_Length,long sizeOf){	long theSize;		*data_Length += 25;	theSize = sizeOf * *data_Length;		if(!D_SetPtrSize(&thePointer,gCount)){		*data_Length -= 25;		return false;	}	return true;}pascal void GetPICTData(Ptr dataPtr,short byteCount){	short theErr;	long longCount;	longCount = byteCount;	theErr = FSRead(globalPicProcRef,&longCount,dataPtr);}double AtomicScatterEl(double dInverse,double atomicNumber){	short **scatterHandle,n;	double ratio,base,interval;	n = sizeof(short);	scatterHandle = (short**)GetResource('Atom',(short)atomicNumber);		dInverse /= 2.;	dInverse	*= 100;	dInverse = Round(dInverse);	dInverse	/= 100;	if(dInverse <= .50){		n = (short)(dInverse / .05);		base = (double)n * .05;		interval = .05;	} else if(dInverse <= 1.0){		n = 5 + (short)(dInverse / .1);		base = .5 + (double)(n - 10) * .1;		interval = .1;	} else if(dInverse <= 2.0){		n = 10 + (short)(dInverse / .2);		base = 1.0 + (double)(n - 15) * .2;		interval = .2;	} else if(dInverse <= 3.0){		n = 16 + (short)(dInverse / .5);		base = 2.0 + (double)(n - 20) * .5;		interval = .5;	} else {		n = 22;		base = 3.;		interval = .5;	}	 ratio = (dInverse - base) / interval;	 	 interval = (double)((*scatterHandle)[n + 1] - (*scatterHandle)[n]) / 100.0;	 base = (double)(*scatterHandle)[n] / 100.;	 base = (double)(base + ratio * interval);	 ReleaseResource((Handle)scatterHandle);	 return base;}/*double AtomicScatterEl(double dInverse,double atomicNumber){	short **scatterHandle,n;	double ratio,base,interval;	n = sizeof(short);	scatterHandle = (short**)GetResource('Atom',(short)atomicNumber);			dInverse *= 50;	dInverse = 	Round(dInverse);	dInverse *= .01;		if(dInverse <= .50){		n = (short)(dInverse * 20);		base = (double)n * .05;		interval = .05;	} else if(dInverse <= 1.0){		n = 5 + (short)(dInverse * 10);		base = .5 + (double)(n - 10) * .1;		interval = .1;	} else if(dInverse <= 2.0){		n = 10 + (short)(dInverse * 5);		base = 1.0 + (double)(n - 15) * .2;		interval = .2;	} else if(dInverse <= 3.0){		n = 16 + (short)(dInverse * 2);		base = 2.0 + (double)(n - 20) * .5;		interval = .5;	} else {		n = 22;		base = 3.;		interval = .5;	}	 ratio = (dInverse - base) / interval;	 	 interval = (double)((*scatterHandle)[n + 1] - (*scatterHandle)[n]) * .01;	 base = (double)(*scatterHandle)[n] * .01;	 base = (double)(base + ratio * interval);	 ReleaseResource((Handle)scatterHandle);	 return base;}*/double AtomicScatterXRay(double dInverse,double atomicNumber){	short **scatterHandle,n;	double ratio,base,interval;	scatterHandle = 0L;	scatterHandle = (short**)GetResource('XrSc',(short)atomicNumber);	if(!scatterHandle)scatterHandle = (short**)GetResource('Atom',(short)atomicNumber);			dInverse /= 2.;		dInverse *= 100;	dInverse = 	Round(dInverse);		dInverse /= 100;		if(dInverse <= .50){		n = (short)(dInverse / .05);		base = (double)n * .05;		interval = .05;	} else if(dInverse <= 1.0){		n = 5 + (short)(dInverse / .1);		base = .5 + (double)(n - 10) * .1;		interval = .1;	} else if(dInverse <= 2.0){		n = 10 + (short)(dInverse / .2);		base = 1.0 + (double)(n - 15) * .2;		interval = .2;	} else if(dInverse <= 3.0){		n = 16 + (short)(dInverse / .5);		base = 2.0 + (double)(n - 20) * .5;		interval = .5;	} else {		n = 22;		base = 3.;		interval = .5;	}	 ratio = (dInverse - base) / interval;	 	 interval = (double)((*scatterHandle)[n + 1] - (*scatterHandle)[n]) / 100.0;	 base = (double)(*scatterHandle)[n] / 100.;	 base = (double)(base + ratio * interval);	  ReleaseResource((Handle)scatterHandle);	 return base;}double AtomicScatterNuetron(double dInverse,double atomicNumber){	short **scatterHandle,n;	double ratio,base,interval;	scatterHandle = 0L;	scatterHandle = (short**)GetResource('NSCT',(short)atomicNumber);	if(!scatterHandle)scatterHandle = (short**)GetResource('Atom',(short)atomicNumber);			dInverse /= 2.;		dInverse *= 100;	dInverse = 	Round(dInverse);		dInverse /= 100;		if(dInverse <= .50){		n = (short)(dInverse / .05);		base = (double)n * .05;		interval = .05;	} else if(dInverse <= 1.0){		n = 5 + (short)(dInverse / .1);		base = .5 + (double)(n - 10) * .1;		interval = .1;	} else if(dInverse <= 2.0){		n = 10 + (short)(dInverse / .2);		base = 1.0 + (double)(n - 15) * .2;		interval = .2;	} else if(dInverse <= 3.0){		n = 16 + (short)(dInverse / .5);		base = 2.0 + (double)(n - 20) * .5;		interval = .5;	} else {		n = 22;		base = 3.;		interval = .5;	}	 ratio = (dInverse - base) / interval;	 	 interval = (double)((*scatterHandle)[n + 1] - (*scatterHandle)[n]) / 100.0;	 base = (double)(*scatterHandle)[n] / 100.;	 base = (double)(base + ratio * interval);	  ReleaseResource((Handle)scatterHandle);	 return base;}double AtomicScatterIon(double dInverse,double atomicNumber){	short **scatterHandle,n;	double ratio,base,interval;	scatterHandle = 0L;	scatterHandle = (short**)GetResource('Atom',(short)atomicNumber);	if(!scatterHandle)scatterHandle = (short**)GetResource('Atom',(short)atomicNumber);		dInverse /= 2.;		dInverse *= 100;	dInverse = 	Round(dInverse);		dInverse /= 100;		if(dInverse <= .50){		n = (short)(dInverse / .05);		base = (double)n * .05;		interval = .05;	} else if(dInverse <= 1.0){		n = 5 + (short)(dInverse / .1);		base = .5 + (double)(n - 10) * .1;		interval = .1;	} else if(dInverse <= 2.0){		n = 10 + (short)(dInverse / .2);		base = 1.0 + (double)(n - 15) * .2;		interval = .2;	} else if(dInverse <= 3.0){		n = 16 + (short)(dInverse / .5);		base = 2.0 + (double)(n - 20) * .5;		interval = .5;	} else {		n = 22;		base = 3.;		interval = .5;	}	 ratio = (dInverse - base) / interval;	 	 interval = (double)((*scatterHandle)[n + 1] - (*scatterHandle)[n]) / 100.0;	 base 		= (double)(*scatterHandle)[n] / 100.;	 base 		= (double)(base + ratio * interval);	 ReleaseResource((Handle)scatterHandle);	 base *= gCurrentObj->theIon->mass / (ELECTRON_MASS * AVOGADROS_NUMBER  * 1000);	 return base;}long	RoundLong(double x){	double i;	double remainder;	long  j;	remainder = modf(x,&i);	if(fabs(remainder) > .5)	{		if(i < 0){				i--;		}else{			if(i > 0){				i++;			}else{				if(remainder < 0){					i--;				}else{					i++;				}			}		}				return i;	}	if(fabs(remainder) == .5){				j = (long)i;		if(j % 2)		{			if(i < 0){				i--;			}else{				if(i > 0){					i++;				}else{					if(remainder < 0){						i--;					}else{						i++;					}				}			}		}	}	return (long)i;}short	Round(double x){	double i;	double remainder;	long  j;	remainder = modf(x,&i);	if(fabs(remainder) > .5)	{		if(i < 0){				i--;		}else{			if(i > 0){				i++;			}else{				if(remainder < 0){					i--;				}else{					i++;				}			}		}		if(i > 32767) {			i = 32767;			return (short)i;		}else if(i < -32767){			i = -32767;			return (short)i;		}		return (short)i;	}	if(fabs(remainder) == .5){		if(i > 32767) {			i = 32767;			return (short)i;		}else if(i < -32767){			i = -32767;			return (short)i;		}		j = (long)i;		if(j % 2)		{			if(i < 0){				i--;			}else{				if(i > 0){					i++;				}else{					if(remainder < 0){						i--;					}else{						i++;					}				}			}		}	}	if(i > 32767) {		i = 32767;		return (short)i;	}else if(i < -32767){		i = -32767;		return (short)i;	}	return (short)i;}unsigned short ConvertToMacBits(unsigned short input){	unsigned short output = 0,i;	unsigned short flag[16] = {0x0100,0x0200,0x0400,0x0800,0x1000,0x2000,0x4000,	0x8000,0x0001,0x0002,0x0004,0x0008,0x0010,0x0020,0x0040,0x0080};	unsigned short macFlag[16] = {0x0001,0x0002,0x0004,0x0008,0x0010,0x0020,0x0040,0x0080,	0x0100,0x0200,0x0400,0x0800,0x1000,0x2000,0x4000,0x8000};		for(i = 0; i <= 15;i++){			if(input & flag[i])output += macFlag[i];	}	return output;}long ipow(long num,long exp){	long k,i;	k = 1;	for(i = 1;i <= exp;i++){		k *= num;	}	return k;}Boolean Quit(void){	if(IsPressed((unsigned short)47)){			return true;	}	return false;}		/*	GenericHandleStoredToResource(Handle theDataBlock,'type',short num,char *theTitle,long sizeOF	{		short 		theResFile;		Handle 		theReshandle,theResHnd;				theResHnd 	= 	GetResource('Atom',1);		theResFile 	= 	HomeResFile(theResHnd);		UseResFile		(theResFile);		ReleaseResource	(theResHnd);				AddResource		((Handle)theDataBlock,'type',num,c2pstr(theTitle));		if(ResError() != noErr){			KillHandle((Handle*)&theDataBlock);			return;		}		WriteResource	((Handle)theDataBlock);				UpdateResFile	(CurResFile());		FlushVol		(0L,0);			KillHandle		(&theDataBlock);			}	{		short 		theResFile;		Handle 		theReshandle,theResHnd;		SpotInfoCrysHandle theDspaceHandle;		SpotInfoCrysPtr dspaceees;		theDspaceHandle = (SpotInfoCrysHandle)D_NewHandle(sizeof(SpotInfoCrys) * (long)MAX_STORE_DSPACE );		theResHnd = GetResource('Atom',1);		theResFile = HomeResFile(theResHnd);		UseResFile(theResFile);		ReleaseResource		(theResHnd);		D_HLock((Handle)theDspaceHandle);		dspaceees = *theDspaceHandle;		sprintf(gTheText,"init dspace values");		for(i = 0; i < MAX_STORE_DSPACE;i++){			dspaceees[i] = dspacings[i];		}		AddResource((Handle)theDspaceHandle,'info',200,c2pstr(gTheText));		D_HUnlock((Handle)theDspaceHandle);		if(ResError() != noErr){			KillHandle((Handle*)&theDspaceHandle);			KillHandle(&theDataBlock);			return;		}				WriteResource((Handle)theDspaceHandle);				UpdateResFile(CurResFile());		FlushVol(0L,0);			KillHandle((Handle*)&theDspaceHandle);			}	*/short patIndex = 1;void	SetMarqueePattern(short *select){	Pattern	thePat;		if(select == NUL){		GetIndPattern (&thePat, 500, patIndex++);		if(patIndex >= 9)			patIndex = 1;	} else {		if(*select < 1 || *select > 8)			*select = 1;		GetIndPattern (&thePat, 500, (*select)++);	}		PenPat(&thePat);	PenMode(patCopy);	return;}void		MoveARect(Rect frameRect,short *moveH,short *moveV){	Point 	oldPoint,thePoint;	short 	delH,delV;	Rect		oldRect;	short 	totalH = 0, totalV = 0;	oldPoint.h = totalH;	oldPoint.v = totalV;	*moveH = 0;	*moveV = 0;	if(!Button()) return ;	gCurrentObj->DoSetOrigin();		GetMouse			(&thePoint);	if(!PtInRect(thePoint,&frameRect))return;	oldRect 	= frameRect;	GetMouse		(&oldPoint);	while(StillDown()){		GetMouse					(&thePoint);		SetMarqueePattern	(NUL);		PenMode						(patXor);		dm_FrameRect					(&frameRect);		Delay							(2,&gLongScratch);		dm_FrameRect					(&frameRect);		if(!PtInRect(thePoint,&gCurrentObj->thePictRect))continue;		if(!EqualPt(oldPoint,thePoint)) {			delH = -oldPoint.h + thePoint.h;			delV = -oldPoint.v + thePoint.v;			OffsetRect		(&frameRect,delH,delV);			totalH 		+= 	delH;			totalV 		+= 	delV;			oldPoint	 = 	thePoint;		}	}	PenNormal();	PenMode(0);	*moveH = totalH;	*moveV = totalV;	return;}void ClearMenu(MenuHandle theMenu){	short i,total;	total = CountMItems(theMenu);	for(i = 1; i <= total;i++)CheckItem(theMenu,i,false);}void		ResizeARect(Rect frameRect,Rect growRect, short *moveH,short *moveV){	Point 	oldPoint,thePoint;	short 	delH,delV;	Rect		oldRect;	short 	totalH = 0, totalV = 0;	oldPoint.h = totalH;	oldPoint.v = totalV;	*moveH = 0;	*moveV = 0;	if(!Button()) return ;	gCurrentObj->DoSetOrigin();		GetMouse			(&thePoint);	if(!PtInRect(thePoint,&frameRect))return;	oldRect 	= frameRect;	GetMouse		(&oldPoint);	while(StillDown()){		GetMouse					(&thePoint);		SetMarqueePattern	(NUL);		PenMode						(patXor);		dm_FrameRect					(&frameRect);		dm_FrameRect					(&growRect);		Delay							(2,&gLongScratch);		dm_FrameRect					(&growRect);		dm_FrameRect					(&frameRect);		if(!PtInRect(thePoint,&gCurrentObj->thePictRect))continue;		if(!EqualPt(oldPoint,thePoint)) {			delH = -oldPoint.h + thePoint.h;			delV = -oldPoint.v + thePoint.v;			OffsetRect		(&frameRect,delH,delV);			growRect.bottom += delV;			growRect.right 	+= delH;			totalH 		+= 	delH;			totalV 		+= 	delV;			oldPoint	 = 	thePoint;		}	}	PenNormal();	PenMode(0);	*moveH = totalH;	*moveV = totalV;	return;}void SetConversionFlags(unsigned short *flag,unsigned short *macFlag){	flag[15] =  0x0080;	flag[14] =  0x0040;	flag[13] =  0x0020;	flag[12] =  0x0010;	flag[11] =  0x0008;	flag[10] =  0x0004;	flag[9] =   0x0002;	flag[8] =   0x0001;	flag[7] =   0x8000;	flag[6] =   0x4000;	flag[5] =   0x2000;	flag[4] =   0x1000;	flag[3] =   0x0800;	flag[2] =   0x0400;	flag[1] =   0x0200;	flag[0] =   0x0100;	macFlag[0] =  0x0001;	macFlag[1] =  0x0002;	macFlag[2] =  0x0004;	macFlag[3] =  0x0008;	macFlag[4] =  0x0010;	macFlag[5] =  0x0020;	macFlag[6] =  0x0040;	macFlag[7] =  0x0080;	macFlag[8] =  0x0100;	macFlag[9] =  0x0200;	macFlag[10] = 0x0400;	macFlag[11] = 0x0800;	macFlag[12] = 0x1000;	macFlag[13] = 0x2000;	macFlag[14] = 0x4000;	macFlag[15] = 0x8000;}void SetConversionFlags2(long int *flag,long int *macFlag){	flag[31] =  0x00000080;	flag[30] =  0x00000040;	flag[29] =  0x00000020;	flag[28] =  0x00000010;	flag[27] =  0x00000008;	flag[26] =  0x00000004;	flag[25] =   0x00000002;	flag[24] =   0x00000001;	flag[23] =   0x00008000;	flag[22] =   0x00004000;	flag[21] =   0x00002000;	flag[20] =   0x00001000;	flag[19] =   0x00000800;	flag[18] =   0x00000400;	flag[17] =   0x00000200;	flag[16] =   0x00000100;	flag[15] =  0x00800000;	flag[14] =  0x00400000;	flag[13] =  0x00200000;	flag[12] =  0x00100000;	flag[11] =  0x00080000;	flag[10] =  0x00040000;	flag[9] =   0x00020000;	flag[8] =   0x00010000;	flag[7] =   0x80000000;	flag[6] =   0x40000000;	flag[5] =   0x20000000;	flag[4] =   0x10000000;	flag[3] =   0x08000000;	flag[2] =   0x04000000;	flag[1] =   0x02000000;	flag[0] =   0x01000000;		macFlag[0] =  0x00000001;	macFlag[1] =  0x00000002;	macFlag[2] =  0x00000004;	macFlag[3] =  0x00000008;	macFlag[4] =  0x00000010;	macFlag[5] =  0x00000020;	macFlag[6] =  0x00000040;	macFlag[7] =  0x00000080;	macFlag[8] =  0x00000100;	macFlag[9] =  0x00000200;	macFlag[10] = 0x00000400;	macFlag[11] = 0x00000800;	macFlag[12] = 0x00001000;	macFlag[13] = 0x00002000;	macFlag[14] = 0x00004000;	macFlag[15] = 0x00008000;		macFlag[16] =  0x00010000;	macFlag[17] =  0x00020000;	macFlag[18] =  0x00040000;	macFlag[19] =  0x00080000;	macFlag[20] =  0x00100000;	macFlag[21] =  0x00200000;	macFlag[22] =  0x00400000;	macFlag[23] =  0x00800000;	macFlag[24] =  0x01000000;	macFlag[25] =  0x02000000;	macFlag[26] = 0x04000000;	macFlag[27] = 0x08000000;	macFlag[28] = 0x10000000;	macFlag[29] = 0x20000000;	macFlag[30] = 0x40000000;	macFlag[31] = 0x80000000;}long int ConvertToMac(long int theValue){	long int long1,long2;	long int  		flag[32],macFlag[32];	short	i;		SetConversionFlags2(flag,macFlag);	long1 = 0;	long2 = 0;	for(i = 0; i <= 31;i++){		if(theValue & flag[i]){			long1 += macFlag[i];		}	}	return long1;}void TestPosition(TPPrPort *thePrintPort,Rect theRect,short *theTop,short *theLeft,		short pageTop,short pageLeft,short secnColLeft,short *pageNo){	if(*theTop >= theRect.bottom - 20){				if(*theLeft == pageLeft && secnColLeft > pageLeft){			*theLeft = secnColLeft;		}else{			(*pageNo)++;			*theLeft = pageLeft;			PrClosePage(*thePrintPort);			PrOpenPage(*thePrintPort,0L);		}		*theTop = pageTop;				}}void	ConvertToCaps(char *theText,short length){	char	theCaps[26] = {'A','B','C','D','E','F','G','H','I','J','K',     					'L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};    char    theLower[26] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',    						'q','r','s','t','u','v','w','x','y','z'};   	short 	oldLength;   	short	i,k;      	oldLength = length;    for(i = 0; i < length;i++){    	Boolean flag;    	flag = false;    	k = 0;    	while(k < 26 && !flag){    		if(theText[i] == theLower[k]){    			theText[i] = theCaps[k];    			flag = true;    		}    		if(theText[i] == theCaps[k]){    			flag = true;    		}    		k++;    	}    	if(flag == false){    		length--;    		for(k = i;k < length;k++)theText[k] = theText[k + 1];    		i--;    	}    }       for(i = length; i < oldLength;i++)theText[i] = ' ';    	   theText[oldLength] = 0;}Boolean StringCompare(char *text,char *test){	short length,length2;	length = strlen(text);	length2 = strlen(test);	ConvertToCaps	(text,length);	length = strlen(text);	if(length2 < length) length = length2;	return strncmp(text,test,length);}Boolean	InRange(double value,double compare,double range,short type){	double min,max;	switch(type){		default:			min = compare - (range * compare);			max = compare + (range * compare);			if(min <= value && max >= value) return true;			return false;			break;		case 1:			if(compare <= value && range >= value) return true;			return false;			break;	}}RgnHandle SetClipToPort(WindowPtr theWindow,short l,short t,short r,short b){		RgnHandle newClip,oldClip;		Rect			theRect;		if(theWindow == 0L) theWindow = FrontWindow();		oldClip = D_NewRgn();		GetClip(oldClip);		SetPort((GrafPtr)theWindow);		newClip = D_NewRgn();		theRect = ((RgnPtr)*(theWindow->visRgn))->rgnBBox;		theRect.right -= r;		theRect.bottom -= b;		theRect.top += t;		theRect.left += l;		RectRgn(newClip,&theRect);		D_SetClip(newClip);		D_DisposeRgn(&newClip);		return oldClip;}double CalcExtinctionDistance(SpotInfo *thePole,double RofEwaldSphere){		double testDspace,theValue,braggSine,braggCosine;		testDspace 	= VectorLengthXYZ(thePole->x,thePole->y,thePole->z);		theValue		=	Cabs(thePole->sF);		if(theValue < .0000001){return 100000;}		braggSine 		= .5 * testDspace / (RofEwaldSphere);		braggCosine 	= sqrt(1 - (braggSine * braggSine));		return (PI * braggCosine * RofEwaldSphere)  / theValue;}#include		"ScatObj.h"void AtomicScatterForDFromSet(double dInverse,Ptr* theHandle,double *theZs,short atom_Count){	short n;//i;	double ratio,base,interval,*theZp;//	double	*value,*scatterV;	ScatObj		*theObj;atom_Count = atom_Count;	n = sizeof(short);			dInverse *= 50;	dInverse = 	Round(dInverse);	dInverse *= .01;		if(dInverse <= .50){		n = (short)(dInverse * 20);		base = (double)n * .05;		interval = .05;	} else if(dInverse <= 1.0){		n = 5 + (short)(dInverse * 10);		base = .5 + (double)(n - 10) * .1;		interval = .1;	} else if(dInverse <= 2.0){		n = 10 + (short)(dInverse * 5);		base = 1.0 + (double)(n - 15) * .2;		interval = .2;	} else if(dInverse <= 3.0){		n = 16 + (short)(dInverse * 2);		base = 2.0 + (double)(n - 20) * .5;		interval = .5;	} else {		n = 22;		base = 3.;		interval = .5;	}	 ratio = (dInverse - base) / interval;	 theZp = theZs;	 theObj = (ScatObj*)theHandle;	 theObj->GetValues(theZp, n, ratio);	 /*	 HLock((Handle)theHandle);	 for(i = 0; i < atom_Count;i++,theZp++){	 		Ptr 			thePtr;	 		Ptr				aPtr;	 		aPtr 			= *theHandle;			thePtr		= (Ptr)aPtr[i];	 		scatterV 	= (double*)thePtr;	 		value			=	&(scatterV[n]);			base 			= *value;		  interval 	= (value[1] - base);		  base 			= base + ratio * interval;	 	 *theZp = base;	 }	  HUnlock((Handle)theHandle);	  */	 return ;}/*pascal	voidPtr	ThruTiltThreadEntry( void *there){	DiffractObject		*t = (DiffractObject *)there;	SpotInfo		*theSpot;	short theIdent;	/*MFTemp....D_HLock(t->theDataHandle);	theSpot = (SpotInfoPtr)*(t->theDataHandle);	theIdent = (theSpot[t->spotLoc].flags & CRYSTAL_MASK);	t->ThruTilt(&theSpot[t->startCount[theIdent]]);		return nil;}*//*pascal	voidPtr	FullTiltThreadEntry( void *there){	DiffractObject		*t = (DiffractObject *)there;	SpotInfo		*theSpot;	short theIdent;	/*MFTemp....D_HLock(t->theDataHandle);	theSpot = (SpotInfoPtr)*t->theDataHandle;	theIdent = (theSpot[t->spotLoc].flags & CRYSTAL_MASK);		t->FullTilt(&t->nOut,&theSpot[t->startCount[theIdent]]);		return nil;}*/void dm_FrameOval(Rect *theRect){	Rect aRect;	aRect = *theRect;	aRect.right += 1;	aRect.bottom  += 1;	FrameOval(&aRect);}void dm_PaintOval(Rect *theRect){	Rect aRect;	aRect = *theRect;	aRect.right += 1;	aRect.bottom  += 1;	PaintOval(&aRect);}void dm_FrameRect(Rect *theRect){	Rect aRect;	aRect = *theRect;	aRect.right += 1;	aRect.bottom  += 1;	FrameRect(&aRect);}void dm_PaintRect(Rect *theRect){	Rect aRect;	aRect = *theRect;	aRect.right += 1;	aRect.bottom  += 1;	PaintRect(&aRect);}void dm_EraseRect(Rect *theRect){	Rect aRect;	aRect = *theRect;	aRect.right += 1;	aRect.bottom  += 1;	EraseRect(&aRect);}Point IntersectionOvals(Rect oval1,Rect oval2){	double center1h,center1v;	double center2h,center2v;	double delH,delV;	double r1,r2,x1,d,y1;	Point thePoint;	center1h = (oval1.left + oval1.right)/2;//find circle centers	center1v = (oval1.top + oval1.bottom)/2;	center2h = (oval2.left + oval2.right)/2;	center2v = (oval2.top + oval2.bottom)/2;	delH = center2h - center1h;//find distance between centers	delV = center2v - center1v;	d		=	 sqrt(delH * delH + delV * delV);	if(d < 1){		if(oval1.left > oval2.left){			thePoint.h = oval1.left;			thePoint.v = center1v;		}else{			thePoint.h = oval2.left;			thePoint.v = center2v;		}		return thePoint;	}		r1 =  (oval1.right - oval1.left)/2;//find radius	r2 =  (oval2.right - oval2.left)/2;//find radius	if(d > fabs(r1) + fabs(r2))//do not intersect	{		thePoint.h = 0;		thePoint.v = 0;		return thePoint;	}	x1 = -((r2 * r2) - (d * d) - (r1 * r1))/(2 * d);//find side of intersection triangle	y1 = fabs(r1 * r1 - x1 * x1);		y1 = sqrt(y1);	thePoint.h = center1h + (x1 * delH /d) + (y1 * delV/d);	thePoint.v = center1v - ((y1 * delH /d) - (x1 * delV/d));	return thePoint;}short GetVersion(short objectType){	short theValue;	theValue = objectType/10;		return (theValue * 10) - objectType;}void GetMuLambdaFromXYZ(double x,double y,double z,double *mu,double *lambda){	double	length;	double	temp;	length = sqrt(x * x + y * y);	if(length <= .00001){		*mu 		= 0;		*lambda 	= 0;		return;	}	temp = sin(acos(z)) / length;	x *= temp;	y *= temp;		NormalizeVector(&x,&y,&z);	*mu 		= asin(x);	temp	=	y / cos(*mu);	if(temp > 1) temp = 1;	if(temp < -1) temp = -1;	*lambda 	= asin(temp);	*mu 		*= (180. / PI);	*lambda 	*= (180. / PI);			/*	temp = 2.0 * atan2(length,2);	z = cos(temp);	temp = sin(temp) / length;	x *= temp;	y *= temp;		NormalizeVector(&x,&y,&z);	*mu 		= asin(x);	*lambda 	= asin(y / cos(*mu));	*mu 		*= (180. / PI);	*lambda 	*= (180. / PI);	*/}Handle WriteToXmlChar(char **charHandle,char aChar){	char theText[10];	theText[1] = 0;	theText[0] =  aChar;	return WriteToXmlString(charHandle,theText);}Handle WriteToXmlString(char **charHandle,char *theText){	long	stringLength;	char  	*theTextPtr;			stringLength	= 	(long)strlen(*charHandle);		stringLength	+= 	strlen(theText);	if(stringLength + 1 > GetHandleSize((Handle)charHandle))		D_SetHandleSize		((Handle*)&charHandle,stringLength + 1);			theTextPtr 		= 	*charHandle;	strcat	(theTextPtr,theText);	return charHandle;}