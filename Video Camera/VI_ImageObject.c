#include	"Diffract_INCs.h"#include	"a_ImageObject.h"#include	"PictureObj.h"//ects:D.M. v2.0:Sources.Jim:Video Camera:VI_ImageObject.cenum{	CAPTURE = 1,		CONFIG_VIDEO = 3,		BILEVEL_XFORM = 5	};typedef struct SPRAMRecord{				short		boardID;				SignedByte	vendorUse1;				SignedByte	vendorUse2;				SignedByte	vendorUse3;				SignedByte	vendorUse4;				SignedByte	vendorUse5;				SignedByte	vendorUse6;			}SPRAMRecord,*SPRAMRecPtr;								void				ImageObject::DoInit(){	variSize 		= true;	rulerHeight		= 0;		inherited::DoInit();	InsertMenu(g_Palette_Menu,-1);		SetRect(&gTheRect,0,0,639,479);	sourceRect = destRect = thePictRect	= gTheRect;	imageReady						= false;	imagePending 					= false;	captureFlag						= false;	zoomFlag						= false;	selectEnable					= true;	thePixMapHndl 					= NewPixMap();	theSelectRect					= (SelectRect*)NUL;	(*thePixMapHndl)->pmTable 		= GetCTable(IMAGE_OBJ);	(*thePixMapHndl)->rowBytes		= 0x8400;	(*thePixMapHndl)->bounds		= gTheRect;	(*thePixMapHndl)->pixelSize		= 8;	SetPort(theWindow);	DMForeColor(1);	DMBackColor(0);	/*KillMBHandle*/DisposeHandle(theMenuBar);		theMenuBar = GetMenuBar();	DrawMenuBar();		EraseRect(&(theWindow->portRect));	if(VideoBoardMissing(9)){		gType = StopAlert(2101,NUL);		CloseTheObject(theWindow);		return;	} else {		VerticalSyncOK();		(*thePixMapHndl)->baseAddr	= (Ptr)boardAddress;		if(!DoConfig()){			CloseTheObject(theWindow);			return;		}	}	DisableItem(GetMHandle(EDIT_MENU),PASTE);	DisableItem(GetMHandle(EDIT_MENU),DO_CLEAR);	DisableItem(GetMHandle(EDIT_MENU),SELECT_ALL);	DoResize();	return;}void ImageObject::SetObjectMenu(void){	theMenuBar = GetNewMBar(IMAGE_OBJ_MB);	ClearMenuBar();/* July 1992 */	SetMenuBar(theMenuBar);}Boolean				ImageObject::DoConfig(void){	short		i,theSelect,slot,channel;	Boolean		quit,retvalue = true;	DialogPtr	theDialog;	theDialog = DM_GetNewDialog(IMAGE_OBJ,NUL,IN_FRONT);		channel 	= 4 + ((short)(*channelSelectReg / 0x40));	GetDItem(theDialog,channel,&gType,&gTheHandle,&gTheRect);	SetCtlValue((ControlHandle)gTheHandle,1);		GetDItem(theDialog,8,&gType,&gTheHandle,&gTheRect);	slot = ((long)boardAddress & 0x00f00000) / 0x00100000;	sprintf(gTheText,"%1x",slot);	c2pstr(gTheText);	SetIText(gTheHandle,pTheText);	quit = false;		while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case DLOG_ENTER_OR_CR:			case 1:				for(i = 4 ; i <= 7 ; i++){					GetDItem(theDialog,i,&gType,&gTheHandle,&gTheRect);					if(GetCtlValue((ControlHandle)gTheHandle) == 1){						*channelSelectReg = (char)((i - 4) * 0x40);					}				}				if(VerticalSyncOK())					quit = true;				break;			case -1:			case 2:				retvalue = false;				quit = true;				break;			case 3:				if(++slot > 0x000E)					slot = 9;				boardAddress = NUL;				if(VideoBoardMissing(slot)){					if(VideoBoardMissing(9)){						quit = true;						i = StopAlert(2101,NUL);						DoClose();					}				}				if(!quit){					theSelect = 1 + ((short)(*channelSelectReg / 0x40));					GetDItem(theDialog,theSelect,&gType,&gTheHandle,&gTheRect);					SetCtlValue((ControlHandle)gTheHandle,1);										GetDItem(theDialog,8,&gType,&gTheHandle,&gTheRect);					slot = ((long)boardAddress & 0x00f00000) / 0x00100000;					sprintf(gTheText,"%1x",slot);					c2pstr(gTheText);					SetIText(gTheHandle,pTheText);				}				break;			case 4:			case 5:			case 6:			case 7:				GetDItem(theDialog,channel,&gType,&gTheHandle,&gTheRect);				SetCtlValue((ControlHandle)gTheHandle,0);				channel = theSelect;				GetDItem(theDialog,channel,&gType,&gTheHandle,&gTheRect);				SetCtlValue((ControlHandle)gTheHandle,1);				break;			default:					break;		}	}	SetPort(theWindow);	DM_DisposDialog(&theDialog);	return(retvalue);}								void				ImageObject::DoClose(void){	DisposCTable((*thePixMapHndl)->pmTable);	DisposPixMap(thePixMapHndl);	inherited::DoClose();}			void				ImageObject::DoIdle(void){	static long startTime;	if(imageReady){		GetAndDisplayFrame();	} else {		if(imagePending){			TestFrame();			if((TickCount() - startTime) > 60)				imagePending = false;		} else {			if(!captureFlag){				startTime = TickCount();				TriggerFrame();			}						}	}}Boolean				ImageObject::DoContent(Point	thePoint){	Boolean	retValue;	if(selectEnable){		retValue 	= inherited::DoContent(thePoint);	} else {		retValue 	= false;	}	return(retValue);}void				ImageObject::DoMenu(long theResult){	short 	theMenu,theItem;	Rect	tempRect;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);		switch(theMenu){		case EDIT_MENU:			switch(theItem){				case UNDO:					break;									case CUT:				case COPY:					if(gTheSelection->isValid){						tempRect 	= sourceRect;						sourceRect 	= gTheSelection->theRect;						CaptureFrame();						if(gTheSelection->selectPict != (PicHandle)NUL)							KillPicture(gTheSelection->selectPict);						gTheSelection->selectPict		= screenPict;						gTheSelection->selectPictRect	= thePictRect;						screenPict = (PicHandle)NUL;						SetRect(&thePictRect,0,0,0,0);						sourceRect = tempRect;					}						break;									case PASTE:					SysBeep(30);					break;									case DO_CLEAR:					break;									case SELECT_ALL:					break;									default:					break;			}			break;		case IMAGE_MENU:			switch(theItem){				case	CAPTURE:					if(gTheSelection->isValid){						sourceRect = gTheSelection->theRect;					}					CaptureFrame();					imageReady = false;					break;				case	BILEVEL_XFORM:					BiLevelTransform();					break;								case	CONFIG_VIDEO:					DoConfig();					break;				default:					break;			}			break;		case PALETTE_MENU:			{				short 			paletteID;				PaletteHandle	thisPalette,newPalette;								if(theItem == 1){					paletteID = 2100;				} else {					paletteID = theItem + 2100;				}				newPalette 	= GetNewPalette(paletteID);				thisPalette = GetPalette(theWindow);				SetPalette(theWindow,newPalette,true);				Palette2CTab(newPalette,(*thePixMapHndl)->pmTable);				ActivatePalette(theWindow);			}			break;					default:			inherited::DoMenu(theResult);			break;	}	HiliteMenu(0);}	Boolean				ImageObject::VideoBoardMissing(short	firstSlot){	OSErr		theError;	SpBlockPtr	thePRAMBlock;	SPRAMRecPtr	theSPRAMRec;	long		theSlot,*lookUpTable,response;	short		i,iErr;		thePRAMBlock 	= (SpBlockPtr)D_NewPtr(sizeof(SpBlock));	theSPRAMRec 	= (SPRAMRecPtr)D_NewPtr(sizeof(SPRAMRecord));		for(theSlot = firstSlot ; theSlot <= 0x000E && boardAddress == NUL ; theSlot++){		thePRAMBlock->spSlot = theSlot;		if(SCkCardStat(thePRAMBlock) == 0){			thePRAMBlock->spResult = (long)theSPRAMRec;			theError = SReadPRAMRec(thePRAMBlock);			if(((SPRAMRecPtr)(thePRAMBlock->spResult))->boardID == 282){				iErr = Gestalt('addr',&response);								if(response & 0x00000001){					boardAddress 		= (theSlot * 0x01000000 + 0xF0000000);				} else {					boardAddress 		= (theSlot * 0x00100000);				}								videoControlReg		= (char*)(boardAddress + 0x080000);				channelSelectReg	= (char*)(boardAddress + 0x080004);				lookUpTable 		= (long*)(boardAddress + 0x090000); 				theSlot = 0xFF000000;								{					unsigned long adr;					unsigned char table[256];										for(i = 0 ; i <= 254 ; i++){						table[i] =  i + 1;					}					table[255] = 0;										i = 0;					for(adr = (long)lookUpTable ; adr <= ((long)lookUpTable + 0x1FFC) ; adr += 4){						(*(char*)adr) = (char)table[i % 256];						i++;					}				}												KillPtr((Ptr)thePRAMBlock);				KillPtr((Ptr)theSPRAMRec);				*videoControlReg 	= (char)1;				*channelSelectReg 	= (char)0;				low = 1;				high = 0;				xFormThresh = 128;				if(*channelSelectReg & 0x08){					objectSize.v = 512 - 16;					objectSize.h = 768 - 17;				} else {					objectSize.v = 480 - 16;					objectSize.h = 640 - 17;				}				return false;			}		}	}		KillPtr((Ptr)thePRAMBlock);	KillPtr((Ptr)theSPRAMRec);	return(true);}void				ImageObject::TriggerFrame(void){	*videoControlReg 	= (char)128;	imagePending = true;	return;}void				ImageObject::TestFrame(void){	if(((*videoControlReg) & 0x80) == 0){		imagePending = false;		imageReady = true;	}	return;}void				ImageObject::GetAndDisplayFrame(void){	short h,v;	imageReady = false;	SetRect(&gTheRect,0,0,639,479);/*	CopyPixMap(((CGrafPtr)theWindow)->portPixMap,thePixMapHndl);	(*thePixMapHndl)->baseAddr	= (Ptr)boardAddress;	(*thePixMapHndl)->rowBytes	= 0x8400;	(*thePixMapHndl)->pmTable 	= GetCTable(IMAGE_OBJ);*/	(*thePixMapHndl)->bounds	= (*((CGrafPtr)theWindow)->portPixMap)->bounds;	DMForeColor(1);	DMBackColor(0);		CopyRgn(picUpdateRgn,gTheRgn);	h = GetCtlValue(hScroll->theControl);	v = GetCtlValue(vScroll->theControl);		destRect 			= theWindow->portRect;	destRect.right 		-= 15;	destRect.bottom 	-= 15;	sourceRect 			= (*((CGrafPtr)theWindow)->portPixMap)->bounds;		sourceRect.left 	+= 2;			sourceRect.right	= sourceRect.left + destRect.right - 1;	sourceRect.bottom	= sourceRect.top + destRect.bottom - 1;		if((sourceRect.right + h) > ((*((CGrafPtr)theWindow)->portPixMap)->bounds.right - 3)){		h = (*((CGrafPtr)theWindow)->portPixMap)->bounds.right - sourceRect.right - 3;		SetCtlValue(hScroll->theControl,h);		SetCtlMax(hScroll->theControl,h);	}		if((sourceRect.bottom + v) > (*((CGrafPtr)theWindow)->portPixMap)->bounds.bottom){		v = (*((CGrafPtr)theWindow)->portPixMap)->bounds.bottom - sourceRect.bottom;		SetCtlValue(vScroll->theControl,v);		SetCtlMax(vScroll->theControl,v);	}			OffsetRect(&sourceRect,h,v);			 					CopyBits(		(BitMap*)(*thePixMapHndl),					(BitMap*)(*(((CGrafPtr)theWindow)->portPixMap)),					&sourceRect,&destRect,srcCopy,0L);								OffsetRgn(gTheRgn,h,v);	DoSetOrigin();	SetClip(gTheRgn);																/*			if(fitWindowFlag){		CopyBits(	(BitMap*)(*thePixMapHndl),					(BitMap*)(*(((CGrafPtr)theWindow)->portPixMap)),					&sourceRect,&theWindow->portRect,srcCopy,0L);	} else {		CopyBits(	(BitMap*)(*thePixMapHndl),					(BitMap*)(*(((CGrafPtr)theWindow)->portPixMap)),					&sourceRect,&destRect,srcCopy,0L);		}		{		short n,m;		char*	theData;				theData = (char*)0xE00000;				for(n = 0 ; n <= 479 ; n++){			MoveTo(0,n);			theData = (char*)(0xE00000 + (long)n * 1024L);			for(m = 0 ; m <= 639 ; m++){				DMForeColor((short)*theData);				LineTo(m,n);				theData++;			}		}	}	*/		if(gTheSelection->isValid){		gTheSelection->DoFrame();	}	DoResetOrigin();	SetClip(eventRgn);	DrawGrowIcon(theWindow);	if(gTheSelection->isValid){		EnableItem(GetMHandle(IMAGE_MENU),CAPTURE);	} else {		DisableItem(GetMHandle(IMAGE_MENU),CAPTURE);	}		return;}void				ImageObject::CaptureFrame(void){	PictureObj*	thePictureObj;	static short x;		TriggerFrame();	Delay(2,&gLongScratch);	gLongScratch = 30 + TickCount();	while(imagePending && gLongScratch >= TickCount()){		TestFrame();		SystemTask();	}	SetZone(SystemZone());	if(screenPict != (PicHandle)NUL){		KillPicture(screenPict);	}	thePictRect = sourceRect;	OffsetRect(&thePictRect,-sourceRect.left,-sourceRect.top);		OffsetRect(&sourceRect,-GetCtlValue(hScroll->theControl),-GetCtlValue(vScroll->theControl));		screenPict = OpenPicture(&sourceRect);	DMForeColor(1);	DMBackColor(0);		CopyBits(		(BitMap*)(*(((CGrafPtr)theWindow)->portPixMap)),					(BitMap*)(*(((CGrafPtr)theWindow)->portPixMap)),					&sourceRect,&sourceRect,srcCopy,0L);			ClosePicture();	SetZone(ApplicZone());		thePictureObj	= (PictureObj*)AllocPictureObj();	if(thePictureObj != (PictureObj*)NUL){		thePictureObj->DoSetup(screenPict,GetPalette(theWindow));		screenPict = (PicHandle)NUL;	}	return;}Boolean				IsValidWindow(WindowPeek);	DiffractObject*		FindObject(short index);	void				ImageObject::DoExport(void){	ListHandle		theList;	Rect			rView,dataBounds;	Cell			theCell;	short			total,textHeight,theSelect;	FontInfo 		theFont;	Point			cellSize,thePoint;	DialogPtr		theDialog;	Boolean			quitFlag = false;	WindowPeek		thisWindow;	long			retValue;	DiffractObject	*theObject;			GetFontInfo(&theFont);		textHeight 	= theFont.ascent + theFont.descent + theFont.leading;	theDialog		= DM_GetNewDialog(EXPORT_DLOG,NUL,IN_FRONT);	SetWTitle(theDialog,"\pExport Image");	SetPort(theDialog);		GetDItem(theDialog,3,&gType,&gTheHandle,&rView);	GetDItem(theDialog,1,&gType,&gTheHandle,&gTheRect);	HiliteControl((ControlHandle)gTheHandle,255);		cellSize.h		= rView.right - rView.left;	cellSize.v		= textHeight + 4;	total = 0;	thisWindow = (WindowPeek)FrontWindow();	while(thisWindow != (WindowPeek)NUL){		if(IsValidWindow(thisWindow)){			total++;		}		thisWindow = thisWindow->nextWindow;	}	SetRect(&dataBounds,0,0,1,total);		ShowWindow(theDialog);	DrawDialog(theDialog);		theList = LNew(&rView,&dataBounds,cellSize,0,theDialog,true,false,false,true);	LDoDraw(true,theList);	(*theList)->selFlags = lOnlyOne;		theCell.h = theCell.v = 0;	thisWindow = (WindowPeek)FrontWindow();	while(thisWindow != (WindowPeek)NUL){		if(IsValidWindow(thisWindow)){			GetWTitle((WindowPtr)thisWindow,(unsigned char*)gTheText);			LSetCell(&(gTheText[1]),(short)(gTheText[0]),theCell,theList);			theCell.v++;		}		thisWindow = thisWindow->nextWindow;	}	gTheRect = rView;	InsetRect(&gTheRect,-1,-1);	FrameRect(&gTheRect);	if(total <= 0){		Tell(STOP_ALERT,"No Windows suitable for export are currently open.");		quitFlag = true;	}	while(!quitFlag){		ModalDialog(SmallFilterUPP,&theSelect);		switch(theSelect){			case DLOG_ENTER_OR_CR:			case 1:				quitFlag = true;				break;			case -1:			case 2:				quitFlag = true;				LDispose(theList);				DM_DisposDialog(&theDialog);				HiliteMenu(0);				gCurrentObj->DoRefresh();				return;				break;			case 3:				thePoint = gTheEvent.where;				GlobalToLocal(&thePoint);				quitFlag = LClick(thePoint,gTheEvent.modifiers,theList);				theCell = LLastClick(theList);				retValue = theCell.v;				GetDItem(theDialog,1,&gType,&gTheHandle,&gTheRect);				HiliteControl((ControlHandle)gTheHandle,0);				break;			case 4:				thePoint = gTheEvent.where;				GlobalToLocal(&thePoint);				quitFlag = LClick(thePoint,gTheEvent.modifiers,theList);				quitFlag = false;				break;			default:				break;		}	}	LDispose(theList);	DM_DisposDialog(&theDialog);	theObject = FindObject((short)retValue);/*	if(theObject->backgroundPict != (PicHandle)NUL)		KillPicture((theObject->backgroundPict);	theObject->backgroundPict 	= screenPict;	theObject->backGRect 		= thePictRect;	gTheRect = theObject->theWindow->portRect;	i 		 = (gTheRect.left + gTheRect.right)/2;	gType 	 = (gTheRect.top + gTheRect.bottom + rulerHeight)/2;	OffsetRect(&(theObject->backGRect),i,gType);	SetZone(SystemZone());	if(HandToHand((Handle*)&(theObject->backgroundPict)) != noErr){		Tell(STOP_ALERT,"Copy of Image Failed! ... Probably low memory");	}	SetZone(ApplicZone());	HiliteMenu(0);*/	gCurrentObj->DoRefresh();}Boolean		IsValidWindow(WindowPeek	thisWindow){	if(thisWindow == (WindowPeek)NUL)		return false;	if(thisWindow->refCon == NUL)		return false;	if(IsValidObj((DiffractObject*)GetWRefCon((WindowPtr)thisWindow)))		return true;	return false;}	DiffractObject*		FindObject(short index){	WindowPeek	thisWindow;	short		count;		count = 0;	thisWindow = (WindowPeek)FrontWindow();	while(thisWindow != (WindowPeek)NUL){		if(IsValidWindow(thisWindow)){			if(count++ == index)				return((DiffractObject*)(thisWindow->refCon));		}		thisWindow = thisWindow->nextWindow;	}	return((DiffractObject*)NUL);}		Boolean				ImageObject::VerticalSyncOK(void){	long	startTime;	char	controlRegValue=0;		startTime = TickCount() + 60;		while(startTime > TickCount() && controlRegValue == 0){		controlRegValue = *videoControlReg & 0x20;	}		if(controlRegValue == 0){		startTime = CautionAlert(2102,NUL);		return false;	}	return true;}			void				ImageObject::BiLevelTransform(void){	DialogPtr	theDialog;	short		theSelect;	Boolean		quitFlag=false;	long		time;	theDialog = DM_GetNewDialog(BI_LEVEL_XFRM,NUL,IN_FRONT);	SetWTitle(theDialog,"\pBi-Level Transformation");	SetPort(theWindow);	low--;	high--;	GetDItem(theDialog,4,&gType,&gTheHandle,&gTheRect);	SetCtlValue((ControlHandle)gTheHandle,xFormThresh);	GetDItem(theDialog,6,&gType,&gTheHandle,&gTheRect);	SetCtlValue((ControlHandle)gTheHandle,low);	GetDItem(theDialog,8,&gType,&gTheHandle,&gTheRect);	SetCtlValue((ControlHandle)gTheHandle,high);	GetDItem(theDialog,5,&gType,&gTheHandle,&gTheRect);	sprintf(gTheText,"%3d",xFormThresh);	c2pstr(gTheText);	SetIText	(gTheHandle,pTheText);	GetDItem	(theDialog,7,&gType,&gTheHandle,&gTheRect);	sprintf		(gTheText,"%3d",low);	c2pstr		(gTheText);	SetIText	(gTheHandle,pTheText);	GetDItem	(theDialog,9,&gType,&gTheHandle,&gTheRect);	sprintf		(gTheText,"%3d",high);	c2pstr		(gTheText);	SetIText	(gTheHandle,pTheText);		low++;	high++;				SetThePalette(xFormThresh);	while(!imageReady){		TestFrame();	}	imageReady = false;	TriggerFrame();	while(!imageReady){		TestFrame();	}	GetAndDisplayFrame();	HiliteOK(theDialog);		while(!quitFlag){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case -3:				SetPort(theWindow);				TriggerFrame();				while(!imageReady){					TestFrame();				}				GetAndDisplayFrame();				DrawDialog(theDialog);								SetPort(theDialog);				break;							case -1:			case 2:				DM_DisposDialog(&theDialog);				SetThePalette(-1);				quitFlag = true;				break;			case DLOG_ENTER_OR_CR:			case 1:				DM_DisposDialog(&theDialog);				quitFlag = true;				break;			case 3:				SetThePalette(-1);				SetPort(theWindow);				TriggerFrame();				while(!imageReady){					TestFrame();				}				GetAndDisplayFrame();				DrawDialog(theDialog);				SetPort(theDialog);				break;			case 4:				GlobalToLocal(&(gTheEvent.where));				GetDItem(theDialog,5,&gType,&gTheHandle,&gTheRect);				SetPort(theWindow);				theSelect = LMGetKeyThresh();				time = 0;				while(StillDown() || time == 0){					xFormThresh = DoTheScroll(theDialog,4,gTheEvent.where);					SetThePalette(xFormThresh);					sprintf(gTheText,"%3d",xFormThresh);					c2pstr(gTheText);					SetIText(gTheHandle,pTheText);					TriggerFrame();					while(!imageReady){						TestFrame();					}					GetAndDisplayFrame();					Delay((long)theSelect,&time);					theSelect = 1;				}				GetDItem(theDialog,4,&gType,&gTheHandle,&gTheRect);				HiliteControl((ControlHandle)gTheHandle,0);				SetPort(theDialog);				break;			case 5:				GetDItem(theDialog,5,&gType,&gTheHandle,&gTheRect);				GetIText(gTheHandle,pTheText);				p2cstr(pTheText);				xFormThresh = atoi(gTheText);				if(xFormThresh > 254){					xFormThresh = 254;					sprintf(gTheText,"%3d",xFormThresh);					c2pstr(gTheText);					SetIText(gTheHandle,pTheText);				}				if(xFormThresh < 1){					xFormThresh = 1;					sprintf(gTheText,"%3d",xFormThresh);					c2pstr(gTheText);					SetIText(gTheHandle,pTheText);				}				GetDItem(theDialog,4,&gType,&gTheHandle,&gTheRect);				SetCtlValue((ControlHandle)gTheHandle,xFormThresh);				SetThePalette(xFormThresh);				SetPort(theWindow);				TriggerFrame();				while(!imageReady){					TestFrame();				}				GetAndDisplayFrame();				SetPort(theDialog);				break;			case 6:				GlobalToLocal(&(gTheEvent.where));				GetDItem(theDialog,7,&gType,&gTheHandle,&gTheRect);				SetPort(theWindow);				theSelect = LMGetKeyThresh();				time = 0;				while(StillDown() || time == 0){					low = DoTheScroll(theDialog,6,gTheEvent.where);					sprintf(gTheText,"%3d",low);					c2pstr(gTheText);					SetIText(gTheHandle,pTheText);					low++;					SetThePalette(xFormThresh);					TriggerFrame();					while(!imageReady){						TestFrame();					}					GetAndDisplayFrame();					Delay((long)theSelect,&time);					theSelect = 1;				}				GetDItem(theDialog,6,&gType,&gTheHandle,&gTheRect);				HiliteControl((ControlHandle)gTheHandle,0);				SetPort(theDialog);				break;			case 7:				GetDItem(theDialog,7,&gType,&gTheHandle,&gTheRect);				GetIText(gTheHandle,pTheText);				p2cstr(pTheText);				low = atoi(gTheText);				if(low > 255){					theSelect = 255;					sprintf(gTheText,"%3d",low);					c2pstr(gTheText);					SetIText(gTheHandle,pTheText);				}				if(low < 0){					low = 0;					sprintf(gTheText,"%3d",low);					c2pstr(gTheText);					SetIText(gTheHandle,pTheText);				}				low++;				GetDItem(theDialog,6,&gType,&gTheHandle,&gTheRect);				SetCtlValue((ControlHandle)gTheHandle,theSelect);				SetThePalette(xFormThresh);				SetPort(theWindow);				TriggerFrame();				while(!imageReady){					TestFrame();				}				GetAndDisplayFrame();				SetPort(theDialog);				break;			case 8:				GlobalToLocal(&(gTheEvent.where));				GetDItem(theDialog,9,&gType,&gTheHandle,&gTheRect);				SetPort(theWindow);				theSelect = LMGetKeyThresh();				time = 0;				while(StillDown() || time == 0){					high = DoTheScroll(theDialog,8,gTheEvent.where);					sprintf(gTheText,"%3d",high);					c2pstr(gTheText);					SetIText(gTheHandle,pTheText);					high++;					SetThePalette(xFormThresh);					TriggerFrame();					while(!imageReady){						TestFrame();					}					GetAndDisplayFrame();					Delay((long)theSelect,&time);					theSelect = 1;				}				GetDItem(theDialog,8,&gType,&gTheHandle,&gTheRect);				HiliteControl((ControlHandle)gTheHandle,0);				SetPort(theDialog);				break;			case 9:				GetDItem(theDialog,9,&gType,&gTheHandle,&gTheRect);				GetIText(gTheHandle,pTheText);				p2cstr(pTheText);				high = atoi(gTheText);				if(high > 255){					high = 255;					sprintf(gTheText,"%3d",high);					c2pstr(gTheText);					SetIText(gTheHandle,pTheText);				}				if(high < 0){					high = 0;					sprintf(gTheText,"%3d",high);					c2pstr(gTheText);					SetIText(gTheHandle,pTheText);				}				GetDItem(theDialog,8,&gType,&gTheHandle,&gTheRect);				SetCtlValue((ControlHandle)gTheHandle,high);				high++;				SetThePalette(xFormThresh);				SetPort(theWindow);				TriggerFrame();				while(!imageReady){					TestFrame();				}				GetAndDisplayFrame();				SetPort(theDialog);				break;			default:				break;		}	}}				void				ImageObject::SetThePalette(short level){	unsigned long adr;	unsigned char table[256];	short			i;	char			*dest;		dest = (char*)(boardAddress + 0x90000);		if(level < 1 || level > 254){		for(i = 0 ; i <= 254 ; i++){			table[i] =  i + 1;		}	} else {		for(i = 0 ; i < level ; i++){			table[i] =  low;		}		for(i = level ; i < 255 ; i++){			table[i] =  high;		}	}	table[255] = 0;		i = 0;		while((*videoControlReg & 0x80) != 0)		continue;	for(adr = (long)dest ; adr <= ((long)dest + 0x1FFC) ; adr += 4){		(*(char*)adr) = (char)table[i % 256];		i++;	}}void				ImageObject::DoRefresh(void){			SetPort(theWindow);		InvalRect(&theWindow->portRect);		BeginUpdate(theWindow);		while(!imageReady){		TestFrame();	}	imageReady = false;	TriggerFrame();	while(!imageReady){		TestFrame();	}	GetAndDisplayFrame();		EndUpdate(theWindow);		inherited::DoRefresh();}	short	DoTheScroll(DialogPtr theDialog,short	theItem,Point thePoint){	short	ammount,part;	ControlHandle	theHandle;		part = FindControl(thePoint,theDialog,&theHandle);	if(part != 0){		HiliteControl(theHandle,part);		switch(part){	/* Switch on  part   */			case 20: 				ammount = -1;				break;			case 21:				ammount = 1;				break;										/* if a scroll bar part  */			case 22:				ammount = (GetCtlMin(theHandle) - GetCtlMax(theHandle)) / 4;				break;			case 23:				ammount = (GetCtlMax(theHandle) - GetCtlMin(theHandle)) / 4;				break;										default:				return(GetCtlValue(theHandle));				break;		}		SetCtlValue(theHandle,GetCtlValue(theHandle) + ammount);		return(GetCtlValue(theHandle));	}	GetDItem(theDialog,theItem,&gType,(Handle*)&theHandle,&gTheRect);	return(GetCtlValue(theHandle));}							