//ces.Jim:GraphicsObj:G_LineObj.c#include	"Diffract_INCs.h"#include 	"LineObj.h"void  LineObj::AverageHV(double *theH,double *theV,double n){	*theH += hor2 + hor1;	*theV += ver2 + ver1;	n += 2;	if(next){ 		next->AverageHV(theH, theV, n);		return;	}	*theH /= n;	*theV /= n;	}void  LineObj::MidPoint(short *theH,short *theV){	double h,v;	h = hor2 + hor1;	v = ver2 + ver1;	*theH = h/2;	*theV = v/2;	}void LineObj::DoInit(Boolean dirFlag,Crystal *aCrystal,Boolean lineType,long options,Point thePoint,Point lastPoint){	h = 0;	k = 0;	l = 1;	direction = dirFlag;	x = 0.;	y = 0.;	z = 0.;	segments = 1;	intensity = 1.;	flags 		= 0L;	next 		= 0L;	previous 	= 0L;	theCrystal = aCrystal;	pinned 			= lineType;	selected = true;	SetLine(thePoint,lastPoint);	theCrystal = aCrystal;	SetFlag(options);	SetFlag(FIRST_RECT);	DrawLine(true);}void LineObj::SetCrystal(Crystal *aCrystal){	theCrystal = aCrystal;}Boolean	LineObj::HitLine(Point thePoint){	Rect rect1,rect2;	Point testPoint,aPoint;	long theMask = 0L;	SetRect				(&rect1,-2,-2,2,2);	aPoint.h = hor1;	aPoint.v = ver1;	OffsetRect		(&rect1,aPoint.h,aPoint.v);	SetRect(&rect2,-2,-2,2,2);	aPoint.h = hor2;	aPoint.v = ver2;	OffsetRect		(&rect2,aPoint.h,aPoint.v);	theMask = SECOND_RECT + FIRST_RECT + ON_LINE + HIT_MASK;	ClearFlag(theMask);		if(PtInRect(thePoint,&rect1)){		 SetFlag(FIRST_RECT);		 return true;	}		if(pinned){		//return false;		testPoint.h = hor2;		testPoint.v = ver2;		GetClip(gTheRgn);		if(!PtInRgn(testPoint,gTheRgn) && PointOnLine(thePoint)){			SetFlag(ON_LINE);			 SetFlag(HIT_MASK);			return true;		}		return false;	}	if(PtInRect(thePoint,&rect2)){		 SetFlag(SECOND_RECT);		 return true;	}	if(PointOnLine(thePoint)){		 SetFlag(ON_LINE);		 SetFlag(HIT_MASK);		 return true;	}	return false;}Boolean	LineObj::ManipulateLine(Point thePoint) /* free line fixes first point */{	static Point oldPoint;	PenState thePenState;	short delH,delV;	long	theMask = 0L;		if(flags == 0) return false;	theMask = HIT_MASK;		if(thePoint.h == oldPoint.h && thePoint.v == oldPoint.v)		return false;	GetPenState(&thePenState);	PenNormal();	//PenPat(0);	//PenMode(patXor);	//SetMarqueePattern	(NUL);	//DrawLine(true);	//Delay							(1,&gLongScratch);	//DrawLine(true);	if(flags & SECOND_RECT){ 		hor2 = thePoint.h;		ver2 = thePoint.v;			}	if(flags & FIRST_RECT){		hor1 = thePoint.h;		ver1 = thePoint.v;	}	if(flags & ON_LINE){	{		if(flags & HIT_MASK)		{			ClearFlag(theMask);			oldPoint = thePoint;		}		delH = thePoint.h - oldPoint.h;		delV = thePoint.v - oldPoint.v;		hor1 += delH;		hor2 += delH;		ver1 += delV;		ver2 += delV;	}	}	//SetMarqueePattern	(NUL);	//DrawLine(true);	//Delay							(1,&gLongScratch);	//DrawLine(true);	if(flags & ALIGN_PREVIOUS){		if(previous){			previous->hor2 = hor1;			previous->ver2 = ver1;		}else{			LineObj* circle;			circle = GetLast();			circle->hor2 = hor1;			circle->ver2 = ver1;		}	}	if(flags & ALIGN_NEXT){		if(next){			next->hor1 = hor2;			next->ver1 = ver2;		}else{			LineObj* circle;			circle = GetFirst();			circle->hor1 = hor2;			circle->ver1 = ver2;		}	}	oldPoint = thePoint;	PenMode(thePenState.pnMode);	return true;}double LineObj::GetLength(void){	double delH,delV;	delH = hor1 - hor2;	delV = ver1 - ver2;	return sqrt((delH * delH) + (delV * delV));}void LineObj::SetLineToRect(Rect theRect){	hor1 = theRect.left;	ver1 = theRect.top;	hor2 = theRect.right;	ver2 = theRect.bottom;}void	LineObj::CopyLineToPtr(Ptr thePtr)					{	SpotInfoPtr theSpot;	theSpot = (SpotInfoPtr)thePtr;	BlockMove((Ptr)&theCrystal,(Ptr)&(theSpot->theCrystal),sizeof(SpotInfo));	return;}void	LineObj::CopyPtrToLine(Ptr thePtr)					{	SpotInfoPtr theSpot;	theSpot = (SpotInfoPtr)thePtr;	BlockMove((Ptr)&(theSpot->theCrystal),(Ptr)&theCrystal,sizeof(SpotInfo));	return;}void LineObj::SetLine(Point thePoint,Point lastPoint){	hor1 = thePoint.h;	ver1 = thePoint.v;	hor2 = lastPoint.h;	ver2 = lastPoint.v;}void LineObj::DoClose(void){	if(previous)previous->next = next;	if(next)next->previous = previous;	D_delete(this);}double LineObj::Angle(void){	double x,y,angle;		y =  ver2 - ver1;	x =  hor2 - hor1;		if(x == 0.0 && y == 0.0){  /* this traps the case where mouse did not move, otherwise NAN results */		return (0.0);	}		angle = atan2(y,x);	angle -= (PI / 2.0);	if(angle < 0.0)		angle += (2.0 * PI);	return angle;}void LineObj::DrawAllLines(Boolean rectFlag){	if(next)next->DrawAllLines( rectFlag);	if(!selected)		DrawLine(rectFlag);	else{		SetMarqueePattern	(NUL);		PenMode				(patXor);		DrawLine			(rectFlag);		Delay				(2,&gLongScratch);		DrawLine			(rectFlag);		PenNormal			();		PenMode				(gCurrentObj->gMode);	}	return;}void LineObj::JustDrawAllLines(Boolean rectFlag){	if(next)next->JustDrawAllLines( rectFlag);	DrawLine(rectFlag);	return;}void LineObj::DrawLine(Boolean rectFlag){	Rect rect1,rect2;	Point aPoint1,aPoint2;	theCrystal->SetColor();	aPoint1.h = hor1;	aPoint1.v = ver1;	aPoint2.h = hor2;	aPoint2.v = ver2;	gCurrentObj->onScreen = true;	gCurrentObj->ObjToLocal(&aPoint1);	gCurrentObj->ObjToLocal(&aPoint2);	if(rectFlag){		SetRect(&rect1,-2,-2,2,2);		OffsetRect(&rect1,aPoint1.h,aPoint1.v);		SetRect(&rect2,-2,-2,2,2);		OffsetRect(&rect2,aPoint2.h,aPoint2.v);		dm_FrameRect(&rect1);		dm_FrameRect(&rect2);	}	MoveTo(aPoint1.h,aPoint1.v);	LineTo(aPoint2.h,aPoint2.v);}double	LineObj::Slope(Boolean *flag){	double delH,delV;	delH = hor1 - hor2;	delV = ver1 - ver2;	if(delH == 0){		*flag = false;		return 0;	}	*flag = true;	return delV / delH;}LineObj*  LineObj::GetFirst(void){	if(previous)return previous->GetFirst();	return this;}LineObj*  LineObj::GetLast(void){	if(next)return next->GetLast();	return this;}LineObj*  LineObj::GetLineNum(short n,short number){	if(n == number) return this;	n++;	if(next)return next->GetLineNum(n,number);	return 0L;}Boolean LineObj::PointOnLine(Point thePoint){	LineObj *theLine;	double difInSlope;	Rect rect1,rect2;	Rect theRect;	short h1,h2,v1,v2;	double length,xx,yy;		SetRect		(&rect1,-2,-2,2,2);	OffsetRect	(&rect1,hor1,ver1);	SetRect		(&rect2,-2,-2,2,2);	OffsetRect	(&rect2,hor2,ver2);	h1 = hor1;	h2 = hor2;	if(h1 > hor2){		h1 = hor2;		h2 = hor1;	}	v1 = ver1;	v2 = ver2;	if(v1 > v2){		v1 = ver2;		v2 = ver1;	}	SetRect(&theRect,h1 - 2,v1 - 2,h2 + 2,v2 + 2);	if(!PtInRect(thePoint,&theRect))		return false;	if(PtInRect(thePoint,&rect1) || PtInRect(thePoint,&rect2))		return false;			theLine = (LineObj*)D_new(LineObj);	DoCopy(theLine);	/* CopyLineToPtr((Ptr)&(theLine->theCrystal)); */	theLine->next = 0L;	theLine->previous = 0L;	theLine->hor1 = hor1;	theLine->ver1 = ver1;	theLine->hor2 = thePoint.h;	theLine->ver2 = thePoint.v;	xx = hor1 - thePoint.h;	yy = ver1 - thePoint.v;	length = sqrt(xx * xx + yy * yy);		difInSlope = AngleBetween(theLine);	difInSlope = length * sin(difInSlope);	theLine->DoClose();	if(fabs(difInSlope) <= 2){		return true;	}	return false;}double LineObj::AngleBetween(LineObj *theLine){	if(theLine == 0L)theLine = next;	return Angle() - theLine->Angle();}double LineObj::AvgPixelsBetween(LineObj *theLine){	double slope1,slope2;	double dspace,dspace1,dspace2;	double X,Y;	short sX1,sX2,sY1,sY2,eX1,eX2,eY1,eY2;	Boolean theFlag;	slope1 = Slope(&theFlag);	if(theLine == 0L)theLine = next;	if(slope1 == 0){		if(!theFlag){			dspace1 = fabs((double)hor1 - theLine->hor1);			dspace2 = fabs((double)hor1 - theLine->hor2);		}else{			dspace1 = fabs((double)ver1 - theLine->ver1);			dspace2 = fabs((double)ver1 - theLine->ver2);		}	}else{		sX1 = hor1;		sX2 = theLine->hor1;		sY1 = ver1;		sY2 = theLine->ver1;		eX1 = hor2;		eX2 = theLine->hor2;		eY1 = ver2;		eY2 = theLine->ver2;		slope2 = -1. / slope1;		X = (slope1 * sX1 - slope2 * sX2 + sY2 - sY1) / (slope1 - slope2);		Y = (slope1 * (X - hor1)) + ver1;		dspace1 = sqrt(((X - sX2) * (X - sX2)) + ((Y - sY2) * (Y - sY2)));				X = (slope1 * sX1 - slope2 * eX2 + eY2 - sY1) / (slope1 - slope2);		Y = (slope1 * (X - sX1)) + sY1;		dspace2 = sqrt(((X - eX2) * (X - eX2)) + ((Y - eY2) * (Y - eY2)));	}	dspace = (dspace1 + dspace2) / 2.;	return dspace;}long LineObj::MaskValue(long theMask){	long 	theValue = 0L;	short 	i = 0;	long 	newValue;	long	test_Mask = 1L;		theValue = flags & theMask;	if(!theValue) return 0L;	while(!(test_Mask & theValue)){	 	newValue = theValue >> 1;	 	theValue = newValue;	}	return theValue;}void LineObj::ClearFlag(long theMask){	flags &= ~theMask;}void LineObj::SetFlag(long theMask){	flags |= theMask;}void LineObj::SetORFlag(short oRNum){	flags |= ((oRNum + 1) * 8);}void LineObj::DoCopy(LineObj *theLine){	theLine->theCrystal = theCrystal;	theLine->h = h;	theLine->k = k;	theLine->l = l;	theLine->direction = direction;	theLine->x = x;	theLine->y = y;	theLine->z = z;	theLine->intensity = intensity;	theLine->angle = angle;	theLine->hor1 = hor1;	theLine->ver1 = ver1;	theLine->hor2 = hor2;	theLine->ver2 = ver2;	theLine->flags = flags;}Point LineObj::CrossOver(LineObj *line2){	double slopep, slope, x,y,yo,yop;	Point thePoint;	Boolean flag,flagp;	thePoint.h = thePoint.v = 0;	if(line2 == 0L)line2 = next;	if(line2 == 0)return thePoint;	slopep = line2->Slope(&flagp);	slope  = Slope(&flag);		if(flag && flagp){		yo = ver1 - (hor1 * slope);		yop = line2->ver1 - (line2->hor1 * slopep);		x 	= (yo - yop) / ( slopep - slope);		y 	= yop + x * (slopep);	}else{		if(!flag  && flagp){			x = hor1;			yop = line2->ver1 - (line2->hor1 * slopep);			y =  yop + x * (slopep);		}else if(!flagp && flag){			x = line2->hor1;			yop = ver1 - (hor1 * slope);			y =  yop + x * (slope);		}else{			x = y = 0;		}	}	thePoint.h = x;	thePoint.v = y;	return thePoint;	}void  LineObj::KillAll(void){	if(next != 0L) next->KillAll();	DoClose();}Boolean LineObj::TakeCareOfLines(Point thePoint,Point lastPoint,short maxLines,  short *hitLine){	RgnHandle		theNewClip;	Boolean			hit;		if(!selected){		(*hitLine) += 1;		if(HitLine(thePoint)){			Rect resultRect;			Point pt1,pt2;			//gCurrentObj->refreshFlag = true;			//gCurrentObj->DoRefresh();			pt1.h = hor1;			pt1.v = ver1;			pt2.h = hor2;			pt2.v = ver2;			Pt2Rect(pt1,pt2,&resultRect);			InvalRect(&resultRect);			selected = true;			return true;		}		if(next != 0L){			 hit = next->TakeCareOfLines(thePoint,lastPoint,maxLines,hitLine);//goes first so we only get one line			if(hit) return hit;		}		if(maxLines > *hitLine || maxLines < 0){			*hitLine = maxLines; // add only one line at a time.			AddLine(thePoint,lastPoint);//bloch			return true;		}		return false;			}		//gCurrentObj->LocalToObj(&thePoint);	GetClip(gTheRgn);	theNewClip = D_NewRgn();	RectRgn	(theNewClip,&gCurrentObj->theVisRect);	D_SetClip	(theNewClip);	ManipulateLine(thePoint);	selected = true;	D_SetClip(gTheRgn);	D_DisposeRgn(&theNewClip);	return true;}void LineObj::AddLine(Point thePoint,Point nextPoint){		if(next != 0L){next->AddLine(thePoint,nextPoint); return;}	next = (LineObj*)D_new(LineObj);	next->DoInit(true,theCrystal,pinned,flags,thePoint,nextPoint);	next->previous = this;	{		Rect resultRect;		Point pt1,pt2;		//gCurrentObj->refreshFlag = true;		//gCurrentObj->DoRefresh();		pt1.h = hor1;		pt1.v = ver1;		pt2.h = hor2;		pt2.v = ver2;		Pt2Rect(pt1,pt2,&resultRect);		InvalRect(&resultRect);	}}short LineObj::NumberOfLines(short count){	count++;	if(next)return next->NumberOfLines(count);	return count;}void LineObj::DeSelectAll(void){	if(next)next->DeSelectAll();	selected = false;}void LineObj::SetSegments(void){	DialogPtr 		theDialog;	short			theSelect;	Boolean			quit,calculateFlag;	if(!selected){		if(next)next->SetSegments();		return;	}	theDialog	= DM_GetNewDialog(SEGMENT_DIALOG,NUL,IN_FRONT);			calculateFlag = quit = false;			SetItemValue( theDialog,3,segments,0);	SelIText(theDialog,3,0,3276);	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case -1:			case 2:				quit = true;				break;			case DLOG_ENTER_OR_CR:			case 1:				calculateFlag = true;					quit = true;				break;			case 3:				break;			default:								break;			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			}	}			if(calculateFlag)		segments	=  GetItemValue( theDialog,3);				DM_DisposDialog(&theDialog);		return;}void LineObj::SetMagnification(void){	}Vector LineObj::GetVector(void){	Vector g;	double segd;	g.x = hor2 - hor1;	g.y = ver2 - ver1;	g.z = 0;	if(segments){		segd = segments;		VectorMultConstant(&g,1/segd);	}	return g;}#pragma segment Mainvoid LineObj::MoveBy(Point delPoint){	hor1 += delPoint.h;	hor2 += delPoint.h;	ver1 += delPoint.v;	ver2 += delPoint.v;	if(flags & ALIGN_PREVIOUS){		if(previous){			previous->hor2 = hor1;			previous->ver2 = ver1;		}else{			LineObj* circle;			circle = GetLast();			circle->hor2 = hor1;			circle->ver2 = ver1;		}	}	if(flags & ALIGN_NEXT){		if(next){			next->hor1 = hor2;			next->ver1 = ver2;		}else{			LineObj* circle;			circle = GetFirst();			circle->hor1 = hor2;			circle->ver1 = ver2;		}	}	}#pragma segment Mainvoid LineObj::MoveAllBy(Point delPoint){	if(next)next->MoveAllBy( delPoint);	hor1 += delPoint.h;	hor2 += delPoint.h;	ver1 += delPoint.v;	ver2 += delPoint.v;}