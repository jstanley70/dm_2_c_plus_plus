//ces.Jim:GraphicsObj:G_TextObjRound.c#include	"Diffract_INCs.h"#include	"TextObj.h"TextRoundObj* TextRoundObj::CreateObject(void){	return (TextRoundObj*)D_new(TextRoundObj);}void	TextRoundObj::Draw(Boolean flag){	Point thePoint,aPoint;	double 	x,y,distance,cX,cY;	double 	angle,centerDisk,value,delH,delV;	short 	startX,startY;	Boolean		redraw = false;	Boolean		flagTooBig;	PenNormal();	if(!flag){		SetMarqueePattern(NUL);		PenMode(patXor);		redraw = true;	}		thePoint.h = (theSpotRect.left + theSpotRect.right) / 2;	if(thePoint.h == 0){		 return;	}//	gCurrentObj->ObjRectToLocal(&theSpotRect);//	gCurrentObj->ObjRectToLocal(&lineRect);	thePoint.h = (theSpotRect.left + theSpotRect.right) / 2;	thePoint.v = (theSpotRect.bottom + theSpotRect.top) / 2;	if(!flag) dm_FrameRect(&theSpotRect);	flagTooBig = false;	if(lineRect.right == lineRect.left && lineRect.bottom == lineRect.top){		startX = lineRect.left ;		startY = lineRect.top ;		flagTooBig = true;	}else{		double	length;		distance = (lineRect.left - lineRect.right) / 2;		cX = (lineRect.left + lineRect.right) / 2;		cY = (lineRect.top + lineRect.bottom) / 2;				x =  thePoint.h - cX;		y =  thePoint.v - cY;		length = sqrt(x * x + y * y);		angle = atan2(y / length,x / length);		angle -= (PI / 2.0);		startX = distance * sin(angle)  + cX;		startY = -distance * cos(angle)  + cY;	}	aPoint.h = startX;	aPoint.v = startY;	if(!flagTooBig){		//this section puts the end of the line at the intersection of the spotrect and		//the limit oval if aPoint is outside the limiting oval		aPoint.v = startY;		delH = aPoint.h - gCurrentObj->centerX;		delV = aPoint.v - gCurrentObj->centerY;		centerDisk 		= 	(gCurrentObj->centerDisk.right - gCurrentObj->centerDisk.left)/2;						value					=	  sqrt(delH * delH + delV * delV);		if(value >= centerDisk - 1 ){			Point cPoint,bPoint;			Rect centerRect;			double valueA,valueB;			//lineRect.right = lineRect.left = aPoint.h;			//lineRect.top = lineRect.bottom = aPoint.v;			centerRect = gCurrentObj->centerDisk;			bPoint =  IntersectionOvals(lineRect,centerRect);			cPoint =  IntersectionOvals(centerRect,lineRect);			delH = bPoint.h - thePoint.h;			delV = bPoint.v - thePoint.v;			valueB					=	 delH * delH + delV * delV;			delH = cPoint.h - thePoint.h;			delV = cPoint.v - thePoint.v;			valueA					=	 delH * delH + delV * delV;			if(valueB < valueA)				aPoint = bPoint;			else				aPoint = cPoint;		}	}	MoveTo(aPoint.h,aPoint.v);		LineTo(thePoint.h,thePoint.v);	if(!flag && redraw){		Delay(2,&gLongScratch);		MoveTo(aPoint.h,aPoint.v);		LineTo(thePoint.h,thePoint.v);		dm_FrameRect(&theSpotRect);	}		thePoint.h = (theSpotRect.left + theSpotRect.right) / 2;	thePoint.v = theSpotRect.bottom - 3;			if(flag)inherited::DrawIndex(thePoint);		PenNormal();	//gCurrentObj->LocalRectToObj(&theSpotRect);	//gCurrentObj->LocalRectToObj(&lineRect);}void TextRoundObj::MoveAll(Point delPoint){	if(next != 0)		next->		MoveAll(delPoint);	if(lineRect.left == 0 && lineRect.right == 0 && lineRect.bottom == 0 && lineRect.top == 0)		return;	OffsetRect		(&theSpotRect,delPoint.h,delPoint.v);	/*if(lineRect.right == lineRect.left && lineRect.bottom == lineRect.top){		lineRect.left +=  delPoint.h;		lineRect.top += delPoint.v;	}else*/	OffsetRect		(&lineRect,delPoint.h,delPoint.v);	return;}