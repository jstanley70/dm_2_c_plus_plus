//ces.Jim:GraphicsObj:G_Pict_Obj.c#include	"Diffract_INCs.h"#include	"GraphFunction.h"#define		OWNER_OBJ	((DiffractObject*)owner)enum	{ 	TRACK_INIT = -1,					TRACK_MOVE,			TRACK_COMPLETE		};				void		PictObj::DoInit(Handle theOwnerObj){	thePict 	= (PicHandle)NUL;	plottedPict/*thePict*/ = (PicHandle)NUL;	owner		= theOwnerObj;	selected	= false;	nextObj 	= (PictObj*)NUL;	numericData	=	(Ptr)0L;	SetRect(&thePictRect,0,0,0,0);}void		PictObj::DoClose(void){	if(nextObj != (PictObj*)NUL)		nextObj->DoClose();	if(plottedPict/*thePict*/ != (PicHandle)NUL) {/*dec 1992 careful closing, wonder if we should do for pictures & menus what you've done for handles*/		KillPicture(plottedPict);		plottedPict/*thePict*/ = 0L;	}		if(thePict != (PicHandle)NUL) {		KillPicture(thePict);		thePict = 0L;	}	if(numericData != (Ptr)NUL){		KillPtr(numericData);		numericData = 0L;	}	D_delete(this);}void		PictObj::AddPictObj(PicHandle newPic,Rect* picRect){	OSErr iErr;	plottedPict/*thePict*/ 			= newPic;	iErr = HandToHand((Handle*)(&plottedPict/*thePict*/));	if(iErr){		FlagMemError(13);	}	thePict		=	newPic;	iErr = HandToHand((Handle*)(&thePict));//just a backup copy of the pict for transfer purposes	if(iErr){		FlagMemError(13);	}	thePictRect 		= *picRect;	nextObj 			= OWNER_OBJ->picObjList;	OWNER_OBJ->picObjList	= this;	OWNER_OBJ->InvalTheRect(&thePictRect);	selected = true;	//DrawPicture(plottedPict,&thePictRect);	ConvertPictToNewTransferMode();	OWNER_OBJ->refreshFlag = true;	OWNER_OBJ->DoRefresh();	DrawSelected();}void		PictObj::DoMove(Point	startPoint)  /* start point is in obj coords */{	if(selected){		Point	thisPoint,lastPoint;		Boolean	moved = false;		short	currentCursor;			currentCursor = OWNER_OBJ->theCursorID;		OWNER_OBJ->SetTheCursor(0);			OWNER_OBJ->ObjToLocal(&startPoint);		DoTrack(startPoint,TRACK_INIT);		lastPoint = startPoint;		gTheRect  = thePictRect;		PenMode(srcXor);		while(StillDown()){			GetMouse(&thisPoint);			if(!EqualPt(thisPoint,lastPoint)){				lastPoint = thisPoint;				gTheRect  = thePictRect;				SubPt(startPoint,&thisPoint);				DoTrack(thisPoint,TRACK_MOVE);				moved = true;			}			}		if(moved){			DoTrack(startPoint,TRACK_COMPLETE);		}		PenNormal();		OWNER_OBJ->SetTheCursor(currentCursor);	} else if(nextObj != (PictObj*)NUL){		nextObj->DoMove(startPoint);	}}void		PictObj::DoTrack(Point	movement,short command){	if(selected){		switch(command){			case	TRACK_INIT:					moveRect = thePictRect;				break;				case	TRACK_MOVE:				OWNER_OBJ->FrameTheRect(&moveRect);				moveRect = thePictRect;				OffsetRect(&moveRect,movement.h,movement.v);				OWNER_OBJ->FrameTheRect(&moveRect);				break;			case	TRACK_COMPLETE:				OWNER_OBJ->EraseTheRect(&thePictRect);				OWNER_OBJ->InvalTheRect(&thePictRect);				thePictRect = moveRect;				OWNER_OBJ->InvalTheRect(&thePictRect);				break;			default:				break;		}	}	if(nextObj != (PictObj*)NUL){		nextObj->DoTrack(movement,command);	}}PictObj*	PictObj::DoSelect(Point	startPoint){	if(PtInRect(startPoint,&thePictRect)){			if(!selected){			//PenMode(srcXor);			//OWNER_OBJ->FrameTheRect(&thePictRect);			//OWNER_OBJ->DMForeColor(15);			//OWNER_OBJ->DMForeColor(COMPLEMENT_COLOR);		//OWNER_OBJ->DMBackColor(BACKGROUND_COLOR);			OWNER_OBJ->STDTheRectMarquee(&thePictRect);			//OWNER_OBJ->DMForeColor(COMPLEMENT_COLOR);		//OWNER_OBJ->DMBackColor(BACKGROUND_COLOR);			//OWNER_OBJ->DMForeColor(14);			PenNormal();			selected = true;			if(nextObj != (PictObj*)NUL){				nextObj->DoSelect(startPoint);			}			gTheSelection->Reset(NUL);			return this;		}		return this;	} else {		if(gShifted){			if(nextObj != (PictObj*)NUL){				if(nextObj->DoSelect(startPoint)){					return (nextObj->DoSelect(startPoint));				}			}			if(selected)return this;			else return 0L;		}else if(selected){			OWNER_OBJ->EraseTheFrame(&thePictRect);			selected = false;			return 0L;		}		if(nextObj != (PictObj*)NUL){			return(nextObj->DoSelect(startPoint));		}		return 0L;	}}PictObj*	PictObj::SelectPictObj(PictObj	*theP){	if(theP == this){		if(!selected){			//PenMode(srcXor);			//OWNER_OBJ->FrameTheRect(&thePictRect);			//OWNER_OBJ->DMForeColor(15);			//OWNER_OBJ->DMForeColor(COMPLEMENT_COLOR);		//OWNER_OBJ->DMBackColor(BACKGROUND_COLOR);			OWNER_OBJ->STDTheRectMarquee(&thePictRect);			//OWNER_OBJ->DMForeColor(14);			PenNormal();		}			selected = true;		return this;	} else {		selected = false;		return 0L;	}}			void			PictObj::ClearSelects(void){		if(nextObj != (PictObj*)NUL)		nextObj->ClearSelects();			if(selected){		OWNER_OBJ->EraseTheFrame(&thePictRect);		selected = false;	}}void			PictObj::DrawSelected(void){		if(nextObj != (PictObj*)NUL)		nextObj->DrawSelected();			if(selected){		PenNormal();		//OWNER_OBJ->DMForeColor(COMPLEMENT_COLOR);		//OWNER_OBJ->DMBackColor(BACKGROUND_COLOR);		//PenMode(srcXor);	//	OWNER_OBJ->FrameTheRect(&thePictRect);		//OWNER_OBJ->DMForeColor(15);		//OWNER_OBJ->DMForeColor(COMPLEMENT_COLOR);		//OWNER_OBJ->DMBackColor(BACKGROUND_COLOR);		OWNER_OBJ->STDTheRectMarquee(&thePictRect);		//OWNER_OBJ->DMForeColor(14);		PenNormal();	}}PictObj* 			PictObj::GetSelected(void){	if(selected){return this;}	if(nextObj != (PictObj*)NUL){		return nextObj->GetSelected();	}return 0L;}void			PictObj::DrawThePicts(void){	RgnHandle theRgn;	GrafPtr   thePort;	if(nextObj != (PictObj*)NUL)		nextObj->DrawThePicts();	GetPort(&thePort);	theRgn = SetClipToPort(thePort,0,0,0,0);	DrawPicture(plottedPict,&thePictRect);	D_DisposeRgn(&theRgn);}void			PictObj::DoFileWrite(short	numPicts){		if(nextObj == (PictObj*)NUL){		gTheFile->WriteShort(numPicts);	} else {		nextObj->DoFileWrite(++numPicts);	}	gTheFile->WriteDataBlock((Ptr)&thePictRect,sizeof(Rect));//	gTheFile->WriteHandle((Handle)thePict);	gTheFile->WriteHandle((Handle)plottedPict);}	void			PictObj::DoFileRead(short count){	OSErr iErr;	PicHandle savedPict;	count--;	if(count > 0){		nextObj = (PictObj*)D_new(PictObj);		nextObj->DoInit(owner);		nextObj->DoFileRead(count);	}		//thePict = (PicHandle)D_TempNewHandle(100,&gTheOSError);	gTheFile->ReadDataBlock((Ptr)&thePictRect,sizeof(Rect));	savedPict = (PicHandle)D_NewHandle(10 * sizeof(char));	gTheFile->ReadHandle((Handle)savedPict);	if(plottedPict)KillPicture(plottedPict);	plottedPict = savedPict;	//all these machinations so that the images is not stored as a d_Handle(DM error checking)	iErr = HandToHand((Handle*)(&plottedPict));//just a backup copy of the pict for transfer purposes	if(iErr){		FlagMemError(13);	}	KillHandle((Handle*)&savedPict);			if(thePict)KillPicture(thePict);	thePict		=	plottedPict;	iErr = HandToHand((Handle*)(&thePict));//just a backup copy of the pict for transfer purposes	if(iErr){		FlagMemError(13);	}}	PictObj*			PictObj::KillSelected(void){	PictObj*  tempObj;	RgnHandle theRgn;	if(nextObj != (PictObj*)NUL){		nextObj = nextObj->KillSelected();	}	if(selected){		tempObj = nextObj;		OWNER_OBJ->InvalTheRect(&thePictRect);		theRgn = SetClipToPort(FrontWindow(),0,OWNER_OBJ->rulerHeight,0,0);		EraseRect(&thePictRect);		//KillPicture(thePict);		if(plottedPict)		KillPicture(plottedPict);		if(thePict != (PicHandle)NUL) {			KillPicture(thePict);			thePict = 0L;		}		D_DisposeRgn(&theRgn);		D_delete(this);		return tempObj;	}	return this;}				void				PictObj::SelectAll(void){	if(nextObj != (PictObj*)NUL){		nextObj->SelectAll();	}	if(!selected){			//OWNER_OBJ->DMForeColor(15);			//OWNER_OBJ->DMForeColor(COMPLEMENT_COLOR);		//OWNER_OBJ->DMBackColor(BACKGROUND_COLOR);			OWNER_OBJ->STDTheRectMarquee(&thePictRect);			//OWNER_OBJ->DMForeColor(14);	//	PenMode(srcXor);	//	OWNER_OBJ->FrameTheRect(&thePictRect);		PenNormal();		selected = true;	}}			void				PictObj::NudgeLeft(void){	short		shift,ierr;		if(nextObj != (PictObj*)NUL){		nextObj->NudgeLeft();	}	if(selected){		if(gShifted){			shift = -5;		} else {			shift = -1;		}				OffsetRect(&thePictRect,shift,0);		ierr = PostEvent(keyDown,'r');		((EvQEl*)((GetEvQHdr())->qTail))->evtQModifiers = cmdKey;	}}void				PictObj::NudgeRight(void){	short		shift,ierr;		if(nextObj != (PictObj*)NUL){		nextObj->NudgeLeft();	}	if(selected){		if(gShifted){			shift = 5;		} else {			shift = 1;		}				OffsetRect(&thePictRect,shift,0);		ierr = PostEvent(keyDown,'r');		((EvQEl*)((GetEvQHdr())->qTail))->evtQModifiers = cmdKey;	}}void				PictObj::NudgeUp(void){	short		shift,ierr;		if(nextObj != (PictObj*)NUL){		nextObj->NudgeLeft();	}	if(selected){		if(gShifted){			shift = -5;		} else {			shift = -1;		}				OffsetRect(&thePictRect,0,shift);		ierr = PostEvent(keyDown,'r');		((EvQEl*)((GetEvQHdr())->qTail))->evtQModifiers = cmdKey;	}}void				PictObj::NudgeDown(void){	short		shift,ierr;		if(nextObj != (PictObj*)NUL){		nextObj->NudgeLeft();	}	if(selected){		if(gShifted){			shift = 5;		} else {			shift = 1;		}				OffsetRect(&thePictRect,0,shift);		ierr = PostEvent(keyDown,'r');		((EvQEl*)((GetEvQHdr())->qTail))->evtQModifiers = cmdKey;	}}		void				PictObj::DoIdle(void){	static short	patNum;		if(nextObj != (PictObj*)NUL){		nextObj->DoIdle();	}	if(selected){		//SetMarqueePattern(&patNum);	//	OWNER_OBJ->FrameTheRect(&thePictRect);	//OWNER_OBJ->DMForeColor(15);//	OWNER_OBJ->DMForeColor(COMPLEMENT_COLOR);//		OWNER_OBJ->DMBackColor(BACKGROUND_COLOR);			OWNER_OBJ->STDTheRectMarquee(&thePictRect);			//OWNER_OBJ->DMForeColor(14);		PenNormal();	}}																								