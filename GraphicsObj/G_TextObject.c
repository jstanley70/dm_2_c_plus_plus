//ces.Jim:GraphicsObj:G_TextObject.c#include	"Diffract_INCs.h"#include	"TextObject.h"void	TextObject::DeactivateAll(void){	Rect  theRect;	LocalizeTextRects();	if(nextText != 0L)		(nextText)->DeactivateAll();			if(active && textFlag){		TEDeactivate(hTE);		theRect = viewRect;		((DiffractObject*)theOwner)->ObjRectToLocal(&theRect);		InsetRect(&theRect,-1,-1);		InvalRect(&theRect);		EraseRect(&theRect);	}	active = false;	return;}TextObject* TextObject::GetActive(void){	LocalizeTextRects();	if(!active){		if(nextText != 0L){			return (nextText)->GetActive();		}else{			return 0L;		}	}	return this;}void TextObject::SetText(Point thePoint){	FontInfo 	theFont;	short 		textHeight;			GetFontInfo(&theFont);	gCurrentObj->LocalToObj(&thePoint);	textHeight = theFont.ascent + theFont.descent + theFont.leading;	SetRect(&destRect,thePoint.h,thePoint.v - textHeight * .5,thePoint.h + 20,thePoint.v + textHeight * .5);	viewRect = destRect;		(*hTE)->viewRect = viewRect;	(*hTE)->destRect = destRect;	LocalizeTextRects();	if(textFlag)TEClick				(thePoint,gShifted,hTE);	if(textFlag)TEActivate			(hTE);	if(textFlag)TESetStyle			(doAll,&((DiffractObject*)gCurrentObj)->theTextSystem->theStyle,false,hTE);			active 			= 	true;	return;}TextObject* TextObject::Add(Point thePoint,void* owner,short theType){		LocalizeTextRects();	while(nextText != 0L && (*hTE)->teLength != 0){		return (nextText)->Add(thePoint,owner,theType);	}	if((*hTE)->teLength == 0){		SetText(thePoint);		return this;	}else{		nextText  = (TextObject*)D_new(TextObject);		nextText->InitText(thePoint, owner,theType,direction,theCrystal);		return nextText;	}	}void TextObject::InitText(Point thePoint,void* owner,short theType,Boolean dirFlag,Crystal *aCrystal){	Rect theRect;		type = theType;	switch(theType){		case ORIGIN:		case REG_POINT:		textFlag = false;		break;		case ASPECT_RATIO:		case TEXT_POINT:		textFlag = true;		break;	}	theOwner 		= 		owner;		nextText		=		0L;	DoInit(dirFlag,aCrystal);		SetRect					(&theRect,0,0,0,0);	hTE 			= 		TEStylNew(&theRect,&theRect);	InvalRect(&theRect);	TESetJust				(localJust,hTE);	TESetStyle				(doAll,&((DiffractObject*)gCurrentObj)->theTextSystem->theStyle,false,hTE);	//SetChars((char*)"\p ");//thePoint.h = -10;//	thePoint.v = -10;	SetText					(thePoint);	DrawText();	active = true;}TextObject* TextObject::DeleteObject(TextObject *theObj,TextObject *previousObj){	TextObject	*theObjNext;	if((long)theObj == (long)this){		if((long)theObj == (long)previousObj){			if((long)(theObj)->nextText != 0L){				theObjNext = nextText;				this->Kill();				return theObjNext;			}else{				this->SetChars((char*)"\p");				active = false;				return this;			}					}else{			(previousObj)->nextText = this->nextText;			this->Kill();			return 0L;		}	}else if(nextText != 0L){		return (nextText)->DeleteObject(theObj,this);	}	return 0L;}void TextObject::KillAll(void){	if(nextText != 0L){		(nextText)->KillAll();	}		if(hTE != 0L){		TEDispose(hTE);		hTE = 0L;	}	nextText = 0L;	D_delete(this);}void TextObject::Kill(void){	EraseObject();	if(hTE != 0L){		if(HGetState((Handle)hTE) == 0){			if(active)TEDeactivate(hTE);			TEDispose(hTE);		}		hTE = 0L;	}	D_delete(this);	}void	TextObject::FrameText(void){	Rect		theRect;	if(gCurrentObj->printing) return;	PenMode(0);	LocalizeTextRects();	theRect 	= viewRect;		//InsetRect	(&theRect,-1,-1);	gCurrentObj->STDTheRectMarquee(&theRect);	PenNormal();	}void TextObject::SetStyle(short font,short size,short justify,short style,RGBColor theColor){		TextStyle	theStyle;		LocalizeTextRects();	TESetJust(justify,hTE);	theStyle.tsFace = style;	theStyle.tsColor = theColor;	theStyle.tsSize = size;	theStyle.tsFont = font;	((DiffractObject*)gCurrentObj)->theTextSystem->theStyle = theStyle;	TESetStyle		(doAll,&theStyle,true,hTE);}void TextObject::ResetViewRect(void){		Point 	maxPoint;	Point 	thePt,charPt;	short 	length,i,j;	Str255 	theString;	short		charW,bottom = 0,right = 0;	TextStyle	aStyle;	short		ascent,lineHeight;		LocalizeTextRects();	  	GetIText((*hTE)->hText,theString);	length = theString[0];		maxPoint.h = (*hTE)->viewRect.right;	maxPoint.v = (*hTE)->viewRect.bottom;	bottom		= 0;				j = ((*hTE)-> selEnd);		charPt = TEGetPoint(j,hTE);	TEGetStyle(j,&aStyle,&lineHeight,&ascent,hTE);	TextFont(aStyle.tsFont);	TextSize(aStyle.tsSize);	TextFace(aStyle.tsFace);			charW = CharWidth(gTheText[0]);	maxPoint.h = 2 * charW + (*hTE)->viewRect.left;		i = 1;	while(i < length){						while(theString[i] != 13 && i < length) i++;		if(i == length && theString[i] != 13) j = i; else j = i - 1;		i++;		thePt = TEGetPoint(j,hTE);				TEGetStyle(j,&aStyle,&lineHeight,&ascent,hTE);		TextFont(aStyle.tsFont);		TextSize(aStyle.tsSize);		TextFace(aStyle.tsFace);				if(thePt.h + charW + CharWidth(theString[j]) > maxPoint.h){			maxPoint.h 	= thePt.h + charW + CharWidth(theString[j]);			bottom 		= thePt.v;		}		if(charPt.v == thePt.v) right = thePt.h + charW + CharWidth(theString[j]) + 2;			}	thePt = TEGetPoint(length,hTE);	maxPoint.v = thePt.v;	if(gTheText[0] == 13 || theString[length] == 13)	{		TEGetStyle(length,&aStyle,&lineHeight,&ascent,hTE);		maxPoint.v += lineHeight;	}		if(bottom != charPt.v && right > maxPoint.h){		maxPoint.h = right;	}		TEGetStyle(length,&aStyle,&lineHeight,&ascent,hTE);	if(lineHeight >  maxPoint.v - (*hTE)->viewRect.top) 		maxPoint.v = lineHeight + viewRect.top;		SetRect(&viewRect,(*hTE)->viewRect.left,(*hTE)->viewRect.top,maxPoint.h + 4,maxPoint.v);	((DiffractObject*)theOwner)->LocalRectToObj(&viewRect);	destRect = viewRect;	JustifyObject();		DrawText();	TextFont(0);	TextSize(0);	TextFace(0);	}void TextObject::SetColor(short theItem,RGBColor *theColor){	LocalizeTextRects();	TextMode(gCurrentObj->gMode);	if(theItem <= 0) theItem = 1;	if(!g_Monitor){		if(theItem == 1){			gCurrentObj->DMForeColor/*PMForeColor*/(BLACK);			PenPat(&qd.black);			PmBackColor(WHITE);			return;		}		if(theItem == 2){			gCurrentObj->DMForeColor/*PMForeColor*/(WHITE);			PmBackColor(BLACK);			PenPat(&qd.white);			return;		}		theItem = 1;		gCurrentObj->DMForeColor/*PMForeColor*/(BLACK);		PmBackColor(WHITE);		PenPat(&qd.black);		return;	}	if(theItem == 1){		gCurrentObj->DMForeColor/*PMForeColor*/(BLACK);		GetEntryColor(GetPalette(((DiffractObject*)gCurrentObj)->theWindow),BLACK,theColor);		return;	}	if(theItem == 2){		gCurrentObj->DMForeColor/*PMForeColor*/(WHITE);		GetEntryColor(GetPalette(((DiffractObject*)gCurrentObj)->theWindow),WHITE,theColor);		return;	}		if(theItem < 7){		RGBColor **aColor;		theItem += 497;		aColor = (RGBColor**)GetResource('COLR',theItem);		*theColor = **aColor;		ReleaseResource((Handle)aColor);		PmBackColor(BACKGROUND_COLOR);		return;	}	gCurrentObj->DMForeColor/*PMForeColor*/(BLACK);	PmBackColor(BACKGROUND_COLOR);	GetEntryColor(GetPalette(( (DiffractObject*)gCurrentObj)->theWindow),BLACK,theColor);}Boolean TextObject::DoTScrap(short	theItem){	TextObject *theTextObj;	Boolean			flag = 0;	if(!textFlag)return false;	LocalizeTextRects();	if(active && ((DiffractObject*)gCurrentObj)->theTextSystem->textOn){		switch(theItem){			case CUT:				TECut(hTE);				flag = 1;				break;			case COPY:				TECopy(hTE);				flag = 1;				break;			case PASTE:				((*hTE)->destRect).right += 400;				((*hTE)->destRect).bottom += 400;				TEPaste(hTE);							flag = 1;				break;			case DO_CLEAR:				TEDelete(hTE);				break;			default:				break;		}		gTheText[0] = 0;		ResetViewRect();	}else if(active){		switch(theItem){			case CUT:				TESetSelect(0,32767,hTE);				TECut(hTE);				TESetSelect(0,0,hTE);				(*hTE)->teLength = 0;				EraseObject();				SetRect(&viewRect,0,0,0,0);				(*hTE)->viewRect = viewRect;				(*hTE)->destRect = viewRect;				flag = 1;				break;			case COPY:				TESetSelect(0,32767,hTE);				TECopy(hTE);				TESetSelect(0,0,hTE);				flag = 1;				break;			case PASTE:				{						Rect  theRect;					Point	thePoint;					TEHandle theHTE;										thePoint.h = -10;					thePoint.v = -10;					theTextObj = Add(thePoint,theOwner,TEXT_POINT);										theRect = viewRect;					OffsetRect(&theRect,20,viewRect.bottom - viewRect.top + 10);										theTextObj->viewRect = theRect;					theTextObj->destRect = theRect;					theHTE = theTextObj->hTE;					(*theHTE)->viewRect = viewRect;	  				(*theHTE)->destRect = viewRect;						TEPaste			(theTextObj->hTE);					gTheText[0] = 0;										theTextObj->	ResetViewRect();				}				flag = 1;				break;			case DO_CLEAR:				(*hTE)->teLength = 0;				InsetRect(&viewRect,-1,-1);				EraseObject();				SetRect(&viewRect,0,0,0,0);				(*hTE)->viewRect = viewRect;				(*hTE)->destRect = viewRect;				flag = 1;				break;			default:				break;	}	}	LocalizeTextRects();	return flag;}void	TextObject::DoKey(char	theChar){	Point	thePoint;	TextObject *pointObj,*aPoint,*nextPoint;	LocalizeTextRects();	if(active){			thePoint.h = thePoint.v = 0;		switch(theChar)		{			case '\35':			thePoint.h = 1;			MoveBy( thePoint);			/*RelocateText(thePoint);			DrawText();*/			return;						case '\34':			thePoint.h = -1;			/*RelocateText(thePoint);			DrawText();*/			MoveBy( thePoint);			return;						case '\36':			thePoint.v = -1;			/*RelocateText(thePoint);			DrawText();*/			MoveBy( thePoint);			return;						case '\37':			thePoint.v = 1;			/*RelocateText(thePoint);			DrawText();*/			MoveBy( thePoint);			return;													default:				break;		}	}	if(theChar == '	'){		pointObj = GetActive();		if(pointObj->textFlag == false)return;		InvalRect(&pointObj->viewRect);		if(pointObj == 0L){			active = true;					}else{			pointObj->active = false;			if(textFlag){				//TESetSelect(0,0,pointObj->hTE);				TEDeactivate(pointObj->hTE);			}			pointObj->DrawText();			if(pointObj->nextText != 0L){				nextPoint =  (pointObj->nextText);				aPoint =	nextPoint->GetPointOfType	(pointObj->type);				aPoint->active = true;			}else{				aPoint = 0L;			}			if(aPoint == 0L){				aPoint = GetPointOfType	(pointObj->type);				if(aPoint != 0L)					aPoint->active = true;			}else{				aPoint->active = true;			}		}		pointObj = GetActive();		if(pointObj != 0L){			PenNormal();			PenMode(0);			TextMode(0);			if(textFlag)TEActivate(pointObj->hTE);						if(textFlag)TESetSelect(0,32000,pointObj->hTE);			pointObj->DrawText();		}		return;	}	if(active){		gTheText[0] = theChar;		ResetViewRect();		if(textFlag)TEKey(theChar,hTE);		DrawText();		return;	}		if(nextText != 0L)		(nextText)->DoKey( theChar);	}Boolean TextObject::DoContent(Point thePoint, Boolean *textOn,short theType){	LocalizeTextRects();	if(!PtInObject(thePoint)){		if(active){			active = false;			DrawText();		}		if(nextText != 0L){			return (nextText)->DoContent( thePoint,textOn,theType);		}else{			if(*textOn){				Add( thePoint,theOwner,theType);				return true;			}else{				return false;			}		}	}else{		Rect testRect;		if(!*textOn){			MoveObject(thePoint);			active = true;						return true;		}		testRect = viewRect;		gCurrentObj->ObjRectToLocal(&testRect);		InsetRect(&testRect,2,2);		if(!PtInRect(thePoint,&testRect)){			MoveObject(thePoint);		}		if(!active){			if(textFlag)TEActivate(hTE);		//	FrameText();			active = true;		}		if(textFlag)TESetStyle		(doAll,&((DiffractObject*)gCurrentObj)->theTextSystem->theStyle,false,hTE);		if(textFlag)TEClick			(thePoint,gShifted,hTE);				return true;	}}Boolean TextObject::MoveObject(Point thePoint){	Point 		delPoint;	RgnHandle	theRgn;	long		lDistVH;	Rect		windowRect,tempRect;		if(!Button())		return false;			windowRect 	= (((DiffractObject*)theOwner)->theWindow)->portRect;	windowRect	= FrontWindow()->portRect;	gTheRect 	= windowRect;	InsetRect(&gTheRect,1,1);	theRgn 		= D_NewRgn();		tempRect 	= viewRect;	((DiffractObject*)theOwner)->ObjRectToLocal(&tempRect);	RectRgn (theRgn, &tempRect);			GetMouse(&thePoint);//	EraseObject();	LocalizeTextRects();		lDistVH = DragGrayRgn (theRgn, thePoint, &gTheRect, &windowRect, 0, NUL);	GetMouse(&thePoint);	D_DisposeRgn (&theRgn);		if(lDistVH == 0x80008000)		return false;		delPoint.v = lDistVH >> 16;	delPoint.h = lDistVH & 0x0000FFFF;	RelocateText(delPoint);	LocalizeTextRects();	D_SetClip(((DiffractObject*)theOwner)->drawRgn);	DrawText();	return true;}void	TextObject::EraseObject(){	Rect		theRect;		LocalizeTextRects();	theRect 	= viewRect;	gCurrentObj->ObjRectToLocal(&theRect);	InsetRect	(&theRect,-2,-2);	EraseRect	(&theRect);	InvalRect	(&theRect);}short	TextObject::GetTotalNoObjects(short n){	LocalizeTextRects();	n++;	if(nextText != 0){		return (nextText)->GetTotalNoObjects( n);	}	return n;}void	TextObject::LocalizeTextRects(void){	Rect theRect;	theRect = viewRect;	gCurrentObj->ObjRectToLocal(&theRect);	(*hTE)->viewRect = theRect;	theRect = destRect;		gCurrentObj->ObjRectToLocal(&theRect);	(*hTE)->destRect = theRect;}void	TextObject::DrawAllText(void){		if(nextText != 0L)		(nextText)->DrawAllText();	if(destRect.left == 0 && destRect.right == 0)return;	LocalizeTextRects();	DrawText();}void	TextObject::DrawText(void){	Rect	theRect;	if(!active){		theRect = viewRect;		gCurrentObj->ObjRectToLocal(&theRect);		LocalizeTextRects();		PenNormal();		PenMode(0);		TEActivate(hTE);		if(textFlag)TEUpdate(&theRect,hTE);		TEDeactivate(hTE);	}else{		LocalizeTextRects();		theRect = viewRect;		gCurrentObj->STDTheRectMarquee(&theRect);		PenNormal();		PenMode(0);		TextMode(0);		if(textFlag)TEUpdate(&theRect,hTE);	}}void TextObject::DoIdle(void){	LocalizeTextRects();	if(nextText != 0L)		(nextText)->DoIdle();	if(active){		if(textFlag)TEIdle(hTE);		DrawText();	}}short	TextObject::PtInObject(Point thePoint){	Rect theRect;	LocalizeTextRects();	theRect = viewRect;	GetMouse(&thePoint);	gCurrentObj->ObjRectToLocal(&theRect);	return PtInRect(thePoint,&theRect);}void	TextObject::WriteAll(){	StScrpHandle hStScrap;	short		length;	CharsHandle hChars;		GetIText((*hTE)->hText,pTheText);	if(pTheText[0] <= 1 && nextText == 0L){		gTheFile->WriteShort(0);		return;	}else{		gTheFile->WriteShort(10);	}	hStScrap 	= GetStylScrap(hTE);	length 		= (*hTE)->teLength;	hChars 		= TEGetText(hTE);		gTheFile	->	WriteShort(length);	gTheFile	->	WriteDataBlock	((Ptr)&viewRect,(long)sizeof(Rect));	gTheFile	->	WriteDataBlock	((Ptr)&destRect,(long)sizeof(Rect));	gTheFile	->	WriteHandle		((Handle)hChars);	gTheFile	->	WriteHandle		((Handle)hStScrap);	DisposHandle((Handle)hStScrap);	if(nextText != 0L){				(nextText)->WriteAll();		return;	}	gTheFile->WriteShort(0);	return;	}void	TextObject::ReadAll(){	short 			isNext;	short			length;	StScrpHandle 	hStScrap;	CharsHandle 	hChars;	Point			thePoint;		thePoint.h = thePoint.v = 0; 	isNext = gTheFile->ReadShort();	if(!isNext){		nextText = 0L;		return;	}	hStScrap 	= 	(StScrpHandle)D_NewHandle((long)sizeof(StScrpHandle));	hChars 		= 	(CharsHandle)D_NewHandle((long)sizeof(char));		length 		= 	gTheFile->ReadShort();	gTheFile	->	ReadDataBlock	((Ptr)&viewRect,(long)sizeof(Rect));	gTheFile	->	ReadDataBlock	((Ptr)&destRect,(long)sizeof(Rect));	gTheFile	->	ReadHandle		((Handle)hChars);	gTheFile	->	ReadHandle		((Handle)hStScrap);		(*hTE)->viewRect = viewRect;	(*hTE)->destRect = destRect;	TEStylInsert((Ptr)*hChars,(long)length,hStScrap,hTE);	KillHandle((Handle*)&hChars);	KillHandle((Handle*)&hStScrap);		active = false;		Add(thePoint,theOwner,TEXT_POINT);		(nextText)->active = false;	(nextText)->ReadAll();		}float* TextObject::GetValues(){	short 	i = 0,kk = 0,j = 0,hklMarker = 0;	short	testType;	char 	theText[254];	float	*thePtr;	short	unitOfMeasure = 0;		GetChars(gTheText);	thePtr = (float*)D_NewPtr(sizeof(float) * 10);		while(gTheText[i] != 0){		switch(gTheText[i]){ 			case '-':			case '1':			case '2':			case '3':			case '4':			case '5':			case '6':			case '7':			case '8':			case '9':			case '0':			case '.':			case '\332':			case '\333':			case '\334':			case '\335':			case '\336':			case '\337':			case '\338':			case '\339':			case '\340':			case '\341':				theText[kk++] = gTheText[i];			break;			case 'n':				if(gTheText[i + 1] == 'm'){										i++;				}				unitOfMeasure = 2;				break;			case 'm':				if(gTheText[i + 1] == 'm'){					unitOfMeasure = 3;					i++;				}else{					unitOfMeasure = 5;				}				break;			case 'c':				if(gTheText[i + 1] == 'm'){										i++;				}				unitOfMeasure = 4;				break;			case '':				if(gTheText[i + 1] == '-'){					unitOfMeasure = 6;					i++;					if(gTheText[i + 1] == '1')i++;				}else{					unitOfMeasure = 1;				}				break;			case ']':			case '}':			case ')':			case '>':				if(unitOfMeasure == 7 && hklMarker == 0){					theText[kk++] = 0;					c2pstr(theText);					IndexFromText(theText);				}else{					theText[kk++] = 0;					l = atof(theText);				}				break;			case '[':			case '{':			case '(':			case '<':				unitOfMeasure = 7;				break;			case ' ':				break;			default:				theText[kk] = 0;				if(unitOfMeasure == 7){					switch(hklMarker){						case 0:							h = atof(theText);							break;						case 1:							k = atof(theText);							break;						case 2:							l = atof(theText);							break;					}										hklMarker++;					kk = 0;					break;				}								thePtr[j++] = atof(theText);				kk = 0;				if(j > 9)					return thePtr;				break;		}		i++;	}	testType = type / 100;	type -= testType * 100;	type += unitOfMeasure * 100;	if(kk > 0){		theText[kk] = 0;		thePtr[j++] = atof(theText);	}	return thePtr;}char* TextObject::GetChars(char *theChars){	Str255 theString;	GetIText((*hTE)->hText,theString);	p2cstr((unsigned char*)theString);	strcpy(theChars,(char*)theString);		return theChars;}void TextObject::SetChars(char *theChars){	TextStyle	theStyle;	short		width;		LocalizeTextRects();	theStyle = ((DiffractObject*)gCurrentObj)->theTextSystem->theStyle;	TextFont(theStyle.tsFont);	TextSize(theStyle.tsSize);	TextFace(theStyle.tsFace);	width = StringWidth(c2pstr(theChars));	EraseObject();	SetRect(&viewRect,viewRect.left,viewRect.top,viewRect.left + width + 10,viewRect.bottom);		JustifyObject();		TESetText(&theChars[1],(long)theChars[0],hTE);	ResetViewRect();	TEActivate(hTE);	DrawText();}void TextObject::JustifyObject(void){	Point	thePoint;		destRect		= viewRect;	(*hTE)->viewRect = viewRect;	(*hTE)->destRect = viewRect;	thePoint.h = thePoint.v = 0;	LocalizeTextRects();}void TextObject::DoCleanUp(void){	TextObject *theText;	LocalizeTextRects();	if(nextText != 0L){		if((nextText)->hTE == 0L || (*(nextText)->hTE)->teLength == 0){			if((nextText)->hTE != 0L){				if(active){					TEDeactivate((nextText)->hTE);					TEDispose((nextText)->hTE);									}else{					TEDispose((nextText)->hTE);				}				(nextText)->hTE = 0L;			}			theText = (nextText)->nextText;			D_delete(nextText);			nextText = theText;		}		if(nextText != 0L)			(nextText)->DoCleanUp();	}}void TextObject::PrintAllText(GrafPtr thePrintPort,Point thePoint){	short 			x,y,lineHeight,numChars,i,count;	FontInfo 		fInfo;	unsigned char*	theText;		if(nextText != 0L)		(nextText)->PrintAllText(thePrintPort,thePoint);			PenNormal();	GetIText((*hTE)->hText,pTheText);	if((*hTE)->txSize < 0){		TextStyle	theStyle;		short		lineHeight,ascent;		TEGetStyle (1, &theStyle, &lineHeight, &ascent, hTE);		TextFace (theStyle.tsFace);		TextFont (theStyle.tsFont);		TextSize (theStyle.tsSize);	} else {		TextFace ((*hTE)->txFace);		TextFont ((*hTE)->txFont);		TextSize ((*hTE)->txSize);	}	TextMode (srcOr);	GetFontInfo (&fInfo);	lineHeight = fInfo.ascent + fInfo.descent + fInfo.leading;		numChars 	= (short)pTheText[0];	theText 	= pTheText;	count 		= 0;	y 			= viewRect.top + lineHeight - fInfo.descent;	for(i = 1 ; i <= (numChars + 1); i++){		if(pTheText[i] == (unsigned char)13 || i > numChars){			theText[0] = (unsigned char)count;			switch((*hTE)->just){				case -1:					x = viewRect.right - StringWidth(theText);					break;				case 0:					x = viewRect.left;					break;				case 1:					x = (viewRect.right + viewRect.left - StringWidth(theText)) / 2;					break;				default:					break;			}			MoveTo(x,y);			DrawDiffractString(theText);			theText = &pTheText[i];			y += lineHeight;			count = 0;		} else {			count++;		}	}				return;		/****** This stuff was removed  			oldPort = (*hTE)->inPort;	(*hTE)->inPort = thePrintPort;	TEUpdate(&viewRect,hTE);	(*hTE)->inPort = oldPort;		return;			RelocateText(thePoint);	DrawText();	(*hTE)->inPort = oldPort;	thePoint.h *= -1;	thePoint.v *= -1;	RelocateText(thePoint);*/}Boolean TextObject::RelocateText(Point thePoint){//	PenState 	thePenState;//	GetPenState(&thePenState);//	PenMode(patXor);//	LocalizeTextRects();//	FrameText();		dm_EraseRect(&viewRect);	dm_EraseRect(&destRect);//	InvalRect(&viewRect);//	InvalRect(&destRect);		OffsetRect(&viewRect,thePoint.h,thePoint.v);	OffsetRect(&destRect,thePoint.h,thePoint.v);  	(*hTE)->viewRect = viewRect;  	(*hTE)->destRect = destRect;  	LocalizeTextRects();//  	SetPenState(&thePenState);  	return true;}