//ces.Jim:GraphicsObj:G_Pict_Obj_Jim.c#include	"GraphFunction.h"#include	"GrabBitData.h"#include	"Diffract_INCs.h"void	PictObj::ZoomAll(double magnification){	if(nextObj != (PictObj*)NUL){		nextObj->ZoomAll(magnification);	}	{		short delH,delV,centerX,centerY;		double delX,delY,centerA,centerB;	delX = (double)(thePictRect.right - thePictRect.left) * magnification / 2.;	delY = (double)(thePictRect.bottom - thePictRect.top) * magnification / 2.;	delH = Round(delX);	delV = Round(delY);	centerA = (double)(thePictRect.right + thePictRect.left) / 2.0;	centerB = (double)(thePictRect.bottom + thePictRect.top) / 2.0;	centerX = Round(centerA);	centerY = Round(centerB);	SetRect(&thePictRect,centerX - delH,centerY - delV,centerX + delH,centerY + delV);	}}#define		OWNER_OBJ	((DiffractObject*)owner)PixMapHandle  PictObj::GetPixelMap(void){	PixMapHandle	thePixMap;	Point	*thePts;	Rect	tempRect,aRect;	if(FrontWindow() == OWNER_OBJ->theWindow){		if(IsValidObj(OWNER_OBJ)){			RgnHandle theRgn;			OWNER_OBJ->DMForeColor(1);			OWNER_OBJ->DMBackColor(0);					thePixMap = NewPixMap();						tempRect  	= thePictRect;			gCurrentObj->ObjRectToLocal(&tempRect);						InsetRect(&tempRect,1,1);			thePts = (Point*)&tempRect;			LocalToGlobal(&(thePts[0]));			LocalToGlobal(&(thePts[1]));			theRgn = D_NewRgn();			GetClip		(theRgn);			aRect = OWNER_OBJ->theWindow->portRect;			thePts = (Point*)&aRect;			LocalToGlobal(&(thePts[0]));			LocalToGlobal(&(thePts[1]));						RectRgn		(gTheRgn,&aRect);			D_SetClip		(gTheRgn);									CopyBits(	(BitMap*)(*thePixMap),						(BitMap*)(*(((CGrafPtr)OWNER_OBJ->theWindow)->portPixMap)),						&tempRect,&tempRect,srcCopy,0L);								OWNER_OBJ->DMBackColor(BACKGROUND_COLOR);						D_SetClip(theRgn);			D_DisposeRgn(&theRgn);					}	}	return thePixMap;}typedef struct ShortSpots{	double	x;	double	y;	double	radius;	double	intensity;}ShortSpots;Handle  PictObj::RadialIntensity(Point centerPt,short *number){	double width,length,radius;	unsigned short *theShort;	double			*radiusValues,**radiusVHdn;	short			i,j;	double			rJ,ri;	long			total;	if(selected){		{			/*This routine sets the center with respect to the picture,			converts the bitmap data to numeric data, and determines minium radius			of the picture*/			if(numericData)KillPtr((Ptr)numericData);			numericData =  (Ptr)GetDataFromPICT(plottedPict/*thePict*/,&rows,&columns,&bitDepth);			if(numericData == 0L)return 0L;			centerPt.h 	-= 	thePictRect.left;			length 		= 	thePictRect.right - thePictRect.left;			width 		= 	thePictRect.bottom - thePictRect.top;			centerPt.v -= 	thePictRect.top;			radius 		= 	centerPt.h;			if(radius > length / 2) radius =  length - centerPt.h;			if(radius > width / 2) radius =  width - centerPt.v;		}		{			 radiusVHdn = (double**)D_NewHandle(radius  * sizeof(double));			 			 if(!HandleIsOK((Handle)radiusVHdn)){			 	KillPtr((Ptr)numericData);			 	numericData = 0L;				return 0L;			}		}		D_HLock(radiusVHdn);				total = radius ;		radiusValues = *radiusVHdn;		for(i = 0; i < total ;i++,radiusValues++)*radiusValues = 0;		radiusValues = *radiusVHdn;		theShort = (unsigned short*)numericData;				theShort = (unsigned short*)numericData;		for(i = 0,ri = -centerPt.v; i < rows;i++,ri += 1){			double testRadius,xSqr;			short	shortRad;			xSqr = (ri * ri);			for(j = 0,rJ = -centerPt.h; j < columns;j++,rJ += 1,theShort++){				testRadius = sqrt(xSqr + (rJ * rJ));				if(testRadius <= radius){										shortRad =  testRadius;					if(shortRad < total){						radiusValues[shortRad] += 256 -((double)*theShort);											}								}							}		}		radiusValues++;		total--;		for(ri = 1; ri <=  total ;radiusValues++,ri++)*radiusValues /= (2 * PI * ri);		radiusValues = *radiusVHdn;		radiusValues[0] = radiusValues[1];		D_HUnlock		(radiusVHdn);		KillPtr			((Ptr)numericData);		numericData = 0L;		return (Handle)radiusVHdn;	} else if(nextObj != (PictObj*)NUL){		return nextObj->RadialIntensity( centerPt, number);	}	return 0L;}Handle PictObj::LineIntensity(Point startPt,Point endPt){	double			length;	unsigned short *theShort;	double			*radiusValues,**radiusVHdn;	short			i,sLength;	long			arrayNo,h,v;	double			rJ,ri,slopeH,slopeV;	Point			thePoint;	if(selected){		if(PtInRect(startPt,&thePictRect) && PtInRect(endPt,&thePictRect))		{			/*This routine sets the center with respect to the picture,			converts the bitmap data to numeric data, and determines minium radius			of the picture*/						numericData =  (Ptr)GetDataFromPICT(plottedPict/*thePict*/,&rows,&columns,&bitDepth);			if(numericData == 0L)return 0L;			startPt.h -= thePictRect.left;			startPt.v -= thePictRect.top;			endPt.h -= thePictRect.left;			endPt.v -= thePictRect.top;			thePoint = endPt;			SubPt(startPt,&thePoint);			ri = thePoint.h;			rJ = thePoint.v;			length = sqrt((ri * ri) + (rJ * rJ));			sLength = (short)length;			theShort = (unsigned short*)numericData;						radiusVHdn = (double**)D_NewHandle((sLength)  * sizeof(double));			 			if(!HandleIsOK((Handle)radiusVHdn)){				KillPtr((Ptr)numericData);				numericData = 0L;				return 0L;			}			D_HLock(radiusVHdn);						radiusValues = *radiusVHdn;			for(i = 0; i < sLength ;i++,radiusValues++)*radiusValues = 0;			radiusValues = *radiusVHdn;			slopeH = thePoint.h;			slopeV = thePoint.v;			slopeH /= length;			slopeV /=  length;			columns++;			for(ri = 0; ri < sLength;ri += 1){				h = Round(ri * slopeH) + startPt.h;				v = Round(ri * slopeV) + startPt.v;				arrayNo = (v * columns) + h;				*radiusValues = 256 - (double)theShort[arrayNo];				radiusValues++;			}			KillPtr((Ptr)numericData);			numericData = 0L;			return (Handle)radiusVHdn;		}	} else if(nextObj != (PictObj*)NUL){		return nextObj->LineIntensity( startPt, endPt);	}	return 0L;}Handle PictObj::IntensityInsideRect(Rect theRect,double *maxIntensity){	unsigned short *theShort,*oldShort;	double			*theValue;	Handle			theValHdn;	short			i,j;	long			arrayNo;	double			rJ,ri;	Point			thePoint,startPt,endPt;	Rect			resultRect;		if(selected){		if(SectRect(&thePictRect,&theRect,&resultRect) && resultRect.left == theRect.left 		&& resultRect.top == theRect.top && resultRect.bottom == theRect.bottom		&& resultRect.right == theRect.right) {					/*This routine returns an array which is the Rect values and the max intensity f			found in the rect.*/						numericData =  (Ptr)GetDataFromPICT(plottedPict/*thePict*/,&rows,&columns,&bitDepth);			if(numericData == 0L)return 0L;			OffsetRect(&theRect, -thePictRect.left,-thePictRect.top);			startPt.h  = theRect.left;			startPt.v  = theRect.top;						endPt.h = theRect.right;			endPt.v = theRect.bottom;						thePoint = endPt;						SubPt(startPt,&thePoint);			ri = thePoint.h + 1;			rJ = thePoint.v + 1;			theValHdn = D_NewHandle(ri * rJ * sizeof(double));			D_HLock(theValHdn);			theValue = (double*)*theValHdn;			columns++;			arrayNo = (startPt.v * (columns)) + startPt.h;			oldShort = (unsigned short*)numericData;			theShort = &(oldShort[arrayNo]);			*maxIntensity = 0;			for(i = startPt.v; i <= endPt.v;i++){				short k;				for(j = startPt.h,k = 0; j <= endPt.h;j++,k++){					*theValue = 256 - (double)theShort[k];					if(*theValue > *maxIntensity)*maxIntensity = *theValue;					theValue++;				}				oldShort 	= theShort;				theShort	= &(oldShort[columns]);			}						D_HUnlock(theValHdn);			KillPtr((Ptr)numericData);			return theValHdn;		}	} else if(nextObj != (PictObj*)NUL){		return nextObj->IntensityInsideRect(theRect,maxIntensity);	}	return 0L;}PictObj*  PictObj::ImageAntiDistortion(float **x,float **y,Point centerPt){		unsigned short 	*dataPtr,						**newData,						*oldData;	double			i,k,l,j;	long 			sizeOf;	long			jj;	OSErr 		iErr;	StartWatch();	if(selected){		if(!PtInRect(centerPt,&thePictRect)){//since this distortion is dependent on distance from 0,0																					//we must supply a center, if the user selected center is outside																					//the picture, we select dead pict center for our 0,0			centerPt.h = (thePictRect.left + thePictRect.right) / 2;			centerPt.v = (thePictRect.top + thePictRect.bottom) / 2;		}				{			/*This routine takes two vectors that correct for radial distortions			 gets the PICT bitmap and then realigns the pixels based on the 			 distortions*/			double a1,a2,b1,b2,a3,b3;									numericData =  (Ptr)GetDataFromPICT(plottedPict/*thePict*/,&rows,&columns,&bitDepth);			if(numericData == 0L)return 0L;		sizeOf = GetPtrSize(numericData);			newData = (unsigned short**)D_NewHandle(sizeOf);			if(newData == 0L){KillPtr(numericData);numericData = 0;return 0L;}			D_HLock((Handle)newData);			dataPtr = *newData;			for(i = 0; i < rows;i++){				for(k = 0; k < columns;k++,dataPtr++){					*dataPtr = 0;				}			}			if(columns % 2)jj = 1;			else jj = 0;			centerPt.h -= thePictRect.left;			centerPt.v -= thePictRect.top;			dataPtr = 	(unsigned short*)*newData;			oldData	=	(unsigned short*)numericData;						a1 = x[1][1];			a2 = x[2][1];			a3 = x[3][1];									b1 = y[1][1];			b2 = y[2][1];			b3 = y[3][1];						for(i = -centerPt.v; i < rows - centerPt.v;i++)			{				double xdis,ydis;				long value;				xdis = i * a2 + centerPt.h;				ydis = i * b2 + centerPt.v;				for(j = -centerPt.h; j < columns - centerPt.h + jj;j++){					unsigned short 	*testPt;					long			n,m;									k = xdis + j * a1 + (i * j * a3);					l = ydis + j * b1 + (i * j * b3);					n = RoundLong(k);					m = RoundLong(l);					if(n >= columns || n < 0){oldData++;continue;}					if(m >= rows || m < 0) {oldData++;continue;}					value = ((m * ((double)columns + 1)) + n);					testPt = &dataPtr[value];					 if(*testPt < *oldData){					 	*testPt = *oldData;					 }					oldData++;				}			}			KillPicture(plottedPict/*thePict*/);			plottedPict = 0L;			KillPtr(numericData);			numericData = 	(Ptr)*newData;								D_DrawPict();			ClipRect(&thePictRect);						D_HUnlock((Handle)newData);			KillHandle((Handle*)&newData);			numericData = 0L;			if(thePict)KillPicture(thePict);			thePict		=	plottedPict;			iErr = HandToHand((Handle*)(&thePict));//just a backup copy of the pict for transfer purposes			if(iErr){				FlagMemError(13);			}			StopWatch();			gCurrentObj->newPictReq = true;			return this;		}	} else if(nextObj != (PictObj*)NUL){		StopWatch();		return nextObj->ImageAntiDistortion(x,y,centerPt);	}	StopWatch();		return 0L;}#include	"QDOffscreen.h"void PictObj::D_DrawPict(void){		CTabHandle		destCTab;	GWorldPtr 		currPort;    // Saves the current port prior to setting up offscreen world	GDHandle 			currDev;       // Saves the current device prior to setting up offscreen world	short 				err;                    //  error returned from Pointer to OffScreen Graphics World	PaletteHandle	thisPalette;	GWorldPtr			gW1;	Rect					theRect;	RgnHandle			theClipRgn;	unsigned short	*dataPtr;		theClipRgn = D_NewRgn();	thisPalette = GetPalette(gCurrentObj->theWindow);	destCTab = GetCTable(2100);	Palette2CTab(thisPalette,destCTab);	CTabChanged(destCTab);	GetGWorld(&currPort,&currDev);	theRect = thePictRect;	OffsetRect(&theRect,-thePictRect.left,-thePictRect.top);	err = NewGWorld(&gW1, (*(currPort->portPixMap))->pixelSize,&theRect,destCTab, nil, 0);// Create Offscreen Graphics world.	//err = NewGWorld(&gW1, 8, &theRect,destCTab, nil, 0);// Create Offscreen Graphics world.	if(err){gW1 = 0L;		FlagMemError(13);	return;	}	if (!err) {		LockPixels (gW1->portPixMap);		// Setup drawing area to be our offscreen graphics world		SetGWorld (gW1, nil);				ForeColor (blackColor);		BackColor (whiteColor);		gCurrentObj->DoResetOrigin();		gCurrentObj->DoSetOrigin();		RectRgn(theClipRgn,&theRect);		D_SetClip(theClipRgn);		EraseRect (&theRect);						gCurrentObj->SetObjectDrawTransferMode();			PenMode(0);		dataPtr = (unsigned short*)numericData;		DrawPixels((unsigned short*)dataPtr, rows, columns);		SetGWorld (currPort, currDev);// Done drawing, now reset Port etc.			ForeColor (blackColor);		BackColor (whiteColor);		RectRgn(theClipRgn,&thePictRect);		D_SetClip(theClipRgn);		EraseRect (&thePictRect);		KillPicture(plottedPict);		plottedPict = 0L;		plottedPict = OpenPicture(&thePictRect);				CopyBits ( (BitMap *) (*(gW1->portPixMap)),						&((GrafPtr)gCurrentObj->theWindow)->portBits, &theRect, &thePictRect, 0, nil);//srcCopy		ClosePicture();				UnlockPixels (gW1->portPixMap);		gCurrentObj->DMBackColor		(BACKGROUND_COLOR);			}	DisposeGWorld(gW1);	DisposCTable(destCTab);	RectRgn(theClipRgn,&theRect);	D_SetClip(theClipRgn);	D_DisposeRgn(&theClipRgn);}void			PictObj::ConvertPictToNewTransferMode(void){	CTabHandle	destCTab;	// Offscreen world variables	GWorldPtr currPort,gMyOffG,gMyOffGLast;    // Saves the current port prior to setting up							// offscreen world	GDHandle currDev;       // Saves the current device prior to setting up							// offscreen world	short err;                    //  error returned from	short bitDepth = 8;	static Rect dOffBounds;   // Bounds of OffScreen Graphics													// World		// Pointer to OffScreen Graphics World	if(nextObj != (PictObj*)NUL)nextObj->ConvertPictToNewTransferMode();			destCTab = GetCTable(2100);	DetachResource((Handle)destCTab);	//{		//PackedBitsInfoPtr theDataInfo;		//theDataInfo = (PackedBitsInfoPtr) GetPICTInfoT(thePict);	//	bitDepth  = theDataInfo->thePixMap.pixelSize;	//}	GetGWorld(&currPort,&currDev);	bitDepth = (*(currPort->portPixMap))->pixelSize;	// Create Offscreen Graphics world.	err = NewGWorld(&gMyOffG, bitDepth, &thePictRect,destCTab, nil, 0);	if(err){gMyOffG = 0L;FlagMemError(13);DisposCTable(destCTab);return;}	err = NewGWorld(&gMyOffGLast, bitDepth, &thePictRect,destCTab, nil, 0);	if(err){gMyOffGLast = 0L;FlagMemError(13);DisposCTable(destCTab);DisposeGWorld(gMyOffG);return;}			// Lock down Pixels that we are drawing to so that memory will not		// move	LockPixels (gMyOffG->portPixMap);	LockPixels (gMyOffGLast->portPixMap);	SetGWorld (gMyOffG, nil);	gCurrentObj->DMBackColor		(BACKGROUND_COLOR);	EraseRect (&thePictRect);	PenMode(0);	if(thePict)DrawPicture(thePict/*thePict*/,&thePictRect);/*picture is drawn in GWorld1, exactly*/else{	DisposCTable(destCTab);	DisposeGWorld(gMyOffG);	DisposeGWorld(gMyOffGLast); 	return;}	KillPicture(plottedPict);//plottedPict); /*kill the Old Picture*/	plottedPict = 0L;	SetGWorld (gMyOffGLast, 0);/*Set to new world*/		plottedPict = OpenPicture(&thePictRect);	if(!plottedPict){FlagMemError(13);DisposeGWorld(gMyOffGLast);DisposCTable(destCTab);DisposeGWorld(gMyOffG);}		ForeColor (blackColor);		BackColor (whiteColor);		PenMode(gCurrentObj->pictTransferMode);				CopyBits ( (BitMap *) (*(gMyOffG->portPixMap)),					&((GrafPtr)gMyOffGLast)->portBits, &thePictRect, &thePictRect, gCurrentObj->pictTransferMode, nil);//New Picture with new transfer mode	ClosePicture();		UnlockPixels (gMyOffG->portPixMap);	UnlockPixels (gMyOffGLast->portPixMap);	gCurrentObj->DMBackColor		(BACKGROUND_COLOR);	DisposCTable(destCTab);	DisposeGWorld(gMyOffG);	DisposeGWorld(gMyOffGLast);	SetGWorld (currPort, currDev);}/*Ptr GetPICTInfo(PicHandle	thePicture){	unsigned short		*theData,*theDataPtr;	Handle				imageData;	short				*opcodeInfo;	Size				numPixels,lBytesFree,bytesNeeded;	long				i;	Ptr					theCharData;		HLock((Handle)thePicture);		// Lock down the picture so it doesn't move 	opcodeInfo	= (short*)&(*thePicture)->picFrame;	opcodeInfo	+= (sizeof(Rect) >> 1);		while(*opcodeInfo != 0x00FF){		switch(*opcodeInfo){			case 0x0011:			// Version Number 				opcodeInfo += 2;				break;							case 0x0C00:			// Header Info				opcodeInfo += 13;				break;							case 0x0001:			// Clip Region 				opcodeInfo += (*(++opcodeInfo) >> 1); // offset by region size + opcode 				break;							// 	NOTE: The PackedBitsRect opcode is documented as having a data structure as 			//	defined above in the PackedBitsInfo structure. However, the data does not  			//	align unless opcodeInfo is decremented. In other words there is an undocumented 			//	four byte shift in the data. 											case 0x0098:			 //PackedBitsRect					PurgeMem(1000000L);				lBytesFree 	= CompactMem(1000000L);				opcodeInfo--;						// Note the decrement 							return (PackedBitsInfoPtr)opcodeInfo;							// return array of shorts 				HUnlock((Handle)thePicture);					break;						case 0x001C:			case 0x001E:				opcodeInfo++;				break;							default:					// OOPS 							SysBeep(30);				if(!DoOtherOPCODE(&opcodeInfo)){					HUnlock((Handle)thePicture);	// OPCODE not recognized 					return(0L);				}				break;		}	}	HUnlock((Handle)thePicture);						// shouldn't ever get to here 	return (Ptr)0L;}theDataInfo->thePixMap.packType 	!= 0 || 	// Try to trap wrong type of pictures		theDataInfo->thePixMap.pixelType 	!= 0 ||		theDataInfo->thePixMap.pixelSize 	!= 8 ||		theDataInfo->thePixMap.cmpCount 	!= 1 ||		theDataInfo->thePixMap.cmpSize	 	!= 8 ||		numColors			 				!= 255){		*/		