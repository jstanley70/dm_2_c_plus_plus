//ces.Jim:GraphicsObj:G_TheTextSystem.c#include	"Diffract_INCs.h"#include	"TextObject.h"#include	"TheTextSystem.h"void CleanTheMenus(TextStyle theStyle,short theJust,short theColor);void TheTextSystem::DoPrint(GrafPtr thePrintPort,Point thePoint){		textObject->PrintAllText(thePrintPort,thePoint);}void	TheTextSystem::LocalizeTextRects(void){	return;	textObject->LocalizeTextRects();}void TheTextSystem::DoInit(Point thePoint,void* owner){	thePoint.h 	= 	5;	thePoint.v	= 	15;	theOwner	=	owner;		textMenu 	= 	(PopUpMenu*)D_new(PopUpMenu);	textMenu	->	InitAtPoint	(thePoint,1,TEXTMENU,true,true);		textOn		=	false;	InsertMenu		(g_theFontMenu,-1);	InsertMenu		(g_theSizeMenu,-1);	InsertMenu		(g_theStyleMenu,-1);	InsertMenu		(g_theJustifyMenu,-1);	InsertMenu		(g_theColorMenu,-1);		CheckItem		(g_theFontMenu,1,true);	CheckItem		(g_theSizeMenu,5,true);	CheckItem		(g_theStyleMenu,1,true);	CheckItem		(g_theJustifyMenu,1,true);	CheckItem		(g_theColorMenu,1,true);	theColorNum		= 1;	textMenu	->	SetPopUp();			textObject 	= 	(TextObject*)D_new(TextObject);	/*	SetRect			(&textObject->destRect,0,0,0,0);	textObject	->	viewRect = 	textObject->destRect;	textObject->hTE 		= 	TEStylNew	(&textObject->destRect,&textObject->viewRect);	textObject->nextText		=	0L;	textObject->theOwner		= 	theOwner;	textObject->	active 		= 	false;	textObject->type		= 	TEXT_POINT;	textObject->textFlag = true;	localJust = 0;	*/	thePoint.h = 0;thePoint.v = 0;	textObject->InitText(thePoint,theOwner,TEXT_POINT,true,((DiffractObject*)theOwner)->theCrystal[0]);	currentText = 	textObject;	{		short lineHeight,ascent;		TEGetStyle(0,&theStyle,&lineHeight,&ascent,textObject->hTE);	}	GetFNum("\pDMFont1",&theStyle.tsFont);	TESetStyle		(0x01,&theStyle,false,currentText->hTE);}void TheTextSystem::DrawMenu(){	textMenu	->	SetPopUp();}void TheTextSystem::DoRefresh(void){		textObject	->	DrawAllText();}void TheTextSystem::DoClose(void){		textObject			->KillAll();	DeleteMenu			((*g_theFontMenu)->menuID);	DeleteMenu			((*g_theSizeMenu)->menuID);	DeleteMenu			((*g_theStyleMenu)->menuID);	DeleteMenu			((*g_theJustifyMenu)->menuID);	DeleteMenu			((*g_theColorMenu)->menuID);	textMenu->DoClose();		D_delete(this);}void	ResetMenu(MenuHandle theMenu,short theItem);void	ResetMenu(MenuHandle theMenu,short theItem){	short num,i;		num = CountMItems(theMenu);	for(i = 1; i <= num;i++)	{		CheckItem(theMenu,i,false);	}	if(theItem !=  0)		CheckItem(theMenu,theItem,true);}Boolean TheTextSystem::DoContent(Point thePoint){	long theResult;	FontInfo 	theFont;	short		textHeight;	CleanTheMenus( theStyle, (*(currentText->hTE))->just,theColorNum);	theResult = textMenu->HitPopUp(thePoint);	textMenu->lastResult = 1;	if(HiWord(theResult) == (*(textMenu->theMenu))->menuID && LoWord(theResult) == 1){		if(textOn){			textOn = false;			gCurrentObj->SetTheCursor(0);			textObject->DeactivateAll();			textMenu->P_SetItemText	(1,(char*)"\pText Off");			textMenu->SetPopUp();			DisableItem(GetMHandle(EDIT_MENU),CUT);			DisableItem(GetMHandle(EDIT_MENU),COPY);		}else{			textOn = true;			gCurrentObj->SetTheCursor(iBeamCursor);			textMenu->P_SetItemText	(1,(char*)"\pText On");			textMenu->SetPopUp();			EnableItem(GetMHandle(EDIT_MENU),CUT);			EnableItem(GetMHandle(EDIT_MENU),COPY);			EnableItem(GetMHandle(EDIT_MENU),PASTE);		}		return true;	} 	if(theResult){		DoMenu(theResult);		return true;	}		GetFontInfo(&theFont);	textHeight = theFont.ascent + theFont.descent + theFont.leading;		if(thePoint.v < ((DiffractObject*)gCurrentObj)->rulerHeight + .5 * textHeight){		if(textOn && thePoint.v < ((DiffractObject*)gCurrentObj)->rulerHeight){			textOn = false;			gCurrentObj->SetTheCursor(0);			textObject->DeactivateAll();			textMenu->P_SetItemText	(1,(char*)"\pText Off");			textMenu->SetPopUp();			return true;		}		return false; 	}		textObject->DeactivateAll();		if(textObject->DoContent(thePoint,&textOn,TEXT_POINT)){		if(textOn){			textMenu->P_SetItemText	(1,(char*)"\pText On");			textMenu->SetPopUp();			EnableItem(GetMHandle(EDIT_MENU),CUT);			EnableItem(GetMHandle(EDIT_MENU),COPY);			EnableItem(GetMHandle(EDIT_MENU),PASTE);		}		return true;	}	textObject->DoCleanUp();	return false;}Boolean TheTextSystem::DoKey(char theChar){	PointObj *theObj,*anObject;	if(textOn){		textObject->DoKey(theChar);		return true;	}else{		if(theChar == '\b')		{			theObj = (PointObj*)textObject->GetActive();			if((long)theObj != 0L){				anObject = (PointObj*)textObject->DeleteObject((TextObject*)theObj,(TextObject*)theObj);				if((long)anObject != 0L){					currentText = textObject  = (TextObject*)anObject;				}				return true;			}					}	}	return false;}void TheTextSystem::DoIdle(void){	/*if(textOn)*/		textObject->DoIdle();}void	TheTextSystem::ReadSystem(void){	textObject->ReadAll();}void	TheTextSystem::WriteSystem(void){	textObject->DoCleanUp();	textObject->WriteAll();}Boolean TheTextSystem::DoMenu(long theResult){	short 		mode;	short		theOffset;	short		theMenu;	short		theItem;	RGBColor	theColor;	Boolean		flag = false;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);	theOffset = 0;	currentText = (TextObject*)textObject->GetActive();	if(currentText == 0L)		currentText = textObject;	if(theMenu == EDIT_MENU)	{		flag = currentText->DoTScrap(theItem);		textObject->DoCleanUp();		currentText = (TextObject*)textObject->GetActive();		if(currentText == 0L)			currentText = textObject;		HiliteMenu(0);		return flag;	}		switch(theMenu){		case FONT:			GetItem(g_theFontMenu,theItem,pTheText);			GetFNum(pTheText,&theStyle.tsFont);						mode = 0x01;			ResetMenu(g_theFontMenu,theItem);			break;		case SIZE:			GetItem(g_theSizeMenu,theItem,pTheText);			p2cstr(pTheText);			theStyle.tsSize = (short)(atof(gTheText));						mode = 0x04;			ResetMenu(g_theSizeMenu,theItem);			break;		case STYLE:			switch(theItem){				case 1:					theStyle.tsFace = 0;				break;				case 2:					theStyle.tsFace |= 1;				break;				case 3:					theStyle.tsFace |= 2;				break;				case 4:					theStyle.tsFace |= 4;				break;				case 5:					theStyle.tsFace |= 8;				break;				case 6:					theStyle.tsFace |= 16;				break;				case 7:					theStyle.tsFace |= 32;				break;				case 8:					theStyle.tsFace |= 64;				break;											}			if(theItem == 1)				ResetMenu(g_theStyleMenu,theItem);			else{				short markChar;				GetItemMark(g_theStyleMenu,theItem,&markChar);				if(markChar)					CheckItem(g_theStyleMenu,theItem,false);				else{					CheckItem(g_theStyleMenu,theItem,true);					CheckItem(g_theStyleMenu,1,false);				}			}			mode = 0x02;						break;			case JUSTIFY:				localJust = theItem;				switch(theItem){					case 1:						TESetJust(0,currentText->hTE);						break;					case 2:						TESetJust(-1,currentText->hTE);						break;					case 3:						TESetJust(1,currentText->hTE);						break;				}				ResetMenu(g_theJustifyMenu,theItem);							HiliteMenu(0);				break;			case COLOR_TEXT_MENU:								currentText->SetColor(theItem,&theColor);				ResetMenu(g_theColorMenu,theItem);				theColorNum = theItem;				theStyle.tsColor = theColor;				mode = doColor;				HiliteMenu(0);				break;			default:				break;	}	HiliteMenu(0);	if(currentText->active && textOn){		(*(currentText->hTE))->destRect.right += 100;		(*(currentText->hTE))->destRect.bottom += 100;	}	TESetStyle		(mode,&theStyle,false,currentText->hTE);	if(currentText->active && textOn){				gTheText[0] = 0;		currentText->EraseObject();		currentText->ResetViewRect	();			}	return false;}void CleanTheMenus(TextStyle theStyle,short theJust,short theColorNum){	char itemString[256];	short i,count;		count = CountMItems(g_theFontMenu);	GetFontName(theStyle.tsFont,pTheText);	p2cstr(pTheText);	sprintf(itemString," ");	i = 1;	while(i <= count && strcmp(itemString,gTheText)){		GetItem(g_theFontMenu,i,(unsigned char*)itemString);		p2cstr((unsigned char*)itemString);		i++;	}	ResetMenu(g_theFontMenu,i - 1);		count = CountMItems(g_theSizeMenu);	sprintf(gTheText,"%d",theStyle.tsSize);	sprintf(itemString," ");	i = 1;	while(i <= count && strcmp(itemString,gTheText)){		GetItem(g_theSizeMenu,i,(unsigned char*)itemString);		p2cstr((unsigned char*)itemString);		i++;	}	ResetMenu(g_theSizeMenu,i - 1);			if(theStyle.tsFace == 0)		ResetMenu(g_theStyleMenu,1);	else{		ResetMenu(g_theStyleMenu,0);		for(i =  0;i <= 6; i++){			short test;			test = (short)ipow(2,i);			if(theStyle.tsFace & test ){				CheckItem(g_theStyleMenu,i + 2,true);			}		}	}				switch(theJust){		case 0:			i = 1;			break;		case -1:			i = 2;			break;		case 1:			i = 3;			break;	}	ResetMenu(g_theJustifyMenu,i);	ResetMenu(g_theColorMenu,theColorNum);		}