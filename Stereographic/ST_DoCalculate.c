#include	"Diffract_INCs.h"//rces.Jim:Stereographic:ST_DoCalculate.c#include	"StereoObject.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"SF_MathLib.h"short	StructFactCompare	(SpotInfo* spot1,SpotInfo* spot2);short	PlaneSpotSort		(SpotInfoPtr	theSpotArray,short data_Count);void	StereoObject::MyCalculate(void){	CalculatePoles(false);}short	StructFactCompare(SpotInfo* spot1,SpotInfo* spot2){	double z1,z2;		z1 = fabs((double)spot1->intensity);	z2 = fabs((double)spot2->intensity);		return((short)((z1 > z2) ? -1 : ((z1 == z2) ? 0 : 1)));}/*   Fix this for KMaps      HERE !!!!*/    short	StereoObject::PlaneSpotSort(SpotInfoPtr	theSpotArray,short	data_Count){	SpotInfo	*thisSpot,*lastSpot;	float		SFValue;	short		i,j,k,num;		qsort(theSpotArray,(long)data_Count,sizeof(SpotInfo),(_compare_function/*__cmp_func_Cmpfun**/)StructFactCompare);		lastSpot 	= theSpotArray;	thisSpot 	= theSpotArray;	SFValue 	= thisSpot->intensity;		for(i = 0 ; i < data_Count ; i++,thisSpot++){		if(thisSpot->direction){			thisSpot->intensity = 1.0;		} else{			thisSpot->intensity /= SFValue;		}	}	thisSpot = theSpotArray;	num = 0;	SFValue = .000001;	for(i = 0 ; i < data_Count ; i++,thisSpot++){		if(thisSpot->intensity < SFValue){				data_Count = i;				continue;		}		num++;	}		data_Count = num;	if(objectType == KIKUCHI_OBJECT || objectType == BEKP_OBJECT || objectType == KOSSEL_OBJECT)return data_Count;		thisSpot = theSpotArray;		for(i = 1 ; i <= data_Count ; i++,thisSpot++){		if((short)(thisSpot->intensity) == 0)			continue;		lastSpot = &theSpotArray[i];		for(j = i + 1 ; j <= data_Count ; j++,lastSpot++){			if((short)(lastSpot->intensity) <= .01)				continue;			k = (short)(1000. * ((double)lastSpot->x - (double)thisSpot->x));			if(k == 0){				k = (short)(1000. * ((double)lastSpot->y - (double)thisSpot->y));				if(k == 0){					k = (short)(1000. * ((double)lastSpot->z - (double)thisSpot->z));					if(k == 0){						if(lastSpot->intensity <= thisSpot->intensity ){							lastSpot->intensity = 0.0;						}else{							thisSpot->intensity = 0.0;						}					}				}			}		}	}	qsort(theSpotArray,(long)data_Count,sizeof(SpotInfo),(_compare_function/*__cmp_func_Cmpfun**/)StructFactCompare);NEXT:	thisSpot 	= theSpotArray;	num = 0;	for(j = 0 ; j < data_Count ; j++,thisSpot++){		if(thisSpot->intensity < SFValue){			data_Count = j;			continue;		}		num++;	}	data_Count = num;	return(data_Count);}void StereoObject::CalculatePoles(Boolean addFlag){	short		a,b,c,				limit,				maxLimit,theMax,				h,k,				start,				numRecs,entries;	short		first,second,i,num;	long		dataFlags,**testArray,testID,dataFlag;	Crystal		*thisCrystal;	double		matrix[3][3],theXForm[3][3],				u,v,w,				x,y,z,				scale,				theH,theK,theL,				SFValue;	double		*theUs,*theVs,*theWs,*theZs,*theBs;	Boolean		hexFlag,errFlag;	SpotInfoPtr	theSpots,thisSpot;	short		testArrayLength;	double		xForm[3][3];	double		xForm00,xForm01,xForm02,xForm10,xForm11,xForm12,xForm20,xForm21,xForm22;	Ptr*		theHandle;	double		compValue;	double		x1,x2,				y1,y2,				z1,z2;	double 		chx,ckx,clx,				chy,cky,cly,				chz,ckz,clz;			errFlag = true;	testArray = (long**)GetResource('DATA',2000);	testArrayLength = GetHandleSize((Handle)testArray)/sizeof(long);RESTART:	dataFlags = 0;	if(!addFlag || theDataHandle == 0L){		if(theDataHandle != (Handle)NUL)			/*Temp*/KillHandle(&theDataHandle);		data_Length = 	350L;		data_Count	= 	0;		data_Size	= 	sizeof(SpotInfo);		data_Expand = 	75;		start = 0;		theDataHandle	= /*Temp*/D_NewHandle((long)(data_Length * data_Size));//,&gTheOSError	}else{		data_Length = 	data_Count;		data_Size	= 	sizeof(SpotInfo);		start = data_Count;		data_Expand = 	75;		ExpandMemory();	}	/*MFTemp*/D_HLock(theDataHandle);	theSpots 	= 	(SpotInfoPtr)*theDataHandle;	GetOrientation(matrix);	//InvertMatrix(matrix);		first = 0;	while(planeBounds[first] <= 0 && first < 2)		first++;	second = 0;	while(dirBounds[second] <= 0 && second < first)		second++;	if(second < first)		first = second;	baseCrystal = first;		for(i  = first ; i < 4 && gNoBreak; i++){		if(planeBounds[i] <= 0){			continue;		}				dataFlags = i;		theMax = limit = planeBounds[i];		thisCrystal = theCrystal[i];				if(thisCrystal->lattice_Type == HEXAGONAL || thisCrystal->lattice_Type == TRIGONAL){			hexFlag = true;		} else {			hexFlag = false;		}				if(structFactFlag){			double electronMassRation;			if(!SetScatteringPosAIntensity(thisCrystal,&theUs,&theVs,&theWs,&theZs,&theBs,&num)){//Timebomb!!//*atom_Count cannot be the same address as *crystal->Atom_Couynt  or you will continually increase the number				/*MFTemp*/D_HUnlock(theDataHandle);				ReleaseResource((Handle)testArray);				return;			}			electronMassRation =   1. + ( (double)energy / 511.);			theHandle = thisCrystal->AtomicScatteringSet(electronMassRation,theBeamFlag);			AtomicScatterForDFromSet(0,theHandle,theZs,num);			compValue = StructureFactorOld(0,0,0,theUs,theVs,theWs,num,theZs,thisCrystal->volume) * .01;		}				GetPPTXFormMatrixBase		(xForm,thisCrystal,0);				MatrixMultiply			(xForm,matrix,theXForm); 		ConverttoReciprocal		(theXForm,(double)thisCrystal->volume,false);		chx = theXForm[0][0] ;		chy = theXForm[1][0];		chz = theXForm[2][0] ;		ckx = theXForm[0][1];		cky = theXForm[1][1] ;		ckz = theXForm[2][1];		clx = theXForm[0][2];		cly = theXForm[1][2] ;		clz = theXForm[2][2] ;								x = -limit * chx;		y = -limit * chy;		z = -limit * chz;						for(a = -limit ; a <= limit && gNoBreak; a++){			h = 100 * abs(a);			theH = (double)a;			x1 = x + -limit * ckx;			y1 = y + -limit * cky;			z1 = z + -limit * ckz;									for(b = -limit ; b <= limit && gNoBreak; b++){				k = h + 10 * abs(b);				theK = (double)b;								x2 = x1 + -limit * clx;				y2 = y1 + -limit * cly;				z2 = z1 + -limit * clz;								if(hexFlag && (abs(a + b) > limit)){					goto NEW_ST_START2;				}								for(c = -limit ; c <= limit && gNoBreak; c++){					double theLength;					testID = k + abs(c);					theL = (double)c;										if(a == 0 && b == 0 && c == 0)goto NEW_ST_START;																	theLength = sqrt(x2 * x2 + y2 * y2 + z2 * z2);					if(theLength > .00001)						scale = 1/theLength;					else						scale = 10000;										AllowBackground();					if(structFactFlag){						AtomicScatterForDFromSet(theLength,theHandle,theZs,num);						SFValue = StructureFactorOld(theH,theK,theL,theUs,theVs,theWs,num,theZs,thisCrystal->volume);						if(SFValue < compValue) goto NEW_ST_START;					} else {						short theValue;						theValue = testID/32;						if(testArrayLength > theValue){						if(((*testArray)[theValue] & (1L << (testID % 32L))) == 0)							goto NEW_ST_START;						}					}																		dataFlag 				= dataFlags;						thisSpot 				= &(theSpots[data_Count++]);						thisSpot->theCrystal	= thisCrystal;						thisSpot->h 			= a;						thisSpot->k 			= b;						thisSpot->l 			= c;						thisSpot->direction		= false;						thisSpot->x 			= x2 * scale;						thisSpot->y 			= y2 * scale;						thisSpot->z 			= z2 * scale;						thisSpot->intensity		= 1;												if(labelMatrixFlag  && first == i && labelBounds >= fabs((double)a) 							&& labelBounds >= fabs((double)b) && labelBounds >= fabs((double)c)){								if(hexFlag){									if(labelBounds >= fabs((double)(a + b))) dataFlag |= TEXT_MASK;								}else dataFlag |= TEXT_MASK;						}						if(full_Symmetry){							dataFlag |= SYMMETRY_MASK;						}						thisSpot->flags 			= 	dataFlag;						thisSpot->intensity			= 	SFValue;						thisSpot->angle				= 	0.0;						thisSpot->sF.r				=	SFValue;						thisSpot->sF.i				=	0;						if(data_Count >= data_Length){							ExpandMemory();														if(MemError() != 0 || FreeMem() < 32000L)							{								if(planeBounds[i] > 0)									planeBounds[i]--;								a = b = c = i = 32000;								if(errFlag){									StopAlert(OUT_OF_MEM,NUL);									{										KeyMap		keyArray;										GetKeys(keyArray);										if(keyArray[1] == 5){											SysBreak();										}									}									errFlag = false;								}								if(structFactFlag){									thisCrystal->ClearAtomicScatSet(theHandle);									KillPtr((Ptr)theUs);									theUs = 0L;								}								addFlag = false;								goto	RESTART;															}						}				theSpots = (SpotInfoPtr)*theDataHandle;	NEW_ST_START:x2 += clx;				y2 += cly;				z2 += clz;								AllowBackground();			}	NEW_ST_START2:x1 += ckx;			y1 += cky;			z1 += ckz;		}		x += chx;		y += chy;		z += chz;			//g_ThreadObj->YieldToThreads(0L);		}		if(structFactFlag){			KillPtr((Ptr)theUs);			theUs = 0L;			numRecs = data_Count - start;			thisCrystal->ClearAtomicScatSet(theHandle);			entries = PlaneSpotSort(&(((SpotInfoPtr)*theDataHandle)[start]),numRecs);			data_Count = start + entries;			start = data_Count;		}	}		for(i = first ; i < 4 && gNoBreak; i++){		if(dirBounds[i] <= 0){			continue;		}		dataFlags = i;		theMax = limit = dirBounds[i];		thisCrystal = theCrystal[i];		if(thisCrystal->lattice_Type == HEXAGONAL || thisCrystal->lattice_Type == TRIGONAL){			hexFlag = true;		} else {			hexFlag = false;		}						GetPPTXFormMatrixBase		(xForm,thisCrystal,0);		MatrixMultiply			(xForm,matrix,theXForm); 				xForm00	=	theXForm[0][0];		xForm01	=	theXForm[0][1];		xForm02	=	theXForm[0][2];				xForm10	=	theXForm[1][0];		xForm11	=	theXForm[1][1];		xForm12	=	theXForm[1][2];				xForm20	=	theXForm[2][0];		xForm21	=	theXForm[2][1];		xForm22	=	theXForm[2][2];		if(hexFlag)/*dec 1992*/			maxLimit = 3.0 + (double)limit;		else			maxLimit = limit;						for(a = -maxLimit ; a <= maxLimit && gNoBreak; a++){						h = 100 * abs(a);			u = a;					for(b = -maxLimit ; b <= maxLimit && gNoBreak; b++){								k = h + 10 * abs(b);				v = b;																for(c = -maxLimit ; c <= maxLimit && gNoBreak; c++){					double u1,v1,w1;					testID = k + abs(c);					AllowBackground();					if(a == 0. && b == 0. && c == 0)							continue;					{						short theValue;						theValue = testID / 32;						if(testArrayLength > theValue){							if(((*testArray)[theValue] & (1L << (testID % 32L))) == 0)								continue;						}					}										if(hexFlag){/*added dec 1992 by jim to accomodate true hex directions*/						u1 = (double)((2 * a) - b);						v1 = (double)((2 * b) - a);						w1 = (double)(c * 3);						if(u1 == 0. && v1 == 0. && w1 == 0)							continue;									Reduce(&u1,&v1,&w1);						if(fabs(u1) > limit)continue;						if(fabs(v1) > limit)continue;						if(fabs(w1) > limit)continue;						if(fabs(u1 + v1) > limit)continue;					}else{						u1 = a;						v1 = b;						w1 = c;					}						w = c;					x = u * xForm00 + v * xForm01 + w * xForm02;					y = u * xForm10 + v * xForm11 + w * xForm12;					z = u * xForm20 + v * xForm21 + w * xForm22;					{						double r,s,t;						INVERT_MATRIX(theXForm);						r = x;						s = y;						t = z;						TRANSFORM_VECTOR(r,s,t,theXForm);						INVERT_MATRIX(theXForm);					}										scale = 1.0 / sqrt(x * x + y * y + z * z);					x *= scale;					y *= scale;					z *= scale;									thisSpot = &(theSpots[data_Count++]);					thisSpot->theCrystal	= thisCrystal;					thisSpot->h 			= a;					thisSpot->k 			= b;					thisSpot->l 			= c;					thisSpot->direction		= true;					thisSpot->x 			= x;					thisSpot->y 			= y;					thisSpot->z 			= z;					thisSpot->intensity		= 1;					dataFlag = dataFlags;					if(labelMatrixFlag  && first == i && labelBounds >= fabs((double)u1) 						&& labelBounds >= fabs((double)v1) && labelBounds >= fabs((double)w1)){							if(hexFlag){								if(labelBounds >= fabs(u1 + v1))dataFlag |= TEXT_MASK;							}else dataFlag |= TEXT_MASK;					}					thisSpot->flags 		= dataFlag;					thisSpot->intensity 	= 1.0;										if(data_Count >= data_Length){						ExpandMemory();						if(MemError() != 0 && FreeMem() < 32000L)						{							if(dirBounds[i] > 0)								dirBounds[i]--;							a = b = c = i = 32000;							if(errFlag){								StopAlert(OUT_OF_MEM,NUL);								{									KeyMap		keyArray;																	GetKeys(keyArray);										if(keyArray[1] == 5){										SysBreak();									}								}								errFlag = false;							}							addFlag = false;							goto	RESTART;						}						theSpots = (SpotInfoPtr)*theDataHandle;					}				}			}			//g_ThreadObj->YieldToThreads(0L);		}	}	/*MFTemp*/D_HUnlock(theDataHandle);	ReleaseResource((Handle)testArray);	if(data_Length >  data_Count){		D_RecoverMemory		(theDataHandle,data_Size,(long)data_Count);	}	addFlag = false;	numSpots = 	data_Length 	= 	data_Count;	if(data_Count == 0)baseCrystal = 0;	obj_Index->theCrystal = theCrystal[baseCrystal];	return;}