#include	"Diffract_INCs.h"#include	"StereoObject.h"//rces.Jim:Stereographic:ST_SP_DefectAnalysis.c#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"Boolean 	CheckGandBeam(SpotInfo* theBeam,SpotInfo* theG);short		SpotCompare(SpotInfoPtr spot1,SpotInfoPtr spot2);void		StereoObject::DoDefectTrace(void){	DialogPtr	theDialog;	short		theSelect,h,v;	Boolean		quit,trueDirFlag;	double		theAngle,x,y,z;		quit = trueDirFlag = false;		theDialog = DM_GetNewDialog(DEFECT_TRACE_DLOG,NUL,IN_FRONT);			g1->SetIndex(theDialog,4);	dirA_1->SetIndex(theDialog,6);	dirB_1->SetIndex(theDialog,7);	theAngle = angle1 * 180.0 / PI;	sprintf(gTheText,"%5.1f",theAngle);	c2pstr(gTheText);	GetDItem(theDialog,5,&gType,&gTheHandle,&gTheRect);	SetIText(gTheHandle,pTheText);	SelIText(theDialog,4,0,20);		while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;					case IN_GO_AWAY:			case 3:				quit = true;				break;							case 2:				trueDirFlag = true;			case DLOG_ENTER_OR_CR:			case 1:				g1->GetIndex(theDialog,4);				dirA_1->GetIndex(theDialog,6);				dirB_1->GetIndex(theDialog,7);				GetDItem(theDialog,5,&gType,&gTheHandle,&gTheRect);				GetIText(gTheHandle,pTheText);				p2cstr(pTheText);				angle1 = atof(gTheText) * PI / 180.0;				SelectWindow(theWindow);				SetPort(theWindow);				theRuler->SetHelp("Enter Trace angle for defect.(After crystal is oriented,align 'hot' great circle to align with defect)");				if((theAngle = DrawDefect(dirA_1,dirB_1,g1,angle1)) == -1957){					DM_DisposDialog(&theDialog);					theRuler->ClearPrompt();					theRuler->ClearHelp();					return;				}				obj_Index->h = 0;				obj_Index->k = 0;				obj_Index->l = 0;				if(trueDirFlag){					trueDirFlag = false;					theAngle += (PI / 2.0);					obj_Index->direction = DIRECTION;					x = cos(theAngle);					y = sin(theAngle);					z = 0;					SetXYZValueToHKL(x,y,z,DIRECTION);					AddThisSpot(x,y,z);					THE_CURRENT_SPOT.flags |= LINE_MASK;					h = (THE_CURRENT_SPOT.spotRect.left + THE_CURRENT_SPOT.spotRect.right) / 2;					v = (THE_CURRENT_SPOT.spotRect.top + THE_CURRENT_SPOT.spotRect.bottom) / 2;					DRAW_LINE_SPOT((&THE_CURRENT_SPOT),h,v);				} else {					obj_Index->direction = PLANE;					x = cos(theAngle);					y = sin(theAngle);					z = 0;					SetXYZValueToHKL(x,y,z,PLANE);					AddThisSpot(x,y,z);					THE_CURRENT_SPOT.flags |= DEFECT_MASK;					THE_CURRENT_SPOT.flags |= PLANE_TRACE;					h = (THE_CURRENT_SPOT.spotRect.left + THE_CURRENT_SPOT.spotRect.right) / 2;					v = (THE_CURRENT_SPOT.spotRect.top + THE_CURRENT_SPOT.spotRect.bottom) / 2;					DRAW_DEFECT_SPOT((&THE_CURRENT_SPOT),h,v);					DRAW_PLANE_TRACE((&THE_CURRENT_SPOT));				}				SetPict(false);				D_DrawPict();				refreshFlag = true;				DoRefresh();				SelectWindow(theDialog);				SetPort(theDialog);				HiliteOK(theDialog);				break;							default:				break;		}	}		DM_DisposDialog(&theDialog);		theRuler->ClearPrompt();	theRuler->ClearHelp();	return;}void		StereoObject::DoDefectAnalysis(void){	DialogPtr	theDialog;	short		theSelect,h,v,loc;	Boolean		quit,calcFlag,trueDirFlag;	double		theAngle1,theAngle2,x,y,z,x1,y1,z1,x2,y2,z2;		quit = calcFlag = trueDirFlag = false;	theDialog = DM_GetNewDialog(DISLOC_LINE_DLOG,NUL,IN_FRONT);	g1->SetIndex(theDialog,3);	dirA_1->SetIndex(theDialog,5);	dirB_1->SetIndex(theDialog,6);	theAngle1 = angle1 * 180.0 / PI;	sprintf(gTheText,"%5.1f",theAngle1);	c2pstr(gTheText);	GetDItem(theDialog,4,&gType,&gTheHandle,&gTheRect);	SetIText(gTheHandle,pTheText);	SelIText(theDialog,3,0,20);		g2->SetIndex(theDialog,7);	dirA_2->SetIndex(theDialog,9);	dirB_2->SetIndex(theDialog,10);	theAngle2 = angle2 * 180.0 / PI;	sprintf(gTheText,"%5.1f",theAngle2);	c2pstr(gTheText);	GetDItem(theDialog,8,&gType,&gTheHandle,&gTheRect);	SetIText(gTheHandle,pTheText);		while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;			case IN_GO_AWAY:			case 2:				quit = true;				break;							case DLOG_ENTER_OR_CR:			case 1:				quit = true;				calcFlag = true;				g1->GetIndex(theDialog,3);				dirA_1->GetIndex(theDialog,5);				dirB_1->GetIndex(theDialog,6);				GetDItem(theDialog,4,&gType,&gTheHandle,&gTheRect);				GetIText(gTheHandle,pTheText);				p2cstr(pTheText);				angle1 = atof(gTheText) * PI / 180.0;								g2->GetIndex(theDialog,7);				dirA_2->GetIndex(theDialog,9);				dirB_2->GetIndex(theDialog,10);				GetDItem(theDialog,8,&gType,&gTheHandle,&gTheRect);				GetIText(gTheHandle,pTheText);				p2cstr(pTheText);				angle2 = atof(gTheText) * PI / 180.0;				break;							default:				break;		}	}	DM_DisposDialog(&theDialog);		if(calcFlag){				theRuler->SetHelp("Enter Trace angle for defect line 1.(After crystal is oriented,align 'hot' great circle to align with defect)");		if((theAngle1 = DrawDefect(dirA_1,dirB_1,g1,angle1)) == -1957)			return;		obj_Index->h = 0;		obj_Index->k = 0;		obj_Index->l = 0;				obj_Index->direction = PLANE;		x1 = cos(theAngle1);		y1 = sin(theAngle1);		z1 = 0;		SetXYZValueToHKL(x1,y1,z1,PLANE);		AddThisSpot(x1,y1,z1);		THE_CURRENT_SPOT.flags |= DEFECT_MASK;		THE_CURRENT_SPOT.flags |= PLANE_TRACE;		loc = spotLoc;		h = (THE_CURRENT_SPOT.spotRect.left + THE_CURRENT_SPOT.spotRect.right) / 2;		v = (THE_CURRENT_SPOT.spotRect.top + THE_CURRENT_SPOT.spotRect.bottom) / 2;		DRAW_DEFECT_SPOT((&THE_CURRENT_SPOT),h,v);		DRAW_PLANE_TRACE((&THE_CURRENT_SPOT));				theRuler->SetHelp("Enter Trace angle for defect line 2.(After crystal is oriented,align 'hot' great circle to align with defect)");		if((theAngle2 = DrawDefect(dirA_2,dirB_2,g2,angle2)) == -1957)			return;		obj_Index->h = 0;		obj_Index->k = 0;		obj_Index->l = 0;		obj_Index->direction = PLANE;		x2 = cos(theAngle2);		y2 = sin(theAngle2);		z2 = 0;		SetXYZValueToHKL(x2,y2,z2,PLANE);		AddThisSpot(x2,y2,z2);		THE_CURRENT_SPOT.flags |= DEFECT_MASK;		THE_CURRENT_SPOT.flags |= PLANE_TRACE;		h = (THE_CURRENT_SPOT.spotRect.left + THE_CURRENT_SPOT.spotRect.right) / 2;		v = (THE_CURRENT_SPOT.spotRect.top + THE_CURRENT_SPOT.spotRect.bottom) / 2;		DRAW_DEFECT_SPOT((&THE_CURRENT_SPOT),h,v);		DRAW_PLANE_TRACE((&THE_CURRENT_SPOT));				x1 = (((SpotInfoPtr)*theDataHandle)[loc]).x;		y1 = (((SpotInfoPtr)*theDataHandle)[loc]).y;		z1 = (((SpotInfoPtr)*theDataHandle)[loc]).z;				CrossProduct(&x,&y,&z,x1,y1,z1,x2,y2,z2);		NormalizeVector(&x,&y,&z);		obj_Index->h = 0;		obj_Index->k = 0;		obj_Index->l = 0;		obj_Index->direction = DIRECTION;		SetXYZValueToHKL(x,y,z,DIRECTION);		AddThisSpot(x,y,z);		THE_CURRENT_SPOT.flags |= LINE_MASK;		h = (THE_CURRENT_SPOT.spotRect.left + THE_CURRENT_SPOT.spotRect.right) / 2;		v = (THE_CURRENT_SPOT.spotRect.top + THE_CURRENT_SPOT.spotRect.bottom) / 2;		DRAW_LINE_SPOT((&THE_CURRENT_SPOT),h,v);		SetXYZValueToHKL(-x,-y,-z,DIRECTION);		AddThisSpot(-x,-y,-z);		THE_CURRENT_SPOT.flags |= LINE_MASK;		h = (THE_CURRENT_SPOT.spotRect.left + THE_CURRENT_SPOT.spotRect.right) / 2;		v = (THE_CURRENT_SPOT.spotRect.top + THE_CURRENT_SPOT.spotRect.bottom) / 2;		DRAW_LINE_SPOT((&THE_CURRENT_SPOT),h,v);				newPictReq = true;	}		return;}double		StereoObject::DrawDefect(Index* dir_A,Index* dir_B,Index* g,double angle){	short		n,beamLoc;	SpotInfo	theBeam,theG;	double		x,y,z,lineAngle,vXForm[3][3];	FindBeamDir(dir_A,dir_B,angle); /* Adds beam spot and rets center xform */	theBeam = THE_CURRENT_SPOT;	beamLoc = data_Count - 1;				g->DoCopy(obj_Index);			if((n = LocatePole(&x,&y,&z)) >= 0){		spotLoc = n;		theG = THE_CURRENT_SPOT;		LabelSpot();	} else {		/*SetXYZValueToHKL(x,y,z,PLANE);*/ /*DIRECTION*/		AddThisSpot(x,y,z);		theG = THE_CURRENT_SPOT;	}		if(!CheckGandBeam(&theBeam,&theG)){		lineAngle = -1957;	} else {		lineAngle = GetAngle();	}	FindVertXform(x,y,vXForm);	RotateSpotsBase(vXForm);	SetPict(true);	D_DrawPict();	refreshFlag = true;	DoRefresh();			return(lineAngle);}Boolean CheckGandBeam(SpotInfo* theBeam,SpotInfo* theG){	double	angle;	char	text[120],text1[120];	GrafPtr	oldPort;	short	i;		GetPort(&oldPort);	if((theBeam->h * theG->h + theBeam->k * theG->k + theBeam->l * theG->l)){		sprintf(gTheText,"The dot product between the Beam and g is not zero");		sprintf(text,"It should be, the data may be in error.");		sprintf(text1,"Click OK to continue, Cancel to abort.");		c2pstr(gTheText);		c2pstr(text);		c2pstr(text1);		ParamText(pTheText,(unsigned char*)text,(unsigned char*)text1,"\p ");		i = CautionAlert(GENERIC_ALERT,0L);		if(i != 2){			SetPort(oldPort);			return false;		}	}	angle = 180. * acos((double)theBeam->x * (double)theG->x + 						(double)theBeam->y * (double)theG->y + 						(double)theBeam->z * (double)theG->z) / PI;	if(fabs(angle - 90.) > 3.){		sprintf(gTheText,"The angle between the Beam and g is %5.1f¡",angle);		sprintf(text,"It should be 90¡, the data may be in error.");		sprintf(text1,"Click OK to continue, Cancel to abort.");		c2pstr(gTheText);		c2pstr(text);		c2pstr(text1);		ParamText(pTheText,(unsigned char*)text,(unsigned char*)text1,"\p ");		i = CautionAlert(GENERIC_ALERT,0L);		if(i != 2){			SetPort(oldPort);			return false;		}	}	SetPort(oldPort);	return true;}void		StereoObject::FindBeamDir(Index* dir_A,Index* dir_B,double angle){	short n;	double x,y,z,length,xForm[3][3];		SetPort(theWindow);	D_SetClip(drawRgn);	SystemTask();		dir_A->DoCopy(obj_Index);	if((n = LocatePole(&x,&y,&z)) >= 0){		spotLoc = n;		LabelSpot();	} else {		/*SetXYZValueToHKL(x,y,z,DIRECTION);*/		AddThisSpot(x,y,z);	}	FindCenterXform(x,y,z,xForm);		SystemTask();		dir_B->DoCopy(obj_Index);	if((n = LocatePole(&x,&y,&z)) >= 0){		spotLoc = n;		LabelSpot();	} else {		/*SetXYZValueToHKL(x,y,z,DIRECTION);*/		AddThisSpot(x,y,z);	}		TransFormVector(&x,&y,&z,xForm);	length = sqrt(x * x + y * y);		x = sin(angle) * x / length;	y = sin(angle) * y / length;	z = cos(angle);	ReverseTransFormVector(&x,&y,&z,xForm);	NormalizeVector(&x,&y,&z);		obj_Index->h = 0;	obj_Index->k = 0;	obj_Index->l = 0;	SetXYZValueToHKL(x,y,z,DIRECTION);	AddThisSpot(x,y,z);	THE_CURRENT_SPOT.flags |= BEAM_MASK;		FindCenterXform(x,y,z,xForm);	RotateSpotsBase(xForm);}double		StereoObject::GetAngle(void){	Point		thePoint,lastPoint;	double		x,y,angle,length,degAngle;	short		h,v,h1,v1,h2,v2;		GetMouse(&thePoint);	x = thePoint.h - centerX;	y = centerY - thePoint.v;	length = sqrt(x * x + y * y);	h = (short)(radius * x / length);	v = -(short)(radius * y / length);	h1 = centerX + h;	v1 = centerY + v;	h2 = centerX - h;	v2 = centerY - v;		lastPoint = thePoint;	angle = atan2(y,x);	degAngle = angle * 180.0 / PI - 90.0;	if(degAngle < -180.0)		degAngle += 360.0;	if(degAngle > 180.0)		degAngle -= 360.0;		theRuler->SetPrompt("Angle between g and defect line is ");	sprintf(gTheText,"%5.1f¡",degAngle);	theRuler->SetInfo(gTheText);	theRuler->SetHelp("Click mouse to enter the Angle.");		PenMode(patXor);	MoveTo(h1,v1);	LineTo(h2,v2);		while(!Button()){		GetMouse(&thePoint);		if(!EqualPt(thePoint,lastPoint)){			x = thePoint.h - centerX;			y = centerY - thePoint.v;			length = sqrt(x * x + y * y);			h = (short)(radius * x / length);			v = -(short)(radius * y / length);			PenMode(patXor);			MoveTo(h1,v1);			LineTo(h2,v2);			h1 = centerX + h;			v1 = centerY + v;			h2 = centerX - h;			v2 = centerY - v;			MoveTo(h1,v1);			LineTo(h2,v2);						angle = atan2(y,x);			degAngle = angle * 180.0 / PI - 90.0;			if(degAngle < -180.0)				degAngle += 360.0;			if(degAngle > 180.0)				degAngle -= 360.0;						sprintf(gTheText,"%5.1f¡",degAngle);			theRuler->SetInfo(gTheText);			lastPoint = thePoint;		}	}	PenMode(patXor);	MoveTo(h1,v1);	LineTo(h2,v2);	PenNormal();	FlushEvents(mDownMask,0);	return(angle);}			void		StereoObject::RotateSpotsBase(double	theXForm[][3]){	short 		i,j;	SpotInfoPtr	theSpot;	double		x,y,z;	double matrix[3][3];	j = data_Count - 1;		TransformAxes(theXForm);	/*MFTemp*/D_HLock(theDataHandle);	theSpot 	= 	(SpotInfoPtr)*theDataHandle;		for(i = 0 ; i <= j ; i++){		if((theSpot->flags & PIN_MASK)){			if((theSpot->flags & PRIME_MASK) == 0){				DuplicateSpotAndPrime(&theSpot,i);				j = data_Count - 1;			}		} else {			x = theSpot->x;			y = theSpot->y;			z = theSpot->z;			TRANSFORM_VECTOR(x,y,z,theXForm);			theSpot->x = x;			theSpot->y = y;			theSpot->z = z;		}		theSpot++;	}	/*MFTemp*/D_HUnlock(theDataHandle);	normalizeFlag 	= true;	normalizeCount	=	0;	CopyAxesIntoMatrix(theXForm);	SetMatrixAEqB(matrix,theXForm);	ZoneAxisFromMatrix(false,theXForm,&calcIrrational,theZoneAxis,theRotationAxis,g_Vector,&rotationAngle,&offLaueDistance,&totalRot,&beamAzimuth);	SetOrientation(theXForm);	newPictReq = true;}		void		StereoObject::SelectHabitPlane(void){	Point				cSize,theCell,thePoint;	DialogPtr		theDialog;	Boolean			quit = false;	short				theSelect,count,numRows,maxEntries,i,spotMap[100];	double			theAngle,theZ,theValue;	Rect				listRect,dataBounds;	ListHandle		theList;	SpotInfoPtr		thisSpot;		maxEntries = (data_Count - 1 > 100) ? 100 : (data_Count - 1);			theDialog = DM_GetNewDialog(HABIT_PLANE_DLOG,NUL,IN_FRONT);		RotateToCntr();		RestoreTheCursor();	//InitCursor()	GetDItem		(theDialog,5,&gType,&gTheHandle,&gTheRect);	sprintf			(gTheText,"%5.2f",habitAngle);	c2pstr			(gTheText);	SetIText		(gTheHandle,pTheText);	SelIText		(theDialog,5,0,10);		GetDItem		(theDialog,6,&gType,&gTheHandle,&listRect);	gTheRect 	= 	listRect;	InsetRect		(&gTheRect,-1,-1);	dm_FrameRect		(&gTheRect);		/*MFTemp*/D_HLock((Handle)theDataHandle);	qsort(((SpotInfoPtr)*theDataHandle),(long)data_Count,sizeof(SpotInfo),(_compare_function/*__cmp_func_Cmpfun**/)SpotCompare);	/*MFTemp*/D_HUnlock((Handle)theDataHandle);		SetRect(&dataBounds,0,0,2,0);	cSize.h 	= cSize.v = 0;	theList 	= LNew(&listRect,&dataBounds,cSize,0,theDialog,false,false,false,true);	(*theList)->selFlags = lOnlyOne;		theAngle				= habitAngle * PI / 180.0;	theZ					= fabs(sin(theAngle));	numRows 				= 0;	thisSpot 				= &((SpotInfoPtr)*theDataHandle)[0];	obj_Index->direction		= PLANE;	theCell.v 				= 0;		for(i = 0 ; i < data_Count && theCell.v < maxEntries && fabs(thisSpot->z) <= theZ ; thisSpot++,i++){ 		spotMap[theCell.v] = i;		if(thisSpot->direction)			continue;		if(thisSpot->h == 0 && thisSpot->k == 0 && thisSpot->l == 0)			continue;		obj_Index->theCrystal 	= thisSpot->theCrystal;		obj_Index->h 			= thisSpot->h;		obj_Index->k				= thisSpot->k;		obj_Index->l				= thisSpot->l;		theCell.h 				= 0;		count 					= LAddRow(1,theCell.v,theList);		obj_Index->SetListIndex(theList,theCell);		theCell.h				= 1;		theValue				= asin((double)(thisSpot->z)) * 180. / PI;		sprintf(gTheText,"%5.2f¡",theValue);		LSetCell((Ptr)gTheText,strlen(gTheText),theCell,theList);		theCell.v = ++numRows;	}	LDoDraw(true,theList);	LUpdate(theDialog->visRgn,theList);	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){						case IN_GO_AWAY:			case 4:				quit = true;				break;			case DLOG_ENTER_OR_CR:			case 1:				LDoDraw(false,theList);				LDelRow(numRows,0,theList);				LDoDraw(true,theList);				LUpdate(theDialog->visRgn,theList);				GetDItem(theDialog,5,&gType,&gTheHandle,&gTheRect);				GetIText(gTheHandle,pTheText);				p2cstr(pTheText);								habitAngle 				= atof(gTheText);				theAngle				= habitAngle * PI / 180.0;				theZ					= fabs(sin(theAngle));				numRows 				= 0;				thisSpot 				= &((SpotInfoPtr)*theDataHandle)[0];				obj_Index->direction		= PLANE;				theCell.v 				= 0;								for(i = 0 ; i < data_Count && theCell.v < maxEntries; thisSpot++,i++){ 					if(fabs(thisSpot->z) > theZ)						continue;					spotMap[theCell.v] = i;					if(thisSpot->direction)						continue;					if(thisSpot->h == 0 && thisSpot->k == 0 && thisSpot->l == 0)						continue;					obj_Index->theCrystal 	= thisSpot->theCrystal;					obj_Index->h 			= thisSpot->h;					obj_Index->k				= thisSpot->k;					obj_Index->l				= thisSpot->l;					theCell.h 				= 0;					count 					= LAddRow(1,theCell.v,theList);					obj_Index->SetListIndex(theList,theCell);					theCell.h				= 1;					theValue				= asin((double)(thisSpot->z)) * 180. / PI;					sprintf(gTheText,"%5.2f¡",theValue);					LSetCell((Ptr)gTheText,strlen(gTheText),theCell,theList);					theCell.v = ++numRows;				}				LDoDraw(true,theList);				LUpdate(theDialog->visRgn,theList);				break;			case 2:				theCell.h = theCell.v = 0;				if(LGetSelect(true,&theCell,theList)){					thisSpot	= &((SpotInfoPtr)*theDataHandle)[spotMap[theCell.v]];					thisSpot->flags |= HABIT_MASK;					if(!(thisSpot->flags & TEXT_MASK))						thisSpot->flags |= TEXT_MASK;					SetPort(theWindow);					//SetPict(false);					gTheRect = thisSpot->spotRect;					InsetRect(&gTheRect,-5,-5);					InvalRect(&gTheRect);					//D_DrawPict();					//DoRefresh();					newPictReq = true;					DoIdle();					SetPort(theDialog);				}				break;			case 3:				theCell.h = theCell.v = 0;				if(LGetSelect(true,&theCell,theList)){					spotLoc	= spotMap[theCell.v];					SetPort(theWindow);					RotateToCntr();					newPictReq = true;					DoIdle();					SetPort(theDialog);				}				break;							case 6:			case 7:				thePoint = gTheEvent.where;				GlobalToLocal(&thePoint);				if(LClick(thePoint,gTheEvent.modifiers,theList)){					theCell.h = theCell.v = 0;					if(LGetSelect(true,&theCell,theList)){						thisSpot	= &((SpotInfoPtr)*theDataHandle)[spotMap[theCell.v]];						thisSpot->flags |= HABIT_MASK;						SetPort(theWindow);						//SetPict(false);						gTheRect = thisSpot->spotRect;						InsetRect(&gTheRect,-5,-5);						InvalRect(&gTheRect);						//DoRefresh();						//D_DrawPict();						//refreshFlag = true;						//DoRefresh();						newPictReq = true;						DoIdle();						SetPort(theDialog);					}				}				break;			case ML_UPDATE_EVT:			SetPort(theDialog);			BeginUpdate(theDialog);				DrawDialog(theDialog);				LDoDraw(true,theList);				LUpdate(theDialog->visRgn,theList);				gTheRect = listRect;				InsetRect(&gTheRect,-1,-1);				dm_FrameRect(&gTheRect);				HiliteOK(theDialog);			EndUpdate(theDialog);			break;			default:				break;		}	}		LDispose(theList);	DM_DisposDialog(&theDialog);		return;}			short	SpotCompare(SpotInfo* spot1,SpotInfo* spot2){	double z1,z2;		z1 = fabs((double)spot1->z);	z2 = fabs((double)spot2->z);		return((short)((z1 < z2) ? -1 : ((z1 == z2) ? 0 : 1)));}		void StereoObject::SetXYZValueToHKL(double x,double y,double z,Boolean directFlag){	double	theXForm[3][3];	CopyAxesIntoMatrix(theXForm);	InvertMatrix(theXForm);	obj_Index->direction = directFlag;	NormalizeVector(&x,&y,&z);	obj_Index->x = x;	obj_Index->y = y;	obj_Index->z = z;		obj_Index->GetTheUVWFromXYZ(theXForm);	obj_Index->ConvertXYZToHKLReduce();	if(obj_Index->direction == false) obj_Index->reduceFlag = false;	}						