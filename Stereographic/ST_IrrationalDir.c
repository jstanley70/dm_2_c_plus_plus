//rces.Jim:Stereographic:ST_IrrationalDir.c#include	"Diffract_INCs.h"#include	"StereoObject.h"#include	"UT_VectorMacros.c"void	ConvertIndex(char*	theText,short	value);void	StereoObject::IrrationalDir(Point thePoint){	double			x,y,z;		short			i;	double			theXForm[3][3];	char			theText[100];			if(!ConvertPointToXYZCart(thePoint,&x,&y,&z))return;				obj_Index->theCrystal = theCrystal[baseCrystal];		for(i = 0; i <= 25;i++) gTheText[i] = 0;			sprintf(gTheText,"Crystal %1d ",obj_Index->theCrystal->idNum + 1);	SetXYZValueToHKL(x,y,z,true);	obj_Index->IndexToIndecies(theText);	p2cstr((unsigned char*)theText);	strcat(gTheText,theText);		SetXYZValueToHKL(x,y,z,false);		sprintf(theText," Plane ");	strcat(gTheText,theText);	obj_Index->reduceFlag = true;	obj_Index->IndexToIndecies(theText);	p2cstr((unsigned char*)theText);	strcat(gTheText,theText);	for(i = baseCrystal + 1; i <= 3;i++){		if(planeBounds[i] <= 0 && dirBounds[i] <= 0)continue;		obj_Index->theCrystal = theCrystal[i];		if(obj_Index->theCrystal->idNum != baseCrystal){			double matrix[3][3];			CopyAxesIntoMatrix(matrix);			InvertMatrix(matrix);			TransFormVector(&x,&y,&z,matrix);			GetPPTXFormMatrixBase(theXForm,obj_Index->theCrystal,0);			InvertMatrix(theXForm);			TransFormVector(&x,&y,&z,theXForm);						NormalizeVector(&x,&y,&z);			theCrystal[i]->Get001XForm(theXForm);			ConverttoReciprocal		(theXForm,(double)theCrystal[i]->volume,false);			TransFormVector(&x,&y,&z,theXForm);			NormalizeVector(&x,&y,&z);			CopyAxesIntoMatrix(matrix);			TransFormVector(&x,&y,&z,matrix);			NormalizeVector(&x,&y,&z);		}		sprintf(theText,"Crystal %1d ",obj_Index->theCrystal->idNum + 1);		strcat(gTheText,theText);		SetXYZValueToHKL(x,y,z,true);		obj_Index->IndexToIndecies(theText);		p2cstr((unsigned char*)theText);		strcat(gTheText,theText);					SetXYZValueToHKL(x,y,z,false);		sprintf(theText," Plane ");		strcat(gTheText,theText);			obj_Index->reduceFlag = true;		obj_Index->IndexToIndecies(theText);		p2cstr((unsigned char*)theText);		strcat(gTheText,theText);	}		theRuler->SetInfo(gTheText);	return ;}				void	ConvertIndex(char*	theText,short	value){	short	tens,ones,x,n;		n = (short)theText[0];	x = abs(value);	tens = x / 10;	ones = x % 10;	if(value >= 0){		if(tens > 0){			theText[++n] = (char)(48 + tens);			theText[0]++;		}		theText[++n] = (char)(48 + ones);		theText[0]++;	} else {		if(tens > 0){			theText[++n] = (char)(220 + tens);			theText[0]++;		}		theText[++n] = (char)(220 + ones);		theText[0]++;	}	theText[++n] = ' ';	theText[0]++;}					