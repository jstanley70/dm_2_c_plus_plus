#include	"Diffract_INCs.h"#include	"StereoObject.h"//rces.Jim:Stereographic:ST_StereoObject.c#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"SF_MathLib.h"#include "ML_StereoProj.h"#include "ML_Crystal.h"#include "ML_PPT_Info.h"#include "ML_BeamOrientation.h"void	StereoObject::DoInit()			/* initialize object			*/{	short i;		variSize						=	true;	rulerHeight					=	50;	normalizeCount				=	0;	normalizeFlag				=	false;	structFactFlag				=	false;	zoomFlag						=	false;	labelBounds					=	2;	plotZoneAxes				=	true;	fillPage						=	true;	wulfNet						=	false;	unitsOfRadius				=	1;	wulfNetSmallDeg			=	2;	wulfNetGreatDeg			=	2;	exactDiameter				=	6;	full_Symmetry				=	false;	x_001.x	= y_001.y = z_001.z	= 1.0;	x_001.y	= x_001.z = y_001.x	= 0.0;	y_001.z = z_001.x = z_001.y	= 0.0;				inherited::DoInit();	resizeOK					=	false;	poleObject				=	0L;	theRuler->EnableButtons(3);	g1 		= ((Index*)D_new(Index))->Init(PLANE,theCrystal[0]);	g2 		= ((Index*)D_new(Index))->Init(PLANE,theCrystal[0]);	dirA_1	= ((Index*)D_new(Index))->Init(DIRECTION,theCrystal[0]);	dirA_2	= ((Index*)D_new(Index))->Init(DIRECTION,theCrystal[0]);	dirB_1	= ((Index*)D_new(Index))->Init(DIRECTION,theCrystal[0]);	dirB_2	= ((Index*)D_new(Index))->Init(DIRECTION,theCrystal[0]);	angle1	= 0.0;	angle2	= 0.0;	habitAngle = 5.0;		previousZoom.theObjectSize	=	objectSize;	previousZoom.hScrollValue	=	0;	previousZoom.vScrollValue	=	0;			fileInfo.sfType = DIF_OBJ;			labelMatrixFlag		= false;	for(i = 0 ; i <= 3 ; i++){		planeBounds[i]	= 0;		dirBounds[i]	= 0;	}	planeBounds[0] = 3;	FinishSetUp();		/*KillMBHandle*/DisposeHandle(theMenuBar);	theMenuBar = GetMenuBar();	DrawMenuBar();			totalPoles = 0;	add_N_Pole = 0;	maxPoles = 0;	poleHandle = 0L;	if(gTheFile->file_is_Open)		return;/*eric's correction dec 1992*/		DoDefine();		return;}void StereoObject::SetObjectMenu(void){	theMenuBar = GetNewMBar(STEREO_OBJ_MB);	ClearMenuBar();/* July 1992 */	SetMenuBar	(theMenuBar);	InsertMenu(g_Pole_Figure_Menu,-1);}void	StereoObject::DoPrint(void){	PrintSetUp();	inherited::DoPrint();	fillPage			=	true;	wulfNet			=	false;	}void	StereoObject::FinishSetUp(void){	if(gTheFile->file_is_Open){		SetWTitle(theWindow,fileInfo.sfFile.name);		return;	}	sprintf(gTheText,"Stereo %d",g_Window_Number);	SetWTitle(theWindow,c2pstr(gTheText));	g_Window_Number++;	}void	StereoObject::PrintSetUp(void){	DialogPtr 		theDialog;	Boolean			quit;	PopUpMenu		*unitPopUp;	long			theResult;	double			theValue;	short			theSelect,oldResult;			theDialog	= DM_GetNewDialog(132,NUL,IN_FRONT);		quit = false;	fillPage = SwitchBoolean(theDialog,2,!fillPage);	SwitchBoolean(theDialog,10,fillPage);	wulfNet  = SwitchBoolean(theDialog,3,!wulfNet);		SetItemValue(theDialog,4,exactDiameter,2);	SetItemValue(theDialog,5,wulfNetGreatDeg,1);		SetItemValue(theDialog,6,wulfNetSmallDeg,1);		unitPopUp		= 	(PopUpMenu*)D_new		(PopUpMenu);	unitPopUp->		Init		(theDialog,7,34,unitsOfRadius);	oldResult = unitsOfRadius;	SelIText(theDialog,4,0,200);	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;			case IN_GO_AWAY:				quit = true;				break;			case DLOG_ENTER_OR_CR:			case 1:				exactDiameter 	= GetItemValue(theDialog,4);				wulfNetGreatDeg = GetItemValue(theDialog,5);					wulfNetSmallDeg = GetItemValue(theDialog,6);				unitsOfRadius	= unitPopUp->lastResult;				quit = true;				break;			case 10:			case 2:				fillPage = SwitchBoolean(theDialog,2,fillPage);				SwitchBoolean(theDialog,10,fillPage);				break;			case 3:				wulfNet  = SwitchBoolean(theDialog,3,wulfNet);				break;			case 7:				theResult = unitPopUp->	DoPopUp();				if(oldResult != unitPopUp->lastResult){					theValue 	= GetItemValue(theDialog,4);					if(unitPopUp->lastResult == 2){						theValue *= 2.54;					}else{						theValue /= 2.54;					}					SetItemValue(theDialog,4,theValue,2);				}				oldResult = unitPopUp->lastResult;				break;			default:				break;		}	}	unitPopUp->DoClose();	DM_DisposDialog(&theDialog);	return;}short	StereoObject::LocatePole(double* x,double* y,double* z){	long			dataMask;	short			i;	double			u,v,w,theXForm[3][3];	SpotInfoPtr		theSpotArray;		dataMask = obj_Index->theCrystal->idNum;	/*MFTemp*/D_HLock((Handle)theDataHandle);	theSpotArray = (SpotInfoPtr)*theDataHandle;	if(data_Count > 0){			for(i = 0 ; i < data_Count ; i++,theSpotArray++){			if(	theSpotArray->flags == dataMask &&				theSpotArray->direction == obj_Index->direction &&				theSpotArray->h == obj_Index->h &&				theSpotArray->k == obj_Index->k &&				theSpotArray->l == obj_Index->l){					*x = theSpotArray->x;					*y = theSpotArray->y;					*z = theSpotArray->z;					/*MFTemp*/D_HUnlock((Handle)theDataHandle);					return (i);			}		}	}	/*MFTemp*/D_HUnlock((Handle)theDataHandle);		if(obj_Index->direction){		u = obj_Index->h;		v = obj_Index->k;		w = obj_Index->l;	} else {		obj_Index->DirOfPlaneNormal(&u,&v,&w);  /*  Look at FindPole */	}		GetPPTXFormMatrixBase(theXForm,obj_Index->theCrystal,0);	TransFormVector(&u,&v,&w,theXForm);	NormalizeVector(&u,&v,&w);		*x = u * x_001.x + v * y_001.x + w * z_001.x;	*y = u * x_001.y + v * y_001.y + w * z_001.y;	*z = u * x_001.z + v * y_001.z + w * z_001.z;	return (-1);}double	StereoObject::SetRadius(void){	double r,xdim,ydim,span;	short	hRes,vRes;	GrafPtr	wPort;		if(fillPage){		xdim = thePictRect.right	- thePictRect.left;		ydim = thePictRect.bottom	- thePictRect.top;				if(xdim < ydim){			r = (xdim - 26) / 2;		} else {			r = (ydim - 26) / 2;		}	}else{		ScreenRes(&hRes, &vRes);		r = exactDiameter * hRes * .5;		if(unitsOfRadius == 2) r *= 2.54;			}	GetWMgrPort (&wPort);		span = 	(double)(wPort->portRect.right - wPort->portRect.left +			wPort->portRect.bottom - wPort->portRect.top) * 1.14;				if(r > span)	/* Stops memory over-run in PICT at high zooms in small circles */		r = span;		projLengthScreen = (float)r;			return projLengthScreen;}void	StereoObject::DrawWulfNet(void){	SpotInfo	localSpot;	SpotInfoPtr theSpot;	double		theXForm[3][3];	double		a = 0,b = 1,c = 0,radians,delRadian;			theSpot		= &localSpot;	delRadian 	= wulfNetGreatDeg * PI / 180;	radians  	= delRadian;	theSpot->theCrystal = theCrystal[0];	theSpot->intensity	=	1;	while( radians < PI){				RotatateMatrixAxis(theXForm,delRadian,0);		TransFormVector(&a,&b,&c,theXForm);		theSpot->x = a;		theSpot->y = b;		theSpot->z = c;		PlaneTraces(theSpot);		radians += delRadian;	}		delRadian = wulfNetSmallDeg * PI / 180;	theSpot->x = 1;	theSpot->y = 0;	theSpot->z = 0;	a = delRadian;		while(a < PI / 2){				theSpot->angle = a;		DrawSmallCircle(theSpot,false);		a += delRadian;	}	theSpot->x = -1;	theSpot->y = 0;	theSpot->z = 0;	a = delRadian;	while( a < PI / 2){		theSpot->angle = a;		DrawSmallCircle(theSpot,false);		a += delRadian;	}}void 	FrameTriangle(Rect *theTriangle);void	DrawCross(Rect *theOval);void	StereoObject::DoPictDraw(){	double 		factor;	Rect 			theOval,oldOval,theRect,newRect;	long 			theX,theY,count=0,drawMask,flagMask;	SpotInfoPtr thisSpot;	short 		theIdent,theRad,h1,v1,h2,v2,i,xdim,theValue;		SetRect(&centerDisk,-projLengthScreen,-projLengthScreen,projLengthScreen,projLengthScreen);		radius = SetRadius();		centerX = (thePictRect.right + thePictRect.left) / 2;	centerY = (thePictRect.bottom + thePictRect.top) / 2;	SetRect(&oldOval,-2,-2,2,2);	theRad = (short)projLengthScreen;	OffsetRect(&centerDisk,centerX,centerY);		SetDrawEnviron();	DMForeColor		(COMPLEMENT_COLOR);	if(objectType == KIKUCHI_OBJECT || objectType == KIKUCHI_OBJECT + 10 ||  objectType == KIKUCHI_OBJECT + 20)	{		theRad = 3;	}else{		if(theRad > 7500)			theRad = 7500;	}	h1 = centerX - theRad;	h2 = centerX + theRad;	v1 = centerY - theRad;	v2 = centerY + theRad;	SetRect(&theRect,h1,v1,h2,v2);	dm_FrameOval(&theRect);		if(objectType == KIKUCHI_OBJECT || objectType == KIKUCHI_OBJECT + 10 ||  objectType == KIKUCHI_OBJECT + 20)	{		theRad = 5;	}else{		theRad = 5;	}	h1 = centerX - theRad;	h2 = centerX + theRad;	v1 = centerY - theRad;	v2 = centerY + theRad;	SetRect(&theRect,h1,v1,h2,v2);	dm_FrameOval(&theRect);	thisSpot = (SpotInfoPtr)*theDataHandle;	numSpots = 	data_Count;		 	for(i = 1 ; i <= data_Count ; i++,thisSpot++){		flagMask = FLAG_MASK & thisSpot->flags;		drawMask = DRAW_MASK & thisSpot->flags;		theOval = oldOval;		if(!(thisSpot->flags & SYMMETRY_MASK)){				if(thisSpot->z < -0.0000001 || (objectType != STEREO_OBJ && !thisSpot->direction)){				thisSpot->spotRect = oldOval;				if(drawMask){					DRAW_PLANE_TRACE(thisSpot);					DRAW_SMALL_CIRCLE(thisSpot);				}				continue;			}		}		if(thisSpot->z < -0.00001){			factor	= projLengthScreen / (-1.0 + thisSpot->z);			theX	= centerX - Round((double)factor * thisSpot->y);			theY	= centerY - Round((double)factor * thisSpot->x);		}else{			factor	= projLengthScreen / (1.0 + fabs(thisSpot->z));			theX	= centerX + Round((double)factor * thisSpot->y);			theY	= centerY + Round((double)factor * thisSpot->x);		}				OffsetRect(&theOval,theX,theY);		theIdent = thisSpot->flags & CRYSTAL_MASK;		if(objectType != STEREO_OBJ && !thisSpot->direction)			continue;		theValue = theIdent;				if(structFactFlag && !thisSpot->direction){				xdim = -Round(2.5 * pow((double)thisSpot->intensity,1/dyRange));				InsetRect(&theOval,xdim,xdim);		}				if(thisSpot->flags & SYMMETRY_MASK){			DMForeColor(theIdent + 10);			if(thisSpot->z < 0){				 InsetRect(&theOval,-2,-2);				 dm_FrameOval(&theOval);			}else{				dm_PaintOval(&theOval);			}			thisSpot->spotRect = theOval;			PenPat(&qd.black);		}else{						if(greyFlag && !thisSpot->direction){				if(g_Monitor){					theValue = 220 * pow((double)thisSpot->intensity,1/dyRange);				}else{					theValue = 10 * pow((double)thisSpot->intensity,1/dyRange);				}			}				if(plotZoneAxes){				if(!(thisSpot->flags & POLE_FIGURE))					DM_DrawRect(theOval,theIdent,theValue,thisSpot->direction);				else{					DMForeColor(theIdent + 10);					if((thisSpot->flags & POLE_001))dm_FrameRect(&theOval);					else if((thisSpot->flags & POLE_111))FrameTriangle(&theOval);					else if((thisSpot->flags & POLE_110)){						theOval.top -= 2;						theOval.bottom += 2;						dm_FrameOval(&theOval);					}					else{					 dm_FrameRect(&theOval);					 DrawCross(&theOval);					}				}							}						if(thisSpot->flags & XTAL_ROT){				newRect = theOval;				InsetRect(&newRect,-1,-1);				dm_FrameRect(&newRect); 				DM_DrawRect(newRect,theIdent,theValue,thisSpot->direction);			}						thisSpot->spotRect = theOval;		}				if(flagMask){			if(drawMask){				DRAW_PLANE_TRACE(thisSpot);				DRAW_SMALL_CIRCLE(thisSpot);			}			if(thisSpot->flags & MARK_MASK){				DRAW_BEAM_SPOT(thisSpot,theX,theY);				DRAW_LINE_SPOT(thisSpot,theX,theY);				DRAW_DEFECT_SPOT(thisSpot,theX,theY);				DRAW_HABIT_PLANE(thisSpot);				DRAW_PIN_MARK(thisSpot,theX,theY);				DRAW_PRIME_MARK(thisSpot,theX,theY);				PenNormal();			}		}	}		/*  from Spot Object  */	//PlotPolePositions();	if(wulfNet)DrawWulfNet();	ClearDrawEnviron();}void DrawCross(Rect *theOval){	MoveTo(theOval->left,(theOval->top + theOval->bottom)/2);	LineTo(theOval->right,(theOval->top + theOval->bottom)/2);	MoveTo((theOval->left + theOval->right)/2,theOval->top);	LineTo((theOval->left + theOval->right)/2,theOval->bottom);}void 	FrameTriangle(Rect *theTriangle){	MoveTo(theTriangle->left,theTriangle->bottom);	LineTo((theTriangle->left + theTriangle->right)/2,theTriangle->top);	LineTo(theTriangle->right,theTriangle->bottom);	LineTo(theTriangle->left,theTriangle->bottom);}void	StereoObject::DoClose(void){	/* Code Added By J.T. */	if(poleObject != (SADObj*)0L){  // add this if          poleObject->stereoObj = 0L;  }	g1->DoClose();	g2->DoClose();	dirA_1->DoClose();	dirA_2->DoClose();	dirB_1->DoClose();	dirB_2->DoClose();	if(poleHandle)KillHandle((Handle*)&poleHandle);	inherited::DoClose();		return;}void	StereoObject::AddSpot(void){	DialogPtr	theDialog;	Point		thePoint;	short		theSelect,crystalID = 0;	PopUpMenu	*theCrystalMenu;	Boolean		textUpdate,addTypeFlag=false;	double		spacing;		thePoint.h = 0;	thePoint.v = rulerHeight + 19;	LocalToGlobal(&thePoint);	theDialog = GetNewDialog(ADD_SPOT_DLOG,NUL,IN_FRONT);		SetPort(theDialog);	if(poleObject) poleObject->stereoObj = 0L;	MoveWindow(theDialog,thePoint.h,thePoint.v,true);	ShowWindow(theDialog);	theCrystalMenu = (PopUpMenu*)D_new(PopUpMenu);	if(!HandleIsOK((Handle)theCrystalMenu)){		DM_DisposDialog(&theDialog);		return;	}		GetDItem(theDialog,3,&gType,&gTheHandle,&gTheRect);	SetCtlValue((ControlHandle)gTheHandle,1);	theCrystalMenu->Init(theDialog,7,52,CRYSTAL_SELECT);		obj_Index->DoInit(false,theCrystal[theCrystalMenu->lastResult - 1]);	SelIText(theDialog,6,0,100);	DrawDialog(theDialog);	while(true){		ModalDialog(TheFilterUPP/*SmallFilterUPP*/,&theSelect);		if(textUpdate && theSelect != 6){			obj_Index->GetIndex(theDialog,6);			obj_Index->SetIndex(theDialog,6);			textUpdate = false;		}					switch(theSelect){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;			case DLOG_ENTER_OR_CR:			case 1:				obj_Index->GetIndex(theDialog,6);				obj_Index->SetIndex(theDialog,6);					spacing = obj_Index->TheDSpacing();				SetPort(theWindow);				if(addTypeFlag){					theRuler->SetPrompt("Adding the type.");					D_SetClip(drawRgn);					if(!(obj_Index->theCrystal->lattice_Type == HEXAGONAL || 						obj_Index->theCrystal->lattice_Type == TRIGONAL)/* || !g_Hex_Four*/){/*dec 1992 jim*/						short	i,u;						double	x,y,z,theD;						Index	*thisIndex;												thisIndex = (Index*)D_new(Index);						obj_Index->DoCopy(thisIndex);						for(i = 0 ; i <= 47 ; i++){							if(i == 8 || i == 24 || i == 40){								u = thisIndex->h;								thisIndex->h = thisIndex->k;								thisIndex->k = u;							}							if(i == 16 || i == 32){								u = thisIndex->l;								thisIndex->l = thisIndex->k;								thisIndex->k = u;							}							thisIndex->DoCopy(obj_Index);							if(i & 1)								obj_Index->h *= -1;							if(i & 2)								obj_Index->k *= -1;							if(i & 4)								obj_Index->l *= -1;							theD = obj_Index->TheDSpacing();							if(fabs(spacing -  theD) < .001){								if((spotLoc = LocatePole(&x,&y,&z)) >= 0){									LabelSpot();								} else {									AddThisSpot(x,y,z);								}							}						}						D_delete(thisIndex);					} else {						{							long 	i,j,m,n,uvtws[3],a,k;							double	x,y,z;							short	u,v,t,w;							Boolean	hex_Four;							hex_Four = g_Hex_Four;							g_Hex_Four = true;							obj_Index->IndexToHex(&u,&v,&t,&w);							uvtws[0] = u;							uvtws[1] = v;							uvtws[2] = t;							a = w;														for(j = -1 ; j <= 1 ; j += 2){								w = j * a;								for(i = -1 ; i <= 1 ; i += 2){									for(m = 0 ; m <= 2 ; m++){										for(n = 0 ; n <= 2 ; n++){											if(m == n)												continue;											u = i * uvtws[m];											v = i * uvtws[n];											t = -u - v;											obj_Index->IndexFromHex(u,v,t,w);											if((k = LocatePole(&x,&y,&z)) >= 0){												spotLoc = k;												g_Hex_Four = hex_Four;												LabelSpot();												g_Hex_Four = true;											} else {												g_Hex_Four = hex_Four;												AddThisSpot(x,y,z);												g_Hex_Four = true;											}										}									}								}							}							g_Hex_Four = hex_Four;						}					}					theRuler->ClearPrompt();				} else {					double	x,y,z;					short n;										theRuler->SetPrompt("Adding the Spot.");					D_SetClip(drawRgn);					SystemTask();					if((n = LocatePole(&x,&y,&z)) >= 0){						spotLoc = n;						LabelSpot();					} else {						AddThisSpot(x,y,z);					}					theRuler->ClearPrompt();				}				SetPort(theDialog);				SelIText(theDialog,6,0,200);				break;							case 2:				theCrystalMenu->DoClose();				DisposDialog(theDialog);				SetPort(theWindow);				newPictReq = true;								return;				break;			case 3:				GetDItem(theDialog,3,&gType,&gTheHandle,&gTheRect);				SetCtlValue((ControlHandle)gTheHandle,1);				GetDItem(theDialog,4,&gType,&gTheHandle,&gTheRect);				SetCtlValue((ControlHandle)gTheHandle,0);				obj_Index->DoInit(false,theCrystal[theCrystalMenu->lastResult - 1]);				obj_Index->GetIndex(theDialog,6);				obj_Index->SetIndex(theDialog,6);				SelIText(theDialog,6,0,100);				break;			case 4:				GetDItem(theDialog,4,&gType,&gTheHandle,&gTheRect);				SetCtlValue((ControlHandle)gTheHandle,1);				GetDItem(theDialog,3,&gType,&gTheHandle,&gTheRect);				SetCtlValue((ControlHandle)gTheHandle,0);				obj_Index->DoInit(true,theCrystal[theCrystalMenu->lastResult - 1]);				obj_Index->GetIndex(theDialog,6);				obj_Index->SetIndex(theDialog,6);				SelIText(theDialog,6,0,100);				break;			case 5:				GetDItem(theDialog,5,&gType,&gTheHandle,&gTheRect);				if(GetCtlValue((ControlHandle)gTheHandle) == 0){					SetCtlValue((ControlHandle)gTheHandle,1);					addTypeFlag = true;				} else {					SetCtlValue((ControlHandle)gTheHandle,0);					addTypeFlag = false;				}				break;			case 6:				textUpdate = true;				break;			case 7:				GlobalToLocal(&gTheEvent.where);				theCrystalMenu->DoPopUp();				GetDItem(theDialog,3,&gType,&gTheHandle,&gTheRect);				if(GetCtlValue((ControlHandle)gTheHandle)){					obj_Index->DoInit(false,theCrystal[theCrystalMenu->lastResult - 1]);				} else {					obj_Index->DoInit(true,theCrystal[theCrystalMenu->lastResult - 1]);				}				obj_Index->GetIndex(theDialog,6);				obj_Index->SetIndex(theDialog,6);				SelIText(theDialog,6,0,100);									break;			default:				break;		}	}}void		StereoObject::AddThisSpot(double x,double y,double z){		long	theX,theY;	double	factor;	Point	*thePoints;		newPictEnable = true;	if(++data_Count >= data_Length){		long	size;		size = GetHandleSize(theDataHandle) + 10 * sizeof(SpotInfo);		SetHandleSize(theDataHandle,size);		if(MemError() == 0 && FreeMem() > 32000L){			data_Length += 10;		} else {			StopAlert(OUT_OF_MEM,NUL);			data_Count--;			return;		}	}		factor	= projLengthScreen / (1.0 + z);	theX	= centerX + (short)(factor * y + .5);	theY	= centerY + (short)(factor * x + .5);	SetRect(&gTheRect,-2,-2,2,2);	OffsetRect(&gTheRect,(short)theX,(short)theY);	/*MFTemp*/D_HLock((Handle)theDataHandle);		spotLoc = data_Count - 1;		THE_CURRENT_SPOT.x 			= x;	THE_CURRENT_SPOT.y 			= y;	THE_CURRENT_SPOT.z 			= z;	THE_CURRENT_SPOT.h 			= obj_Index->h;	THE_CURRENT_SPOT.k 			= obj_Index->k;	THE_CURRENT_SPOT.l 			= obj_Index->l;	THE_CURRENT_SPOT.direction 	= obj_Index->direction;	THE_CURRENT_SPOT.theCrystal 	= obj_Index->theCrystal;	THE_CURRENT_SPOT.flags		= obj_Index->theCrystal->idNum;	if(obj_Index->flags & POLE_FIGURE){		THE_CURRENT_SPOT.flags |= (POLE_ALL & obj_Index->flags);	}	THE_CURRENT_SPOT.spotRect	= gTheRect;	if(objectType == KIKUCHI_OBJECT || objectType == KIKUCHI_OBJECT + 10 ||  objectType == KIKUCHI_OBJECT + 20)	{		if(!THE_CURRENT_SPOT.direction){			float theD;			long	flags;			flags = K_MAP_MASK | SMALL_CIRCLE;			THE_CURRENT_SPOT.flags |= flags;			theD = THE_CURRENT_SPOT.theCrystal->DSpacing(THE_CURRENT_SPOT.h,THE_CURRENT_SPOT.k,THE_CURRENT_SPOT.l);			theD += theD;			THE_CURRENT_SPOT.angle =  (PI / 2.0) - asin(wavelength / theD);			DrawSmallCircle((&THE_CURRENT_SPOT),false);		}				/*MFTemp*/D_HUnlock((Handle)theDataHandle);		return;	}				if(z > -.05){		thePoints = (Point*)(&gTheRect);		ObjToLocal(&thePoints[0]);		ObjToLocal(&thePoints[1]);		obj_Index->theCrystal->SetColor();		if(obj_Index->direction){			dm_PaintRect(&gTheRect);		} else {			dm_PaintOval(&gTheRect);		}	}		if(!(THE_CURRENT_SPOT.flags & POLE_FIGURE)){		if(obj_Index->h != 0 || obj_Index->k != 0 || obj_Index->l != 0 )			LabelSpot();	}		/*MFTemp*/D_HUnlock((Handle)theDataHandle);}void	StereoObject::ZoomPrevious(void){	Point	tempSize;	short	hVal,vVal;		tempSize	= objectSize;	hVal		= GetCtlValue(hScroll->theControl);	vVal		= GetCtlValue(vScroll->theControl);		objectSize	= previousZoom.theObjectSize;	zoomFlag	= true;		newPictReq = true;	//SetPict(true);	SetCtlValue(hScroll->theControl,previousZoom.hScrollValue);	SetCtlValue(vScroll->theControl,previousZoom.vScrollValue);		previousZoom.theObjectSize	= tempSize;	previousZoom.hScrollValue	= hVal;	previousZoom.vScrollValue	= vVal;	ResetCurvedLabels();	return;}void	StereoObject::ZoomIn(Point thePoint){	Point	thisPoint,startPoint;	Rect	lastRect;	unsigned long	theResult;	double	xLoc,yLoc,xCos,yCos,magX,magY,theMag;	short	x,y;		PenMode(srcXor);		startPoint = thisPoint = thePoint;	gTheRect.left	= thisPoint.h - 100;	gTheRect.right	= gTheRect.left + 200;	gTheRect.top	= thisPoint.v - 100;	gTheRect.bottom	= gTheRect.top + 200;	dm_FrameRect(&gTheRect);	lastRect = gTheRect;		while(Button()){		GetMouse(&thisPoint);		if(!EqualPt(thisPoint,thePoint)){			theResult = DeltaPoint(startPoint,thisPoint);			gTheRect.left	= startPoint.h - abs(LoWord(theResult));			gTheRect.right	= startPoint.h + abs(LoWord(theResult));			gTheRect.top	= startPoint.v - abs(HiWord(theResult));			gTheRect.bottom = startPoint.v + abs(HiWord(theResult));			SystemTask();			dm_FrameRect(&lastRect);			dm_FrameRect(&gTheRect);			lastRect = gTheRect;			thePoint = thisPoint;		} else {			Delay(6L,&theResult);		}		SystemTask();	}	dm_FrameRect(&lastRect);		SetTheCursor(WATCH_CURSOR);	/*************** Save Previous Zoom ***************/		previousZoom.theObjectSize	=	objectSize;	previousZoom.hScrollValue	=	GetCtlValue(hScroll->theControl);	previousZoom.vScrollValue	=	GetCtlValue(vScroll->theControl);		/*************** Calculate Magnification ***************/		magX	= (double)theWindow->portRect.right / (double)(lastRect.right - lastRect.left);	magY	= (double)theWindow->portRect.bottom / (double)(lastRect.bottom - lastRect.top);	if(magX < magY){		theMag = magX;	} else {		theMag = magY;	}	if(theMag > 8.0 || theMag < 1.0)		theMag = 2.0;		magX = (double)objectSize.h * theMag;	if(magX > 32767.0)		magX = 32767.0;	objectSize.h = (short)magX;		magY = (double)objectSize.v * theMag;	if(magY > 32767.0)		magY = 32767.0;	objectSize.v = (short)magY;		/*************** Find Spot Location ***************/		startPoint.h += GetCtlValue(hScroll->theControl);	startPoint.v += GetCtlValue(vScroll->theControl);	xCos = (double)(startPoint.h - centerX) / projLengthScreen;	yCos = (double)(startPoint.v - centerY) / projLengthScreen;		/*************** Calculate the Picture ***************/		zoomFlag = true;	SetPict(true);	D_DrawPict();			/*************** Set Scroll Bars ***************/		xLoc 	= (double)centerX + xCos * projLengthScreen;	yLoc 	= (double)centerY + yCos * projLengthScreen;	x 		= xLoc + 13 - theWindow->portRect.right / 2;	y 		= yLoc + 10 - (rulerHeight + theWindow->portRect.bottom) / 2;		SetCtlValue(hScroll->theControl,x);	SetCtlValue(vScroll->theControl,y);	SetPort(theWindow);	newPictReq = true;	dm_EraseRect(&thePictRect);	InvalRect(&thePictRect);	ResetCurvedLabels();	//refreshFlag = true;	//dm_EraseRect(&thePictRect);	//InvalRect(&thePictRect);	//DoRefresh();		return;}void	StereoObject::PlaneTraces(SpotInfoPtr theSpot){	double		X,Y,Z,R,theAngle,dist,px,py,offset,scale,centX,centY;	Rect		theRect;	RgnHandle 	oldClipRgn,newClipRgn;	short		hVal,vVal;	Point		thePoint;		 	if(theSpot->z >= 0.0){		Z = theSpot->z;		scale = 2.0 / (1.0 + Z);		Y = scale * theSpot->x;		X = scale * theSpot->y;	} else {		Z = -theSpot->z;		scale = 2.0 / (1.0 + Z);		Y = -scale * theSpot->x;		X = -scale * theSpot->y;	}		dist = sqrt(X * X + Y * Y);	if(onScreen){		hVal = GetCtlValue(hScroll->theControl);		vVal = GetCtlValue(vScroll->theControl);	} else {		hVal = vVal = 0;	}	if(dist < 1.989){		double	x1,y1,x2,y2,x3,y3,x4,y4,rectDiagonal;				/************ Set up Rect for the oval ***********/				theAngle = atan2(Y,X);		offset = projLengthScreen * tan(0.78539816339744831 - atan2(dist , 2.0));		R = (projLengthScreen * projLengthScreen + offset * offset)/(offset + offset);		px = (offset - R) * cos(theAngle);		py = (offset - R) * sin(theAngle);		centX = centerX - px;		centY = centerY - py;		theRect.top 	= centY - R - vVal;		theRect.left	= centX - R - hVal;		theRect.bottom	= centY + R - vVal;		theRect.right	= centX + R - hVal;				/************ Set up rotated Rect for the clip ***********/				rectDiagonal = projLengthScreen * 1.41421356237309505;						theAngle += 0.78539816339744831;		x2 = -rectDiagonal * sin(theAngle);		y2 = rectDiagonal * cos(theAngle);		x3 = -y2;		y3 = x2;						theAngle += 0.78539816339744831;		x1 = projLengthScreen * cos(theAngle);		y1 = projLengthScreen * sin(theAngle);		x4 = -x1;		y4 = -y1;						x1 += centerX - hVal;		x2 += centerX - hVal;		x3 += centerX - hVal;		x4 += centerX - hVal;		y1 += centerY - vVal;		y2 += centerY - vVal;		y3 += centerY - vVal;		y4 += centerY - vVal;				/************ Set up the clip ***********/				newClipRgn = D_NewRgn();		oldClipRgn = D_NewRgn();		OpenRgn();		MoveTo((short)x1,(short)y1);		LineTo((short)x2,(short)y2);		LineTo((short)x3,(short)y3);		LineTo((short)x4,(short)y4);		LineTo((short)x1,(short)y1);		CloseRgn(newClipRgn);		if(onScreen)			SectRgn(drawRgn,newClipRgn,newClipRgn);		GetClip(oldClipRgn);		D_SetClip(newClipRgn);			dm_FrameOval(&theRect);		RectRgn(oldClipRgn,&thePictRect);		D_SetClip(oldClipRgn);		D_DisposeRgn(&newClipRgn);		D_DisposeRgn(&oldClipRgn);	} else {		py = -(double)projLengthScreen * X / dist;		px = (double)projLengthScreen * Y / dist;		thePoint.h = centerX - px;		thePoint.v = centerY - py;		if(onScreen)		ObjToLocal(&thePoint);		MoveTo(thePoint.h,thePoint.v);		thePoint.h = centerX + px;		thePoint.v = centerY + py;		if(onScreen)			ObjToLocal(&thePoint);		LineTo(thePoint.h,thePoint.v);	}//	newPictEnable = true;newPictEnable = true;}void	StereoObject::TwoPointPlane(Boolean	initFlag){	static 	SpotInfo	*spot1,*spot2;		static	short		theSelect;	Point	*thePoints;	if(initFlag){		spot1 = spot2 = (SpotInfo*)NUL;		theSelect = 1;		theRuler->SetHelp("Select the first pole.");		return;	}		switch(theSelect){		case 1:			spot1 = (&THE_CURRENT_SPOT);			theSelect = 2;			theRuler->SetHelp("Select the second pole.");			gTheRect = spot1->spotRect;			InsetRect(&gTheRect,-1,-1);			InvertTheRect(&gTheRect);			return;			break;		case 2:			spot2 = (&THE_CURRENT_SPOT);			theSelect = 1;			{				double 		x,y,z,x1,y1,z1,x2,y2,z2,factor;				SpotInfoPtr	newSpot,theSpots;				long		size,theX,theY;							x1 = spot1->x;				y1 = spot1->y;				z1 = spot1->z;							x2 = spot2->x;				y2 = spot2->y;				z2 = spot2->z;								CrossProduct(&x,&y,&z,x1,y1,z1,x2,y2,z2);				if(z < 0.0){					x *= -1.0;					y *= -1.0;					z *= -1.0;				}				NormalizeVector(&x,&y,&z);/*changed position 1993 March 4*/				if(data_Count >= data_Length){					size = GetHandleSize(theDataHandle) + 10 * sizeof(SpotInfo);					SetHandleSize(theDataHandle,size);					if(MemError() == 0 && FreeMem() > 32000L){						data_Length += 10;					} else {						StopAlert(OUT_OF_MEM,NUL);						data_Count--;					}				}				/*MFTemp*/D_HLock(theDataHandle);				theSpots = (SpotInfoPtr)*theDataHandle;								newSpot 			= &(theSpots[data_Count++]);				newSpot->theCrystal	= spot1->theCrystal;				newSpot->x			= x;				newSpot->y			= y;				newSpot->z			= z;				newSpot->h			= newSpot->k = newSpot->l = 0;				newSpot->flags 		= (spot1->flags & CRYSTAL_MASK) + PLANE_TRACE + HABIT_MASK;				newSpot->direction 	= false;								/*MFTemp*/D_HUnlock(theDataHandle);												gTheRect = spot1->spotRect;				InsetRect(&gTheRect,-1,-1);				InvertTheRect(&gTheRect);				PlaneTraces(newSpot);				factor	= projLengthScreen / (1.0 + newSpot->z);				theX	= centerX + (short)(factor * newSpot->y + .5);				theY	= centerY + (short)(factor * newSpot->x + .5);				SetRect(&gTheRect,-2,-2,2,2);				OffsetRect(&gTheRect,(short)theX,(short)theY);				newSpot->spotRect = gTheRect;				thePoints = (Point*)(&gTheRect);				ObjToLocal(&thePoints[0]);				ObjToLocal(&thePoints[1]);				dm_PaintOval(&gTheRect);			}			theRuler->SetHelp("Select the first pole.");			newPictEnable = true;			return;			break;		default:			return;			break;	}}void	StereoObject::AddSmallCircle(){	short		xOrg,yOrg;	Point		thisPoint,lastPoint,centerPoint;	double		x1,y1,z1,r,R,angle,x,y,z;			gTheRect = THE_CURRENT_SPOT.spotRect;	xOrg = (gTheRect.left + gTheRect.right) / 2;	yOrg = (gTheRect.top + gTheRect.bottom) / 2;	centerPoint.h = centerX;	centerPoint.v = centerY;	ObjToLocal(&centerPoint);	lastPoint.h = xOrg;	lastPoint.v = yOrg;	ObjToLocal(&lastPoint);	xOrg = lastPoint.h;	yOrg = lastPoint.v;	thisPoint = lastPoint;	D_SetClip(drawRgn);	THE_CURRENT_SPOT.theCrystal->SetColor();	PenMode(patXor);	MoveTo(xOrg,yOrg);	LineTo(thisPoint.h,thisPoint.v);	x = THE_CURRENT_SPOT.x;	y = THE_CURRENT_SPOT.y;	z = THE_CURRENT_SPOT.z;	while(Button()){		GetMouse(&thisPoint);		if(thisPoint.h != lastPoint.h || thisPoint.v != lastPoint.v){			D_SetClip(drawRgn);			THE_CURRENT_SPOT.theCrystal->SetColor();			PenMode(patXor);			LineTo(xOrg,yOrg);			LineTo(thisPoint.h,thisPoint.v);			lastPoint = thisPoint;			y1 = (double)(lastPoint.h - centerPoint.h); 			x1 = (double)(lastPoint.v - centerPoint.v); 			if(x1 == 0.0 && y1 == 0.0){				angle = acos(z);			} else {				r = sqrt(x1 * x1 + y1 * y1);				R = fabs((double)projLengthScreen);				angle = 2.0 * atan(r / R);				z1 = cos(angle);				r /= sin(angle);				x1 /= r;				y1 /= r;				angle = acos(x1 * x + y1 * y + z1 * z);			}			R = angle * 180. / PI;			sprintf(gTheText,"%5.2f¡",R);			theRuler->SetInfo(gTheText);			MoveTo(thisPoint.h,thisPoint.v);			D_SetClip(drawRgn);			THE_CURRENT_SPOT.theCrystal->SetColor();			PenMode(patXor);		}	}	LineTo(xOrg,yOrg);	PenNormal();	if(angle > (PI/45.)){		THE_CURRENT_SPOT.flags |= SMALL_CIRCLE;		THE_CURRENT_SPOT.angle = angle;		DrawSmallCircle((&THE_CURRENT_SPOT),false);		newPictEnable = true;	}}	void	StereoObject::DrawArc(Rect theRect,double cx,double cy,double radius){	double	R,centX,centY,theAngle,startAngle,d;	double	a11,a12,a21,a22,theCos_a11,theCos_a21,theSin_a12,theSin_a22;	Point	p0,p1,p2,p3,p4,p5,p6,*rectPoint;	RgnHandle	theOldClip;	centX 		= (double)(theRect.right + theRect.left) * .5 - cx;		/* small circle center	*/	centY 		= (double)(theRect.bottom + theRect.top) * .5 - cy;	startAngle	= -atan2(centY,centX);		R =  .5 * (theRect.right - theRect.left);							/* smal circle radius	*/	d = sqrt(centX * centX + centY * centY);							/* dist between centers	*/	theAngle = acos((d * d + radius * radius - R * R) / ((radius + radius) * d));		a11 = a22 = cos(startAngle);	a12 = sin(startAngle);	a21 = -a12;				theCos_a11 = theCos_a21 = cos(theAngle);	theSin_a12 = theSin_a22 = sin(theAngle);		theCos_a11 *= a11;	theCos_a21 *= a21;	theSin_a12 *= a12;	theSin_a22 *= a22;		p0.h = (short)(cx - radius * (a11 + a12));	p0.v = (short)(cy - radius * (a21 + a22));		p1.h = (short)(cx + radius * (theCos_a11 - a12));	p1.v = (short)(cy + radius * (theCos_a21 - a22));		p2.h = (short)(cx + radius * (theCos_a11 - theSin_a12));	p2.v = (short)(cy + radius * (theCos_a21 - theSin_a22));		p3.h = (short)(cx + radius * a11);	p3.v = (short)(cy + radius * a21);		p4.h = (short)(cx + radius * (theCos_a11 + theSin_a12));	p4.v = (short)(cy + radius * (theCos_a21 + theSin_a22));		p5.h = (short)(cx + radius * (theCos_a11 + a12));	p5.v = (short)(cy + radius * (theCos_a21 + a22));		p6.h = (short)(cx + radius * (a12 - a11));	p6.v = (short)(cy + radius * (a22 - a21));		ObjToLocal(&p0);	ObjToLocal(&p1);	ObjToLocal(&p2);	ObjToLocal(&p3);	ObjToLocal(&p4);	ObjToLocal(&p5);	ObjToLocal(&p6);	OpenRgn(); 	MoveTo(p0.h,p0.v);	LineTo(p1.h,p1.v);	LineTo(p2.h,p2.v);	LineTo(p3.h,p3.v);	LineTo(p4.h,p4.v);	LineTo(p5.h,p5.v);	LineTo(p6.h,p6.v);	LineTo(p0.h,p0.v);		CloseRgn(gTheRgn);	if(onScreen)		SectRgn(drawRgn,gTheRgn,gTheRgn);		theOldClip = D_NewRgn();	GetClip(theOldClip);	D_SetClip(gTheRgn);		rectPoint = (Point*)(&theRect);	ObjToLocal(rectPoint);	ObjToLocal(&(rectPoint[1]));	dm_FrameOval(&theRect);		D_SetClip(theOldClip);	D_DisposeRgn(&theOldClip);		return;}void	StereoObject::RotateVert(void){	double		theXForm[3][3];		SetTheCursor(WATCH_CURSOR);	FIND_VERT_XFORM(THE_CURRENT_SPOT.x,THE_CURRENT_SPOT.y,theXForm);	RotateSpotsBase(theXForm);		return;}void	StereoObject::RotateHoriz(void){	double		theXForm[3][3];		SetTheCursor(WATCH_CURSOR);	FIND_HORIZ_XFORM(THE_CURRENT_SPOT.x,THE_CURRENT_SPOT.y,theXForm);	RotateSpotsBase(theXForm);	return;}void	StereoObject::RotateToCntr(void){	double		theXForm[3][3];	double		x,y,z;		SetTheCursor(WATCH_CURSOR);	x = THE_CURRENT_SPOT.x;	y = THE_CURRENT_SPOT.y;	z = THE_CURRENT_SPOT.z;	FIND_CENTER_XFORM(x,y,z,theXForm);	RotateSpotsBase(theXForm);	return;}void StereoObject::DoARotation(double angle,short axis){	double theXForm[3][3];	RotatateMatrixAxis(theXForm,angle,axis);		totalTilts[axis] += angle;	RotateSpotsBase(theXForm);	}void	StereoObject::RotateAround(Point where,Boolean shifted,Boolean click){	static Boolean	initFlag;	static double	startAngle,endAngle;	static Point	lastPoint;	static Rect		theRect;	double			angle;	short			start,end,theRad;		if(funcInit){		theRad = (short)projLengthScreen;		if(theRad > 7500)			theRad = 7500;		startAngle 		= endAngle = 0.0;		theRect.left	= centerX - theRad;		theRect.right	= centerX + theRad;		theRect.top		= centerY - theRad;		theRect.bottom	= centerY + theRad;		funcInit 		= false;		initFlag		= false;		return;	}		if(shifted){		angle = atan2(THE_CURRENT_SPOT.y,THE_CURRENT_SPOT.x);		angle -= (PI / 2.0);		if(initFlag){			start	= 90 - (short)(.5 + startAngle * 180.0 / PI);			end		= 90 - (short)(.5 + endAngle * 180.0 / PI);			InvertArc(&theRect,start,end - start);		}		if(angle < 0.0)			angle += (2.0 * PI);		startAngle = endAngle = angle;		initFlag = true;		sprintf(gTheText,"Rotation angle = 0.0¡");		theRuler->SetInfo(gTheText);		theRuler->SetHelp("Single click to rotate.");	} else if(click && initFlag){		double		theXForm[3][3],x,y;				x = where.h - centerX;		y = centerY - where.v;		angle = endAngle - startAngle;		x = cos(angle);		y = sin(angle);		SetTheCursor(WATCH_CURSOR);		FindHorizXform(y,x,theXForm);		RotateSpotsBase(theXForm);		startAngle = endAngle;		sprintf(gTheText,"Rotation angle = 0.0¡");		theRuler->SetInfo(gTheText);		initFlag = false;		theRuler->SetHelp("Shift click to select spot to rotate.");			} else if(!EqualPt(where,lastPoint) && initFlag){		double x,y;				x = where.h - centerX;		y = centerY - where.v;		angle = atan2(y,x);		if(angle < 0.0)			angle += (2.0 * PI);		if((angle - startAngle) > PI){			angle -= (2.0 * PI);		} else if((angle - startAngle) <= -PI) {			angle += (2.0 * PI);		}		start	= 90 - (short)(.5 + endAngle * 180.0 / PI);		end		= 90 - (short)(.5 + angle * 180.0 / PI);		InvertArc(&theRect,start,end - start);		endAngle = angle;		angle = (endAngle - startAngle) * 180.0 / PI;		sprintf(gTheText,"Rotation angle = %5.1f¡",angle);		theRuler->SetInfo(gTheText);	}	lastPoint = where;}void	StereoObject::StandardProj(){	double		theXForm[3][3];		SetTheCursor(WATCH_CURSOR);	CopyAxesIntoMatrix(theXForm);	InvertMatrix(theXForm);	RotateSpotsBase(theXForm);	newPictReq = true;	return;}void	StereoObject::DoMenu(long	theResult){	short theMenu,theItem;		theMenu = HiWord(theResult);	theItem = LoWord(theResult);		switch(theMenu){		case 152:			DoPoleObjectMenu( theItem);						break;		case 153:			DoPoleFigureMenu(theItem);			break;		case	FUNCTION_MENU:			switch(theItem){				case 	RE_DEFINE:					//DoDefine();					 DoSetUp();					break;				case	RE_DRAW:					SetTheCursor(WATCH_CURSOR);					zoomFlag = false;					reSizeFlag = true;					newPictReq = true;					break;									case 	ADD_SPOT:					AddSpot();					break;									case	PLANE_TRACES:					functionID		= PLANE_TRACES_F;					theRuler->SetHelp("Click on pole to add/delete plane traces");					theRuler->SetPrompt("Add / Delete plane traces");					SetTheCursor(TARGET_CURSOR);					break;									case	PLANE_THRU_PTS:					functionID		= PLANE_THRU_PTS_F;					theRuler->SetHelp("Click on two poles to add/delete a plane trace which contains both poles");					theRuler->SetPrompt("Add a plane trace through two points");					TwoPointPlane(true);   /* does set up only */					SetTheCursor(TARGET_CURSOR);					break;									case	ADD_SMALL_CIRCLE:					functionID		= ADD_SMALL_CIRCLE_F;					theRuler->SetHelp("Click and hold on desired pole to be center of small circle, draw out mouse to desired radius, release. Click on pole to release.");					theRuler->SetPrompt("Add / Delete small Circles");					SetTheCursor(TARGET_CURSOR);					break;									case	ADD_TA:					theRuler->SetHelp("Click/Hold on projection for interactive definition.");					theRuler->SetPrompt("Add a tensile axis");					AddTA();					theRuler->ClearPrompt();					theRuler->ClearHelp();					break;									case	IRRATIONAL_DIR:					theRuler->SetHelp("Click on a pole to select a Crystal.");					theRuler->SetPrompt("Irrational Direction.   Value is: ");					functionID		= IRRATIONAL_DIR_F;					break;									case	DEFECT_TRACE:									theRuler->SetPrompt("TEM defect traces.");					DoDefectTrace();					break;								case	DEFECT_ANALYSIS:					theRuler->SetPrompt("TEM defect Analysis.");					DoDefectAnalysis();					break;									case	SELECT_HABIT_PLANE:					theRuler->SetHelp("Click on a pole to select a direction.");					theRuler->SetPrompt("Select a Habit plane.");					functionID		= SELECT_HABIT_PLANE_F;					SetTheCursor(TARGET_CURSOR);					break;				case	ADD_SPOTS_FROM_SYMMETRY:					DoSpotAdditionBySymmetry();					break;					default:					inherited::DoMenu(theResult);					break;			}			break;					case	INFO_MENU:			switch(theItem){				case 	IRRATIONAL_DIR:					break;									default:					inherited::DoMenu(theResult);					break;			}			break;					case	ROTATE_MENU:			switch(theItem){				case	ROTATE_TO_CNTR:					functionID		= ROTATE_TO_CNTR_F;					theRuler->SetHelp("Click on a pole to select new center.  Rotation is along great circle connecting pole and current center");					theRuler->SetPrompt("Rotate to Center");					SetTheCursor(TARGET_CURSOR);					break;									case 	ROTATE_VERT:					functionID		= ROTATE_VERT_F;					theRuler->SetHelp("Click on a pole to be rotated to vertical.  Rotation is around center direction");					theRuler->SetPrompt("Rotate Vertical");					SetTheCursor(TARGET_CURSOR);					break;									case	ROTATE_HORIZ:					functionID		= ROTATE_HORIZ_F;					theRuler->SetHelp("Click on a pole to be rotated to horizontal.  Rotation is around center direction");					theRuler->SetPrompt("Rotate Horizontal");					SetTheCursor(TARGET_CURSOR);					break;								case	ROTATE_AROUND:					functionID		= ROTATE_AROUND_F;					theRuler->SetPrompt("Rotate about Center");					theRuler->SetHelp("Shift click to pick point to rotate.  Then move mouse (do not hold down) to desired angle. Click once.");					SetTheCursor(TARGET_CURSOR);					funcInit = true;					break;				case	ROTATE_AROUND_X:					functionID		= ROTATE_AROUND_X_F;					theRuler->SetPrompt("Rotate about X");					theRuler->SetHelp("Shift click to pick point to rotate.  Then move mouse (do not hold down) to desired angle. Click once.");					SetTheCursor(TARGET_CURSOR);					funcInit = true;					break;					case	ROTATE_AROUND_Y:					functionID		= ROTATE_AROUND_Y_F;					theRuler->SetPrompt("Rotate about Y");					theRuler->SetHelp("1. Shift click to pick point to rotate about Y axis.  2. Move mouse (do not hold down) to desired angle. 3. Click once.");					SetTheCursor(TARGET_CURSOR);					funcInit = true;					break;				case ROTATE_AROUND_ANY:									functionID		= ROTATE_AROUND_ANY_F;					theRuler->SetPrompt("Rotate about Any Pole");					theRuler->SetHelp("Shift click to pick point to rotate about.  Then move mouse (do not hold down) to desired angle. Click once.");					SetTheCursor(TARGET_CURSOR);					funcInit = true;					break;				case	STANDARD_PROJ:					theRuler->ClearPrompt();					functionID	= 0;					funcInit 	= true;					StandardProj();					break;									case	ZOOM_IN:					functionID		= ZOOM_IN_F;					theRuler->SetHelp("Zoom by clicking on area of interest and pulling mouse to enclose desired area.  Zoom does not rotate crystal.");					theRuler->SetPrompt("Select Zoom Area");					SetTheCursor(ZOOM_CURSOR);										break;									case	ZOOM_PREVIOUS:					theRuler->ClearPrompt();					functionID	= 0;					funcInit 	= true;					SetTheCursor(WATCH_CURSOR);					ZoomPrevious();										break;								case	LOCK_SPOTS:					functionID		= LOCK_SPOTS_F;					theRuler->SetPrompt("Lock / Unlock Spots");					theRuler->SetHelp("Clicking on a spot Toggles the rotation Lock.");					SetTheCursor(TARGET_CURSOR);					funcInit = true;					break;									default:					inherited::DoMenu(theResult);					break;			}			break;				default:			inherited::DoMenu(theResult);			break;	}	HiliteMenu(0);	return;}Boolean			StereoObject::DoContent(Point thePoint){	short i;	short oldPValue[4],oldDValue[4];	if(theRuler->functionFlag){		if(FindSpot(thePoint)){			switch(functionID){				case SELECT_POLE_FIGURE:					for(i = 0; i < 4;i++){//save old caluclation falues						oldPValue[i] = planeBounds[i];						planeBounds[i] = -1;						oldDValue[i] = dirBounds[i];						dirBounds[i] = -1;					}					if(THE_CURRENT_SPOT.direction)dirBounds[THE_CURRENT_SPOT.flags & CRYSTAL_MASK] = 3;					else planeBounds[THE_CURRENT_SPOT.flags & CRYSTAL_MASK] = 3;					CalculatePoleStereogram( thePoint);					for(i = 0; i < 3;i++){						planeBounds[i] = oldPValue[i];						dirBounds[i] = oldDValue[i];					}					break;				case SHOW_POLE_OR_MATRIX:										DisplayORMatrices();										break;				case SET_MATRIX_TO_EXP:					SetMatrixToORExp();					break;				case FIND_POLE_ORIENTATION:					DeterminePoleFigureOR(thePoint);					break;				case ROTATE_TO_CNTR_F:					RotateToCntr();					return true;					break;									case ROTATE_VERT_F:					RotateVert();					return true;					break;									case ROTATE_HORIZ_F:					RotateHoriz();					return true;					break;									case ROTATE_AROUND_F:					if(gShifted){						RotateAround(thePoint,true,false);					} else {						RotateAround(thePoint,false,true);					}					return true;					break;				case ROTATE_AROUND_X_F:				case ROTATE_AROUND_Y_F:				case ROTATE_AROUND_ANY_F:					if(gShifted){						RotateAroundX(thePoint,functionID - ROTATE_AROUND_X_F + 1 ,true,false);					} else {						RotateAroundX(thePoint,functionID - ROTATE_AROUND_X_F + 1,false,true);					}					return true;					break;												case ZOOM_IN_F:					ZoomIn(thePoint);					return true;					break;									case PLANE_TRACES_F:					THE_CURRENT_SPOT.flags ^= PLANE_TRACE;					if(THE_CURRENT_SPOT.flags & PLANE_TRACE){						THE_CURRENT_SPOT.theCrystal->SetColor();					} else {						DMForeColor(BACKGROUND_COLOR);					}					PlaneTraces((&THE_CURRENT_SPOT));					return true;					break;									case PLANE_THRU_PTS_F:					THE_CURRENT_SPOT.theCrystal->SetColor();					TwoPointPlane(false);					return true;					break;									case ADD_SMALL_CIRCLE_F:					THE_CURRENT_SPOT.flags ^= SMALL_CIRCLE;					if(THE_CURRENT_SPOT.flags & SMALL_CIRCLE){						AddSmallCircle();					} else {						DrawSmallCircle((&THE_CURRENT_SPOT),true);					//	newPictEnable = true;					}					return true;					break;									case	IRRATIONAL_DIR_F:					{						Point	thisPoint;						thisPoint.h = thisPoint.v = -12345;  /* Force an update to display crystal */						IrrationalDir(thisPoint);					}					return true;					break;									case	SELECT_HABIT_PLANE_F:					SelectHabitPlane();					return true;					break;								case 	LOCK_SPOTS_F:					LockSpot();					return true;									default:					break;			}		} else {			switch(functionID){				case ZOOM_IN_F:					ZoomIn(thePoint);					return true;					break;									case ROTATE_AROUND_F:					RotateAround(thePoint,false,true);					return true;					break;				case ROTATE_AROUND_X_F:				case ROTATE_AROUND_Y_F:				case ROTATE_AROUND_ANY_F:						RotateAroundX(thePoint,functionID - ROTATE_AROUND_X_F + 1,false,true);					return true;				default:					break;			}		}	}	return(inherited::DoContent(thePoint));}void			StereoObject::DoIdle(void){	short 		i;	SpotInfo	*theSpot;	Point		where;	double		x,y,z;	short		theCount;		if(normalizeFlag){		theSpot = &(((SpotInfoPtr)*theDataHandle)[normalizeCount]);		theCount = normalizeCount;		for(i = 1 ; i <= 20 && i + theCount <= data_Count; i++,theSpot++){			x = theSpot->x;			y = theSpot->y;			z = theSpot->z;			NORMALIZE_VECTOR(x,y,z);			theSpot->x = x;			theSpot->y = y;			theSpot->z = z;			/*NORMALIZE_VECTOR(theSpot->x,theSpot->y,theSpot->z);*/						normalizeCount++;			if(normalizeCount >= data_Count){				x = x_001.x;				y = x_001.y;				z = x_001.z;				NORMALIZE_VECTOR(x,y,z);				x_001.x = x;				x_001.y = y;				x_001.z = z;								x = y_001.x;				y = y_001.y;				z = y_001.z;				NORMALIZE_VECTOR(x,y,z);				y_001.x = x;				y_001.y = y;				y_001.z = z;				x = z_001.x;				y = z_001.y;				z = z_001.z;				NORMALIZE_VECTOR(x,y,z);				z_001.x = x;				z_001.y = y;				z_001.z = z;				normalizeCount = 0;				normalizeFlag = false;			}		}	}	switch(functionID){		case IRRATIONAL_DIR_F:			GetMouse(&where);			IrrationalDir(where);			break;				case ROTATE_AROUND_F:			GetMouse(&where);			RotateAround(where,false,false);			break;		case ROTATE_AROUND_X_F:		case ROTATE_AROUND_Y_F:		case ROTATE_AROUND_ANY_F:			GetMouse(&where);			RotateAroundX(where,functionID - ROTATE_AROUND_X_F + 1,false,false);			break;		default:			break;	}				inherited::DoIdle();	return;}void			StereoObject::DoDblClick(Point	where){	inherited::DoDblClick(where);		return;}void			StereoObject::DoKey(char	theChar){	inherited::DoKey(theChar);	return;}void	StereoObject::DrawTheText(void){	DrawSpotAttributes();}void			StereoObject::DoRefresh(void){	inherited::DoRefresh();}void			StereoObject::DoAuxWrite(void){	short i;		for(i = 0 ; i <= 3 ; i++){		gTheFile->WriteShort(planeBounds[i]);		gTheFile->WriteShort(dirBounds[i]);	}	gTheFile->WriteBoolean(structFactFlag);	gTheFile->WriteDataBlock((Ptr)&x_001,sizeof(Axis));	gTheFile->WriteDataBlock((Ptr)&y_001,sizeof(Axis));	gTheFile->WriteDataBlock((Ptr)&z_001,sizeof(Axis));	gTheFile->WriteShort(centerX);	gTheFile->WriteShort(centerY);	gTheFile->WriteFloat(projLengthScreen);	gTheFile->WriteShort(ZoomCount);	gTheFile->WriteDataBlock((Ptr)&previousZoom,sizeof(ZoomInfo));	gTheFile->WriteLong(totalPoles);	if(totalPoles > 0){		gTheFile->WriteLong(add_N_Pole);		gTheFile->WriteLong(maxPoles);		gTheFile->WriteHandle((Handle)poleHandle);	}		inherited::DoAuxWrite();}void			StereoObject::DoAuxRead(void){	short i;		for(i = 0 ; i <= 3 ; i++){		planeBounds[i] = gTheFile->ReadShort();		dirBounds[i] = gTheFile->ReadShort();	}	structFactFlag = gTheFile->ReadBoolean();	gTheFile->ReadDataBlock((Ptr)&x_001,sizeof(Axis));	gTheFile->ReadDataBlock((Ptr)&y_001,sizeof(Axis));	gTheFile->ReadDataBlock((Ptr)&z_001,sizeof(Axis));	centerX = gTheFile->ReadShort();	centerY = gTheFile->ReadShort();	projLengthScreen = gTheFile->ReadFloat();	ZoomCount = gTheFile->ReadShort();	gTheFile->ReadDataBlock((Ptr)&previousZoom,sizeof(ZoomInfo));	if(objectType == STEREO_OBJ){		totalPoles = gTheFile->ReadLong();		if(totalPoles > 0){			add_N_Pole = gTheFile->ReadLong();			maxPoles 	= gTheFile->ReadLong();			if(!poleHandle){				poleHandle = (PolePosition**)D_NewHandle(sizeof(PolePosition) * 5);			}			gTheFile->ReadHandle((Handle)poleHandle);		}	}	inherited::DoAuxRead();}void			StereoObject::LockSpot(void){	short	cx,cy;	Point	thisPoint;	thisPoint.h = (THE_CURRENT_SPOT.spotRect.left + THE_CURRENT_SPOT.spotRect.right) / 2;	thisPoint.v = (THE_CURRENT_SPOT.spotRect.top + THE_CURRENT_SPOT.spotRect.bottom) / 2;	ObjToLocal(&thisPoint);	cx = thisPoint.h;	cy = thisPoint.v;	THE_CURRENT_SPOT.flags ^= PIN_MASK;	if(THE_CURRENT_SPOT.flags & PIN_MASK){		DMForeColor((THE_CURRENT_SPOT.flags & CRYSTAL_MASK) + 10);			DRAW_PIN_MARK(((&THE_CURRENT_SPOT)),cx,cy);	} else {		gTheRect = THE_CURRENT_SPOT.spotRect;		InsetRect(&gTheRect,-3,-3);		EraseTheRect(&gTheRect);		InvalTheRect(&gTheRect);	}	//newPictEnable = true;}void			StereoObject::DuplicateSpotAndPrime(SpotInfoPtr *theSpot, short i){		SpotInfo	thatSpot;		thatSpot = **theSpot;	(*theSpot)->flags |= PRIME_MASK;		if(++data_Count >= data_Length){		long	size;		/*MFTemp*/D_HUnlock((Handle)theDataHandle);		size = GetHandleSize(theDataHandle) + 10 * sizeof(SpotInfo);		SetHandleSize(theDataHandle,size);		/*MFTemp*/D_HLock((Handle)theDataHandle);		if(MemError() == 0 && FreeMem() > 32000L){			data_Length += 10;		} else {			StopAlert(OUT_OF_MEM,NUL);			data_Count--;			return;		}	}			spotLoc = data_Count - 1;	thatSpot.flags ^= PIN_MASK;	((SpotInfoPtr)*theDataHandle)[spotLoc] = thatSpot;	*theSpot = &(((SpotInfoPtr)*theDataHandle)[i]);}void	StereoObject::RationalizeData(void){	g1->theCrystal = theCrystal[0];	g2->theCrystal = theCrystal[0];	dirA_1->theCrystal = theCrystal[0];	dirA_2->theCrystal = theCrystal[0];	dirB_1->theCrystal = theCrystal[0];	dirB_2->theCrystal = theCrystal[0];	inherited::RationalizeData();}