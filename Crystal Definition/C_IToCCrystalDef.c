//C_IToCCrystalDef.c#include	"Diffract_INCs.h"#include 	"ITCCrystalDef.h"double CrystalRandom(void);enum{	REPLACE1 = 1,	CANCEL1,	ENTER1,	DELETE,	XINPUT,	The_SCROLL_RECT,	POPUPCLICK,	THE_LIST_RECT };enum{	XPUSH = 1,	YPUSH,	ZPUSH,	ATOMPUSH,	DWPUSH};#define DLOG_WY_IN 103short			firstSpaceGrp,lastSpaceGrp;short			lastSelected;ResType			theResType;IntNatTblRsrc 		theSpaceGrp;char				*positionString;char				*extinctionString;		Cell				gTheCell;PopUpMenu		*theMenuHnd;Boolean ITCCrystalObject::InitCrystal(short num){	Boolean flag;		flag = inherited::InitCrystal(num);		if(!flag) return false;	theSpaceGrp.headLine = (char*)D_NewPtr(80 * sizeof(char));	extinctionString = (char*)D_NewPtr(500 * sizeof(char));	positionString   = (char*)D_NewPtr(2000 * sizeof(char));	if(theSpaceGrp.headLine == 0L || extinctionString == 0L || positionString == 0L){		return false;	}		return true;}void ITCCrystalObject::SetDataForIToC(void){	short theValue;	theMenuHnd = (PopUpMenu*)D_new(PopUpMenu);	switch(lattice_Type)	{		case TRICLINIC:			firstSpaceGrp = 1;			lastSpaceGrp = 2;			theResType = 'Tric';			theValue = 101;			break;		case MONOCLINIC:			firstSpaceGrp = 3;			lastSpaceGrp = 15;			theResType = 'Mono';			theValue =  102;			break;		case ORTHORHOMBIC:			firstSpaceGrp = 16;			lastSpaceGrp = 74;			theResType = 'Orth';			theValue = 103;			break;		case TETRAGONAL:			firstSpaceGrp = 75;			lastSpaceGrp = 142;			theResType = 'Tetr';			theValue = 104;			break;		case TRIGONAL:			firstSpaceGrp = 143;			lastSpaceGrp = 167;			theResType = 'Trig';			theValue = 105;			break;		case HEXAGONAL:			firstSpaceGrp = 168;			lastSpaceGrp = 194;			theResType = 'Hexa';			theValue = 106;			break;		case CUBIC:			firstSpaceGrp = 195;			lastSpaceGrp = 230;			theResType = 'Cubc';			theValue = 107;			break;		case TRIGHEX:			firstSpaceGrp = 1146;			lastSpaceGrp = 1167;			theResType = 'Trhx';			theValue = 125;			break;	}	if(spaceGrpNm > lastSpaceGrp || spaceGrpNm < firstSpaceGrp) spaceGrpNm = firstSpaceGrp;			lastSelected = spaceGrpNm - firstSpaceGrp + 1;	if(theResType == 'Trhx'){		switch(spaceGrpNm){			case 1146:				lastSelected = 1;				break;			case 1148:				lastSelected = 2;				break;			case 1155:				lastSelected = 3;				break;			case 1160:				lastSelected = 4;				break;			case 1161:				lastSelected = 5;				break;			case 1166:				lastSelected = 6;				break;			case 1167:				lastSelected = 7;				break;		}	}	theMenuHnd->Init(theDialog,POPUPCLICK,theValue,lastSelected);	}Boolean ITCCrystalObject::EnterWyCrystalPos(void){	short 			item,n = 0;		/*pascal Boolean 	TheFilter();*/	short 			hor;	WckoffPosition *theAtom = 0L;			//gScreenSize = oldPort->portRect;	theDialog = DM_GetNewDialog(DLOG_WY_IN, 0L,(WindowPtr)-1L);		SetDataForIToC();		SetSpaceGroup();		SetWyDItems();	SetTheXYZText();	DrawBoxes();	InitAtomList();	gTheCell.v = 0;	gTheCell.h = 0;	SetSpaceGroup();	SetWyDItems();	ChangeOfSpaceGroup();	ListAtoms();		SelIText(theDialog,XINPUT,0,32767);			while(1 != 2){		SystemTask();		ModalDialog(TheFilterUPP,&item);		switch(item){			case REPLACE1:				ConvertWyckoffToReal();				if(theAtomList != 0L) LDispose(theAtomList);				theMenuHnd->DoClose();				if(theDialog != 0L){					DM_DisposDialog(&theDialog);				}				if(wy_Atom_Count < 0) return false;				return true;						case CANCEL1:			case CANCELCLICK: 				if(theAtomList != 0L) LDispose(theAtomList);				theMenuHnd->DoClose();				if(theDialog != 0L){					DM_DisposDialog(&theDialog);				}				return false;						case ENTERCLICK:			case ENTER1:				EnterXYZ(theAtom);				ListAtoms();				LSetSelect(false,gTheCell,theAtomList);				if(gTheCell.h < 4 && gTheCell.h > 0){					hor = gTheCell.h + 1;				}else {					if(gTheCell.h == 4){						hor = 1;					}else{						hor = 0;					}					if(gTheCell.v < wy_Atom_Count){						gTheCell.v++;					}else{						gTheCell.v = 0;						gTheCell.h = 1;					}				}				LSetSelect(true,gTheCell,theAtomList);				CorrectList(hor);				SetTheXYZText();				break;			case DELETE:				DeleteAtom();				ListAtoms();				SetTheXYZText();				break;			case XINPUT:				break;				case The_SCROLL_RECT:				GlobalToLocal(&(gTheEvent.where));				LClick(gTheEvent.where,gTheEvent.modifiers,theAtomList);				break;			case POPUPCLICK:				lastSelected = LoWord(theMenuHnd->DoPopUp());								spaceGrpNm = lastSelected + firstSpaceGrp - 1;				if(theResType == 'Trhx'){					switch(lastSelected){						case 1:							spaceGrpNm = 1146;							break;						case 2:							spaceGrpNm = 1148;							break;						case 3:							spaceGrpNm = 1155;							break;						case 4:							spaceGrpNm = 1160;							break;						case 5:							spaceGrpNm = 1161;							break;						case 6:							spaceGrpNm = 1166;							break;						case 7:							spaceGrpNm = 1167;							break;					}				}				SetSpaceGroup();				SetWyDItems();				ChangeOfSpaceGroup();				gTheCell.v = 0;				gTheCell.h = 0;				ListAtoms();				break;			case THE_LIST_RECT:				HandleListRect();				break;			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			default:				break;		}		if(item > THE_LIST_RECT && item <= THE_LIST_RECT + 30){			AddAtom(item);			SetTheXYZText();			ListAtoms();		}	}}void 	ITCCrystalObject::DeleteAtom(void){	short i;	short type;	Handle theHandle;	Rect theRect;	if(wy_Atom_Count < 0) return;			for(i = gTheCell.v; i <= wy_Atom_Count - 1; i++) theWyckAtoms[i] = theWyckAtoms[i + 1];			LDelRow(1,wy_Atom_Count,theAtomList);	wy_Atom_Count--;	if(gTheCell.v > wy_Atom_Count){		gTheCell.v = wy_Atom_Count;	}	GetDItem(theDialog,THE_LIST_RECT,&type,&theHandle,&theRect);	LSetSelect(true,gTheCell,theAtomList);	if(gTheCell.h == 0)		CorrectList(0);	else		CorrectList(1);	SelIText(theDialog,XINPUT,0,32767);}void	ITCCrystalObject::EnterXYZ(WckoffPosition *theAtom){	Handle theHandle;	Rect theRect;	short type;	theAtom = &theWyckAtoms[gTheCell.v];	GetDItem(theDialog,XINPUT,&type,&theHandle,&theRect);	GetIText(theHandle,pTheText);	switch(gTheCell.h){		case XPUSH:			theAtom->x = atof(p2cstr(pTheText));			break;		case YPUSH:			theAtom->y = atof(p2cstr(pTheText));			break;		case ZPUSH:			theAtom->z = atof(p2cstr(pTheText));			break;		case ATOMPUSH:			theAtom->atomicNum = TheAtomicNum(p2cstr(pTheText));			break;		case DWPUSH:			theAtom->bi = atof(p2cstr(pTheText));			break;		default:			break;	}	}void	ITCCrystalObject::AddAtom(short posNumber){	char theChar;	short multiplicity,i;	WckoffPosition* theWyAtomsOld;	posNumber -= THE_LIST_RECT;				wy_Atom_Count++;		theWyAtomsOld = (WckoffPosition*)D_NewPtr((wy_Atom_Count + 1) * sizeof(WckoffPosition));	for(i = 0; i <= wy_Atom_Count - 1;i++){		theWyAtomsOld[i] = theWyckAtoms[i];	}	KillPtr((Ptr)theWyckAtoms);	theWyckAtoms = (WckoffPosition*)D_NewPtr((wy_Atom_Count + 1) * sizeof(WckoffPosition));	for(i = 0; i <= wy_Atom_Count;i++){		theWyckAtoms[i] = theWyAtomsOld[i];	}		KillPtr((Ptr)theWyAtomsOld);		theChar = 'a' + posNumber - 1;	multiplicity = theSpaceGrp.posMultiplicity[posNumber];	if(multiplicity == 0)		multiplicity = 1;	if(wy_Atom_Count == 0){		sprintf(theWyckAtoms[wy_Atom_Count].wckoffPosName,"%c%d",theChar,multiplicity);		theWyckAtoms[wy_Atom_Count].wckoffPosNo = posNumber;		theWyckAtoms[wy_Atom_Count].x = 0.0;		theWyckAtoms[wy_Atom_Count].y = 0.0;		theWyckAtoms[wy_Atom_Count].z = 0.0;		theWyckAtoms[wy_Atom_Count].atomicNum = 29;		theWyckAtoms[wy_Atom_Count].bi = 0;	}else{		theWyckAtoms[wy_Atom_Count] = theWyckAtoms[wy_Atom_Count - 1];		sprintf(theWyckAtoms[wy_Atom_Count].wckoffPosName,"%c%d",theChar,multiplicity);		theWyckAtoms[wy_Atom_Count].wckoffPosNo = posNumber;	}	LSetSelect(false,gTheCell,theAtomList);	gTheCell.v = LAddRow(1,wy_Atom_Count,theAtomList);	if(gTheCell.h == 0)		CorrectList(0);	else		CorrectList(1);	SelIText(theDialog,XINPUT,0,32767);}void ITCCrystalObject::SetWyDItems(void){	Handle itemHandle;	Rect theRect;	short i,k,item;		k = 0;	while(theSpaceGrp.posMultiplicity[k + 1] != 0){		k++;	}	for(i = k; i <= 29; i++){		GetDItem(theDialog,i + THE_LIST_RECT + 1,&item,&itemHandle,&theRect);		SetCtlValue((ControlHandle)itemHandle,0);		HiliteControl((ControlHandle)itemHandle,255);	}	for(i = 0; i < k; i++){		GetDItem(theDialog,i + THE_LIST_RECT + 1,&item,&itemHandle,&theRect);		SetCtlValue((ControlHandle)itemHandle,1);		HiliteControl((ControlHandle)itemHandle,0);	}}void	ITCCrystalObject::InitAtomList(void)			/*  Initialize the atom list		*/{	FontInfo 	theFont;	short		textHeight;	Point		cellSize;	Handle theHandle;	Rect theRect,rBounds;	short	type;			GetDItem(theDialog,THE_LIST_RECT,&type,&theHandle,&theRect);	GetFontInfo(&theFont);	textHeight = theFont.ascent + theFont.descent + theFont.leading;	SetRect(&rBounds,0,0,7,wy_Atom_Count + 1);	cellSize.h = 53;	cellSize.v = textHeight;	theAtomList = LNew(&theRect,&rBounds,cellSize,0,theDialog,true,false,false,true);	(*theAtomList)->selFlags = 0x80;		return;}void   ITCCrystalObject::DrawBoxes(){	Handle theHandle;	Rect theRect,aRect;	short	type;		GetDItem(theDialog,THE_LIST_RECT,&type,&theHandle,&theRect);		SetRect(&aRect,theRect.left - 1,theRect.top - 1,theRect.right + 1,theRect.bottom + 1);	dm_EraseRect(&theRect);	dm_FrameRect(&aRect);	GetDItem(theDialog,THE_LIST_RECT + 1,&type,&theHandle,&theRect);	aRect.left = theRect.left - 1;	aRect.top = theRect.top - 1;	GetDItem(theDialog,THE_LIST_RECT + 30,&type,&theHandle,&theRect);	aRect.right = theRect.right + 1;	aRect.bottom = theRect.bottom + 1;	PenSize(2,2);	dm_FrameRect(&aRect);	PenNormal();}void	ITCCrystalObject::ListAtoms(){	short i,j;	Boolean flag;	Cell theCell;	Atom theAtom;	for(i = gTheCell.v ; i <= wy_Atom_Count ; i++){		theCell.v = i;		for(j = 0 ; j <= 5 ; j++){			theCell.h = j;			switch(j){				case 0:					strcpy(gTheText,theWyckAtoms[i].wckoffPosName);					break;				case 1:					sprintf(gTheText,"%6.5f",theWyckAtoms[i].x);					break;				case 2:					sprintf(gTheText,"%6.5f",theWyckAtoms[i].y);					break;				case 3:					sprintf(gTheText,"%6.5f",theWyckAtoms[i].z);					break;				case 4:					if(gCurrentObj->calcDW){						theAtom.atomicNum = theWyckAtoms[i].atomicNum;						theAtom.x = theWyckAtoms[i].x;						theAtom.y = theWyckAtoms[i].y;						theAtom.z = theWyckAtoms[i].z;						CorrectAtomDWToTemp(&theAtom,gCurrentObj->temperature);						theWyckAtoms[i].bi = theAtom.bi;					}					flag = GetAtomicSymbol(theWyckAtoms[i].atomicNum,gTheText);					break;				case 5:					sprintf(gTheText,"%6.5f",theWyckAtoms[i].bi);					break;			}			c2pstr(gTheText);			LSetCell(&(gTheText[1]),(short)(gTheText[0]),theCell,theAtomList);		}	}	return;}void ITCCrystalObject::ChangeOfSpaceGroup(void){	char theChar;	short multiplicity,i,k,n;	k = 0;	while(theSpaceGrp.posMultiplicity[k + 1] != 0){		k++;	}		for(i = 0; i <= wy_Atom_Count; i++){		n = theWyckAtoms[i].wckoffPosNo;		if(n > k){			gTheCell.v = i;			DeleteAtom();			i--;			continue;		}		theChar = 'a' + n - 1;		multiplicity = theSpaceGrp.posMultiplicity[n];		if(theSpaceGrp.posMultiplicity[n] == 0)			multiplicity = 1;		sprintf(theWyckAtoms[i].wckoffPosName,"%c%d",theChar,multiplicity);	}}void ITCCrystalObject::SetTheXYZText(void){	short 	i,type;	Handle 	theHandle;	Rect 	theRect;	Boolean flag;	Atom theAtom;		if(gTheCell.h == 0)		i = 1;	else		i = gTheCell.h;	switch(i){		case XPUSH:			sprintf(gTheText,"%6.5f",theWyckAtoms[gTheCell.v].x);			break;		case YPUSH:			sprintf(gTheText,"%6.5f",theWyckAtoms[gTheCell.v].y);			break;		case ZPUSH:			sprintf(gTheText,"%6.5f",theWyckAtoms[gTheCell.v].z);			break;		case ATOMPUSH:			flag = GetAtomicSymbol(theWyckAtoms[gTheCell.v].atomicNum,gTheText);			if(gCurrentObj->calcDW){				theAtom.atomicNum = theWyckAtoms[gTheCell.v].atomicNum;				CorrectAtomDWToTemp(&theAtom,gCurrentObj->temperature);				theWyckAtoms[gTheCell.v].bi = theAtom.bi;			}			break;		case DWPUSH:			sprintf(gTheText,"%6.5f",theWyckAtoms[gTheCell.v].bi);			break;	}	GetDItem(theDialog,XINPUT,&type,&theHandle,&theRect);	SetIText(theHandle,c2pstr(gTheText));	SelIText(theDialog,XINPUT,0,32767);}void ITCCrystalObject::CorrectList(short hor){	LSetSelect(false,gTheCell,theAtomList);	gTheCell.h = 0;	LSetSelect(true,gTheCell,theAtomList);	LAutoScroll(theAtomList);	LSetSelect(false,gTheCell,theAtomList);	gTheCell.h = hor;	LSetSelect(true,gTheCell,theAtomList);	}void ITCCrystalObject::HandleListRect(void){	Point thePoint;	Cell theCell;	short i,k;	Rect theRect;	Boolean flag;	SetPort(theDialog);	GlobalToLocal(&(gTheEvent.where));	flag = LClick(gTheEvent.where,gTheEvent.modifiers,theAtomList);	//theCell = LLastClick(theAtomList);		GetMouse(&thePoint);	SetRect(&theRect,-5,-5,-5,-5);	for(i = 0;i <= wy_Atom_Count;i++){		theCell.v = i;		for(k = 0; k <= 5;k++){			theCell.h = k;			LRect(&theRect,theCell,theAtomList);			if(PtInRect(thePoint,&theRect)){				gTheCell.v = theCell.v;				gTheCell.h = theCell.h;			}		}	}	if(flag && gTheCell.h == ATOMPUSH){		DoUserDefAtom(&theWyckAtoms[gTheCell.v].atomicNum);		GetAtomicSymbol(theWyckAtoms[gTheCell.v].atomicNum,gTheText);		theCell.v = gTheCell.v;		gTheCell.v = 0;		DrawBoxes();		ListAtoms();		gTheCell.v = theCell.v;	}else if(flag && theCell.h == ATOMPUSH + 1){		Atom theAtom;		theAtom.atomicNum = theWyckAtoms[gTheCell.v].atomicNum;		theAtom.bi			=	theWyckAtoms[gTheCell.v].bi;		GetDWFactor(&theAtom);		theWyckAtoms[gTheCell.v].bi = theAtom.bi;		theCell.v = gTheCell.v;		gTheCell.v = 0;		DrawBoxes();		ListAtoms();		gTheCell.v = theCell.v;	}	SetTheXYZText();	SelIText(theDialog,XINPUT,0,32767);}void ITCCrystalObject::ConvertWyckoffToReal(){	double addCrysMult,crysMulX[4],crysMulY[4],crysMulZ[4];	short i,j,k,kk,l,multCryIt,mm,theNumberShort;	short totCrysMul,totPosMul;	short	theAtomNo;	float *wyckoffPosNo,*wyckoffPosNoSet;	float theNumber;	Atom  *theAtomsPtr;		spaceGrpNm = theSpaceGrp.spaceGrpNm;	crysMulX[0] = 0.0;	crysMulY[0] = 0;	crysMulZ[0] = 0.0;	totCrysMul = 0;	atom_Count = -1;	switch(theSpaceGrp.crystlMultiplicity)	{		case 2:			crysMulX[1] = .5;			crysMulY[1] = .5;			crysMulZ[1] = 0.0;			totCrysMul = 1;			break;		case 3:			crysMulX[1] = .5;			crysMulY[1] = .5;			crysMulZ[1] = .0;						crysMulX[2] = .5;			crysMulY[2] = .0;			crysMulZ[2] = .5;						crysMulX[3] = .0;			crysMulY[3] = .5;			crysMulZ[3] = .5;			totCrysMul = 3;			break;		case 4:			crysMulX[1] = .5;			crysMulY[1] = .5;			crysMulZ[1] = .5;			totCrysMul = 1;			break;		case 5:			crysMulX[1] = .0;			crysMulY[1] = .5;			crysMulZ[1] = .5;			totCrysMul = 1;			break;		case 6:			crysMulX[1] = 2./3.;			crysMulY[1] = 1./3.;			crysMulZ[1] = 1./3.;						crysMulX[2] = 1./3.;			crysMulY[2] = 2./3.;			crysMulZ[2] = 2./3.;			totCrysMul = 2;			break;		default:			break;		}		atom_Count = 0;	for(i = 0; i <= wy_Atom_Count; i++)	{		k = theWyckAtoms[i].wckoffPosNo;		atom_Count += theSpaceGrp.posMultiplicity[k] ;	}		wyckoffPosNoSet = (float*)D_NewPtr((long)(300 * sizeof(float)));	KillHandle((Handle*)&theAtoms);	theAtoms = (AtomHnd)D_NewHandle((long)(atom_Count) * sizeof(Atom));	D_HLock((Handle)theAtoms);	atom_Count--;	theAtomsPtr = *theAtoms;	j = -1;	for(i = 0; i <= wy_Atom_Count; i++)	{		double bi;		k = theWyckAtoms[i].wckoffPosNo;		theAtomNo = theWyckAtoms[i].atomicNum;		bi =	theWyckAtoms[i].bi;		totPosMul = theSpaceGrp.posMultiplicity[k] / (totCrysMul + 1);		totPosMul *= 3;				wyckoffPosNo = wyckoffPosNoSet;		ReturnTheSpecificNumber(k,wyckoffPosNo);		totPosMul--;		kk = 0;		for(multCryIt = 0; multCryIt <= totCrysMul;multCryIt++){			kk = 0;			wyckoffPosNo = wyckoffPosNoSet;			for(l = 0; l <= totPosMul; l++){				if(kk == 0){					kk = 3;					j++;					theAtomsPtr[j].atomicNum 	= theAtomNo;					theAtomsPtr[j].wyckOffNum 	= k;					theAtomsPtr[j].x 			= 0;					theAtomsPtr[j].y 			= 0;					theAtomsPtr[j].z 			= 0;					theAtomsPtr[j].bi 			= bi;				}				switch(kk){					case 3:						addCrysMult = crysMulX[multCryIt];						break;					case 2:						addCrysMult = crysMulY[multCryIt];						break;					case 1:						addCrysMult = crysMulZ[multCryIt];						break;					default:						break;				}				theNumber = 0;				for(mm = 0; mm <= 1; mm++){					if(*wyckoffPosNo > 10 ||*wyckoffPosNo < -10){						switch((short)(*wyckoffPosNo))						{							case 100:								theNumber += theWyckAtoms[i].x;								break;							case -100:								theNumber -= theWyckAtoms[i].x;								break;							case 200:								theNumber += theWyckAtoms[i].y;								break;							case -200:								theNumber -= theWyckAtoms[i].y;								break;							case 300:								theNumber += theWyckAtoms[i].z;								break;							case -300:								theNumber -= theWyckAtoms[i].z;								break;							default:								break;						}					}else{						theNumber += *wyckoffPosNo;					}					wyckoffPosNo++;					}				theNumber += addCrysMult;				theNumberShort = theNumber;				theNumber -= theNumberShort;				switch(kk){					case 3:						theAtomsPtr[j].x = theNumber;						break;					case 2:						theAtomsPtr[j].y = theNumber;						break;					case 1:						theAtomsPtr[j].z = theNumber;						break;					default:						break;				}				kk--;			}					}			}	D_HUnlock((Handle)theAtoms);	KillPtr((Ptr)wyckoffPosNoSet);}void ITCCrystalObject::LookUpTableWyckofConvert(char *theChar,float *theNumber,Boolean addFlag){	short i;	for(i = 0; i <= 1;i++){		if(i == 1 && addFlag == false)			return;		switch((int)theChar[i]){			case 'x':			case 'X':				theNumber[i] = 100;				break;			case 'y':			case 'Y':				theNumber[i] = 200;				break;			case 'z':			case 'Z':				theNumber[i] = 300;				break;			case '0':				theNumber[i] = 0;				break;			case 'Å':			case 'ô':				theNumber[i] = -100;				break;			case '´':			case 'ç':				theNumber[i] = -200;				break;			case '½':			case 'ó':					theNumber[i] = -300;				break;			case (char)0xDA:	/*		case 'Ú':	*/				theNumber[i] = -1./8.;				break;			case '1':			case '!':				theNumber[i] = 1./8.;				break;			case (char)0xDB:	/*		case 'Û':	*/				theNumber[i] = -1./4.;				break;			case '2':			case '@':				theNumber[i] = 1./4.;				break;			case (char)0xDC:	/*		case 'Ü':  */				theNumber[i] = -3./8.;				break;			case '3':			case '#':				theNumber[i] = 3./8.;				break;			case (char)0xDD:	/*		case 'Ý': */				theNumber[i] = -1./2.;				break;			case '4':			case '$':				theNumber[i] = 1./2.;				break;			case (char)0xDE:	/*		case 'Þ':		*/				theNumber[i] = -5./8.;				break;			case '5':			case '%':				theNumber[i] = 5./8.;				break;			case (char)0xDF:	/*		case 'ß':		*/				theNumber[i] = -3./4.;				break;			case '6':			case '^':				theNumber[i] = 3./4.;				break;			case (char)0xE0:	/*		case 'à':		*/				theNumber[i] = -7./8.;				break;			case '7':			case '&':				theNumber[i] = 7./8.;				break;			case 'Œ':			case '':				theNumber[i] = -1./6.;				break;			case 'a':			case 'A':				theNumber[i] = 1./6.;				break;			case 'º':			case 'õ':				theNumber[i] = -2./6.;				break;			case 'b':			case 'B':				theNumber[i] = 2./6.;				break;			case '':			case '‚':				theNumber[i] = -4./6.;				break;			case 'c':			case 'C':				theNumber[i] = 4./6.;				break;			case '¶':			case 'ë':				theNumber[i] = -5./6.;				break;			case 'd':			case 'D':				theNumber[i] = 5./6.;				break;			case 'e':				theNumber[i] = 1./12.;				break;			case 'f':				theNumber[i] = 5./12.;				break;			case 'g':				theNumber[i] = 7./12.;				break;			case 'h':				theNumber[i] = 11./12.;				break;			default:				break;		}	}	}void ITCCrystalObject::ReturnTheSpecificNumber(short i,float *wyckoffPosNo){	char *information;	char theChar[2];	float *theNumber,*theNumPtr;	Boolean flagAdd;	information  = theSpaceGrp.posString[i];	theNumPtr = wyckoffPosNo;	flagAdd = false;	theNumber = theNumPtr;	theNumber[0] = 0;	theNumber[1] = 0;	while(*information != ';' && *information != '\0'){		if(*information == ','){			information++;			continue;		}		theChar[0] = information[0];		theChar[1] = information[1];		switch((int)theChar[1]){			case 'A':			case 'B':			case 'C':			case 'D':			case 'X':			case 'Y':			case 'Z':			case '!':			case '@':			case '#':			case '$':			case '%':			case '^':			case '&':			case '':			case 'õ':			case '‚':			case 'ë':			case 'ô':			case 'ç':			case 'ó':			case 'Ú':			case 'Û':			case 'Ü':			case 'Ý':			case 'Þ':			case 'ß':			case 'à':				flagAdd = true;				break;			default:				break;		}				LookUpTableWyckofConvert(theChar,theNumber,flagAdd);		/*flagAdd;  Error Think C*/		theNumPtr++;		theNumPtr++;		if(flagAdd == true)			information++;		flagAdd = false;		theNumPtr[0] = 0;		theNumPtr[1] = 0;		theNumber = theNumPtr;		information++;	}}void ITCCrystalObject::SetSpaceGroup(void){	char *theInformation;	char *countedInformation;	short i,j,size;	Handle theResHandle;	theResHandle = GetResource(theResType,spaceGrpNm);	if((long)theResHandle == 0L){		return;	}		countedInformation 		= (char*)D_NewPtr(1000 * sizeof(char));	theInformation 			= (char*)(*theResHandle);	theSpaceGrp.spaceGrpNm 	= *(theInformation++);	if(theSpaceGrp.spaceGrpNm < 0){		theSpaceGrp.spaceGrpNm += 256;	}	if(theResType == 'Trhx') theSpaceGrp.spaceGrpNm += 1000;	theSpaceGrp.crystlMultiplicity = (int)*(theInformation++);	i = 1;	while(*theInformation != ';'){		theSpaceGrp.posMultiplicity[i++] = (int)*(theInformation++);		if(theSpaceGrp.posMultiplicity[i-1] < 0){			theSpaceGrp.posMultiplicity[i-1] += 256;		}	}	theInformation++;	theSpaceGrp.posMultiplicity[i] = 0;		i = 0;	j = 0;	while(*theInformation != ';'){			countedInformation[j++] = *(theInformation++);	}			countedInformation[j++] = *(theInformation++);	countedInformation[j] = '\0';				size = strlen(countedInformation) + 1;	strncpy(theSpaceGrp.headLine,countedInformation,size);		i = 1;	theSpaceGrp.extinctString[0] = extinctionString;	theSpaceGrp.posString[0] = positionString;	theSpaceGrp.extinctString[1] = extinctionString;	theSpaceGrp.posString[1] = positionString;	while(theSpaceGrp.posMultiplicity[i] != 0 && *(theInformation) != '\0'){		j = 0;		while(*theInformation != ';')			countedInformation[j++] = *(theInformation++);		countedInformation[j++] = *(theInformation++);			countedInformation[j] = '\0';		size = (strlen(countedInformation) + 1);		strncpy(theSpaceGrp.posString[i],countedInformation,size);		theSpaceGrp.posString[i + 1] = &((theSpaceGrp.posString[i])[size + 1]);				j = 0;		while(*theInformation != ';')			countedInformation[j++] = *(theInformation++);					countedInformation[j++] = *(theInformation++);			countedInformation[j] = '\0';		size = (strlen(countedInformation) + 1);		strncpy(theSpaceGrp.extinctString[i],countedInformation,size);		theSpaceGrp.extinctString[i + 1] = &((theSpaceGrp.extinctString[i])[size + 1]);		i++;			}	KillPtr((Ptr)countedInformation);	ReleaseResource((Handle)theResHandle);	return;}void ITCCrystalObject::JustifyAtomPositions(short formulaUnits){		WckoffPosition* theWyAtomsOld;	short			theElement;	short			p,i,k,multiplicity;	AtomPtr			atomPos;	short			kMax;		switch(lattice_Type)	{		case TRICLINIC:			theResType = 'Tric';			break;		case MONOCLINIC:			theResType = 'Mono';			break;		case ORTHORHOMBIC:			theResType = 'Orth';			break;		case TETRAGONAL:			theResType = 'Tetr';			break;		case TRIGONAL:			theResType = 'Trig';			break;		case HEXAGONAL:			theResType = 'Hexa';			break;		case CUBIC:			theResType = 'Cubc';			break;		case TRIGHEX:			theResType = 'Trhx';			break;	}	SetSpaceGroup();	kMax = 1;	while(theSpaceGrp.posMultiplicity[kMax]  != 0)kMax++;	kMax--;	if(wy_Atom_Count >= 0)KillPtr(theWyckAtoms);	wy_Atom_Count = -1;		theWyAtomsOld = (WckoffPosition*)D_NewPtr((atom_Count + 1) * sizeof(WckoffPosition));	D_HLock((Handle)theAtoms);	atomPos = *theAtoms;		i = 0;	while(i < atom_Count){		short j;		Boolean	flag;		theElement = atomPos->atomicNum;		j = 0;		flag = true;		while(theElement == atomPos->atomicNum && flag == true){			atomPos++;			j++;			i++;			if(i == atom_Count) flag = false;		}		j *= formulaUnits;		k = kMax;		if(theSpaceGrp.posMultiplicity[k]  <= j){			short n;			n = j / (theSpaceGrp.posMultiplicity[k]);			for(p = 0; p < n;p++){				wy_Atom_Count++;				theWyAtomsOld[wy_Atom_Count].wckoffPosNo = k;				theWyAtomsOld[wy_Atom_Count].x = CrystalRandom();				theWyAtomsOld[wy_Atom_Count].y = CrystalRandom();				theWyAtomsOld[wy_Atom_Count].z = CrystalRandom();				theWyAtomsOld[wy_Atom_Count].atomicNum =  theElement;			}		}else{			do{				k--;				multiplicity = theSpaceGrp.posMultiplicity[k] ;							}while(j != multiplicity && k != 0);			if(k == 0) k = 1;			wy_Atom_Count++;			theWyAtomsOld[wy_Atom_Count].wckoffPosNo = k;			theWyAtomsOld[wy_Atom_Count].x = CrystalRandom();			theWyAtomsOld[wy_Atom_Count].y = CrystalRandom();			theWyAtomsOld[wy_Atom_Count].z = CrystalRandom();			theWyAtomsOld[wy_Atom_Count].atomicNum =  theElement;		}	}	theWyckAtoms = (WckoffPosition*)D_NewPtr((wy_Atom_Count + 1) * sizeof(WckoffPosition));	for(i = 0; i <= wy_Atom_Count;i++){		theWyckAtoms[i] = theWyAtomsOld[i];	}		KillPtr((Ptr)theWyAtomsOld);	ConvertWyckoffToReal();	JustifyAtomPos();	ReconfigureElementList();}double CrystalRandom(void){	double theNumber,fabsNumber;	long	shortNum;	theNumber 	=  (double)(Random()) ;	theNumber 	*= .00305185;	shortNum 		= theNumber;	theNumber	-= shortNum;	fabsNumber	= fabs(theNumber);	if(fabsNumber <= .0001) return  .0001;	if(fabs(fabsNumber - .5) <= .0001) return theNumber +  .001;	if(fabs(fabsNumber - .75) <= .0001) return theNumber +  .001;	if(fabs(fabsNumber - .25) <= .0001) return theNumber +  .001;	if(fabs(fabsNumber - .3333) <= .0001) return theNumber +  .001;	if(fabs(fabsNumber - .6667) <= .0001) return theNumber +  .001;	if(fabs(fabsNumber - .125) <= .0001) return theNumber +  .001;	if(fabs(fabsNumber - .375) <= .0001) return theNumber +  .001;	if(fabs(fabsNumber - .625) <= .0001) return theNumber +  .001;	if(fabs(fabsNumber - .875) <= .0001) return theNumber +  .001;	return theNumber;}void ITCCrystalObject::DoClose(void){		KillPtr((Ptr)theSpaceGrp.headLine);	KillPtr((Ptr)extinctionString);	KillPtr((Ptr)positionString);	inherited::DoClose();}