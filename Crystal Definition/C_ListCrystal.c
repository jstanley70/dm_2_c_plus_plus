//C_ListCrystal.c#include	"Diffract_INCs.h"void		ListCrystal::DoInit			(short currentDataBase){	next = 0L;	dataBase 		= currentDataBase;	fileName 		= (char*)D_NewPtr(1 * sizeof(char));	formula			= (char*)D_NewPtr(1 * sizeof(char));	FOM 			= -1;	volume 			= 0;	spaceGrp 		= 0;	lattice_Type 	= 0;	year			= 1800;}void		ListCrystal::CopyDMCrystal (Crystal *theCrystal){	short length;	length = strlen(theCrystal->crystalName);	length++;	if(length <= 0) 		length = 1;	KillPtr			((Ptr)fileName);	fileName 	= 	D_NewPtr(length * sizeof(char));	strncpy			(fileName,theCrystal->crystalName,length);	fileName[length - 1] = 0;	length 		= 	strlen(theCrystal->formulaText);	length++;	if(length <= 0) 		length = 1;	KillPtr			((Ptr)formula);	formula 	= 	D_NewPtr(length * sizeof(char));	strncpy			(formula,theCrystal->formulaText,length);	formula[length - 1] = 0;	volume 		= 	theCrystal->volumeReduced;	year 		= 	theCrystal->year;	spaceGrp 	= 	theCrystal->spaceGrpNm;	theUnitCell = 	theCrystal->theUnitCell;	lattice_Type = 	theCrystal->lattice_Type;}			ListCrystal*		ListCrystal::DoAdd			(Crystal *theCrystal,short currentDataBase,										long ref1,long ref2){	if(next != 0L){		return next->DoAdd			(theCrystal, currentDataBase,ref1,ref2);	}	next = (ListCrystal*)D_new(ListCrystal);		next->	DoInit(currentDataBase);	next->	CopyDMCrystal (theCrystal);	next->	refNo1 = ref1;	next->	refNo2 = ref2;	next->	next = 0L;	return 	next;}void	ListCrystal::KillAll(void){	DoCloseAll();	KillPtr((Ptr)formula);	KillPtr((Ptr)fileName);	D_delete(this);}void		ListCrystal::DoCloseAll			(void){	if(next != 0L){		next->DoCloseAll	();	}	if(next != 0L){		KillPtr((Ptr)next->formula);		KillPtr((Ptr)next->fileName);		D_delete(next);		next = 0L;	}	}void		ListCrystal::DoClose			(void){		KillPtr(formula);	KillPtr(fileName);	D_delete(this);	}ListCrystal*	ListCrystal::DeleteCrystal	(short crystalNumber,short theNumber){	if(crystalNumber > theNumber + 1 && next != 0L){		theNumber++;				return next->DeleteCrystal	(crystalNumber, theNumber);	}	{		ListCrystal *theNext;		if(next != 0L){			theNext = next->next;			next->DoClose();		}else			theNext = 0L;				next = theNext;	}	return next;}ListCrystal*	ListCrystal::GetCrystal		(short crystalNumber,short *theNumber){	if(crystalNumber > *theNumber && next != 0L){		short theValue;		theValue = *theNumber;		*theNumber = theValue + 1;				return next->GetCrystal	(crystalNumber, theNumber);	}	return this;}char*		ListCrystal::CrystalTitle	(char *aTitle){	char theText[100];			if(FOM > 0){		sprintf(theText,"%3d  ",FOM);		strcpy(aTitle,theText);	}		sprintf(theText,"%5d  ",volume);	strcat(aTitle,theText);	strcat(aTitle,CrystalType(theText));	strcat(aTitle,"    ");	strcat(aTitle,formula);	aTitle[36] = (char)0;	return aTitle;}char*	ListCrystal::CrystalType		(char* theText){	short 			lastSelected;	ResType 		theResType;	MenuHandle		theMenuHnd;	short			firstSpaceGrp,lastSpaceGrp;		switch(lattice_Type)	{		case TRICLINIC:			firstSpaceGrp = 1;			lastSpaceGrp = 2;			theResType = 'Tric';			theMenuHnd = GetMenu(101);			break;		case MONOCLINIC:			firstSpaceGrp = 3;			lastSpaceGrp = 15;			theResType = 'Mono';			theMenuHnd = GetMenu(102);			break;		case ORTHORHOMBIC:			firstSpaceGrp = 16;			lastSpaceGrp = 74;			theResType = 'Orth';			theMenuHnd = GetMenu(103);			break;		case TETRAGONAL:			firstSpaceGrp = 75;			lastSpaceGrp = 142;			theResType = 'Tetr';			theMenuHnd = GetMenu(104);			break;		case TRIGONAL:			firstSpaceGrp = 143;			lastSpaceGrp = 167;			theResType = 'Trig';			theMenuHnd = GetMenu(105);			break;		case HEXAGONAL:			firstSpaceGrp = 168;			lastSpaceGrp = 194;			theResType = 'Hexa';			theMenuHnd = GetMenu(106);			break;		case CUBIC:			firstSpaceGrp = 195;			lastSpaceGrp = 230;			theResType = 'Cubc';			theMenuHnd = GetMenu(107);			break;		case TRIGHEX:			firstSpaceGrp = 1146;			lastSpaceGrp = 1167;			theResType = 'Trhx';			theMenuHnd = GetMenu(125);			break;	}	if(spaceGrp > lastSpaceGrp || spaceGrp < firstSpaceGrp) spaceGrp = firstSpaceGrp;			lastSelected = spaceGrp - firstSpaceGrp + 1;		if(theResType == 'Trhx'){		switch(spaceGrp){			case 1146:				lastSelected = 1;				break;			case 1148:				lastSelected = 2;				break;			case 1155:				lastSelected = 3;				break;			case 1160:				lastSelected = 4;				break;			case 1161:				lastSelected = 5;				break;			case 1166:				lastSelected = 6;				break;			case 1167:				lastSelected = 7;				break;		}	}	GetItem(theMenuHnd,lastSelected,(unsigned char*)theText);	DeleteMenu((*theMenuHnd)->menuID);	ReleaseResource((Handle)theMenuHnd);	p2cstr((unsigned char*)theText);	return theText;}void		ListCrystal::FillListVol			(ListParameters  *start,short *n){	start[*n].address 	= 	(Ptr)this;	start[*n].value 	= 	volume;	if(next != 0L)	{		(*n)++;		next->FillListVol		(  start, n);	}	}void ListCrystal::FillSortedList(ListParameters *start,short n,short lastN){	if(n == lastN)	{		next = 0L;		return;	}	next = (ListCrystal*)start[n + 1].address;	n++;	next-> FillSortedList(start,n,lastN);}void	ListCrystal::FillListFOM		(ListParameters  *start,short *n){	start[*n].address 	= 	(Ptr)this;	start[*n].value 	= 	FOM;	if(next != 0L)	{		(*n)++;		next->FillListFOM		( start, n);	}}void		ListCrystal::ChangeFileName(unsigned char* theText){	short length;	KillPtr(fileName);	p2cstr(theText);	length = strlen((char*)theText);	fileName = (char*)D_NewPtr((length + 2) * sizeof(char));	strcpy(fileName,(char*)theText);	c2pstr((char*)theText);}void		ListCrystal::DoCopy			(ListCrystal *copyCrystal){	short length;	next = 0L;	dataBase 	= 	copyCrystal->dataBase;	length 		= 	strlen(copyCrystal->fileName);	fileName 	= 	D_NewPtr(length * sizeof(char));	strcpy			(fileName,copyCrystal->fileName);	length 		= 	strlen(copyCrystal->formula);	formula 	= 	D_NewPtr(length * sizeof(char));	strcpy			(formula,copyCrystal->formula);	volume 		= 	copyCrystal->volume;	spaceGrp 	= 	copyCrystal->spaceGrp;	theUnitCell = 	copyCrystal->theUnitCell;	lattice_Type = 	copyCrystal->lattice_Type;}void	ListCrystal::FillMenuFrom(MenuHandle theMenu,short start){		short noOfItems;	short i;		noOfItems		=	CountMItems(theMenu);	for(i = start + 1; i <= noOfItems;i++) 			DelMenuItem(theMenu,start + 1);		}void	ListCrystal::AppendItemsToMenu(MenuHandle theMenu){	short iItemCnt;	CrystalTitle(gTheText);	c2pstr(gTheText);	AppendMenu(theMenu,pTheText);	iItemCnt = CountMItems(theMenu);	EnableItem(theMenu,iItemCnt);}