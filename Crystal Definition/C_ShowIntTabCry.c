//C_ShowIntTabCry.c#include	"Diffract_INCs.h"#include	"ShowIntTabCry.h"char**  		xmlDocument;enum{	TRICLINICW =	141, 	MONOCLINICW, 	ORTHORHOMBICW,	TETRAGONALW, 	TRIGONALW, 	TRIGHEXW, 	HEXAGONALW, 	CUBICW};#define  SHOWINTMENBAR 100void ShowIntTables::DoInit(void){				variSize					=	true;	rulerHeight					=	0;	inherited::DoInit();	theSpaceGrp = (IntNatTblRsrc*)D_NewPtr(sizeof(IntNatTblRsrc));	InitWyckoff();	sprintf(gTheText,"Space Group Tables");	SetWTitle(theWindow,c2pstr(gTheText));			/*KillMBHandle*/DisposeHandle(theMenuBar);	theMenuBar = GetMenuBar();	DrawMenuBar();}void ShowIntTables::SetObjectMenu(void){	GrafPtr	theWMgrPort;	short	i,k;		for(i = 0 ; i <= 7 ; i++){		theMenuTab[i] = (MenuHandle)NUL;	}		GetWMgrPort(&theWMgrPort);	if((theWMgrPort->portRect.right - theWMgrPort->portRect.left) > 620){		theMenuBar = GetNewMBar(100);		ClearMenuBar();/* July 1992 */		SetMenuBar(theMenuBar);	} else {		theMenuBar = GetNewMBar(101);		ClearMenuBar();/* July 1992 */		SetMenuBar(theMenuBar);		for(i = TRICLINICW , k = 0 ; i <= CUBICW ; i++ , k++){			gTheText[0] = (char)0;			theMenuTab[k]	= DMJ_GetMenu(i);			(*theMenuTab[k])->menuID = i;			InsertMenu(theMenuTab[k],-1);		}	}	DrawMenuBar();}void ShowIntTables::DoMenu(long theResult){	short theMenu,theItem;	theItem 		= LoWord(theResult);	theMenu 		= HiWord(theResult);	//xmlDocument 	= 	D_NewHandle(1000);/*	WriteToXmlString(xmlDocument,"<SpaceGroups>");		for(theMenu = TRICLINICW; theMenu <= CUBICW; theMenu++)	{		for(theItem = 1; theItem <= 40; theItem++)		{			if(DoResourceMenu(theMenu,theItem)){				SetPict(true);			}		}	}	WriteToXmlString(xmlDocument,"</SpaceGroups>");	*/	gTheFile->SaveFileOpen('TEXT');		gTheFile->WriteHandle((Handle)xmlDocument);			gTheFile->DoFileClose();	//	KillHandle(&xmlDocument);		switch(theMenu){						case TRICLINICW:		 	case MONOCLINICW:		 	case ORTHORHOMBICW:			case TETRAGONALW:		 	case HEXAGONALW:		 	case CUBICW:		 	case TRIGONALW:		 	case TRIGHEXW:		 		DoResourceMenu(theMenu,theItem);								//SetPict(true);				newPictReq = true;				break;			default:			inherited::DoMenu(theResult);				break;	}		//HiliteMenu(0);	return;}void ShowIntTables::SetSpaceGrpToInit(void){	short i;	theSpaceGrp->spaceGrpNm = 1;	KillPtr((Ptr)theSpaceGrp->headLine);	theSpaceGrp->headLine = (char*)D_NewPtr(10 * sizeof(char));	sprintf(theSpaceGrp->headLine,"p1");	theSpaceGrp->crystlMultiplicity = 0;	for(i = 0;i <= 29; i++){		theSpaceGrp->posMultiplicity[i] = 0;		KillPtr((Ptr)theSpaceGrp->posString[i]);		theSpaceGrp->posString[i] = (char*)D_NewPtr(10 * sizeof(char));		sprintf((char*)theSpaceGrp->posString[i],"o");		KillPtr((Ptr)theSpaceGrp->extinctString[i]);		theSpaceGrp->extinctString[i] = (char*)D_NewPtr(10 * sizeof(char));		sprintf((char*)theSpaceGrp->extinctString[i],"0");	}}void ShowIntTables::DoClose(void){	short i;	if(this->theSpaceGrp != 0L){		KillPtr((Ptr)this->theSpaceGrp->headLine);		for(i = 0;i <= 29; i++){			KillPtr((Ptr)this->theSpaceGrp->posString[i]);			KillPtr((Ptr)this->theSpaceGrp->extinctString[i]);		}		KillPtr((Ptr)this->theSpaceGrp);	}	for(i = 0 ; i <= 7 ; i++){		if(theMenuTab[i] != (MenuHandle)NUL){			DeleteMenu((*theMenuTab[i])->menuID);			DisposHandle((Handle)theMenuTab);		}	}	inherited::DoClose();	}void ShowIntTables::InitWyckoff(){	short i;	theSpaceGrp->spaceGrpNm = 1;	theSpaceGrp->headLine = (char*)D_NewPtr(10 * sizeof(char));	sprintf(theSpaceGrp->headLine,"p1");	theSpaceGrp->crystlMultiplicity = 0;	for(i = 0;i <= 29; i++){		theSpaceGrp->posMultiplicity[i] = 0;		theSpaceGrp->posString[i] = (char*)D_NewPtr(10 * sizeof(char));		sprintf((char*)theSpaceGrp->posString[i],"o");		theSpaceGrp->extinctString[i] = (char*)D_NewPtr(10 * sizeof(char));		sprintf((char*)theSpaceGrp->extinctString[i],"0");	}}void ShowIntTables::SetPict(Boolean erase){	char *information;	short i,j,k,n,m,z;	short theLeft = 10,theBottom = 20,leftMark,rightMark,theTop,oldBottom;	char theChar;	char theText[255];	char aText[20];	/*pascal Boolean TheFilter();*/	Boolean flag;	Boolean doneBeforeFlag;	Rect theRect;	Point	lastPoint;	D_SetClip(gUpdateAll);	InvalRgn(drawRgn);	information = theSpaceGrp->headLine;			//	WriteToXmlString(xmlDocument,"<SpaceGroup>");		if(erase){  /* dummy to keep unused erase from generating a warning */		i = 0;	}		leftMark = theLeft = theVisRect.left + 5;	rightMark = theVisRect.right;	theBottom = 15 + theVisRect.top;	if(screenPict != NUL){		KillPicture(screenPict);	}	SetRect(&theRect,0,0,700,750);	/*theRect = theVisRect;	theRect.bottom = theVisRect.bottom +  490;	theRect.right = theVisRect.right + 40;	*/	thePictRect = theRect;	objectSize.h = thePictRect.right;	objectSize.v = thePictRect.bottom;	objectSize.v = thePictRect.bottom;	objectSize.h = thePictRect.right;	screenPict = OpenPicture(&theRect); 	DMBackColor(WHITE); 	DMForeColor(BLACK);	dm_EraseRect(&theRect);			PenNormal();	MoveTo(theLeft,theBottom);	sprintf(theText,"# %d",theSpaceGrp->spaceGrpNm);	TextSize(12);	//	WriteToXmlString(xmlDocument,"<Number>");	//	WriteToXmlString(xmlDocument,theText);//	WriteToXmlString(xmlDocument,"</Number>");	DrawString(c2pstr(theText));	TextFont(9);	theLeft += 50;	i = 0;	j = 0;//	WriteToXmlString(xmlDocument,"<GeneralInfo>");	theStart:	while(*information != ';' && *information != '\0'){		theChar = *information++;		switch(theChar){			case ',':				theLeft += 25;				goto theStart;          		break;			case '<':				j = 0;				MoveTo(theLeft + i,theBottom + 6);				i += 5;				TextSize(9);				theChar = *(information++);				DrawChar(theChar);				//WriteToXmlChar(xmlDocument,theChar);					goto theStart;				break;			case '>':				i = 0;				MoveTo(theLeft + j,theBottom - 4);				j += 5;				TextSize(9);				theChar = *(information++);				DrawChar(theChar);				//WriteToXmlChar(xmlDocument,theChar);					goto theStart;				break;			case ':':				MoveTo(theLeft - 2,theBottom);				theChar = *(information++);				TextSize(9);				DrawChar(theChar);				//WriteToXmlChar(xmlDocument,theChar);					theLeft += 10;				goto theStart;				break; 			default:				break;						}							/* if(theChar >= 'å' && theChar <= 'Ω'){			theChar -= 'å';			theChar += 'a';			TextSize(12);			MoveTo(theLeft,theBottom);			DrawChar(theChar);			MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 3,theBottom - 10);			theLeft += 10;			continue;		} */		TextSize(12);		flag = false;		switch((int)theChar){			case (char)0xDA:			case (char)0xC1:				theChar = '1';								flag = true;				break;			case (char)0xDB:			case (char)0xAA:				theChar = '2';							flag = true;				break;			case (char)0xDC:			case (char)0xA3:				theChar = '3';								flag = true;				break;			case (char)0xDD:			case (char)0xA2:				theChar = '4';								flag = true;				break;			case (char)0xDE:			case (char)0xB0:				theChar = '5';				flag = true;				break;			case (char)0xDF:			case (char)0xA4:				theChar = '6';				flag = true;				break;			case (char)0xE0:			case (char)0xA6:				theChar = '7';				flag = true;				break;			case (char)0xF5:			case (char)0xA5:				theChar = '8';				flag = true;				break;			case (char)0xE1:			case (char)0xBB:				theChar = '9';				flag = true;				break;		}		if(flag){			MoveTo(theLeft,theBottom);			DrawChar(theChar);	//		WriteToXmlString(xmlDocument,"-");	//		//WriteToXmlChar(xmlDocument,theChar);				GetPen(&lastPoint);			Move(-1,-12);			LineTo(theLeft,theBottom - 12);			MoveTo(lastPoint.h,lastPoint.v);			theLeft = lastPoint.h;		/*			MoveTo(theLeft - 1,theBottom - 12);			LineTo(theLeft + 4,theBottom - 12);			theLeft += 10;		*/			continue;		}		if(theChar == (char)0xDA ){			theChar -= (char)0xDA;			theChar += '1';		}		TextSize(12);		MoveTo(theLeft,theBottom);		DrawChar(theChar);		//WriteToXmlChar(xmlDocument,theChar);			theLeft += 10;	}//	WriteToXmlString(xmlDocument,"</GeneralInfo>");		k = 0;//	WriteToXmlString(xmlDocument,"<Multiplicity>");		switch(theSpaceGrp->crystlMultiplicity)	{		case 1:			sprintf(theText,"(0,0,0)");			break;		case 2:			sprintf(theText,"(0,0,0)  (1/2,1/2,0)");			break;		case 3:			sprintf(theText,"(0,0,0)  (1/2,1/2,0)  (1/2,0,1/2)  (0,1/2,1/2)");			break;		case 4:			sprintf(theText,"(0,0,0)   (1/2,1/2,1/2)");			break;		case 5:			sprintf(theText,"(0,0,0)   (0,1/2,1/2)");			break;		case 6:			sprintf(theText,"(0,0,0)   (2/3,1/3,1/3)   (1/3,2/3,2/3)");			break;		default:			break;		}//	WriteToXmlString(xmlDocument,theText);//	WriteToXmlString(xmlDocument,"</Multiplicity>");	theLeft = leftMark + 40;	theBottom += 20;	MoveTo(theLeft,theBottom);	TextSize(12);	DrawString(c2pstr(theText));			while(theSpaceGrp->posMultiplicity[k + 1] != 0){		k++;	}	TextSize(10);	theLeft = leftMark;	theBottom += 5;	theTop = theBottom;	doneBeforeFlag = false;//	WriteToXmlString(xmlDocument,"<PosMultiplicity>");	for(i = k; i >= 1; i--){	//	WriteToXmlString(xmlDocument,"<Line>");		theChar = 'a' + i - 1;		theLeft = leftMark;		theBottom += 15;		if(theBottom >= theRect.bottom - 5){			if(doneBeforeFlag == true)				goto Ending;			z = k;			while(theSpaceGrp->posMultiplicity[z] > 2)					z--;			theBottom -= ((z - i) * 15);			leftMark += 240;			theLeft = leftMark;			doneBeforeFlag = true;		}		TextSize(10);		theTop = theBottom;		sprintf(theText,"%d   %c ",theSpaceGrp->posMultiplicity[i],theChar);		MoveTo(theLeft,theBottom);	//	WriteToXmlString(xmlDocument,theText);		DrawString(c2pstr(theText));				information  = theSpaceGrp->posString[i];		theLeft = leftMark + 32;		m = 0;			//	WriteToXmlString(xmlDocument,"<Degeneracies>");		while(*information != ';' && *information != '\0'){			if(*information == ','){				m++;				theLeft = leftMark + 32 + m * 104;								information++;				if(theLeft + 240 >= rightMark){					theLeft = leftMark + 32;					m = 0;					theBottom += 15;					if(theBottom >= theRect.bottom - 5){						if(doneBeforeFlag == true)							goto Ending;						z = k;						while(theSpaceGrp->posMultiplicity[z] > 2)								z--;						theBottom -= ((z - i) * 15);						leftMark += 240;						theLeft = leftMark;						doneBeforeFlag = true;					}				}				continue;			}			theChar = *information;			switch((int)theChar){				case 'A':				case 'B':				case 'C':				case 'D':				case 'X':				case 'Y':				case 'Z':				case '!':				case '@':				case '#':				case '$':				case '%':				case '^':				case '&':					theLeft -= 2;					MoveTo(theLeft,theBottom);				//	WriteToXmlString(xmlDocument,"+");					DrawChar('+');					theLeft += 8;					break;				case 'Å':				case 'ı':				case 'Ç':				case 'Î':				case 'Ù':				case 'Á':				case 'Û':				case '⁄':				case '€':				case '‹':				case '›':				case 'ﬁ':				case 'ﬂ':				case '‡':					MoveTo(theLeft,theBottom);				//	WriteToXmlString(xmlDocument,"+");					DrawChar('+');					theLeft += 8;					break;				default:					break;			}						LookUpTableWyckof(theChar,&theLeft,theBottom);			theLeft += 10;			information++;		}		//WriteToXmlString(xmlDocument,"</Degeneracies>");		information = theSpaceGrp->extinctString[i];		oldBottom = theBottom;		theBottom = theTop;		theLeft = rightMark - 160;		//WriteToXmlString(xmlDocument,"<Extinction>");		while(*information != ';' && *information != '\0'){			j = 0;			while(*information != ',' && *information != ';'){				theText[j++] = *(information++);			}				if(*information != ';')					information++;				theText[j] = '\0';				n = atoi(theText);						ExtinctionPrint(n,theLeft,theBottom);			theBottom += 15;			if(theBottom >= theRect.bottom - 5){				if(doneBeforeFlag == true)					goto Ending;				z = k;				while(theSpaceGrp->posMultiplicity[z] > 2)						z--;				theBottom -= ((z - i) * 15);				leftMark += 240;				theLeft = leftMark;				doneBeforeFlag = true;			}		}	//	WriteToXmlString(xmlDocument,"</Extinction>");		if(theBottom >= oldBottom + 15)			theBottom -= 15; 		else			theBottom = oldBottom;	//		WriteToXmlString(xmlDocument,"</Line>");	}//	WriteToXmlString(xmlDocument,"</PosMultiplicity>");Ending:	  ClosePicture();	DoResize();	TextSize(12);	TextFont(0);//	WriteToXmlString(xmlDocument,"</SpaceGroup>");			}void ShowIntTables::LookUpTableWyckof(char theChar,short* ptrLeft,short theBottom){	char theText[255];	short theLeft;	theLeft = *ptrLeft;	MoveTo(theLeft,theBottom);	TextSize(10);//	WriteToXmlString(xmlDocument,",");	switch((int)theChar){		case 'x':		case 'X':			DrawChar('x');		//	WriteToXmlString(xmlDocument,"x");			break;		case 'y':		case 'Y':			DrawChar('y');			WriteToXmlString(xmlDocument,"y");			break;		case 'z':		case 'Z':			DrawChar('z');			//WriteToXmlString(xmlDocument,"z");			break;		case '0':			DrawChar(theChar);			//WriteToXmlString(xmlDocument,"0");			break;		case '≈':		case 'Ù':			MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 3,theBottom - 10);			MoveTo(theLeft,theBottom);			DrawChar('x');			//WriteToXmlString(xmlDocument,"-x");			break;		case '¥':		case 'Á':			MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 3,theBottom - 10);			MoveTo(theLeft,theBottom);			DrawChar('y');		//	WriteToXmlString(xmlDocument,"-y");			break;		case 'Ω':		case 'Û':				MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 3,theBottom - 10);			MoveTo(theLeft,theBottom);			DrawChar('z');			//WriteToXmlString(xmlDocument,"-z");			break;		case (char)0xDA:			MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 3,theBottom - 10);			//WriteToXmlString(xmlDocument,"-");		case '1':		case '!':			TextSize(9);			sprintf(theText,"1|8");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;		//	WriteToXmlString(xmlDocument,"1/8");			break;		case (char)0xDB:			MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 6,theBottom - 10);		//	WriteToXmlString(xmlDocument,"-");		case '2':		case '@':			TextSize(9);			sprintf(theText,"1|4");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;		//	WriteToXmlString(xmlDocument,"1/4");			break;		case (char)0xDC:			TextSize(9);			MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 6,theBottom - 10);		//	WriteToXmlString(xmlDocument,"-");		case '3':		case '#':			TextSize(9);			sprintf(theText,"3|8");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;			//WriteToXmlString(xmlDocument,"3/8");			break;		case (char)0xDD:			MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 6,theBottom - 10);			//WriteToXmlString(xmlDocument,"-");		case '4':		case '$':			TextSize(9);			sprintf(theText,"1|2");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;			//WriteToXmlString(xmlDocument,"1/2");			break;		case (char)0xDE:			MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 6,theBottom - 10);			//WriteToXmlString(xmlDocument,"-");		case '5':		case '%':			TextSize(9);			sprintf(theText,"5|8");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;			WriteToXmlString(xmlDocument,"5/8");			break;		case (char)0xDF:						MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 6,theBottom - 10);			//WriteToXmlString(xmlDocument,"-");		case '6':		case '^':			TextSize(9);			sprintf(theText,"3|4");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;			//WriteToXmlString(xmlDocument,"3/4");			break;		case (char)0xE0:			MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 6,theBottom - 10);			//WriteToXmlString(xmlDocument,"-");		case '7':		case '&':			TextSize(9);			sprintf(theText,"7|8");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;			//WriteToXmlString(xmlDocument,"7/8");			break;		case 'å':		case 'Å':			MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 6,theBottom - 10);			//WriteToXmlString(xmlDocument,"-");		case 'a':		case 'A':			TextSize(9);			sprintf(theText,"1|6");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 10;			//WriteToXmlString(xmlDocument,"1/6");			break;		case '∫':		case 'ı':			MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 6,theBottom - 10);			//WriteToXmlString(xmlDocument,"-");		case 'b':		case 'B':			TextSize(9);			sprintf(theText,"1|3");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;			//WriteToXmlString(xmlDocument,"1/3");			break;		case 'ç':		case 'Ç':			MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 6,theBottom - 10);			//WriteToXmlString(xmlDocument,"-");		case 'c':		case 'C':			TextSize(9);			sprintf(theText,"2|3");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;			//WriteToXmlString(xmlDocument,"2/3");			break;		case '∂':		case 'Î':			MoveTo(theLeft - 1,theBottom - 10);			LineTo(theLeft + 6,theBottom - 10);			//WriteToXmlString(xmlDocument,"-");		case 'd':		case 'D':			TextSize(9);			sprintf(theText,"5|6");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;			//WriteToXmlString(xmlDocument,"5/6");			break;				case 'e':			TextSize(9);			sprintf(theText,"1|12");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;			//WriteToXmlString(xmlDocument,"1/12");			break;				case 'f':			TextSize(9);			sprintf(theText,"5|12");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;			//WriteToXmlString(xmlDocument,"5/12");			break;				case 'g':			TextSize(9);			sprintf(theText,"7|12");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;			//WriteToXmlString(xmlDocument,"7/12");			break;		case 'h':			TextSize(9);			sprintf(theText,"11|12");			DrawString(c2pstr(theText));			*ptrLeft = theLeft + 8;			//WriteToXmlString(xmlDocument,"11/12");			break;	}	}void ShowIntTables::ExtinctionPrint(short n,short theLeft,short theBottom){	char theText[255];	if(n == 0)		return;	switch(n){		case 1:			sprintf(theText,"0k0: k = 2n");			break;		case 2:			sprintf(theText,"h00: h = 2n");			break;		case 3:			sprintf(theText,"00l: l = 2n");			break;		case 4:			sprintf(theText,"hkl: h+k = 2n");			break;		case 5:			sprintf(theText,"h0l: h = 2n");			break;		case 6:			sprintf(theText,"0kl: k = 2n");			break;		case 7:			sprintf(theText,"hk0: h+k = 2n");			break;		case 8:			sprintf(theText,"h0l: l = 2n");			break;		case 9:			sprintf(theText,"00l: l = 2n");			break;		case 10:			sprintf(theText,"hkl: k = 2n");			break;		case 11:			sprintf(theText,"hkl: h = 2n");			break;		case 12:			sprintf(theText,"hkl: l = 2n");			break;		case 13:			sprintf(theText,"hkl: h+l = 2n");			break;		case 14:			sprintf(theText,"0kl: l = 2n");			break;		case 15:			sprintf(theText,"hk0: h = 2n");			break;		case 16:			sprintf(theText,"hkl: h+k,k+l,h+l = 2n");			break;		case 17:			sprintf(theText,"hk0: k = 2n");			break;		case 18:			sprintf(theText,"hkl: h+k+l = 2n");			break;		case 19:			sprintf(theText,"0kl: k+l = 2n");			break;		case 20:			sprintf(theText,"h0l: h+l = 2n");			break;		case 21:			sprintf(theText,"hk0: h+k = 2n");			break;		case 22:			sprintf(theText,"hkl: k+l = 2n");			break;		case 23:			sprintf(theText,"hkl: h+k = 2n");			break;		case 24:			sprintf(theText,"0kl: k = 2n");			break;		case 25:			sprintf(theText,"hkl: h = 2n+1 or h+k+l=4n");			break;		case 26:			sprintf(theText,"0kl: k+l = 4n");			break;		case 27:			sprintf(theText,"h0l: h+l = 4n");			break;		case 28:			sprintf(theText,"h00: h = 4n");			break;		case 29:			sprintf(theText,"0k0: k = 4n");			break;		case 30:			sprintf(theText,"00l: l = 4n");			break;		case 31:			sprintf(theText,"hk0: h+k = 4n");			break;		case 32:			sprintf(theText,"hkl: h=2n+1orh,k,l=4n+2orh,k,l=4n");			break;		case 33:			sprintf(theText,"hhl: l = 2n");			break;		case 34:			sprintf(theText,"hkl: l=2n+1 or 2h+l = 4n");			break;		case 35:			sprintf(theText,"hkl: l=2n+1 or 2h+l = 4n");			break;		case 36:			sprintf(theText,"hkl:l=2n+1orh,k=2norh+k+l=4n");			break;		case 37:			sprintf(theText,"h-h0: h = 2n");			break;		case 38:			sprintf(theText,"hhl:l=2n+1 or l = 4n");			break;		case 39:			sprintf(theText,"0kl:l=2n+1 or l=4n");			break;		case 40:			sprintf(theText,"hkl: l=2n+1or2k+l=4n");			break;		case 41:			sprintf(theText,"0kl: l=2n+1 or 2h+l = 4n");			break;		case 42:			sprintf(theText,"hhl: l = 4n");			break;		case 43:			sprintf(theText,"hhl: 2h + l = 4n");			break;		case 44:			sprintf(theText,"hkl: 2h + l = 4n");			break;		case 45:			sprintf(theText,"hhl: l = 2n + 1 or h = 2n");			break;		case 46:			sprintf(theText,"hkl: h + k + l = 4n");			break;		case 47:			sprintf(theText,"000l: l = 3n");			break;		case 48:			sprintf(theText,"hkil:l=2norh-k=3n+1orh-k=3n+2");			break;		case 49:			sprintf(theText,"hhh: h = 2n");			break;		case 50:			sprintf(theText,"h-hl: l = 2n");			break;		case 51:			sprintf(theText,"000l: l = 6n");			break;		case 52:			sprintf(theText,"hkil: l = 3n");			break;		case 53:			sprintf(theText,"hkil:h=2n+1ork=2n+1orl=3n");			break;		case 54:			sprintf(theText,"h-h0l:l=2norl=3n+1orl=3n+2");			break;		case 55:			sprintf(theText,"hh(-2h)l:l=2norl=3n+1orl=3n+1");			break;		case 56:			sprintf(theText,"hkl:h+k+l=2n or h=2n+1,k=4n,l=4n+2");			break;		case 57:			sprintf(theText,"hhl:h+l=2n");			break;		case 58:			sprintf(theText,"hkl:h,k=2n+1orh=2n+1,k=4n,l=4n+2orhkl=4n+2or=4n");			break;		case 59:			sprintf(theText,"0kl:k=2n+1orl=2n+1ork+l=4n");			break;		case 60:			sprintf(theText,"hkl:h,k=2n,h+k+l=4norh,k=2n+1l=4n+2or\rh=8n,k=8n+4,h+k+l=4n+2\rh,k=8n+1,l=4norh=8n+1,k=8n-1,l=4norh,k=8n+3,l=4n\rh=8n+3k=8n-3,l=4n");			break;		case 61:			sprintf(theText,"hkl:h = 2n+1 or h = 4n");			break;		case 62:			sprintf(theText,"hhl:h = 2n");			break;		case 63:			sprintf(theText,"hkl: h,k,l =4n + 2 or h,k,l =4n");			break;		case 64:			sprintf(theText,"hkl: h,k = 2n + 1,l=4n+2 or h,k,l =4n");			break;		case 65:			sprintf(theText,"hkl:h,k=2n,h+k+l=4norh,k=2n+1l=4n+2or\rh=8n,k=8n+4,h+k+l=4n+2");			break;					default:			break;	}	MoveTo(theLeft,theBottom);	//WriteToXmlString(xmlDocument,theText);	DrawString(c2pstr(theText));		}Boolean ShowIntTables::DoResourceMenu(short theMenu,short theItem){	Handle theReshandle;	short number;	Boolean flag;	switch(theMenu){		case TRICLINICW:			theReshandle = GetResource('Tric',theItem);			break;		case MONOCLINICW:			theReshandle = GetResource('Mono',theItem + 2);			break;		case ORTHORHOMBICW:			theReshandle = GetResource('Orth',theItem + 15);			break;		case TETRAGONALW:			theReshandle = GetResource('Tetr',theItem + 74);			break;		case TRIGONALW:			theReshandle = GetResource('Trig',theItem + 142);			break;		case TRIGHEXW:			switch(theItem){				case 1:					number = 1146;					break;				case 2:					number = 1148;					break;				case 3:					number = 1155;					break;				case 4:					number = 1160;					break;				case 5:					number = 1161;					break;				case 6:					number = 1166;					break;				case 7:					number = 1167;					break;			}			theReshandle = GetResource('Trhx',number);			break;		case HEXAGONALW:			theReshandle = GetResource('Hexa',theItem + 167);			break;		case CUBICW:			theReshandle = GetResource('Cubc',theItem + 194);			break;	}	flag = false;	if(theReshandle){		flag = true;		SetTheSpaceGroupHandle(theReshandle);	}	ReleaseResource(theReshandle);	return flag;}void ShowIntTables::SetTheSpaceGroupHandle(Handle theResHandle){	char *theInformation;	char *countedInformation;	short i,j;		countedInformation = (char*)D_NewPtr(500 * sizeof(char));		theInformation = (char*)(*theResHandle);	theSpaceGrp->spaceGrpNm = *(theInformation++);	if(theSpaceGrp->spaceGrpNm < 0){		theSpaceGrp->spaceGrpNm += 256;	}	theSpaceGrp->crystlMultiplicity = (int)*(theInformation++);	i = 1;		while(*theInformation != ';'){		theSpaceGrp->posMultiplicity[i++] = (int)*(theInformation++);		if(theSpaceGrp->posMultiplicity[i-1] < 0){			theSpaceGrp->posMultiplicity[i-1] += 256;		}	}	theInformation++;	theSpaceGrp->posMultiplicity[i] = 0;		i = 0;	j = 0;	while(*theInformation != ';'){			countedInformation[j++] = *(theInformation++);	}			countedInformation[j++] = *(theInformation++);	countedInformation[j] = '\0';		KillPtr((Ptr)theSpaceGrp->headLine);	theSpaceGrp->headLine = (char*)D_NewPtr((long)(strlen(countedInformation) + 1) * sizeof(char));			strcpy(theSpaceGrp->headLine,countedInformation);		i = 1;		while(theSpaceGrp->posMultiplicity[i] != 0 && *(theInformation) != '\0'){		j = 0;		while(*theInformation != ';')			countedInformation[j++] = *(theInformation++);		countedInformation[j++] = *(theInformation++);			countedInformation[j] = '\0';				KillPtr((Ptr)theSpaceGrp->posString[i]);		theSpaceGrp->posString[i] = (char*)D_NewPtr((long)(strlen(countedInformation) + 1) * sizeof(char));				strcpy(theSpaceGrp->posString[i],countedInformation);						j = 0;		while(*theInformation != ';')			countedInformation[j++] = *(theInformation++);					countedInformation[j++] = *(theInformation++);			countedInformation[j] = '\0';					KillPtr((Ptr)theSpaceGrp->extinctString[i]);		theSpaceGrp->extinctString[i] = (char*)D_NewPtr((long)(strlen(countedInformation) + 1) * sizeof(char));				strcpy(theSpaceGrp->extinctString[i],countedInformation);				i++;	}	KillPtr((Ptr)countedInformation);}void ShowIntTables::InputNewResource(void){	DialogPtr 	theDialog;	short		wyckoffNumber = 1;	short 		item,n = 0;	GetPort					(&theWindow);	theDialog 		= DM_GetNewDialog(100, 0L,(WindowPtr)-1L);	SetUpDialog			(theDialog);	RestateWyckoffPosition(theDialog,wyckoffNumber);		while(1 != 2){		SystemTask();		ModalDialog(TheFilterUPP,&item);		switch(item){			case 1:				GetDialogInfo(theDialog);							case 2:				DM_DisposDialog(&theDialog);				return;			case 3:				EnterWyckoffPosition(theDialog,wyckoffNumber);				break;			case 4:				wyckoffNumber++;				RestateWyckoffPosition(theDialog,wyckoffNumber);								break;			case 5:				wyckoffNumber--;				RestateWyckoffPosition(theDialog,wyckoffNumber);								break;			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			default:				break;		}	}}void ShowIntTables::GetDialogInfo(DialogPtr theDialog){	char theText[255];	short type,stringlength = 0;	Handle theHandle;	Rect theRect;	Handle theReshandle;	MenuHandle theMenu;	short i;	short menuNumber;	char *totalString,*thePointer;	ResType  theTypeDef;		totalString = (char*)D_NewPtr(2000 * sizeof(char));		sprintf(theText,"%d",theSpaceGrp->spaceGrpNm);	GetDItem(theDialog,6,&type,&theHandle,&theRect);	GetIText(theHandle,(unsigned char*)theText);	theSpaceGrp->spaceGrpNm = atoi(p2cstr((unsigned char*)theText));	totalString[stringlength++] = (char)theSpaceGrp->spaceGrpNm;		GetDItem(theDialog,8,&type,&theHandle,&theRect);	GetIText(theHandle,(unsigned char*)theText);	theSpaceGrp->crystlMultiplicity = atoi(p2cstr((unsigned char*)theText));	totalString[stringlength++] = (char)theSpaceGrp->crystlMultiplicity;		i = 1;		while(theSpaceGrp->posMultiplicity[i] != 0)		totalString[stringlength++] =  (char)theSpaceGrp->posMultiplicity[i++];		totalString[stringlength++] = ';';	totalString[stringlength++] = '\0';				GetDItem(theDialog,7,&type,&theHandle,&theRect);	GetIText(theHandle,(unsigned char*)theText);		p2cstr((unsigned char*)theText);	stringlength = strlen(theText);	if(theText[stringlength - 1] != ';'){		theText[stringlength++] = ';';		theText[stringlength++] = '\0';	}	KillPtr((Ptr)theSpaceGrp->headLine);	theSpaceGrp->headLine = (char*)D_NewPtr((strlen(theText) + 1) * sizeof(char));	strcpy(theSpaceGrp->headLine,theText);	stringlength = strlen(theSpaceGrp->headLine);	strncat(totalString,theSpaceGrp->headLine,stringlength + 1);		i = 1;		while(theSpaceGrp->posMultiplicity[i] != 0){		strncat(totalString,theSpaceGrp->posString[i],2000);		strncat(totalString,theSpaceGrp->extinctString[i],2000);		i++;	}	stringlength = strlen(totalString);	thePointer = (char*)D_NewPtr((long)strlen(totalString) * sizeof(char));	stringlength = strlen(totalString);	strcpy(thePointer,totalString);	stringlength = strlen(thePointer);	KillPtr((Ptr)totalString);	sprintf(theText,"%d   ",theSpaceGrp->spaceGrpNm);	stringlength = strlen(theText);	i = 0;	while(theSpaceGrp->headLine[i] != ',' && i <= 10 && theSpaceGrp->headLine[i] != ';'){		theText[stringlength++] = theSpaceGrp->headLine[i++];	}	theText[stringlength] = '\0';		if(theSpaceGrp->spaceGrpNm < 3)	{		theTypeDef = 'Tric';		menuNumber = 101;		goto endit;			}	if(theSpaceGrp->spaceGrpNm < 16)	{		theTypeDef = 'Mono';		menuNumber = 102;		goto endit;		}	if(theSpaceGrp->spaceGrpNm < 75)	{		theTypeDef = 'Orth';		menuNumber = 103;		goto endit;		}	if(theSpaceGrp->spaceGrpNm < 143)	{		theTypeDef = 'Tetr';		menuNumber = 104;		goto endit;		}	if(theSpaceGrp->spaceGrpNm < 168)	{		theTypeDef = 'Trig';		menuNumber = 105;		goto endit;		}	if(theSpaceGrp->spaceGrpNm < 195)	{		theTypeDef = 'Hexa';		menuNumber = 106;		goto endit;		}	if(theSpaceGrp->spaceGrpNm < 231)	{		theTypeDef = 'Cubc';		menuNumber = 107;		goto endit;		}	if(theSpaceGrp->spaceGrpNm < 1168)	{		theTypeDef = 'Trhx';		menuNumber = 125;		goto endit;		}endit:	theReshandle = GetResource(theTypeDef,theSpaceGrp->spaceGrpNm);		if(theReshandle == 0L){			AddResource(&thePointer,theTypeDef,theSpaceGrp->spaceGrpNm,c2pstr(theText));			if(ResError() != noErr){				KillPtr((Ptr)thePointer);				return;			}			theReshandle = GetResource(theTypeDef,theSpaceGrp->spaceGrpNm);			theMenu = GetMenu(menuNumber);			AppendMenu(theMenu,(unsigned char*)theText);		}else{			HNoPurge(theReshandle);			*theReshandle = thePointer;			ChangedResource(theReshandle);			if(ResError() != noErr){				KillPtr((Ptr)thePointer);				return;			}		}		WriteResource(theReshandle);		HPurge(theReshandle);		ReleaseResource(theReshandle);		KillPtr((Ptr)thePointer);		UpdateResFile(CurResFile());		return;	}void ShowIntTables::SetUpDialog(DialogPtr theDialog){	char theText[255];	short type;	Handle theHandle;	Rect theRect;		sprintf(theText,"%d",theSpaceGrp->spaceGrpNm);	GetDItem(theDialog,6,&type,&theHandle,&theRect);	SetIText(theHandle,c2pstr(theText));		GetDItem(theDialog,7,&type,&theHandle,&theRect);	SetIText(theHandle,c2pstr(theSpaceGrp->headLine));	p2cstr((unsigned char*)theSpaceGrp->headLine);		sprintf(theText,"%d",theSpaceGrp->crystlMultiplicity);	GetDItem(theDialog,8,&type,&theHandle,&theRect);	SetIText(theHandle,c2pstr(theText));}void ShowIntTables::EnterWyckoffPosition(DialogPtr theDialog,short wyckoffNumber){	char theText[255];	short type;	Handle theHandle;	Rect theRect;	short stringlength;	GetDItem(theDialog,10,&type,&theHandle,&theRect);	GetIText(theHandle,(unsigned char*)theText);	theSpaceGrp->posMultiplicity[wyckoffNumber] = atoi(p2cstr((unsigned char*)theText));		GetDItem(theDialog,11,&type,&theHandle,&theRect);	GetIText(theHandle,(unsigned char*)theText);	p2cstr((unsigned char*)theText);	stringlength = strlen(theText);	if(theText[stringlength - 1] != ';'){		theText[stringlength++] = ';';		theText[stringlength++] = '\0';	}	KillPtr((Ptr)theSpaceGrp->posString[wyckoffNumber]);	theSpaceGrp->posString[wyckoffNumber] = (char*)D_NewPtr((strlen(theText) + 1) * sizeof(char));	strcpy(theSpaceGrp->posString[wyckoffNumber],theText);		GetDItem(theDialog,12,&type,&theHandle,&theRect);	GetIText(theHandle,(unsigned char*)theText);	p2cstr((unsigned char*)theText);		stringlength = strlen(theText);	if(theText[stringlength - 1] != ';'){		theText[stringlength++] = ';';		theText[stringlength] = '\0';	}		KillPtr((Ptr)theSpaceGrp->extinctString[wyckoffNumber]);	theSpaceGrp->extinctString[wyckoffNumber] = (char*)D_NewPtr((strlen(theText) + 1) * sizeof(char));	strcpy(theSpaceGrp->extinctString[wyckoffNumber],theText);}void ShowIntTables::RestateWyckoffPosition(DialogPtr theDialog,short wyckoffNumber){	char theChar;	char theText[255];	short type;	Handle theHandle;	Rect theRect;		theChar = 'a' + wyckoffNumber - 1;	sprintf(theText,"%c",theChar);	GetDItem(theDialog,9,&type,&theHandle,&theRect);	SetIText(theHandle,c2pstr(theText));		GetDItem(theDialog,10,&type,&theHandle,&theRect);	sprintf(theText,"%d",theSpaceGrp->posMultiplicity[wyckoffNumber]);	SetIText(theHandle,c2pstr(theText));		GetDItem(theDialog,11,&type,&theHandle,&theRect);	SetIText(theHandle,c2pstr(theSpaceGrp->posString[wyckoffNumber]));	p2cstr((unsigned char*)theSpaceGrp->posString[wyckoffNumber]);		GetDItem(theDialog,12,&type,&theHandle,&theRect);	SetIText(theHandle,c2pstr(theSpaceGrp->extinctString[wyckoffNumber]));	p2cstr((unsigned char*)theSpaceGrp->extinctString[wyckoffNumber]);	}