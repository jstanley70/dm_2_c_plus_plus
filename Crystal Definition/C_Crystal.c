// C_Crystal.c#include		"Diffract_INCs.h"#include 	"ITCCrystalDef.h"#include 	"crystalFaceObj.h"#include		"UT_VectorMacros.c"	#include 	"ML_Crystal.h"#include		"EveMacros.h"#include		"ScatObj.h"short			uniqueMenuID;#define		CRYSTAL_VERSION   200Boolean		Crystal::InitCrystal(short num)		/*  Crystal Def method				*/{		short 			i;	long 			verticesAndEdges;	CrystalFacePtr 	theFacesPtr,theFace;	Boolean 		flag = false;	AtomPtr 		theAtomsPtr;	Crystal*		dummyCrystal;		dummyCrystal				= this;	lattice_Type				= CUBIC;	spaceGrpNm					= 195;	atom_Count					= 0;	wy_Atom_Count				= 0;	lastUserDef					= -1;	lastPhysicalParam			= 0;	lastThermoParam				= 0;	face_Count 					= 5;	verticesAndEdges 			= 18;	last_Edge					= -1;	last_Vertice				= -1;	noDifrntElem				= 1;	referenceInfoSet			= false;	idNum						= num;	theAtoms		= (AtomHnd)D_NewHandle((long)(atom_Count + 1) * sizeof(Atom)); 					if(!HandleIsOK((Handle)theAtoms)){						atom_Count = 0;						return false;					}	theWyckAtoms	= (WckoffPosition*)D_NewPtr((long)(wy_Atom_Count + 1) * sizeof(WckoffPosition)); 					if(!MemoryIsOK((Ptr)theWyckAtoms)){						wy_Atom_Count = 0;						return false;					}												physicalParams 	= (float**)D_NewHandle(sizeof(float));	thermoParams 	= (float**)D_NewHandle(sizeof(float));					theUnitCell.a				= theUnitCell.b		= theUnitCell.c		= 2.0;	theUnitCell.alpha			= theUnitCell.beta	= theUnitCell.gamma	= 90.0;		D_HLock((Handle)theAtoms);	theAtomsPtr = *theAtoms;	for(i = 0 ; i <= atom_Count ; i++){		theAtomsPtr[i].atomicNum 	= 29;		theAtomsPtr[i].x			= theAtomsPtr[i].y	= theAtomsPtr[i].z	= theAtomsPtr[i].bi = 0.0;		theAtomsPtr[i].wyckOffNum 	= 0;	}		D_HUnlock((Handle)theAtoms);			theWyckAtoms[0].x				= 0.0;	theWyckAtoms[0].y				= 0.0;	theWyckAtoms[0].z				= 0.0;	theWyckAtoms[0].bi				= 0.0;	theWyckAtoms[0].wckoffPosNo 	= 1;	theWyckAtoms[0].atomicNum 		= 29;	strcpy(theWyckAtoms[0].wckoffPosName,"a1");	strcpy(theWyckAtoms[0].wckoffPosName,"a1");		for(i = 0; i < 21;i++)elasticConstants[i] = 0;	elasticConstants[0] = 1.29;	elasticConstants[1] = 1.07;	elasticConstants[2] = 1.07;	elasticConstants[6] = 1.29;	elasticConstants[7] = 1.07;	elasticConstants[11] = 1.291;	elasticConstants[15] = .82;	elasticConstants[18] = .82;	elasticConstants[20] = .82;			for(i = 0 ; i < 26 ; i++) theUserAtoms[i] = (UserDefAtom*)NUL;				elementList[0] = 28;	for( i = 1; i < 20; i++) elementList[i] = -1;				crystalName = D_NewPtr(5 * sizeof(char));	sprintf			(crystalName,"name");	formulaText = D_NewPtr(8 * sizeof(char));	sprintf			(formulaText,"element");	year 			= 1800;	cODEN 		= D_NewPtr(5 * sizeof(char));	sprintf			(cODEN,"none");	author 		= D_NewPtr(7 * sizeof(char));	sprintf			(author,"nobody");	reference 	= D_NewPtr(9 * sizeof(char));	sprintf			(reference,"magazine");		GetSvals();	CellVolume();	ChemicalFormula(); 	theFaces		= (CrystalFaceHnd)D_NewHandle((long)(face_Count + 1) * sizeof(CrystalFace)); 					if(!HandleIsOK((Handle)theFaces)){						face_Count = -1;						return false;					}	theEdges 		= 	(CrystalEdgeHnd)D_NewHandle(verticesAndEdges * sizeof(CrystalEdge));					if(!HandleIsOK((Handle)theEdges)){						face_Count = -1;						return false;					}						theVertices 	= (CrystalVerticeHnd)D_NewHandle(verticesAndEdges * sizeof(CrystalVertice));					if(!HandleIsOK((Handle)theVertices)){						face_Count = -1;						return false;					}	D_HLock((Handle)theFaces);	theFace = theFacesPtr = *theFaces;	for(i = 0;i <= face_Count; i++,theFace++){		theFace->h = 	theFace->k = 	theFace->l = 	0;		theFace->area = 2;		theFace->theCrystal = (Handle)this;		theFace->direction = false;		theFace->x = 0;		theFace->y = 0;		theFace->z = 0;		theFace->length = 1.0;		theFace->flags = 0;	}	theFacesPtr[0].h =  1;	theFacesPtr[1].h = -1;	theFacesPtr[2].k =  1;	theFacesPtr[3].k = -1;	theFacesPtr[4].l =  1;	theFacesPtr[5].l = -1;	D_HUnlock((Handle)theFaces);	{//		SpotInfoCrysHandle theReshandle;//		SpotInfoCrysPtr dspaceees;//		short j; //		double p;		/*theReshandle = (SpotInfoCrysHandle)GetResource('info',200);		dspaceees = *theReshandle;		j = MAX_STORE_DSPACE;		p = GetHandleSize((Handle)theReshandle);		j = p /sizeof(SpotInfoCrys) ;		if(j == MAX_STORE_DSPACE){			for(i = 0;i < j;i++){				 dspacings[i] = dspaceees[i];				 dspacings[i].theCrystal = (Handle)this;			}			ReleaseResource((Handle)theReshandle);		}else{*/	//		short 		i;	//		Handle 		theResHnd;	//		short 		theResFile;	//		SpotInfoCrys **dspace;	//		SpotInfoCrysPtr dspaceees;						//SetDSpace();/* dec 1992 ***********/						/*theResHnd = GetResource('Atom',1);			theResFile = HomeResFile(theResHnd);			UseResFile(theResFile);			ReleaseResource(theResHnd);			sprintf(gTheText,"Standard d-spacings");			dspace  = (SpotInfoCrys**)D_NewHandle(sizeof(SpotInfoCrys) * MAX_STORE_DSPACE);			D_HLock((Handle)dspace);			dspaceees = *dspace;			for(i = 0;i < MAX_STORE_DSPACE;i++){				 dspaceees[i] = dspacings[i];				 dspaceees[i].theCrystal = (Handle)this;			}			D_HUnlock((Handle)dspace);			AddResource((Handle)dspace,'info',200,c2pstr(gTheText));						if(ResError() != noErr){				KillHandle((Handle*)&dspace);				return false;			}			WriteResource((Handle)dspace);						UpdateResFile(CurResFile());			FlushVol(0L,0);				KillHandle((Handle*)&dspace);*/		//}	}	#ifdef _DEMO_VERS_		SetCrystalData(this,num);	#endif	DetermineCrystalFaces();	DetermineVertices();	DetermineEdges();	SetDSpace();	return true;	}void	Crystal::DoClose(void)		/*  Close crystal method			*/{	short i;	for(i = 0 ; i <= lastUserDef ; i++){		if((long)theUserAtoms[i] != NUL){			theUserAtoms[i]->DoClose();		}	}		KillHandle((Handle*)&theAtoms);	KillPtr((Ptr)theWyckAtoms);	KillHandle((Handle*)&thermoParams);	KillHandle((Handle*)&physicalParams);	KillPtr((Ptr)formulaText);	KillPtr((Ptr)crystalName);	KillPtr((Ptr)cODEN);	KillPtr((Ptr)author);	KillPtr((Ptr)reference);			KillHandle((Handle*)&theFaces);	KillHandle((Handle*)&theEdges);	KillHandle((Handle*)&theVertices);		D_delete(this);	return;}PicHandle	Crystal::DisplayCrystal(Rect	*theRect,short horiz,short vert){	short 		length,h,v,i,width;	PicHandle	thePict;	Rect			frameRect;	double 		density;	char		theText[255];	Handle 		theHandle;	short 		theID;	ResType 	theType;	double		avgAtWt,avgZ;	RgnHandle	oldClp;	FontInfo 	theFont;	GetFontInfo(&theFont);	TextFont	(systemFont);	TextSize	(12);	PenNormal	();	sprintf		(gTheText,"Crystal Type:  Orthorhombic");	c2pstr		(gTheText);	width 	= 	StringWidth((unsigned char*)gTheText);	SetRect		(theRect,2,2,width + 30,225);	OffsetRect	(theRect,horiz,vert);		//InsetRect	(&frameRect,-2,-2);	frameRect = *theRect;	oldClp 		=	 D_NewRgn();	GetClip(oldClp);	ClipRect(theRect);	thePict 	= OpenPicture(theRect);	/************************************ Eric Added this section *****************/		{		Rect	colorBar;		colorBar = frameRect;		colorBar.top	+= 1;		colorBar.left	+= 1;		colorBar.right	= colorBar.left + 6;		colorBar.bottom	-= 1;		gCurrentObj->DMForeColor/*PMForeColor*/(10 + idNum);		dm_PaintRect(&colorBar);		gCurrentObj->DMForeColor(BLACK);	}/*****************************************************************************/	p2cstr(pTheText);	gCurrentObj->DMBackColor/*PMForeColor*/(WHITE);	gCurrentObj->DMForeColor/*PMForeColor*/(BLACK);	switch(lattice_Type){		case	CUBIC:			sprintf(&(gTheText[14])," Cubic");			if(spaceGrpNm) theHandle = GetResource('Cubc',spaceGrpNm);			break;		case	TETRAGONAL:			sprintf(&(gTheText[14])," Tetragonal");			if(spaceGrpNm) theHandle = GetResource('Tetr',spaceGrpNm);			break;		case	ORTHORHOMBIC:			sprintf(&(gTheText[14])," Orthorhombic");			if(spaceGrpNm) theHandle = GetResource('Orth',spaceGrpNm);			break;		case	TRIGONAL:			sprintf(&(gTheText[14])," Trigonal");			if(spaceGrpNm) theHandle = GetResource('Trig',spaceGrpNm);			break;		case	TRIGHEX:			sprintf(&(gTheText[14])," Rhombohedra");			if(spaceGrpNm) theHandle = GetResource('Trhx',spaceGrpNm);			break;		case	HEXAGONAL:			sprintf(&(gTheText[14])," Hexagonal");			if(spaceGrpNm) theHandle = GetResource('Hexa',spaceGrpNm);			break;		case	MONOCLINIC:			sprintf(&(gTheText[14])," Monoclinic");			if(spaceGrpNm) theHandle = GetResource('Mono',spaceGrpNm);			break;		case	TRICLINIC:			if(spaceGrpNm) theHandle = GetResource('Tric',spaceGrpNm);			sprintf(&(gTheText[14])," Triclinic");			break;		default:			sprintf(&(gTheText[14])," ????");			break;	}	c2pstr(gTheText);		length = StringWidth((unsigned char*)gTheText);	h = (theRect->left + theRect->right - length) / 2;	v = 25;	MoveTo(h,v + vert + 3);	Line(length,0);	MoveTo(h,v + vert);	DrawDiffractString((unsigned char*)gTheText);	v += 25;	density = CrystalDensity(&avgAtWt,&avgZ);	for(i = 1 ; i <= 9 ; i++){		switch(i){			case 1:				if(spaceGrpNm){					GetResInfo(theHandle,&theID,&theType,(unsigned char*)theText);					p2cstr((unsigned char*)theText);					sprintf(gTheText,"Space Group = ");					strcat(gTheText,theText);				}else{					sprintf(gTheText,"Space Group No = Not Given");				}				if(theHandle)ReleaseResource(theHandle);				break;			case 2:				sprintf(gTheText,"    a = %5.2f ",theUnitCell.a);				break;			case 3:				sprintf(gTheText,"    b = %5.2f ",theUnitCell.b);				break;			case 4:				sprintf(gTheText,"    c = %5.2f ",theUnitCell.c);				break;			case 5:				sprintf(gTheText,"alpha = %5.2f ¡",theUnitCell.alpha);				break;			case 6:				sprintf(gTheText,"beta  = %5.2f ¡",theUnitCell.beta);				break;			case 7:				sprintf(gTheText,"gamma = %5.2f ¡",theUnitCell.gamma);				break;			case 8:				sprintf(gTheText,"volume = %8.3f 3",volume);				break;			case 9:				sprintf(gTheText,"density calc. = %8.3f gm/cm3",density);				break;		}		c2pstr(gTheText);		length = StringWidth((unsigned char*)gTheText);		h = 200;		MoveTo(h + horiz - length,v + vert);		DrawDiffractString(pTheText);		v += 20;	}	PenSize(2,2);	PenNormal();	gCurrentObj->DMForeColor(BLACK);		FrameRect(&frameRect);		ClosePicture();	D_SetClip(oldClp);	D_DisposeRgn(&oldClp);	return(thePict);}			void	Crystal::CrystalDef(void){		Crystal *toBeDefinedCrystal;		toBeDefinedCrystal = (Crystal*)AllocCrystal(this->idNum);	if((Ptr)toBeDefinedCrystal == (Ptr)NUL)		return;	CopyCrystal(toBeDefinedCrystal);gCurrentObj->crystalDialogFlag = true;	if(toBeDefinedCrystal->DoDefine()){		if(!toBeDefinedCrystal->SameCrystal(this))			gCurrentObj->changedFlag = true;		toBeDefinedCrystal->CopyCrystal(this);	}	crystalColor = toBeDefinedCrystal->crystalColor;	toBeDefinedCrystal->DoClose();	#ifdef _DEMO_VERS_		SetCrystalData(this,idNum);	#endif	gCurrentObj->crystalDialogFlag = false;}			Boolean	Crystal::CopyCrystal(Crystal	*theCrystal){	short				i;	AtomPtr 			crysTheAtoms,theAtomsPtr;	CrystalFacePtr 		crystFaces,theFacesPtr;	CrystalVerticePtr 	crystVertices,theVerticesPtr;	CrystalEdgePtr 		crystEdges,theEdgesPtr;	float 				*oldValue,*theValue;	KeyMap		keyArray;	#ifdef _DEMO_VERS_		SetCrystalData(theCrystal,idNum);	#endif	if(theCrystal == this)		return false;		theCrystal->idNum 				= idNum;	theCrystal->lattice_Type 		= lattice_Type;	theCrystal->atom_Count 			= atom_Count;							/*  Num of entries used	- 1			*/	theCrystal->wy_Atom_Count 		= wy_Atom_Count;	theCrystal->face_Count 			= face_Count;	theCrystal->last_Vertice 		= last_Vertice;	theCrystal->last_Edge			= last_Edge;	theCrystal->spaceGrpNm 			= spaceGrpNm;	theCrystal->lastPhysicalParam 	= lastPhysicalParam;	theCrystal->lastThermoParam 	= lastThermoParam;		for(i = 0 ; i <= theCrystal->lastUserDef ; i++){		theCrystal->theUserAtoms[i]->DoClose();	}	theCrystal->lastUserDef 		= lastUserDef;		theCrystal->referenceInfoSet 	= referenceInfoSet;			for(i = 0 ; i <= lastUserDef ; i++){		theCrystal->theUserAtoms[i] = (UserDefAtom*)D_new(UserDefAtom);		theCrystal->theUserAtoms[i]->DoInit();	}						/*  Last user defined atom			*/	theCrystal->theUnitCell = theUnitCell;						/*  The unit cell specs				*/	for(i = 0; i<= 5;i++) theCrystal->sVals[i] = sVals[i];							/*  S values for calcs				*/		for(i = 0; i< MAX_STORE_DSPACE;i++){		 theCrystal->dspacings[i] = dspacings[i];			 theCrystal->dspacings[i].theCrystal = theCrystal;	}							/*  Unit cell volume				*/	theCrystal->crystalColor = crystalColor;						/*	Color for spot objects			*/		KillHandle((Handle*)&theCrystal->theAtoms);	if(atom_Count < 0){		atom_Count = 0;		theCrystal->theAtoms	= (AtomHnd)D_NewHandle((atom_Count + 1) * sizeof(Atom));	}else{								theCrystal->theAtoms	= (AtomHnd)D_NewHandle((atom_Count + 1) * sizeof(Atom));							if(MemError() != 0 || (Handle)theCrystal->theAtoms == (Handle)NUL){								StopAlert(OUT_OF_MEM,NUL);								{									GetKeys(keyArray);										if(keyArray[1] == 5){										SysBreak();									}								}								return false;							}	}							KillPtr((Ptr)theCrystal->theWyckAtoms);	theCrystal->theWyckAtoms = (WckoffPosition*)D_NewPtr((wy_Atom_Count + 1) * sizeof(WckoffPosition));							if(MemError() != 0 || (Ptr)theCrystal->theWyckAtoms == (Ptr)NUL){								StopAlert(OUT_OF_MEM,NUL);								{																	GetKeys(keyArray);										if(keyArray[1] == 5){										SysBreak();									}								}								return false;							}									if(lastThermoParam >= 0){		KillHandle((Handle*)&theCrystal->thermoParams);		theCrystal->thermoParams = (float**)D_NewHandle((lastThermoParam + 1) * sizeof(CrystalFace));		if(MemError() != 0 || (Ptr)theCrystal->thermoParams == (Ptr)NUL){			StopAlert(OUT_OF_MEM,NUL);								{																	GetKeys(keyArray);										if(keyArray[1] == 5){										SysBreak();									}								}			return false;		}		theValue = *(theCrystal->thermoParams);		oldValue = *thermoParams;		for(i = 0 ; i <= lastThermoParam ; i++){			theValue[i] = oldValue[i];		}	}else theCrystal->thermoParams = 0L;	if(lastPhysicalParam >= 0){		KillHandle((Handle*)&theCrystal->physicalParams);		theCrystal->physicalParams = (float**)D_NewHandle((lastPhysicalParam + 1) * sizeof(CrystalFace));		if(MemError() != 0 || (Ptr)theCrystal->physicalParams == (Ptr)NUL){			StopAlert(OUT_OF_MEM,NUL);			{							GetKeys(keyArray);				if(keyArray[1] == 5){					SysBreak();				}			}			return false;		}		theValue = *(theCrystal->physicalParams);		oldValue = *physicalParams;		for(i = 0 ; i <= lastPhysicalParam ; i++){			theValue[i] = oldValue[i];		}			}else theCrystal->physicalParams = 0L;	crysTheAtoms = *(theCrystal->theAtoms);	theAtomsPtr = *theAtoms;		for(i = 0 ; i <= atom_Count ; i++){		crysTheAtoms[i] = theAtomsPtr[i];	}	for(i = 0 ; i <= wy_Atom_Count ; i++){		theCrystal->theWyckAtoms[i] = theWyckAtoms[i];	}		for(i = 0 ; i <= lastUserDef ; i++){		if(!theUserAtoms[i]->CopyUDAtom(theCrystal->theUserAtoms[i]))			lastUserDef = i;	}	for(i = 0; i <= 19; i++){		theCrystal->elementList[i] = -1;	}	theCrystal->noDifrntElem = noDifrntElem;	for(i = 0 ; i <= noDifrntElem - 1 ; i++){		theCrystal->elementList[i] = elementList[i];	}		for(i = 0; i<= 20;i++)theCrystal->elasticConstants[i] = elasticConstants[i];		theCrystal->volume = volume;	theCrystal->volumeReduced = volumeReduced;	theCrystal->year = year;		VerifyObjects();	i = strlen(cODEN);	KillPtr((Ptr)theCrystal->cODEN);	theCrystal->cODEN = D_NewPtr((long)(i + 2) * sizeof(char));	strcpy(theCrystal->cODEN,cODEN);			i = strlen(author);	KillPtr((Ptr)theCrystal->author);	theCrystal->author = D_NewPtr((long)(i + 2) * sizeof(char));	strcpy(theCrystal->author,author);			i = strlen(reference);	KillPtr((Ptr)theCrystal->reference);	theCrystal->reference = D_NewPtr((long)(i + 2) * sizeof(char));	strcpy(theCrystal->reference,reference);			i = strlen(crystalName);	KillPtr((Ptr)theCrystal->crystalName);	theCrystal->crystalName = D_NewPtr((long)(i + 2) * sizeof(char));	strcpy(theCrystal->crystalName,crystalName);		i = strlen(formulaText);	KillPtr((Ptr)theCrystal->formulaText);	theCrystal->formulaText = D_NewPtr((long)(i + 2) * sizeof(char));	strcpy(theCrystal->formulaText,formulaText);								KillHandle((Handle*)&theCrystal->theFaces);	theCrystal->theFaces = (CrystalFaceHnd)D_NewHandle((face_Count + 1) * sizeof(CrystalFace));						if(MemError() != 0 || (Handle)theCrystal->theFaces == (Handle)NUL){							StopAlert(OUT_OF_MEM,NUL);							{															GetKeys(keyArray);								if(keyArray[1] == 5){									SysBreak();								}							}							return false;						}							KillHandle((Handle*)&theCrystal->theVertices);						if(last_Vertice < 0) last_Vertice = 0;	theCrystal->theVertices = (CrystalVerticeHnd)D_NewHandle((last_Vertice + 1) * sizeof(CrystalVertice));							if(MemError() != 0 || (Handle)theCrystal->theVertices == (Handle)NUL){								StopAlert(OUT_OF_MEM,NUL);								{																	GetKeys(keyArray);										if(keyArray[1] == 5){										SysBreak();									}								}								return false;							}							KillHandle((Handle*)&theCrystal->theEdges);						if(last_Edge < 0) last_Edge = 0;	theCrystal->theEdges = (CrystalEdgeHnd)D_NewHandle((last_Edge + 1) * sizeof(CrystalEdge));						if(MemError() != 0 || (Handle)theCrystal->theEdges == (Handle)NUL){							StopAlert(OUT_OF_MEM,NUL);							{															GetKeys(keyArray);								if(keyArray[1] == 5){									SysBreak();								}							}							return false;						}	D_HLock((Handle)theCrystal->theFaces);	D_HLock((Handle)theFaces);	crystFaces = *theCrystal->theFaces;	theFacesPtr = *theFaces;	for(i = 0 ; i <= face_Count ; i++){		crystFaces[i] = theFacesPtr[i];		crystFaces[i].theCrystal = (Handle)theCrystal;	}	D_HUnlock((Handle)theCrystal->theFaces);	D_HUnlock((Handle)theFaces);		D_HLock((Handle)theCrystal->theVertices);	D_HLock((Handle)theVertices);	crystVertices = *theCrystal->theVertices;	theVerticesPtr = *theVertices;	for(i = 0 ; i <= last_Vertice ; i++){		crystVertices[i] = theVerticesPtr[i];	}	D_HUnlock((Handle)theCrystal->theVertices);	D_HUnlock((Handle)theVertices);		D_HLock((Handle)theCrystal->theEdges);	D_HLock((Handle)theEdges);	crystEdges = *theCrystal->theEdges;	theEdgesPtr = *theEdges;	for(i = 0 ; i <= last_Edge ; i++){		crystEdges[i] = theEdgesPtr[i];	}	D_HUnlock((Handle)theCrystal->theEdges);	D_HUnlock((Handle)theEdges);	theCrystal->GetSvals();			return true;}Boolean	Crystal::DoDefine(void){	Boolean				quit=false,retValue=false,changed=false,keyTest=false;	DialogPtr			theDialog;	short					theSelect;	ML_CrysParamsPtr	theMLParms;		theDialog 		= 	DM_GetNewDialog(CRYSTAL_DEF_D,NUL,IN_FRONT);		ML_DoCrystalSetup((Ptr)this,theDialog,(Ptr*)&theMLParms);		while(!quit){		ModalDialog(TheFilterUPP/*MLogFilterUPP*/,&theSelect);		switch(theSelect){			case DLOG_GO_AWAY:			case C_DLOG_CANCEL:					retValue	= false;					quit 		= true;					ML_DoCrystalRead((Ptr)this,theDialog,(Ptr)theMLParms,retValue);//you must kill active handles and pointers				break;							case C_DLOG_OK:				quit 	= true;				retValue = true;				//ML_ReadCrystal(this,theDialog,theMLParms);//august 1996				#if defined(_newkey_) && !defined(_DEMOVERS_/*added _*/)					KEYTEST2(keyTest);				#endif				//if(theMLParms->changed)retValue = true;//august 1996				ML_DoCrystalRead((Ptr)this,theDialog,(Ptr)theMLParms,retValue);				if(!theMLParms->changed)retValue = false;				break;							case ML_UPDATE_EVT:				SetPort(theDialog);				BeginUpdate(theDialog);				UpdateDialog(theDialog,theDialog->visRgn);				ML_DoCrystalHit((Ptr)this,theDialog,ML_UPDATE_EVT,(Ptr)theMLParms);								if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;				default:				ML_DoCrystalHit((Ptr)this,theDialog,theSelect,(Ptr)theMLParms);				break;		}					}	DM_DisposDialog(&theDialog);	if(keyTest){		theUnitCell.a			= sqrt(7.0 + (double)(Random() % 8));		theUnitCell.b			= theUnitCell.a + sqrt(theUnitCell.a * .125);		theUnitCell.c			= theUnitCell.b - sqrt(theUnitCell.a * .125);		theUnitCell.alpha		= theUnitCell.a * 11.26 + (double)(Random() % 20) / 7.1;		theUnitCell.beta		= sqrt(681.0 + (double)(Random() % 19) * 1.165);		theUnitCell.gamma		= (200.0 / theUnitCell.a) + 6.0;	}	return(retValue);}Boolean Crystal::SameCrystal(Crystal* test){	short i;	AtomPtr theAtomOld,theAtomNew;	if(theUnitCell.a !=	test->theUnitCell.a)return false;	if(theUnitCell.b !=	test->theUnitCell.b)return false;	if(theUnitCell.c !=	test->theUnitCell.c)return false;	if(theUnitCell.alpha !=	test->theUnitCell.alpha)return false;	if(theUnitCell.beta !=	test->theUnitCell.beta)return false;	if(theUnitCell.gamma !=	test->theUnitCell.gamma)return false;	if(atom_Count != test->atom_Count) return false;	theAtomOld = *test->theAtoms;	theAtomNew = *theAtoms;	for(i = 0; i <= atom_Count; i++)	{		if(theAtomNew[i].atomicNum != theAtomOld[i].atomicNum)return false;		if(theAtomNew[i].x != theAtomOld[i].x)return false;		if(theAtomNew[i].y != theAtomOld[i].y)return false;		if(theAtomNew[i].z != theAtomOld[i].z)return false;	}	return true;}Boolean Crystal::ReconfigureElementList(void){	short i,j;	short		anAtomicNumber;	Boolean flag;		for(j = 0; j <= 19; j++){		elementList[j] = -1;	}	noDifrntElem = 0;	for(i = 0 ; i <= atom_Count ; i++){		flag = false;		if((*theAtoms)[i].atomicNum == 104){			StopAlert(ATOMS_NOT_DEFINED,0L);			i = atom_Count;			return false ;		}		anAtomicNumber = (*theAtoms)[i].atomicNum;		j = ReturnValance(&anAtomicNumber);		anAtomicNumber -= 1;		j = 0;		while(elementList[j] >= 0 && !flag && j <=  19){			if(anAtomicNumber == elementList[j++])flag = true;		}		if(flag == false && noDifrntElem < 20){			elementList[noDifrntElem++] = anAtomicNumber;		}				}	return true;}#define	THE_TEXT_BOX	3void	Crystal::SetNumAtoms(void){	DialogPtr 	theDialog;	Boolean		changed,quit;	short			count,theMax,i,type,theSelect;	Atom			*NewAtoms;	Rect			theRect;		changed	= quit = false;	theDialog = DM_GetNewDialog(DLOG_SET_NUM_ATOMS,NUL,IN_FRONT);	GetDialogItem(theDialog,THE_TEXT_BOX,&type,&gTheHandle,&theRect);	sprintf(gTheText,"%3d",atom_Count + 1);	c2pstr(gTheText);	SetIText(gTheHandle,pTheText);	SelIText(theDialog,THE_TEXT_BOX,0,3);		while(!quit){		ModalDialog(NUL,&theSelect);		switch(theSelect){			case DLOG_CANCEL:				if(!changed || CANCEL_YOUR_MODS){					quit 		= true;				}				break;			case DLOG_OK:				GetDItem(theDialog,THE_TEXT_BOX,&type,&gTheHandle,&theRect);				GetIText(gTheHandle,pTheText);				p2cstr(pTheText);				count = atoi(gTheText) - 1;				if(count < 0)					count = 0;				if(atom_Count != count){					if(atom_Count > count){						theMax = count;					} else {						theMax = atom_Count;					}											NewAtoms = (Atom*)D_NewPtr((long)(count + 1) * sizeof(Atom));					if(MemError() == 0 && NewAtoms != (Atom*)NUL){						for(i = 0 ; i <= theMax ; i++){							NewAtoms[i] = (*theAtoms)[i];						}						if(count > atom_Count){							for(i = atom_Count ; i <= count ; i++){								NewAtoms[i] = (*theAtoms)[atom_Count];							}						}												atom_Count = count;						KillHandle((Handle*)&theAtoms);						theAtoms = (AtomHnd)D_NewHandle((long)(atom_Count + 1) * sizeof(Atom));						if(!MemError()){							for(i = 0 ; i <= atom_Count ; i++){								(*theAtoms)[i] = NewAtoms[i];							}							KillPtr((Ptr)NewAtoms);						}else{							i = StopAlert(OUT_OF_MEM,NUL);							{								KeyMap		keyArray;															GetKeys(keyArray);								if(keyArray[1] == 5){									SysBreak();								}							}						}						quit	= true;					} else {						i = StopAlert(OUT_OF_MEM,NUL);						{							KeyMap		keyArray;													GetKeys(keyArray);							if(keyArray[1] == 5){								SysBreak();							}						}					}				} else {					quit	= true;				}									break;			case THE_TEXT_BOX:				changed = true;				break;			default:				break;			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;		}	}	DM_DisposDialog(&theDialog);}	Boolean		Crystal::GetAtomicSymbol(short	theAtomNum,char	*theText){	short theAtomicNum;	short i,j,k;	char *el0,*el1,*el2,*el3,*el4;		theAtomicNum = theAtomNum;			el0 = "H HeLiBeB C N O F NeNaMgAlSiP S ClArK CaScTiV CrMnFe";	el1 = "CoNiCuZnGaGeAsSeBrKrRbSrY ZrNbMoTcRuRhPdAgCdInSnSbTe";	el2 = "I XeCsBaLaCePrNdPmSmEuGdTbDyHoErTmYbLuHfTaW ReOsIrPt";	el3 = "AuHgTlPbBiPoAtRnFrRaAcThPaU NpPuAmCmBkCfEsFmMdNoLr??";	el4 = "QAQBQCQDQEQFQGQHQIQJQKQLQMQNQOQPQQQRQSQTQUQVQWQXQYQZ";	k = ReturnValance(&theAtomicNum);	i = (theAtomicNum - 1) / 26;	j = 2 * ((theAtomicNum - 1) % 26);	switch(i){		case 0:			theText[0] = el0[j++];			theText[1] = el0[j];			theText[2] = (char)0;			goto FINISH;			break;		case 1:			theText[0] = el1[j++];			theText[1] = el1[j];			theText[2] = (char)0;			goto FINISH;			break;		case 2:			theText[0] = el2[j++];			theText[1] = el2[j];			theText[2] = (char)0;			goto FINISH;			break;		case 3:			theText[0] = el3[j++];			theText[1] = el3[j];			theText[2] = (char)0;			/* if(j == 51)				return(false); */							goto FINISH;			break;		case 4:			theText[0] = el4[j++];			theText[1] = el4[j];			theText[2] = (char)0;			return(true);		default:				/*  !!! No Break !!!  */			theText[0] = '?';			theText[1] = '?';			theText[2] = (char)0;			return(false);			break;	}FINISH:	if(k == 0) return true;	if(k > 0){ 	  sprintf(&theText[2],"+%d",k);	}else		sprintf(&theText[2],"%d",k);	return true;}short Crystal::ReturnValance(short *atomicNum){	short radType;	radType = 0;	if(*atomicNum >= 105 && *atomicNum <= 199){ 		return 0;	}	if(*atomicNum > 200 || *atomicNum < 0){		radType = *atomicNum / 100;		*atomicNum -= radType * 100;		if(radType > 0) radType--;		if(radType < 0) *atomicNum *= -1;	}	return radType;}short	Crystal::TheAtomicNum(char	*theText){	short i,sign,theValue,length,number;	char *el1,*el2,*el3,*el4,*el5;		el1 = "H HELIBEB C N O F NENAMGALSIP S CLARK CASCTIV CRMNFE";	el2 = "CONICUZNGAGEASSEBRKRRBSRY ZRNBMOTCRURHPDAGCDINSNSBTE";	el3 = "I XECSBALACEPRNDPMSMEUGDTBDYHOERTMYBLUHFTAW REOSIRPT";	el4 = "AUHGTLPBBIPOATRNFRRAACTHPAU NPPUAMCMBKCFESFMMDNOLR??";	el5 = "QAQBQCQDQEQFQGQHQIQJQKQLQMQNQOQPQQQRQSQTQUQVQWQXQYQZ";	sign = 1;	theValue = 0;	length = strlen(theText);	i = 0;	while(theValue == 0 && i <= length) theValue = atof(&theText[i++]);	if(theValue > 0){		theValue++;	}	if(theValue < 0)		sign = -1;	for ( i = 0 ; i <= 1 ; i++){		if(theText[i] >= 'a' && theText[i] <= 'z')			theText[i] -= (char)32;	 	if(theText[i] < 'A' || theText[i] > 'z')			theText[i] = ' ';	}		for(i = 0 ; i <= 50 ; i += 2){		if(el1[i] == theText[0] && el1[i + 1] == theText[1] ){			number = sign * (1 + i / 2) + 100 * theValue;			goto ENDIT;		}		if(el2[i] == theText[0] && el2[i + 1] == theText[1] ){			number = sign * (27 + i / 2) + 100 * theValue;			goto ENDIT;		}		if(el3[i] == theText[0] && el3[i + 1] == theText[1] ){			number = sign * (53 + i / 2) + 100 * theValue;			goto ENDIT;		}		if(el4[i] == theText[0] && el4[i + 1] == theText[1] ){			number = sign * (79 + i / 2) + 100 * theValue;			goto ENDIT;		}		if(el5[i] == theText[0] && el5[i + 1] == theText[1] ){			i /= 2;			if(i <= lastUserDef)				return (105 + i);			return(104);		}	}	return (104); ENDIT:	 /* theResHandle = GetResource('Atom',number);		if(theResHandle == 0L)return 104;			ReleaseResource((Handle)theResHandle); */	return number;}void		Crystal::DoUserDefAtom(short *atomicNumPtr){	UserDefAtom* theNewOne;		if(*atomicNumPtr >= 105 && *atomicNumPtr < 200){		theNewOne = (UserDefAtom*)D_new(UserDefAtom);		if(!HandleIsOK((Handle)theNewOne)){			return;		}		theNewOne->DoInit();		theUserAtoms[*atomicNumPtr - 105]->CopyUDAtom(theNewOne);		if(theNewOne->DoDefine()){			theUserAtoms[*atomicNumPtr - 105]->DoClose();			theUserAtoms[*atomicNumPtr - 105] = (UserDefAtom*)D_new(UserDefAtom);			theUserAtoms[*atomicNumPtr - 105]->DoInit();			theNewOne->CopyUDAtom(theUserAtoms[*atomicNumPtr - 105]);			theNewOne->DoClose();		}else{			theNewOne->DoClose();		}	} else {		if(NoteAlert(NEW_USER_DEF,NUL) != 1){			return;		}		if(lastUserDef >= 25){			StopAlert(TOO_MANY_USER_DEF,NUL);						return;		}		theNewOne = (UserDefAtom*)D_new(UserDefAtom);		if(!HandleIsOK((Handle)theNewOne)){			return;		}		theNewOne->DoInit();		if(theNewOne->DoDefine()){			theUserAtoms[++lastUserDef] = (UserDefAtom*)D_new(UserDefAtom);			if(!HandleIsOK((Handle)theUserAtoms[lastUserDef])){				theNewOne->DoClose();				return;			}			theUserAtoms[lastUserDef]->DoInit();			theNewOne->CopyUDAtom(theUserAtoms[lastUserDef]);			*atomicNumPtr = lastUserDef + 105;			theNewOne->DoClose();		} else {			theNewOne->DoClose();		}	}	return;}void		Crystal::PackUDAtoms(void){	Boolean flags[26];	short i,j,count,nums[26];		count = 0;		if(lastUserDef < 0)		return;			for(i = 0 ; i <= lastUserDef ; i++){				/* 	Clear Flags					*/		flags[i] = false;		count++;	}		for(i = 0 ; i <= atom_Count ; i++){					/*	Set flags for "found" atoms	*/		if((*theAtoms)[i].atomicNum > 104 && (*theAtoms)[i].atomicNum < 140)			flags[(*theAtoms)[i].atomicNum - 105] = true;	}		for(i = 0 , j = 0 ; i <= lastUserDef ; i++){		/* Calc new Atomic numbers		*/		if(flags[i]){			nums[i] = 105 + j++;		}	}					for(i = 0 ; i <= lastUserDef ; i++){				/*  Dispose unused 				*/		if(!flags[i]){									/*  Flag is clear so...			*/			theUserAtoms[i]->DoClose();					/*  Kill theUD atom				*/			theUserAtoms[i] = (UserDefAtom*)NUL;		}	}		for(i = 0 ; i <= atom_Count ; i++){					/*	Adjust atomic numbers		*/		if((*theAtoms)[i].atomicNum > 104 && (*theAtoms)[i].atomicNum < 140)			(*theAtoms)[i].atomicNum = nums[(*theAtoms)[i].atomicNum - 105];	}		for(i = 0 ; i <= lastUserDef ; i++){		if(theUserAtoms[i] == (UserDefAtom*)NUL){			for(j = i + 1 ; j <= lastUserDef ; j++){				theUserAtoms[j - 1] = theUserAtoms[j];			}			i--;			lastUserDef--;		}	}		}#define CRYS_SAVE_AS 124#define CRYST_OBJ_2   2void		Crystal::FileSaveCrystal(short fileType)		/*	Save the crystal to the file	*/{	gCurrentObj->currentCrystal = this;	switch(fileType){		case 1:			gTheFile->SaveFileOpen(CRYST_OBJ);			if(!gTheFile->file_is_Open)				return; 			FileWriteCrystal();			gTheFile->DoFileClose();			break;		case 2:			gTheFile->SaveFileOpen(CRYST_OBJ_2);			if(!gTheFile->file_is_Open)				return; 			FileWriteOldDesktop();			gTheFile->DoFileClose();			break;		case 3:			gTheFile->SaveFileOpen(CRYST_OBJ_OLD);			if(!gTheFile->file_is_Open)				return; 			SaveAsOldFormat();			gTheFile->DoFileClose();			break;		case 4:			gTheFile->SaveFileOpen('TEXT');			if(!gTheFile->file_is_Open)				return; 			SaveAsText();			gTheFile->DoFileClose();			break;	}}void		Crystal::FileOpenCrystal(void)		/*  Open the Crystal File			*/{		gCurrentObj->currentCrystal = this;		gTheFile->ReadFileOpen(CRYST_OBJ);		if(!gTheFile->file_is_Open)				return;		FileReadCrystal();		gTheFile->DoFileClose();}typedef struct	AtomsDM1{	short	atomicNum;	short	wyckOffNum;	float	x;	float	y;	float	z;} AtomsDM1;typedef	struct	SpotInfoCrysDM1{	Handle			theCrystal;	/* 4 */	short			h;				/* 2 */	short			k;				/* 2 */	short			l;				/* 2 */	Boolean			direction;		/* 2 */	float			x;				/* 4 */	float			y;				/* 4 */	float			z;				/* 4 */	float			intensity;		/* 4 */	float			angle;		/* 4 */	Rect			spotRect;		/* 8 */	long			flags;			/* 4 */}SpotInfoCrysDM1;void		Crystal::FileReadCrystal()		/*  Read crystal from the file		*/{	short						i,j;	short 					theNumber;	short						version;	short						oldTotWy;	CrystalFacePtr 	theFacesPtr;	AtomsDM1 			**oldAtoms;	WyckoffOld 			*oldWyck = 0L;	WyckoffOld			*tempWckoffPtr;	char					*theSrcPtr,*theDestPtr;		if(gTheFile->theFileInfo.sfType == CRYST_OBJ_OLD ||			gTheFile->theFileInfo.sfType == CRYST_OBJ_OLDEST){				OpenOldFormat();							return;		}	if(gTheFile->theFileInfo.sfType == 'TEXT')		return;	version			= gTheFile->ReadShort();	if(version >= CRYSTAL_VERSION)			lattice_Type	= gTheFile->ReadShort();	else		lattice_Type = version;			spaceGrpNm		= gTheFile->ReadShort();	oldTotWy = atom_Count;	atom_Count		= gTheFile->ReadShort();	wy_Atom_Count	= gTheFile->ReadShort();	face_Count		= gTheFile->ReadShort();	noDifrntElem	= gTheFile->ReadShort();	for(i = 0 ; i <= lastUserDef ; i++){		theUserAtoms[i]->DoClose();	}	lastUserDef		= gTheFile->ReadShort();	lastPhysicalParam = gTheFile->ReadShort();	lastThermoParam = gTheFile->ReadShort();	last_Edge 		= gTheFile->ReadShort();	last_Vertice 	= gTheFile->ReadShort();	fileNo 			= gTheFile->ReadShort();	cardNo 			= gTheFile->ReadShort();		year 			= gTheFile->ReadShort();	volumeReduced 	= gTheFile->ReadFloat();	referenceInfoSet 	= gTheFile->ReadBoolean();					for(i = 0 ; i <= lastUserDef ; i++){				theUserAtoms[i] = (UserDefAtom*)D_new(UserDefAtom);		theUserAtoms[i]->DoInit();		theUserAtoms[i]->FileReadUserDef();	}		gTheFile->ReadDataBlock((Ptr)&theUnitCell,sizeof(UnitCell));	gTheFile->ReadDataBlock((Ptr)&theReducedCell,sizeof(UnitCell));	if(version < CRYSTAL_VERSION){ 			oldWyck = (WyckoffOld*)gTheFile->ReadPtr((Ptr)oldWyck);				//  Structure alignment fix *************		if(oldWyck->wckVersion != -1957){			tempWckoffPtr	= oldWyck;			oldWyck				= (WyckoffOld*)D_NewPtr((long)(wy_Atom_Count + 1) * sizeof(WyckoffOld));			theSrcPtr			= (char*)tempWckoffPtr;			for(i = 0 ; i <= wy_Atom_Count ; i++){				theDestPtr	= (char*)(&oldWyck[i]);								for(j = 1 ; j <= 22 ; j++)*theDestPtr++	= *theSrcPtr++;									oldWyck[i].wckVersion	= -1957;			}			KillPtr(tempWckoffPtr);		}		if(theWyckAtoms)KillPtr((Ptr)theWyckAtoms);		theWyckAtoms	= (WckoffPosition*)D_NewPtr((long)(wy_Atom_Count + 1) * sizeof(WckoffPosition));		for(i= 0; i <= wy_Atom_Count;i++)		{			short k;			for(k = 0; k < 4;k++)theWyckAtoms[i].wckoffPosName[k] = oldWyck[i].wckoffPosName[k];			theWyckAtoms[i].wckoffPosName[5] = 0;			theWyckAtoms[i].x = oldWyck[i].x;			theWyckAtoms[i].y = oldWyck[i].y;			theWyckAtoms[i].z = oldWyck[i].z;			theWyckAtoms[i].atomicNum = oldWyck[i].atomicNum;			theWyckAtoms[i].wckoffPosNo = oldWyck[i].wckoffPosNo;			theWyckAtoms[i].bi = 0;		}				//wy_Atom_Count = oldTotWy;		KillPtr(oldWyck);	}else{		theWyckAtoms = (WckoffPosition*)gTheFile->ReadPtr((Ptr)theWyckAtoms);	}		formulaText = (char*)gTheFile->ReadPtr((Ptr)formulaText);	crystalName = (char*)gTheFile->ReadPtr((Ptr)crystalName);	cODEN 		= (char*)gTheFile->ReadPtr((Ptr)cODEN);	author 		= (char*)gTheFile->ReadPtr((Ptr)author);	reference 	= (char*)gTheFile->ReadPtr((Ptr)reference);	{		long		value;		value = sizeof(AtomsDM1);	}	if(version < 200){		Atom		*aAtom;		AtomsDM1	*oldAtom;				oldAtoms = (AtomsDM1**)D_NewHandle(sizeof(AtomsDM1) * 2);		gTheFile->ReadHandle((Handle)oldAtoms);				if(theAtoms != 0L)KillHandle((Handle*)&theAtoms);		theAtoms	=	(Atom**)D_NewHandle(sizeof(Atom) * (atom_Count + 1));		D_HLock((Handle)theAtoms);		D_HLock((Handle)oldAtoms);		aAtom		=	*theAtoms;		oldAtom		=	*oldAtoms;		for(i= 0; i <= atom_Count;i++)		{			aAtom[i].x = oldAtom[i].x;			aAtom[i].y = oldAtom[i].y;			aAtom[i].z = oldAtom[i].z;			aAtom[i].atomicNum = oldAtom[i].atomicNum;			aAtom[i].wyckOffNum = oldAtom[i].wyckOffNum;			aAtom[i].bi = 0;		}		D_HUnlock((Handle)theAtoms);		D_HUnlock((Handle)oldAtoms);		KillHandle((Handle*)&oldAtoms);	}else{		gTheFile->ReadHandle((Handle)theAtoms);	}		gTheFile->ReadHandle((Handle)theFaces);	D_HLock((Handle)theFaces);	theFacesPtr = *theFaces;		for(i = 0; i <= face_Count;i++,theFacesPtr++)theFacesPtr->theCrystal = (Handle)this;	D_HUnlock((Handle)theFaces);	gTheFile->ReadHandle((Handle)theEdges);	gTheFile->ReadHandle((Handle)theVertices);		if(lastPhysicalParam >= 0) gTheFile->ReadHandle((Handle)physicalParams);	if(lastThermoParam >= 0) gTheFile->ReadHandle((Handle)thermoParams);		gTheFile->ReadDataBlock((Ptr)elementList,(sizeof(short) * 20));		theNumber 			= gTheFile->ReadShort();	if(version < 200){		SpotInfoCrysDM1 dspac[MAX_STORE_DSPACE];		gTheFile->ReadDataBlock((Ptr)dspac,sizeof(SpotInfoCrysDM1) * theNumber);			}else{		gTheFile->ReadDataBlock((Ptr)dspacings,sizeof(SpotInfo/*SpotInfoCrys*/) * theNumber);	}		for(i = 0; i < theNumber;i++) dspacings[i].theCrystal = this;	if(theNumber < MAX_STORE_DSPACE)	for(i = theNumber; i < MAX_STORE_DSPACE;i++) dspacings[i] =  dspacings[theNumber - 1];	gTheFile->ReadDataBlock((Ptr)&crystalColor,sizeof(RGBColor));	gTheFile->ReadDataBlock((Ptr)elasticConstants,sizeof(float) * 21);	#ifdef _DEMO_VERS_	SetCrystalData(this,idNum);	return;	#endif		JustifyAtomPos();	GetSvals();	CellVolume();//	SetDSpace();}void		Crystal::FileWriteCrystal()		/*  Read crystal from the file		*/{	short	i;	#ifdef _DEMO_VERS_	SetCrystalData(this,idNum);	#endif	SetDSpace();	gTheFile->WriteShort(CRYSTAL_VERSION);	gTheFile->WriteShort(lattice_Type);	gTheFile->WriteShort(spaceGrpNm);	gTheFile->WriteShort(atom_Count);	gTheFile->WriteShort(wy_Atom_Count);	gTheFile->WriteShort(face_Count);	gTheFile->WriteShort(noDifrntElem);	gTheFile->WriteShort(lastUserDef);	gTheFile->WriteShort(lastPhysicalParam);	gTheFile->WriteShort(lastThermoParam);		gTheFile->WriteShort(last_Edge);	gTheFile->WriteShort(last_Vertice);	gTheFile->WriteShort(fileNo);	gTheFile->WriteShort(cardNo);	gTheFile->WriteShort(year);	gTheFile->WriteFloat(volumeReduced);	gTheFile->WriteBoolean(referenceInfoSet);		for(i = 0 ; i <= lastUserDef ; i++){				theUserAtoms[i]->FileWriteUserDef();	}		gTheFile->WriteDataBlock((Ptr)&theUnitCell,sizeof(UnitCell));		gTheFile->WriteDataBlock((Ptr)&theReducedCell,sizeof(UnitCell));		gTheFile->WritePtr((Ptr)theWyckAtoms);	gTheFile->WritePtr((Ptr)formulaText);	gTheFile->WritePtr((Ptr)crystalName);	gTheFile->WritePtr((Ptr)cODEN);	gTheFile->WritePtr((Ptr)author);	gTheFile->WritePtr((Ptr)reference);		gTheFile->WriteHandle((Handle)theAtoms);	gTheFile->WriteHandle((Handle)theFaces);	gTheFile->WriteHandle((Handle)theEdges);	gTheFile->WriteHandle((Handle)theVertices);	if(lastPhysicalParam >= 0) gTheFile->WriteHandle((Handle)physicalParams);	if(lastThermoParam >= 0) gTheFile->WriteHandle((Handle)thermoParams);		gTheFile->WriteDataBlock((Ptr)elementList,(sizeof(short) * 20));		gTheFile->WriteShort(MAX_STORE_DSPACE);	gTheFile->WriteDataBlock((Ptr)dspacings,(sizeof(SpotInfo/*SpotInfoCrys*/) * MAX_STORE_DSPACE));		gTheFile->WriteDataBlock((Ptr)&crystalColor,sizeof(RGBColor));	gTheFile->WriteDataBlock((Ptr)elasticConstants,(sizeof(float) * 21));	}void		Crystal::FileWriteOldDesktop(void)		/*  Write  crystal to  old file style		*/{	short	i;	WyckoffOld *oldWyck;		#ifdef _DEMO_VERS_	SetCrystalData(this,idNum);	#endif	gTheFile->WriteShort(lattice_Type);	gTheFile->WriteShort(spaceGrpNm);	gTheFile->WriteShort(atom_Count);	gTheFile->WriteShort(wy_Atom_Count);	gTheFile->WriteShort(face_Count);	gTheFile->WriteShort(noDifrntElem);	gTheFile->WriteShort(lastUserDef);	gTheFile->WriteShort(lastPhysicalParam);	gTheFile->WriteShort(lastThermoParam);		gTheFile->WriteShort(last_Edge);	gTheFile->WriteShort(last_Vertice);	gTheFile->WriteShort(fileNo);	gTheFile->WriteShort(cardNo);	gTheFile->WriteShort(year);	gTheFile->WriteFloat(volumeReduced);	gTheFile->WriteBoolean(referenceInfoSet);		for(i = 0 ; i <= lastUserDef ; i++){				theUserAtoms[i]->FileWriteUserDef();	}		gTheFile->WriteDataBlock((Ptr)&theUnitCell,sizeof(UnitCell));		gTheFile->WriteDataBlock((Ptr)&theReducedCell,sizeof(UnitCell));	oldWyck	= (WyckoffOld*)D_NewPtr((long)(wy_Atom_Count + 1) * sizeof(WyckoffOld));	for(i= 0; i <= wy_Atom_Count;i++)	{		short k;		for(k = 0; k < 4;k++)oldWyck[i].wckoffPosName[k] = theWyckAtoms[i].wckoffPosName[k];		oldWyck[i].wckoffPosName[5] = 0;		oldWyck[i].wckoffPosName[4] = 0;		oldWyck[i].x = theWyckAtoms[i].x;		oldWyck[i].y = theWyckAtoms[i].y;		oldWyck[i].z = theWyckAtoms[i].z;		oldWyck[i].atomicNum = theWyckAtoms[i].atomicNum;		oldWyck[i].wckoffPosNo = theWyckAtoms[i].wckoffPosNo;		oldWyck[i].wckVersion	= -1957;	}			gTheFile->WritePtr((Ptr)oldWyck);	KillPtr(oldWyck);		gTheFile->WritePtr((Ptr)formulaText);	gTheFile->WritePtr((Ptr)crystalName);	gTheFile->WritePtr((Ptr)cODEN);	gTheFile->WritePtr((Ptr)author);	gTheFile->WritePtr((Ptr)reference);	{		Atom		*aAtom;		AtomsDM1	*oldAtom,**oldAtoms;				oldAtoms = (AtomsDM1**)D_NewHandle(sizeof(AtomsDM1) * (atom_Count + 1));		D_HLock((Handle)theAtoms);		D_HLock((Handle)oldAtoms);		aAtom		=	*theAtoms;				oldAtom		=	*oldAtoms;		for(i= 0; i <= atom_Count;i++)		{			oldAtom[i].x = aAtom[i].x;			oldAtom[i].y = aAtom[i].y;			oldAtom[i].z = aAtom[i].z;			oldAtom[i].atomicNum = aAtom[i].atomicNum;			oldAtom[i].wyckOffNum = aAtom[i].wyckOffNum;					}		D_HUnlock((Handle)theAtoms);		D_HUnlock((Handle)oldAtoms);		gTheFile->WriteHandle((Handle)oldAtoms);				KillHandle((Handle*)&oldAtoms);	}		gTheFile->WriteHandle((Handle)theFaces);	gTheFile->WriteHandle((Handle)theEdges);	gTheFile->WriteHandle((Handle)theVertices);	if(lastPhysicalParam >= 0) gTheFile->WriteHandle((Handle)physicalParams);	if(lastThermoParam >= 0) gTheFile->WriteHandle((Handle)thermoParams);		gTheFile->WriteDataBlock((Ptr)elementList,(sizeof(short) * 20));		gTheFile->WriteShort(MAX_STORE_DSPACE);	gTheFile->WriteDataBlock((Ptr)dspacings,(sizeof(SpotInfo/*SpotInfoCrys*/) * MAX_STORE_DSPACE));		gTheFile->WriteDataBlock((Ptr)&crystalColor,sizeof(RGBColor));	gTheFile->WriteDataBlock((Ptr)elasticConstants,(sizeof(float) * 21));	}void		Crystal::GetSvals(void){	double alpha,beta,gamma;		alpha 		= theUnitCell.alpha * PI / 180.0;	beta		= theUnitCell.beta * PI / 180.0;	gamma		= theUnitCell.gamma * PI / 180.0;		sVals[0] 	= theUnitCell.b * theUnitCell.b					* theUnitCell.c * theUnitCell.c					* sin(alpha) * sin(alpha);						sVals[1] 	= theUnitCell.a * theUnitCell.a					* theUnitCell.c * theUnitCell.c					* sin(beta) * sin(beta);						sVals[2] 	= theUnitCell.a * theUnitCell.a					* theUnitCell.b * theUnitCell.b					* sin(gamma) * sin(gamma);						sVals[3] 	= theUnitCell.a * theUnitCell.b					* theUnitCell.c * theUnitCell.c					* (cos(alpha) * cos(beta) - cos(gamma));				sVals[4] 	= theUnitCell.b * theUnitCell.c					* theUnitCell.a * theUnitCell.a					* (cos(beta) * cos(gamma) - cos(alpha));						sVals[5] 	= theUnitCell.c * theUnitCell.a					* theUnitCell.b * theUnitCell.b					* (cos(gamma) * cos(alpha) - cos(beta));					}double		Crystal::DSpacing(short h,short k,short l){	double D,H,K,L;	if(volume < .5 || h == 0 && k == 0 && l == 0) return 0;	H = (double)h;	K = (double)k;	L = (double)l;		D = volume /			sqrt(				H * (sVals[0] * H + 2. * sVals[3] * K) +				K * (sVals[1] * K + 2. * sVals[4] * L) +				L * (sVals[2] * L + 2. * sVals[5] * H ));	return(D);}double		Crystal::DSpacingDouble(float h,float k,float l){	double D,H,K,L;	if(volume < .5 || h == 0 && k == 0 && l == 0) return 0;	H = (double)h;	K = (double)k;	L = (double)l;	D = volume /			sqrt(				H * (sVals[0] * H + 2. * sVals[3] * K) +				K * (sVals[1] * K + 2. * sVals[4] * L) +				L * (sVals[2] * L + 2. * sVals[5] * H ));	return(D);}void		Crystal::CellVolume(){	double cosA,cosB,cosC;	char **theReducedQ,*reduction;	double theValue;	cosA 	= cos(theUnitCell.alpha * PI / 180.);	cosB	= cos(theUnitCell.beta * PI / 180.);	cosC 	= cos(theUnitCell.gamma * PI / 180.);	volume	= 	theUnitCell.a * theUnitCell.b * theUnitCell.c *				sqrt(	1.0 - cosA * cosA - 						cosB * cosB - cosC * cosC + 						2.0 * cosA * cosB * cosC);	theValue = 1;	if(spaceGrpNm <= 230){		theReducedQ = (char**)GetResource('info',300);		reduction = *theReducedQ;		theValue = (double)reduction[spaceGrpNm];		ReleaseResource((Handle)theReducedQ);	}else{		theValue = 3.;	}	volumeReduced = volume / theValue;		return;}void 	Crystal::Get001XForm(double xForm[][3]){ /*Unfortunately, This Function Returns a column Matrix, not a Row Matrix*/	double scale,angleA,angleB,angleC,cosGammaPrime,sinGammaPrime;	scale = PI / 180.0;	angleA = (double)theUnitCell.alpha * scale;	angleB = (double)theUnitCell.beta	* scale;	angleC = (double)theUnitCell.gamma * scale;	cosGammaPrime = (cos(angleA) * cos(angleB) - cos(angleC))/ (sin(angleA) * sin(angleB));	if(fabs(cosGammaPrime) < 1e-12)cosGammaPrime = 0;	sinGammaPrime = sqrt(1 - (cosGammaPrime * cosGammaPrime));	xForm[0][0] = (double)theUnitCell.a * sin(angleB) * sinGammaPrime;	xForm[1][0] = -(double)theUnitCell.a * sin(angleB) * cosGammaPrime;	xForm[2][0] = (double)theUnitCell.a * cos(angleB);		xForm[0][1] = 0.0;	xForm[1][1] = (double)theUnitCell.b * sin(angleA);	xForm[2][1] = (double)theUnitCell.b * cos(angleA);		xForm[0][2] = 0.0;	xForm[1][2] = 0.0;	xForm[2][2] = (double)theUnitCell.c;	}void    Crystal::SetDSpace(void){	short i,theSize,h,k,l,j;	SpotInfoPtr/*SpotInfoCrys*/ dspace;	SpotInfoHandle	theDataBlock;		theSize = 4;/*dec 9 1992*/	switch(lattice_Type){		case CUBIC:		case TRIGHEX:			theSize = 5;/*dec 9 1992*/			break;	}	h = theSize;	k = theSize; 	l = theSize;	theDataBlock = (SpotInfoHandle)SubCalcDSpacings((Crystal*)this,h,k,l,1,.01);	if(gCount < 0)gCount = 0;	if(gCount < MAX_STORE_DSPACE){			j = gCount;		for(i = gCount;i < MAX_STORE_DSPACE;i++){			dspacings[i].x = -1;			dspacings[i].y = -1;			dspacings[i].theCrystal = this;		}	}else		j = MAX_STORE_DSPACE;			/*MFTemp*/D_HLock(theDataBlock);		dspace = *theDataBlock;	for(i = 0;i < j;i++,dspace++){		dspacings[i] = *dspace;	}		/*MFTemp*/D_HUnlock(theDataBlock);	/*Temp*/KillHandle((Handle*)&theDataBlock);	return;		}void	Crystal::PlaneToDir(double *H,double *K,double *L){	double	u,v,w;	u = sVals[0] * (*H) + sVals[3] * (*K) + sVals[5] * (*L);	v = sVals[3] * (*H) + sVals[1] * (*K) + sVals[4] * (*L); 	w = sVals[5] * (*H) + sVals[4] * (*K) + sVals[2] * (*L);	*H = u;	*K = v;	*L = w;	return;}void	Crystal::SetColor(void){	gCurrentObj->DMForeColor/*PMForeColor*/(10 + idNum);}Boolean Crystal::RhomboToTrig(void){	short i=0,j=0,k=0;	AtomPtr theAtomsPtr;	AtomPtr NewAtoms;	if(!(lattice_Type == TRIGONAL || lattice_Type == TRIGHEX))		return false;	if(TRIGHEX == lattice_Type){		double xForm[3][3] = {				{.66666666667,-.333333333,-.33333333},				{.333333333,.33333333,-.66666666667},				{.333333333,.333333333333,.33333333333}};		double rAlpha,sinAlpha,cH,aH;						rAlpha = theUnitCell.alpha * PI/360;		sinAlpha = sin(rAlpha);		aH = 2 * theUnitCell.a * sinAlpha;		cH = aH * 3 * sqrt( 1 - (1.3333333333 * sinAlpha * sinAlpha))/(2 * sinAlpha);		theUnitCell.b = theUnitCell.a = aH;		theUnitCell.c = cH;		theUnitCell.alpha = theUnitCell.beta = 90;		theUnitCell.gamma = 120;						D_HLock((Handle)theAtoms);		NewAtoms = (Atom*)D_NewPtr((long)(atom_Count + 1) * 3 * sizeof(Atom));		theAtomsPtr = *theAtoms;		k = atom_Count + 1;		j = 2 * (atom_Count + 1);		for(i = 0 ; i <= atom_Count ; i++,j++,k++){			double x,y,z;			x = theAtomsPtr[i].x;			y = theAtomsPtr[i].y;			z = theAtomsPtr[i].z;			TRANSFORM_VECTOR(x,y,z,xForm);			theAtomsPtr[i].x = x;			theAtomsPtr[i].y = y;			theAtomsPtr[i].z = z;			NewAtoms[k] = NewAtoms[j] = NewAtoms[i] = theAtomsPtr[i]; 			NewAtoms[k].x += .666666667; 			NewAtoms[k].y += .3333333333; 			NewAtoms[k].z += .3333333333;			NewAtoms[j].x += .3333333333; 			NewAtoms[j].y += .6666666666; 			NewAtoms[j].z += .6666666666;		}		D_HUnlock((Handle)theAtoms);		KillHandle((Handle*)&theAtoms);		atom_Count += 1;		atom_Count *= 3;		atom_Count -= 1;		theAtoms = (AtomHnd)D_NewHandle((atom_Count + 1) * sizeof(Atom));		if(!MemError()){			for(i = 0 ; i <= atom_Count ; i++){				(*theAtoms)[i] = NewAtoms[i];			}			KillPtr((Ptr)NewAtoms);		}else{			i = StopAlert(OUT_OF_MEM,NUL);			{				KeyMap		keyArray;							GetKeys(keyArray);				if(keyArray[1] == 5){					SysBreak();				}			}		}		if(spaceGrpNm > 1000)			spaceGrpNm -= 1000;		else			spaceGrpNm = 146;				lattice_Type = TRIGONAL;		EliminateDuplicates();	}else{		double  xForm[3][3] = {				{1,0,1},				{-1,1,1},				{0,-1,1}};		double aR,caH,cosA;						aR =  sqrt( (3 * (double)theUnitCell.a * (double)theUnitCell.a) + ((double)theUnitCell.c * (double)theUnitCell.c)) / 3;		caH = theUnitCell.c / theUnitCell.a; 		caH *= caH * .33333333333;		cosA = ((caH) - .5) / (caH + 1);		theUnitCell.c = theUnitCell.b = theUnitCell.a = aR;		theUnitCell.gamma = theUnitCell.alpha = theUnitCell.beta = acos(cosA) * 180 / PI;		D_HLock((Handle)theAtoms);		theAtomsPtr = *theAtoms;		for(i = 0 ; i <= atom_Count ; i++,j++,k++){			double x,y,z;			x = theAtomsPtr[i].x;			y = theAtomsPtr[i].y;			z = theAtomsPtr[i].z;			TRANSFORM_VECTOR(x,y,z,xForm);			theAtomsPtr[i].x = x;			theAtomsPtr[i].y = y;			theAtomsPtr[i].z = z;		}		D_HUnlock((Handle)theAtoms);		switch(spaceGrpNm)		{						case 146:case 148: case 155: case 160: case 161: case 166: case 167:			spaceGrpNm += 1000;			break;			default:				spaceGrpNm = 1146;			break;		}		lattice_Type = TRIGHEX;	}	EliminateDuplicates();	return true;}Ptr*  Crystal::AtomicScatteringSet(double electronMassRation,short theBeamFlag){	short		element = -21131;	double	atomicScatterNum;	short		i,k;	Atom		*dummyAtom;	double	*atomicScatter;	short		**atomicScatterSet;	ScatObj	*theObj = 0L;	short		p;		//theHandle = (Ptr*)D_NewHandle(sizeof(Ptr) * (atom_Count + 1));	D_HLock((Handle)theAtoms);	dummyAtom = *theAtoms;	electronMassRation *= .01;	for(i = 0; i <= atom_Count; i++,dummyAtom++)	{		if(element != (short)dummyAtom->atomicNum){			p = 0;			element 					= (short)dummyAtom->atomicNum;			atomicScatterNum 	= 0.0;			atomicScatter			=	(double*)D_NewPtr(sizeof(double) * 23);			if(element >= 105 && element < 199){				UserDefAtom*	thisUDAtom;				double				percent;				short 				m,theAtom,atNum;				for(m = 0;m < 23;m++)atomicScatter[m] = 0.0;				m 						= element - 105;				thisUDAtom 		= theUserAtoms[m];				for(theAtom 	= 0 ; theAtom <= thisUDAtom->lastAtom ; theAtom++){					percent 		= thisUDAtom->theElements[theAtom].percent  *  electronMassRation * .01;					atNum				= thisUDAtom->theElements[theAtom].atomicNum;					switch(theBeamFlag){						case 1:							atomicScatterSet = (short**)GetResource('Atom',(short)atNum);							break;						case 2:							atomicScatterSet = (short**)GetResource('XrSc',(short)atNum);							break;						case 3:							atomicScatterSet = (short**)GetResource('Atom',(short)atNum);							break;						default:							atomicScatterSet = (short**)GetResource('Atom',(short)atNum);							break;					}					if(atomicScatterSet){						for(k = 0; k < 23;k++)atomicScatter[k] += (double)((*atomicScatterSet)[k]) * percent;						ReleaseResource((Handle)atomicScatterSet);					}				}			}else{				switch(theBeamFlag){					case 1:						atomicScatterSet = (short**)GetResource('Atom',(short)element);						break;					case 2:						atomicScatterSet = (short**)GetResource('XrSc',(short)element);						break;					case 3:						atomicScatterSet = (short**)GetResource('Atom',(short)element);						break;					default:						atomicScatterSet = (short**)GetResource('Atom',(short)element);						break;				}				if(atomicScatterSet){					short *atomShort;					atomShort = (*atomicScatterSet);					for(k = 0; k < 23;k++,atomShort++){						double intensity;						double	atomLong;						atomLong = (double)*atomShort;						intensity = (double)atomLong   * electronMassRation;						atomicScatter[k] = intensity;					}					ReleaseResource((Handle)atomicScatterSet);				}else				{					for(k = 0; k < 23;k++)atomicScatter[k] = 0;				}			}					}		if(theObj == 0){			theObj = (ScatObj*)D_new(ScatObj);			theObj->Init(atomicScatter);		}else{			theObj->Add(atomicScatter,p);		}		p++;//flag that says element is the same, no need to make a new object		//((*theHandle))[i] = atomicScatter;//remember the electronMassRatio is accounted for	}	D_HUnlock((Handle)theAtoms);	return (Ptr*)theObj;}void Crystal::ClearAtomicScatSet(Ptr* theHandle){	ScatObj *theObj;	theObj = (ScatObj*)theHandle;	theObj->CloseAll(0L);/*	short		element = -21131;	short		i;	Atom		*dummyAtom;	Ptr		value;		dummyAtom = *theAtoms;	for(i = 0; i <= atom_Count; i++,dummyAtom++)	{		if(element != (short)dummyAtom->atomicNum){				element 					= (short)dummyAtom->atomicNum;				value	=	(Ptr)(*theHandle)[i];				KillPtr(value);					}	}	KillHandle((Handle*)&theHandle);*/}DialogPtr 		theDialog;Rect			theRect,rBounds;short			type,theSelect;ListHandle		theAtomList;Cell			theActiveCell,theCell;	void		Crystal::InitAtomList(void)			/*  Initialize the atom list		*/{	FontInfo 	theFont;	short		textHeight;	Point		cellSize;		GetFontInfo(&theFont);		textHeight 	= theFont.ascent 						+ theFont.descent 						+ theFont.leading;		GetDItem(theDialog,C_THE_LIST_RECT,&type,&gTheHandle,&theRect);	dm_EraseRect(&theRect);	SetRect(&rBounds,0,0,6,atom_Count + 1);	cellSize.h = 53;	cellSize.v = textHeight;	theAtomList = LNew(&theRect,&rBounds,cellSize,0,theDialog,true,false,false,true);	(*theAtomList)->selFlags = 0x80;	return;}void	Crystal::ListAtoms(void){	short i,j;	Boolean flag;	AtomPtr theAtomPtr;		D_HLock((Handle)theAtoms);	theAtomPtr = *theAtoms;	for(i = 0 ; i <= atom_Count ; i++,theAtomPtr++){		theCell.v = i;		for(j = 0 ; j <= 5 ; j++){			theCell.h = j;			switch(j){				case 0:					sprintf(gTheText,"%4d",i + 1);					break;				case 1:					sprintf(gTheText,"%6.5f",theAtomPtr->x);					break;				case 2:					sprintf(gTheText,"%6.5f",theAtomPtr->y);					break;				case 3:					sprintf(gTheText,"%6.5f",theAtomPtr->z);					break;				case 4:					flag = GetAtomicSymbol(theAtomPtr->atomicNum,gTheText);					break;				case 5:					if(gCurrentObj->calcDW)CorrectAtomDWToTemp(theAtomPtr,gCurrentObj->temperature);					sprintf(gTheText,"%6.5f",theAtomPtr->bi);					break;			}			c2pstr(gTheText);			LSetCell(&(gTheText[1]),(short)(gTheText[0]),theCell,theAtomList);		}	}	D_HUnlock((Handle)theAtoms);	return;}