//Crystal Definition:C_CrystalFaceObj.c#include	"Diffract_INCs.h"#include 	"crystalFaceObj.h"#include "ML_CrystalFace.h"#define DLOG_FACE_LIB 11116#define DLOG_LIB_NAME 998void	Permutate(void);short latticeType;void PutCrystalFaceObj::Kill(void){		KillPtr((Ptr)theFaces);		theIndex->DoClose();	oldCrystal->DoClose();	LDispose(theFaceList);	/*if(this->theDialog != 0L)		DM_DisposDialog(&(this->theDialog));	else{		KillDialogMenuBar();		SetPort(oldPort);	}*/	D_delete(this);	}void PutCrystalFaceObj::DoCopy(Crystal *crystalObj){	short i;	KillHandle((Handle*)&crystalObj->theFaces);			crystalObj->theFaces = (CrystalFaceHnd)D_NewHandle((face_Count + 1) * sizeof(CrystalFace));	if(!HandleIsOK((Handle)crystalObj->theFaces)){		crystalObj->face_Count = -1;		return;	}	KillHandle((Handle*)&crystalObj->theEdges);	crystalObj->theEdges = (CrystalEdgeHnd)D_NewHandle((3 * (face_Count + 1)) * sizeof(CrystalEdge));	if(!HandleIsOK((Handle)crystalObj->theEdges)){		crystalObj->face_Count = -1;		return;	}	KillHandle((Handle*)&crystalObj->theVertices);	crystalObj->theVertices = (CrystalVerticeHnd)D_NewHandle((3 * (face_Count + 1)) * sizeof(CrystalVertice));	if(!HandleIsOK((Handle)crystalObj->theVertices)){		crystalObj->face_Count = -1;		return;	}	crystalObj->face_Count = face_Count;	for(i = 0; i <= face_Count; i++)		(*crystalObj->theFaces)[i] = theFaces[i];	crystalObj->DetermineCrystalFaces();	crystalObj->DetermineVertices();	crystalObj->DetermineEdges();	/*crystalObj->CleanBadPlanes();*/					}void PutCrystalFaceObj::Init(Crystal *crystalObjOld){	theIndex 			= 	(Index*)D_new(Index);	theIndex			->	DoInit(false,crystalObjOld);	theIndex->direction = 	false;	face_Count 			= 	crystalObjOld->face_Count;	maxFaces 			= 	face_Count + 100;	activeRow 			= 	0;	theFaces 			= 	(CrystalFace*)D_NewPtr((maxFaces + 1) * sizeof(CrystalFace));	InitFaces				(crystalObjOld);	oldCrystal 			= 	(Crystal*)D_new(Crystal);	oldCrystal			->	InitCrystal(0);	crystalObjOld		->	CopyCrystal(oldCrystal);			latticeType 		= 	crystalObjOld->lattice_Type;		crystalToSet = crystalObjOld;}void 	PutCrystalFaceObj::DeleteFace(void){	short 	i;	short 	type;	Handle 	theHandle;	Rect 	theRect;	if(face_Count < 1)		return;	for(i = activeRow; i <= face_Count - 1; i++){		theFaces[i] = theFaces[i + 1];	}	LDelRow(1,face_Count,theFaceList);	face_Count--;	if(activeRow > face_Count){		activeRow = face_Count;	}	GetDItem(theDialog,THE_LIST_RECT_CF,&type,&theHandle,&theRect);	LSetSelect(true,gTheCell,theFaceList);	if(gTheCell.h == 0)		CorrectList(0);	else		CorrectList(1);	SelIText(theDialog,HKLINPUT,0,32767);}void	PutCrystalFaceObj::EnterHKL(void){	CrystalFace *theFace;	Handle 		theHandle;	Rect 		theRect;	short 		type;	theFace = &theFaces[activeRow];	GetDItem(theDialog,(short)HKLINPUT,&type,&theHandle,&theRect);	GetIText(theHandle,pTheText);	switch(gTheCell.h){		case HPUSH:			theIndex->IndexFromText(gTheText); 			theFace->h = theIndex->h;			theFace->k = theIndex->k;			theFace->l = theIndex->l;			break;		case LENGTHPUSH:			theFace->area = atof(p2cstr(pTheText));			break;		default:			break;	}	}void	PutCrystalFaceObj::AddFace(void){	short j;	CrystalFace *theFacesOld;	face_Count++;	if(face_Count >= maxFaces){		theFacesOld = (CrystalFace*)D_NewPtr((maxFaces + 1) * sizeof(CrystalFace));		for(j = 0; j <= maxFaces;j++){			theFacesOld[j] = theFaces[j];		}		maxFaces = 20 + face_Count;		KillPtr((Ptr)theFaces);		theFaces = (CrystalFace*)D_NewPtr((maxFaces + 1) * sizeof(CrystalFace));		for(j = 0; j <= face_Count;j++){			theFaces[j] = theFacesOld[j];		}			KillPtr((Ptr)theFacesOld);	}	theFaces[face_Count].h = theFaces[face_Count - 1].h;	theFaces[face_Count].k = theFaces[face_Count - 1].k;	theFaces[face_Count].l = theFaces[face_Count - 1].l;	theFaces[face_Count].area = theFaces[face_Count - 1].area;	activeRow = LAddRow(1,face_Count,theFaceList);	activeRow = face_Count;	if(gTheCell.h == 0)		CorrectList(0);	else		CorrectList(1);}void DoListBoxes(DialogPtr theDialog){	Handle theHandle;	Rect theRect,aRect;	short	type;			GetDItem(theDialog,THE_LIST_RECT_CF,&type,&theHandle,&theRect);	SetRect(&aRect,theRect.left - 1,theRect.top - 1,theRect.right + 1,theRect.bottom + 1);	dm_EraseRect(&theRect);	dm_FrameRect(&aRect);}void	PutCrystalFaceObj::InitFaceList(void)			/*  Initialize the atom list		*/{	FontInfo 	theFont;	short		textHeight;	Point		cellSize;	Handle 		theHandle;	Rect theRect,rBounds,aRect;	short	type;	PenNormal();		GetDItem(theDialog,THE_LIST_RECT_CF,&type,&theHandle,&theRect);	SetRect(&aRect,theRect.left - 1,theRect.top - 1,theRect.right + 1,theRect.bottom + 1);	dm_EraseRect(&aRect);	dm_FrameRect(&aRect);		GetFontInfo(&theFont);	textHeight = theFont.ascent + theFont.descent + theFont.leading;	SetRect(&rBounds,0,0,3,face_Count + 1);	cellSize.h = 55;	cellSize.v = textHeight;	theFaceList = LNew(&theRect,&rBounds,cellSize,0,theDialog,true,false,false,true);	(*theFaceList)->selFlags = 0x80;	PenNormal();	return;}void	PutCrystalFaceObj::ListFaces(void){	short i,j;	Cell theCell;	theCell.h = 1;	SetPort(theDialog);	PenNormal();	for(i = 0 ; i <= face_Count ; i++){		theCell.v = i;		for(j = 0; j <= 2; j++){			theCell.h = j;			switch(j){				case 0:					sprintf(gTheText,"%d",i + 1);					c2pstr(gTheText);					LSetCell(&(gTheText[1]),(short)(gTheText[0]),theCell,theFaceList);					break;				case 1:					theIndex->h = theFaces[i].h;					theIndex->k = theFaces[i].k;					theIndex->l = theFaces[i].l;					theIndex->SetListIndex(theFaceList,theCell);					break;				case 2:									sprintf(gTheText,"%5.3f",theFaces[i].area);					c2pstr(gTheText);					LSetCell(&(gTheText[1]),(short)(gTheText[0]),theCell,theFaceList);					break;				default:					break;			}		}	}		return;}void	PutCrystalFaceObj::ListFace(void){	short i,j;	Cell theCell;		i = theCell.v = gTheCell.v;	for(j = 0 ; j <= 2 ; j++){		theCell.h = j;				switch(j){			case 0:				sprintf(gTheText,"%d",i + 1);				c2pstr(gTheText);				LSetCell(&(gTheText[1]),(short)(gTheText[0]),theCell,theFaceList);				break;			case 1:				theIndex->h = theFaces[i].h;				theIndex->k = theFaces[i].k;				theIndex->l = theFaces[i].l;				theIndex->SetListIndex(theFaceList,theCell);				break;			case 2:				sprintf(gTheText,"%5.3f",theFaces[i].area);				c2pstr(gTheText);				LSetCell(&(gTheText[1]),(short)(gTheText[0]),theCell,theFaceList);				break;		}			}	return;}void PutCrystalFaceObj::InitFaces(Crystal *crystalObj){	short i;		for(i = 0; i <= face_Count; i++)		theFaces[i] = (*crystalObj->theFaces)[i];}void PutCrystalFaceObj::SetTheHKLText(void){	short 	i,type;	Handle 	theHandle;	Rect 	theRect;	if(gTheCell.h == 0)		i = 1;	else		i = gTheCell.h;	switch(i){		case HPUSH:			theIndex->h = theFaces[activeRow].h;			theIndex->k = theFaces[activeRow].k;			theIndex->l = theFaces[activeRow].l;			theIndex->IndexToText(gTheText);			break;		case LENGTHPUSH:			sprintf(gTheText,"%f5.3",theFaces[activeRow].area);			c2pstr(gTheText);			break;	}	GetDItem(theDialog,HKLINPUT,&type,&theHandle,&theRect);	SetIText(theHandle,pTheText);	SelIText(theDialog,HKLINPUT,0,32767);}void PutCrystalFaceObj::CorrectList(short hor){	LSetSelect(false,gTheCell,theFaceList);	gTheCell.v = activeRow;	gTheCell.h = 0;	LSetSelect(true,gTheCell,theFaceList);	LAutoScroll(theFaceList);	LSetSelect(false,gTheCell,theFaceList);	gTheCell.h = hor;	LSetSelect(true,gTheCell,theFaceList);	}void PutCrystalFaceObj::HandleListRect(void){	Point thePoint;	Cell theCell;	short i,k;	Rect theRect;	Boolean flag;	GlobalToLocal(&(gTheEvent.where));	SetPort(theDialog);	flag = LClick(gTheEvent.where,gTheEvent.modifiers,theFaceList);	GetMouse(&thePoint);	SetRect(&theRect,-5,-5,-5,-5);	for(i = 0;i <= face_Count;i++){		theCell.v = i;		for(k = 0; k <= 4;k++){			theCell.h = k;			LRect(&theRect,theCell,theFaceList);			if(PtInRect(thePoint,&theRect)){				gTheCell.v = activeRow = theCell.v;				gTheCell.h = theCell.h;			}		}	}	SetTheHKLText();}void	PutCrystalFaceObj::Permutate(){	short i;	short face_Count_N = -1,faceCountOld;	CrystalFace *newFaces;	newFaces = (CrystalFace*)D_NewPtr((100 + face_Count) * sizeof(CrystalFace));	faceCountOld = face_Count_N = face_Count;	for(i = 0; i <= face_Count; i++){		newFaces[i] = theFaces[i];	}	i = gTheCell.v;	CubicPermutate(&face_Count_N,theFaces[i],newFaces,true,latticeType);			for(i = faceCountOld; i <= face_Count_N; i++) {		AddFace();		theFaces[i] = newFaces[i];	}	DeleteFace();	KillPtr((Ptr)newFaces);}void PutCrystalFaceObj::DoLibrary(){	short 			theSelect;	Boolean 		quit = false;	Boolean			saveData;	Boolean			oldG;	ML_CrysFaceParamsPtr		 theParams;		theDialog = DM_GetNewDialog(DLOG_FACE_LIB,0L,(WindowPtr)-1L);	if(!theDialog)return;	theParams = (ML_CrysFaceParams*)D_NewPtr(sizeof(ML_CrysFaceParams));	theParams->theCrystalFaceObj = this;	oldG = g_Monitor;	g_Monitor = false;	DoSetUp( (Ptr)crystalToSet,(Ptr)theParams);	while(!quit){		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				quit = DoHit(  (Ptr)theParams, theSelect,&saveData);				EndUpdate(theDialog);				break;			default:					quit = DoHit(  (Ptr)theParams, theSelect,&saveData);					break;		}		}	DoRead( (Ptr)crystalToSet,(Ptr)theParams, saveData);	KillPtr((Ptr)theParams);	g_Monitor = oldG;	DM_DisposDialog(&theDialog);	return ;}Boolean PutCrystalFaceObj::DoHit(/*DialogPtr aDialog,*/Ptr thePtr,short theSelect,Boolean *saveData){	Boolean 		nEW = true;	double 			yForm[3][3],zForm[3][3];	Handle			theReshandle;	double			x,y;	short				i,j;	double			xForm[3][3];	Rect 			thePicRect;	Crystal			*originalCrystal;	RgnHandle		newClip;	RgnHandle		oldClip;	Rect			eraseRect;	CrystalFace		**theFacesHandle;	PicHandle		thePict;	PopUpMenu  		*theCrystalFaceList;	short			theResult;	static short  currentCase = -1;	short			hor;	double		theRot;	Boolean			theFlag;	ML_CrysFaceParamsPtr theParams;	theParams 			= (ML_CrysFaceParamsPtr)thePtr;	for(i = 0;i < 3;i++){for(j = 0; j < 3;j++)xForm[i][j] = theParams->xForm[i][j];}	thePicRect 			= theParams->thePicRect;	originalCrystal = theParams->originalCrystal;	newClip 				= theParams->newClip;	oldClip 				= theParams->oldClip;	eraseRect 			= theParams->eraseRect;	theFacesHandle 	= theParams->theFacesHandle;	thePict 				= theParams->thePict;	theCrystalFaceList = theParams->theCrystalFaceList;	theResult 			= theParams->theResult;	theFlag 				= theParams->theFlag;	SetPort(theDialog);	RectRgn(newClip,&theDialog->portRect);	if(currentCase == -1){		currentCase = 0;		theSelect = REDRAW_FACES;			}		switch(theSelect){			case REPLACE:				*saveData = true;				theParams->thePicRect = thePicRect;				theParams->originalCrystal = originalCrystal;				theParams->newClip = newClip;				theParams->oldClip = oldClip;				theParams->eraseRect = eraseRect;				theParams->theFacesHandle = theFacesHandle;				theParams->thePict = thePict;				theParams->theCrystalFaceList = theCrystalFaceList;				theParams->theResult = theResult;				theParams->theFlag = theFlag;				return true;			case CANCEL:			case CANCELCLICK: 				*saveData = false;				theParams->thePicRect = thePicRect;				theParams->originalCrystal = originalCrystal;				theParams->newClip = newClip;				theParams->oldClip = oldClip;				theParams->eraseRect = eraseRect;				theParams->theFacesHandle = theFacesHandle;				theParams->thePict = thePict;				theParams->theCrystalFaceList = theCrystalFaceList;				theParams->theResult = theResult;				theParams->theFlag = theFlag;				return true;										case ENTERCLICK:			case ENTER:			case 5:				EnterHKL();				ListFace();				if(gTheCell.h < 2 && gTheCell.h > 0){					hor = gTheCell.h + 1;				}else {					if(gTheCell.h == 2){						hor = 1;					}else{						hor = 0;					}					if(activeRow < face_Count){						activeRow++;					}				}				CorrectList(hor);				SetTheHKLText();				InvalRgn(newClip);				break;			case ADD:				AddFace();				ListFace();				SetTheHKLText();				break;			case DELETE_CF:				DeleteFace();				ListFaces();				SetTheHKLText();				break;			case HKLINPUT:				break;			case LIBRARY:								theCrystalFaceList->DoPopUp();				if(theCrystalFaceList->lastResult == 0) break;				if(theCrystalFaceList->lastResult == 2){										{					CrystalFace *theFacesPtr;					oldCrystal->Wigner_Seitz();					face_Count = oldCrystal->face_Count;					theFacesPtr   = *oldCrystal->theFaces;					for(i = 0; i <= face_Count;i++){						theFaces[i] = theFacesPtr[i];						theFaces[i].theCrystal = (Handle)oldCrystal;					}										DoCopy(oldCrystal);											face_Count = oldCrystal->face_Count;						theFacesPtr   = *oldCrystal->theFaces;						for(i = 0; i <= face_Count;i++){							theFaces[i] = theFacesPtr[i];						}					}					LDispose(theFaceList);					InitFaceList();					ListFaces();					SetTheHKLText();									SetClip(newClip);					Identity_Matrix(xForm);					EraseRect(&eraseRect);				 						 		KillPicture(thePict);					thePict = oldCrystal->DrawMorphology(xForm,thePicRect);					DoBoxes(theDialog);														 		DrawPicture(thePict,&thePicRect);										SetClip(oldClip);					InvalRgn(newClip);					break;				}				if(theResult != theCrystalFaceList->lastResult && 					theCrystalFaceList->lastResult > 1)				{										theResult = theCrystalFaceList->lastResult; 					theReshandle = 0L;					theReshandle = GetResource('FcLb',theResult);					theFacesHandle = (CrystalFace**)theReshandle;					face_Count = GetHandleSize((Handle)theFacesHandle)/sizeof(CrystalFace);					face_Count--;					for(i = 0; i <= face_Count;i++){						 theFaces[i] = (*theFacesHandle)[i];						 theFaces[i].theCrystal = (Handle)oldCrystal;						 if(theFaces[i].area <= 1){						 	theFaces[i].area = 2;						 }					}										DoCopy(oldCrystal);			 		ReleaseResource(theReshandle);					gTheCell.v = 0;					gTheCell.h = 1;										LDispose(theFaceList);					InitFaceList();					ListFaces();					SetTheHKLText();									}				if(theResult != theCrystalFaceList->lastResult && 					theCrystalFaceList->lastResult <= 1){					theResult = 0;										originalCrystal->CopyCrystal(oldCrystal);								 		theResult = theCrystalFaceList->lastResult;			 		face_Count = oldCrystal->face_Count;			 		gTheCell.v = 0;					gTheCell.h = 1;										InitFaces(oldCrystal);			 		LDispose(theFaceList);					InitFaceList();			 		ListFaces();			 					 		SetTheHKLText();			 						}				SetClip(newClip);				Identity_Matrix(xForm);				dm_EraseRect(&eraseRect);		 				 		KillPicture(thePict);				thePict = oldCrystal->DrawMorphology(xForm,thePicRect);				DoBoxes(theDialog);										 		DrawPicture(thePict,&thePicRect);								SetClip(oldClip);				InvalRgn(newClip);				break;			case PERMUTATION:				this->Permutate();				ListFaces();				break;				case The_SCROLL_RECT:				GlobalToLocal(&(gTheEvent.where));				LClick(gTheEvent.where,gTheEvent.modifiers,theFaceList);				break;			case THE_LIST_RECT_CF:				HandleListRect();				break;			case ADD_LIBRARY:				AddResourceToLibrary(theCrystalFaceList);				EraseRect(&theDialog->portRect);				InvalRect(&theDialog->portRect);				theCrystalFaceList->lastResult = theResult;				theCrystalFaceList->SetPopUp();				break;			case ROTATEXYPLUS:				theFlag = true;			case ROTATEXYNEG:			//	SetClip(newClip);			CONTINUE1:				if(theFlag) theRot = 5;				else theRot = -5;				y = sin(theRot * PI / 180);				x = cos(theRot * PI / 180);				Identity_Matrix(yForm);				yForm[0][0] = x;				yForm[0][1] = -y;				yForm[1][0] = y;				yForm[1][1] = x;				 MatrixMultiply(xForm,yForm,zForm);				SetMatrixAEqB(xForm,zForm);				KillPicture(thePict);				thePict = oldCrystal->DrawMorphology(xForm,thePicRect);			// 	dm_EraseRect(&eraseRect);		 		DrawPicture(thePict,&thePicRect);		 		Delay							(2,&gLongScratch);		 		if(!Button()){		 			theFlag = false;		 			currentCase = 0;		 		}else{		 			currentCase = ROTATEXYNEG;		 		}			 //	if(Button()) goto CONTINUE;			 		InvalRgn(newClip);		//	 	SetClip(oldClip);				break;			case ROTATEZYPLUS:				theFlag = true;			case ROTATEZYNEG:			//	SetClip(newClip);				CONTINUE:				if(theFlag) theRot = 5;				else theRot = -5;				 y = sin(theRot * PI / 180);				x = cos(theRot * PI / 180);				Identity_Matrix(yForm);				yForm[1][1] = x;				yForm[1][2] = -y;				yForm[2][2] = x;				yForm[2][1] = y;				 MatrixMultiply(xForm,yForm,zForm);				SetMatrixAEqB(xForm,zForm);			//	dm_EraseRect(&eraseRect);				KillPicture(thePict);								thePict = oldCrystal->DrawMorphology(xForm,thePicRect);				theFlag = false;			 //	DrawPicture(thePict,&thePicRect);			 	Delay							(2,&gLongScratch);			// 	if(Button()) goto CONTINUE;				InvalRgn(newClip);			// 	SetClip(oldClip);			 if(!Button()){		 			theFlag = false;		 			currentCase = 0;		 		}else{		 			currentCase = ROTATEZYNEG;		 		}			 	break;			case REDRAW_FACES:			//	SetClip(newClip);				//theCrystalFaceList->lastResult = -1;								DoCopy(oldCrystal);				Identity_Matrix(xForm);				KillPicture(thePict);				thePict = oldCrystal->DrawMorphology(xForm,thePicRect);			//	dm_EraseRect(&eraseRect);		 				 	//	DrawPicture(thePict,&thePicRect);		 		InvalRgn(newClip);		//		SetClip(oldClip);								theFlag = false;				break;									default:				break;			case ML_UPDATE_EVT:			SetClip(newClip);			DrawDialog(theDialog);					dm_EraseRect(&eraseRect);			DoBoxes(theDialog);			DrawPicture(thePict,&thePicRect);						theCrystalFaceList->SetPopUp();			if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				SetClip(oldClip);					if(!Button()){theFlag = false; currentCase = 0;}					if(Button() && currentCase == ROTATEXYNEG)goto CONTINUE1;					if(Button() && currentCase == ROTATEZYNEG)goto CONTINUE;			break;		}		for(i = 0;i < 3;i++){for(j = 0; j < 3;j++)theParams->xForm[i][j] = xForm[i][j];}		theParams->thePicRect = thePicRect;		theParams->originalCrystal = originalCrystal;		theParams->newClip = newClip;		theParams->oldClip = oldClip;		theParams->eraseRect = eraseRect;		theParams->theFacesHandle = theFacesHandle;		theParams->thePict = thePict;		theParams->theCrystalFaceList = theCrystalFaceList;		theParams->theResult = theResult;		theParams->theFlag = theFlag;		return false;}void DoBoxes(DialogPtr theDialog){	Rect 	theRect;	short 	type,midHor,midVer;	Handle 	theHandle;		GetDItem(theDialog,ROTATEXYPLUS,&type,&theHandle,&theRect);	PenSize(2,2);	dm_FrameRect(&theRect);		midHor = (theRect.left + theRect.right) / 2;	midVer = (theRect.top + theRect.bottom) / 2;	InsetRect(&theRect,2,2);	MoveTo(theRect.left,theRect.bottom);	LineTo(midHor,midVer);	MoveTo(theRect.left,theRect.top);	LineTo(midHor,midVer);		GetDItem(theDialog,ROTATEXYNEG,&type,&theHandle,&theRect);	dm_FrameRect(&theRect);	midHor = (theRect.left + theRect.right) / 2;	midVer = (theRect.top + theRect.bottom) / 2;	InsetRect(&theRect,2,2);	MoveTo(theRect.right,theRect.bottom);	LineTo(midHor,midVer);	MoveTo(theRect.right,theRect.top);	LineTo(midHor,midVer);		GetDItem(theDialog,ROTATEZYPLUS,&type,&theHandle,&theRect);	dm_FrameRect(&theRect);		midHor = (theRect.left + theRect.right) / 2;	midVer = (theRect.top + theRect.bottom) / 2;	InsetRect(&theRect,2,2);	MoveTo(theRect.left,theRect.bottom);	LineTo(midHor,midVer);	MoveTo(theRect.right,theRect.bottom);	LineTo(midHor,midVer);		GetDItem(theDialog,ROTATEZYNEG,&type,&theHandle,&theRect);	dm_FrameRect(&theRect);			midHor = (theRect.left + theRect.right) / 2;	midVer = (theRect.top + theRect.bottom) / 2;	InsetRect(&theRect,2,2);	MoveTo(theRect.left,theRect.top);	LineTo(midHor,midVer);	MoveTo(theRect.right,theRect.top);	LineTo(midHor,midVer);	PenSize(1,1);}void PutCrystalFaceObj::AddResourceToLibrary(PopUpMenu *theCrystalFaceList){	short 		i,resID;	char		theText[255];	CrystalFaceHnd theNewFaces;	sprintf(gTheText,"Shape Name");	if(!GetShapeName(gTheText))return;		theNewFaces = (CrystalFaceHnd)D_NewHandle((face_Count + 1) * sizeof(CrystalFace));		for(i = 0; i <= face_Count;i++) (*theNewFaces)[i] = theFaces[i];		resID = CountMItems(theCrystalFaceList->theMenu) + 1;	sprintf(theText,"%d ",resID);	strcat(theText,gTheText);	c2pstr(theText);	theCrystalFaceList->P_AppendMenu(theText);	//Changes Preference File so these changes remain permanent!!!	#if defined(_newkey_)		gDefault->SetPreferenceFile	((Handle)theNewFaces,resID,'FcLb',(char*)theText);	#endif	UpdateResFile							(g_AppResFile);	FlushVol									(0L,0);	KillHandle((Handle*)&theNewFaces);}Boolean PutCrystalFaceObj::GetShapeName(char *theText){	short 			item,type;	Handle 			theHandle;	Rect 			theRect;	pascal Boolean 	TheFilter();	DialogPtr		newDialog;	newDialog = DM_GetNewDialog(DLOG_LIB_NAME, 0L,(WindowPtr)-1L);	GetDItem(newDialog,3,&type,&theHandle,&theRect);	SetIText(theHandle,c2pstr(theText));	p2cstr((unsigned char*)theText);	while(1 != 2){		SystemTask();		ModalDialog(TheFilterUPP,&item);		switch(item)		{			case DLOG_ENTER_OR_CR:			case 	1:				GetDItem(newDialog,3,&type,&theHandle,&theRect);		 		GetIText(theHandle,(unsigned char*)theText);                p2cstr((unsigned char*)theText);				DM_DisposDialog(&newDialog);				return true;			case 2:				DM_DisposDialog(&newDialog);				return false;			case ML_UPDATE_EVT:					BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;		}	}}