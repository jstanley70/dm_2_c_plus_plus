//C_Index.c#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"short 		ConvertChar(char);short		ConvertLongChar(char *theText,short *strPos);void 		ConvertText(char *theText,short *strPos,short k);void	D_ValidObject(Handle	theObject);void	Index::DoInit(Boolean dirFlag,Crystal*	thatCrystal)	/*  Initialize Index		*/{	h			= 0; 	k			= 0;	l			= 1;	direction	= dirFlag;	flags		=	0L;	if(dirFlag)		reduceFlag	= true;	else		reduceFlag	= false;	theCrystal	= thatCrystal;	x = 0.0;	y = 0.0;	z = 1.0;	SetRect(&theSpotRect,-1,-1,1,1);	D_ValidObject((Handle)theCrystal);	return;}Index*	Index::Init(Boolean dirFlag,Crystal*	thatCrystal){	DoInit(dirFlag,thatCrystal);	return(this);}void	Index::DoClose()							/*  Close the Index 		*/					/*  Initialize Index		*/{	D_delete(this);	return;}void Index::DoCopy(Index *theIndex){	theIndex->theCrystal = theCrystal;	theIndex->h = h;	theIndex->k = k;	theIndex->l= l;	theIndex->direction = direction;	theIndex->reduceFlag = reduceFlag;	theIndex->x = x;	theIndex->y = y;	theIndex->z = z;	theIndex->intensity = intensity;	theIndex->theSpotRect = theSpotRect;	theIndex->flags = flags;	theIndex->angle = angle;	/* BlockMove((Ptr)&theCrystal,(Ptr)&(theIndex->theCrystal),sizeof(SpotInfo)); */	return;}void	Index::CopyIndexToPtr(Ptr thePtr)					{	SpotInfoPtr theSpot;	theSpot = (SpotInfoPtr)thePtr;	theSpot->theCrystal = theCrystal;	theSpot->h = h;	theSpot->k = k;	theSpot->l= l;	theSpot->direction = direction;	theSpot->x = x;	theSpot->y = y;	theSpot->z = z;	theSpot->intensity = intensity;	theSpot->spotRect = theSpotRect;	theSpot->flags = flags;	theSpot->angle = angle;	/* BlockMove((Ptr)&theCrystal,(Ptr)&(theSpot->theCrystal),sizeof(SpotInfo)); */	return;}void	Index::CopyPtrToIndex(Ptr thePtr)					{	SpotInfoPtr theSpot;	theSpot = (SpotInfoPtr)thePtr;	theCrystal = theSpot->theCrystal;	h = theSpot->h;	k = theSpot->k;	l = theSpot->l;	direction = theSpot->direction;	if(direction) reduceFlag = true;	else		 reduceFlag = false;	x = theSpot->x ;	y = theSpot->y;	z = theSpot->z;	angle = theSpot->angle;	intensity = theSpot->intensity;	theSpotRect = theSpot->spotRect;	flags = theSpot->flags;	D_ValidObject((Handle)theCrystal);	/* BlockMove((Ptr)&(theSpot->theCrystal),(Ptr)&theCrystal,sizeof(SpotInfo)); */	return;}void	Index::IndexFromText(char*	theText){	short a = 0,b = 0,c = 0,d = 0,i = 0,j = 0;	if(!(theCrystal->lattice_Type == HEXAGONAL || theCrystal->lattice_Type == TRIGONAL ) || !g_Hex_Four){		if((short)theText[0] <= 4){			theText++;			a = ConvertChar(*theText);			theText++;			b = ConvertChar(*theText);			theText++;			c = ConvertChar(*theText);		}else{			a = ConvertLongChar(theText,&i);			b = ConvertLongChar(theText,&i);			c = ConvertLongChar(theText,&i);		}		h = a;		k = b;		l = c;		return;	}	if((theCrystal->lattice_Type == HEXAGONAL && g_Hex_Four)  || (theCrystal->lattice_Type == TRIGONAL && g_Hex_Four)){		if((short)theText[0] <= 4){			theText++;			a = ConvertChar(*theText);			theText++;			b = ConvertChar(*theText);			theText++;			c = ConvertChar(*theText);			theText++;			d = ConvertChar(*theText);		}else{			a = ConvertLongChar(theText,&i);			b = ConvertLongChar(theText,&i);			c = ConvertLongChar(theText,&i);			d = ConvertLongChar(theText,&i);		}				if(direction){			h = a - c;			k = b - c;			l = d;		} else {			h = a;			k = b;			l = d;		}	} 	return;}short ConvertLongChar(char *theText,short *strPos){	short i ,j = -1;	short h = 0,l,k;	char newText[10];	i = *strPos;	while(theText[i] != 0 && theText[i] != ' ' && theText[i] != ',')	{		j++;		newText[j] = theText[i];		i++;	}	if(j < 0)		j = 0;	l = 0;	for(k = j; k >= 0;k--)	{		h += ConvertChar(newText[k]) * pow(10,(double)l);		l++;	}	if(theText[i] != 0)		i++;	*strPos = i;	return h;}void	Index::IndexToText(char*	theText){	short			H,K,T,L,i;	double			u,v,w;	i = 1;	u = (double)h;	v = (double)k;	w = (double)l;		while(fabs(u) > 100 || fabs(v) > 100 || fabs(w) > 100)	{		u /= 10;		v /= 10;		w /= 10;	} 	h = Round(u);	k = Round(v);	l = Round(w);	if((theCrystal->lattice_Type == HEXAGONAL && g_Hex_Four) || (theCrystal->lattice_Type == TRIGONAL && g_Hex_Four)){		if(direction){			H = u = (double)((2 * h) - k);			K = v = (double)((2 * k) - h);			L = w = (double)(l * 3);			if(u == 0. && v == 0. && w == 0)				w = 1.;						if(reduceFlag)				Reduce(&u,&v,&w);			else{				if(!(H % 3) && !(K % 3) && !(L % 3)){					u /= 3;					v /= 3;					w /= 3;				}							}			H = u;			K = v;			T = -(H + K);			L = w;						ConvertText(theText,&i,H);			ConvertText(theText,&i,K);			ConvertText(theText,&i,T);			ConvertText(theText,&i,L);		} else {			if(reduceFlag){				u = h;				v = k;				w = l;				Reduce(&u,&v,&w);				H = u;				K = v;				L = w;				T = - (H + K);				ConvertText(theText,&i,H);				ConvertText(theText,&i,K);				ConvertText(theText,&i,T);				ConvertText(theText,&i,L);			}else{				T = - (h + k);				ConvertText(theText,&i,h);				ConvertText(theText,&i,k);				ConvertText(theText,&i,T);				ConvertText(theText,&i,l);			}		}	} else {			if(reduceFlag){				u = h;				v = k;				w = l;				Reduce(&u,&v,&w);				H = u;				K = v;				L = w;			}else{				H = h;				K = k;				L = l;			}			ConvertText(theText,&i,H);			ConvertText(theText,&i,K);			ConvertText(theText,&i,L);	}	theText[0] = i - 1;}void	Index::IndexToStraightText(char*	theText){	short			H,K,T,L;	double			u,v,w;	if((theCrystal->lattice_Type == HEXAGONAL && g_Hex_Four) || (theCrystal->lattice_Type == TRIGONAL && g_Hex_Four)){		if(direction){			u = (double)((2 * h) - k);			v = (double)((2 * k) - h);			w = (double)(l * 3);			if(u == 0. && v == 0. && w == 0)				w = 1.;			Reduce(&u,&v,&w);			H = u;			K = v;			T = -(H + K);			L = w;				} else {			if(reduceFlag){				u = h;				v = k;				w = l;				Reduce(&u,&v,&w);				H = u;				K = v;				L = w;				T = - (H + K);							}else{				H = h;/*This is a correction made in October 1993 J.T.*/				K = k;				L = l;				T = - (h + k);			}			sprintf(theText,"%d%d%d%d",H,K,T,L);		}	} else {			if(reduceFlag){				u = h;				v = k;				w = l;				Reduce(&u,&v,&w);				H = u;				K = v;				L = w;			}else{				H = h;				K = k;				L = l;			}			sprintf(theText,"%d%d%d",H,K,L);	}}	Boolean	Index::GetIndex(DialogPtr theDialog,short theItem)			/*  Get data from dialog	*/					/*  Initialize Index		*/{	Handle	theHandle;	Rect			theRect;	short			type,a,b,c,i,a1,b1,c1;	double			u,v,w;		u = h;	v = k;	w = l;	Reduce(&u,&v,&w);	a = u;	b = v;	c = w;			for(i = 0; i <= 15;i++) pTheText[i] = (char)0;	GetDItem(theDialog,theItem,&type,&theHandle,&theRect);	GetIText(theHandle,pTheText);	IndexFromText(gTheText);	if( h == 0 && k == 0 && l == 0)		l = 1;	u = h;	v = k;	w = l;		Reduce(&u,&v,&w);	a1 = u;	b1 = v;	c1 = w;						if(a1 == a && b1 == b && c1 == c) return false;	return true;}void	Index::SetIndex(DialogPtr theDialog,short theItem)			/*  Set Dialog Info			*/					/*  Initialize Index		*/{	Handle			theHandle;	Rect			theRect;	short			type;	unsigned char	theText[100];		IndexToText((char*)theText);	GetDItem(theDialog,theItem,&type,&theHandle,&theRect);	SetIText(theHandle,theText);	return;}void	Index::GetListIndex(ListHandle theList,Cell theCell)		/*  Get data from List		*/{	short length,i;	for(i = 0; i <= 12;i++) gTheText[i] = (char)0;	LGetCell(&(gTheText[1]),&length,theCell,theList);	IndexFromText(gTheText);	return;}	void	Index::SetListIndex(ListHandle theList,Cell theCell)		/*  Get data from List		*/{	IndexToText(gTheText);	LSetCell(&(gTheText[1]),(short)(gTheText[0]),theCell,theList);	return;}void	Index::SetListIndecies(ListHandle theList,Cell theCell)		/*  Get data from List		*/{		IndexToIndecies(gTheText);	LSetCell(&(gTheText[1]),(short)(gTheText[0]),theCell,theList);	return;}void	Index::SetListDir(ListHandle theList,Cell theCell){	short length;		if(direction){		length = sprintf(gTheText,"Direction");	} else {		length = sprintf(gTheText,"Plane");	}	LSetCell(gTheText,length,theCell,theList);}void	Index::GetDrawnText(char	theText[256],Rect theRect[4],short *textSize)				/*  Initialize Index		*/{		short	length,lengthSt,x[4];		short	i;	double	u,v,w;	short 	textWidth;	short	textWidthSt;	Boolean extraText;	FontInfo theFont;	u = (double)h;	v = (double)k;	w = (double)l;		while(fabs(u) > 100 || fabs(v) > 100 || fabs(w) > 100)	{		u /= 10;		v /= 10;		w /= 10;	} 	h = Round(u);	k = Round(v);	l = Round(w);	if(theCrystal->lattice_Type == HEXAGONAL && g_Hex_Four || theCrystal->lattice_Type == TRIGONAL && g_Hex_Four){		if(direction){			u = (double)((2 * h) - k);			v = (double)((2 * k) - h);			w = (double)(l * 3);			if(u == 0. && v == 0. && w == 0)				w = 1.;			Reduce(&u,&v,&w);			x[0] = u;			x[1] = v;			x[2] = -(x[0] + x[1]);			x[3] = w;   		} else {			if(reduceFlag){				u = (long)h;				v = (long)k;				w = (long)l;				if(u == 0. && v == 0. && w == 0)					w = 1.;				Reduce(&u,&v,&w);				x[0] = u;				x[1] = v;				x[2] = -(u + v);				x[3] = w;  			}else{				x[0] = h;				x[1] = k;				x[2] = - (h + k);				x[3] = l;			}		}			} else {		if(reduceFlag){			u = (long)h;			v = (long)k;			w = (long)l;			if(u == 0. && v == 0. && w == 0)				w = 1.;			Reduce(&u,&v,&w);			x[0] = u;			x[1] = v;			x[2] = 0;			x[3] = w;   		}else{			x[0] = h;			x[1] = k;			x[2] = 0;			x[3] = l;		}	}	if(direction)		sprintf(&theText[0],"[");	else		sprintf(&theText[0],"(");	extraText = false;	GetFontInfo(&theFont);	textWidth = theFont.widMax;	*textSize = theFont.ascent + theFont.leading + theFont.descent;	for(i = 0; i <= 3;i++){		if(fabs((double)x[i]) > 9)			extraText = true;	}	for(i = 0; i <= 3;i++){		theRect[i].left = -100;		theRect[i].top = 0;		theRect[i].bottom = 0;		if(i == 2 && !(theCrystal->lattice_Type == HEXAGONAL  || theCrystal->lattice_Type == TRIGONAL) || i == 2 && !g_Hex_Four)			continue;		lengthSt 	= 	strlen(theText);		c2pstr			(theText);		textWidthSt = 	StringWidth((unsigned char*)theText);		p2cstr			((unsigned char*)theText);		sprintf			(&theText[lengthSt],"%d",(short)fabs((double)x[i]));		length 		= 	strlen(theText);		c2pstr			(theText);		textWidth 	= 	StringWidth((unsigned char*)theText);		p2cstr			((unsigned char*)theText);		if(extraText && i != 3){ 			sprintf(&theText[length]," ");		}		if(x[i] < 0){			theRect[i].left =  textWidthSt + 1;			theRect[i].right = textWidth - 1;		}			}		length = strlen(theText);	if(direction)		sprintf(&theText[length],"]");	else		sprintf(&theText[length],")");		return;}void	Index::ShowIndex(Point theLocation)		/*  Uses Chicago Font		*/{	Rect theRect[4];	short textSize;	char	theText[256];	short	horStart,verStart;	short i;	PenState thePenState;	GetPenState(&thePenState);	TextFont(0);	TextSize(12);	if(!direction)reduceFlag = false;	GetDrawnText(theText,theRect,&textSize);	horStart = theLocation.h;	verStart = theLocation.v;	MoveTo(horStart,verStart);	/* SetColor(); feb 1993 by jim...Removed April to fix info index background */ 	c2pstr(theText);		{		Rect aRect;		short length,height;		FontInfo theFont;		GetFontInfo(&theFont);				height = theFont.ascent + theFont.descent;		length = StringWidth((unsigned char*)theText);				SetRect(&aRect,horStart,verStart - height,horStart + length,verStart);		dm_EraseRect(&aRect);	}	DrawDiffractString((unsigned char*)theText);	for(i = 0 ; i <= 3 ; i++){		if(theRect[i].left == -100)			continue;		OffsetRect(&theRect[i],horStart,verStart - textSize + 4);		MoveTo(theRect[i].left,theRect[i].top);		LineTo(theRect[i].right,theRect[i].top);	}	SetPenState(&thePenState);}	void	Index::DrawIndex(Point theLocation)		/*  Uses Symbol Font		*/{	Rect theRect[4],textRect;	char	theText[256];	short	horStart,verStart;	short i;	short textSize;	PenState thePenState;		GetPenState	(&thePenState);	TextFont	(courier); /* courier */	TextSize	(9);	if(!direction)reduceFlag = false;	GetDrawnText	(theText,theRect,&textSize);	c2pstr			(theText);	horStart 	= 	theLocation.h - (StringWidth((unsigned char*)theText) / 2);	verStart	= 	theLocation.v - 2;	MoveTo			(horStart,verStart);	SetRect			(&textRect,horStart,verStart - 10,horStart + StringWidth((unsigned char*)theText),verStart);	InsetRect		(&textRect,-1,-1);	/*Mar 1995 by jim...Removed April to fix info index background */	SetColor(); 	dm_EraseRect		(&textRect);			if(gCurrentObj->printing)TextMode(0);else TextMode(srcCopy);				DrawDiffractString((unsigned char*)theText);	//DrawString((unsigned char*)theText);		/* CODE EXAMPLE #1 */	//printf( "pi = %7.5f", 3.141593 );	for(i = 0 ; i <= 3 ; i++){		if(theRect[i].left == -100)			continue;		OffsetRect(&theRect[i],horStart,verStart - textSize + 2);		MoveTo(theRect[i].left,theRect[i].top);		LineTo(theRect[i].right,theRect[i].top);	}	TextFont(0); /* system */	TextSize(12);	SetPenState(&thePenState);}void	Index::EraseDrawnIndex(Point theLocation)		/*  Uses courier Font		*/{	Rect theRect[4],textRect;	char	theText[256];	short	horStart,verStart;	short i;	short textSize;	PenState thePenState;	GetPenState(&thePenState);	TextFont(courier); /* courier */	TextSize(9);	if(!direction)reduceFlag = false;	GetDrawnText	(theText,theRect,&textSize);	c2pstr			(theText);	horStart 	= 	theLocation.h - (StringWidth((unsigned char*)theText) / 2);	verStart 	= 	theLocation.v;	MoveTo			(horStart,verStart);	SetRect			(&textRect,horStart,verStart - 10,horStart + StringWidth((unsigned char*)theText),verStart);	InsetRect		(&textRect,-1,-1);	gCurrentObj->DMForeColor(BACKGROUND_COLOR);		if(!Button())		dm_EraseRect(&textRect);	DrawDiffractString((unsigned char*)theText);	for(i = 0 ; i <= 3 ; i++){		if(theRect[i].left == -100)			continue;		OffsetRect(&theRect[i],horStart,verStart - textSize + 2);		MoveTo(theRect[i].left,theRect[i].top);		LineTo(theRect[i].right,theRect[i].top);	}	TextFont(0); /* system */	TextSize(12);	SetPenState(&thePenState);}void	Index::SetColor(void)  /*feb 1993*/{	if(resetMode){               /* allows xor transfer mode for moving labels  */		TextMode(srcOr);		TextMode(srcCopy);	} else {		resetMode = true;		TextMode(srcCopy);	}		if(g_Monitor)	{		PenNormal();	   gCurrentObj->DMForeColor(theCrystal->idNum + 10);	   gCurrentObj->DMBackColor(BACKGROUND_COLOR);	}else{		PenNormal();		gCurrentObj->DMForeColor(BLACK);		PenPat(&qd.black);		gCurrentObj->DMBackColor(WHITE);	}}void				Index::IndexToIndecies(char*	theText){	short	i;		IndexToText(theText);	i = (short)theText[0] + 1;	if(direction){		theText[0] 		= '[';		theText[i++] 	= ']';	} else {		theText[0] 		= '(';		theText[i++] 	= ')';	}	theText[i] 	= (char)0;	c2pstr(theText);}void				Index::TextToIndecies(char*	theText){	char	aText[255];		if(direction){		sprintf(aText,"[");		strcat(aText,theText);		sprintf(theText,"]");		strcat(aText,theText);		strcpy(theText,aText);	} else {		sprintf(aText,"(");		strcat(aText,theText);		sprintf(theText,")");		strcat(aText,theText);		strcpy(theText,aText);	}}double				Index::TheDSpacing(void){	double	theSpacing;	if(direction)		return(0.0);	theSpacing = theCrystal->DSpacing(h,k,l);	return(theSpacing);}double		Index::TheDSpacingDouble(void){	double	theSpacing;		if(direction)		return(0.0);	theSpacing = theCrystal->DSpacingDouble(x,y,z);	return(theSpacing);}double	Index::TheExtinctionDist(double RofEwaldSphere,double electronMassRation, short theBeamFlag){	double testDspace, theValue;//braggSine,braggCosine;	dcomplex abC;	if(direction) return 0.0;	testDspace 		= TheDSpacing();	if(testDspace < .0001)testDspace = 0;	else testDspace = 1/ testDspace;	theValue 			= IndexStructureFactor(testDspace,electronMassRation,theBeamFlag,&abC);//always returns a Ug/dielectric constantif(theValue < .00000001){return 100000;}	return RofEwaldSphere / theValue;//this assumes s == 0;}void Index::PlaneNormalOfDir(double *U,double *V,double *W){	double u,v,w,a,b,c,alpha1,gamma1,beta1,scale;	if(!direction){		*U = h;		*V = k;		*W = l;		return;	}	u = h;	v = k;	w = l;		scale = PI / 180.;	a = theCrystal->theUnitCell.a;	b = theCrystal->theUnitCell.b;	c = theCrystal->theUnitCell.c;	alpha1 = cos((double)(theCrystal->theUnitCell.alpha) * scale );	beta1 = cos((double)(theCrystal->theUnitCell.beta) * scale);	gamma1 = cos((double)(theCrystal->theUnitCell.gamma) * scale);	*U = ((u * a * a ) + (v * a * b * gamma1) + (w * c * a * beta1) );	*V = ((u * a * b * gamma1) + (v * b * b) + (w * b * c * alpha1));	*W = ((u * c * a * beta1) + (v * b * c * alpha1) + (w * c * c));}double				Index::DirCosOfPlaneNormal(double *U,double *V,double *W){	double L;		DirOfPlaneNormal(U,V,W);	L = sqrt(*U * *U + *V * *V + *W * *W);	*U /= L;	*V /= L;	*W /= L;	return TheDSpacing();}void				Index::DirOfPlaneNormal(double *U,double *V,double *W){	double	*sVals;		if(direction){		*U = h;		*V = k;		*W = l;		return;	}			sVals = theCrystal->sVals;	*U = h * sVals[0] + k * sVals[3] + l * sVals[5];	*V = h * sVals[3] + k * sVals[1] + l * sVals[4];	*W = h * sVals[5] + k * sVals[4] + l * sVals[2];		*U /= theCrystal->volume;	*V /= theCrystal->volume;	*W /= theCrystal->volume;		}short 	Index::ReduceIndex(void){	double			u,v,w;	short			theOrder = 1;	u = (double)h;	v = (double)k;	w = (double)l;	if(reduceFlag)		theOrder = Reduce(&u,&v,&w);	h = u;	k = v;	l = w;	return theOrder;}void				Index::IndexToHex(short* H,short* K,short* T,short* L){	double			u,v,w;	u = (double)h;	v = (double)k;	w = (double)l;		while(fabs(u) > 100 || fabs(v) > 100 || fabs(w) > 100)	{		u /= 10;		v /= 10;		w /= 10;	} 	h = Round(u);	k = Round(v);	l = Round(w);		if(!g_Hex_Four){		u = h;		v = k;		w = l;		if(reduceFlag){			Reduce(&u,&v,&w);		}		*H = u;		*K = v;		*T = 0;		*L = w;		return;	}	if(direction){		u = (double)((2 * h) - k);		v = (double)((2 * k) - h);		w = (double)(l * 3);		if(u == 0. && v == 0. && w == 0)			w = 1.;		Reduce(&u,&v,&w);		*H = u;		*K = v;		*T = -(u + v);		*L = w;	} else {		if(reduceFlag){			u = (double)h;			v = (double)k;			w = (double)l;			if(u == 0. && v == 0. && w == 0)				w = 1.;			Reduce(&u,&v,&w);			*H = u;			*K = v;			*T = -(u + v);			*L = w;		}else{			*H = h;			*K = k;			*T = -(h + k);			*L = l;		}	}}void				Index::IndexFromHex(short u,short v,short t,short w){	if(!g_Hex_Four){		h = u;		k = v;		l = w;	}	if(direction){		h = u - t;		k = v - t;		l = w;	} else {		h = u;		k = v;		l = w;	}}void				Index::ReadIndex(Crystal *aCrystal[4]){	h = gTheFile->ReadShort();	k = gTheFile->ReadShort();	l = gTheFile->ReadShort();	direction = gTheFile->ReadBoolean();	x = gTheFile->ReadFloat();	y = gTheFile->ReadFloat();	z = gTheFile->ReadFloat();	intensity = gTheFile->ReadFloat();	angle = gTheFile->ReadFloat();	flags = gTheFile->ReadLong();	theCrystal = aCrystal[flags & CRYSTAL_MASK];	gTheFile->ReadDataBlock((Ptr)&theSpotRect,sizeof(Rect));}