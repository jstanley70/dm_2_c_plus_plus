//C_Crystal2.c#define		THE_BIG_DUMMY	10#include	"Diffract_INCs.h"#include 	"ITCCrystalDef.h"#include 	"crystalFaceObj.h"#include	"UT_VectorMacros.c"#include	"Dir_Paths.h"#include	"Quickdraw.h"	Boolean FileError		(short num,short theError);Boolean FacesParallel	(CrystalFace *facePtr1,CrystalFace *facePtr2);Boolean CommonFaces		(CrystalVertice theVertice1,CrystalVertice theVertice2,short *face1,short *face2);Handle 	WriteStrgHnd	(char **charHandle,char *theText,double theValue,short floatInt);void 	DrawCrystalLine	(double x1,double y1,double z1,double x2,double y2,double z2,double length1,double length2, Point imageCenter,double scaling);Boolean FileError(short num,short theError){	short width;	Rect msgRect;	char *theText;		if(theError >= 0)		return false;	theText = (char*)D_NewPtr(255 * (long)sizeof(char));	switch(theError){		case noErr:			KillPtr((Ptr)theText);			return false;			break;		case openErr:			sprintf(theText,(char*)"\pDriver cannot respond to the Open call.");			break;		case nsvErr:			sprintf(theText,(char*)"\pSpecified Volume doesnt exist");			break;		case rfNumErr:			sprintf(theText,(char*)"\pReference number specifies non-existant path");			break;		case fnfErr:			sprintf(theText,(char*)"\pFile not found.");			break;		case dupFNErr:			sprintf(theText,(char*)"\pduplicate file name.");			break;		default:			sprintf(theText,(char*)"\pError %d encountered",theError);			break;	}	while(Button())		;	MoveTo(100,100);	DrawDiffractString((unsigned char*)theText);	width = StringWidth((unsigned char*)theText);	sprintf(theText,(char*)"\pat location %d",num);	MoveTo(100,120);	DrawDiffractString((unsigned char*)theText);	while(!Button())		;	msgRect.top = 80;	msgRect.bottom = 122;	msgRect.left = 100;	msgRect.right = 102 + width;	dm_EraseRect(&msgRect);	KillPtr((Ptr)theText);	return true;}void Crystal::JustifyAtomPos(void){	short i,theInt;	double	theValue;	AtomPtr theAtomsPtr,theAtomPtr;	D_HLock((Handle)theAtoms);	theAtomPtr = theAtomsPtr = *theAtoms;	for(i = 0; i <= atom_Count;i++,theAtomPtr++)	{		//theAtomPtr = &theAtomsPtr[i];		if(theAtomPtr->x >= 1){			theInt = theAtomPtr->x;			theAtomPtr->x -= theInt;		}		if(theAtomPtr->y >= 1){			theInt = theAtomPtr->y;			theAtomPtr->y -= theInt;		}		if(theAtomPtr->z >= 1){			theInt = theAtomPtr->z;			theAtomPtr->z -= theInt;		}				if(theAtomPtr->x < -0.00001){			theInt = theAtomPtr->x;			theValue = theAtomPtr->x - theInt;			theAtomPtr->x = 1 + theValue;		}		if(theAtomPtr->y < -0.00001){			theInt = theAtomPtr->y;			theValue = theAtomPtr->y - theInt;			theAtomPtr->y = 1 + theValue;		}		if(theAtomPtr->z < -0.00001){			theInt = theAtomPtr->z;			theValue = theAtomPtr->z - theInt;			theAtomPtr->z = 1 + theValue;		}	}	D_HUnlock((Handle)theAtoms);	EliminateDuplicates();}void Crystal::EliminateDuplicates(void){	short i,k,j;	AtomPtr theAtomPtr,theAtomJPtr,theAtomKPtr;		/* July 1992   Moved D_HLock and theAtomPtr down two lines */	if(atom_Count <= 1)		return;	D_HLock((Handle)theAtoms);	theAtomPtr = *theAtoms;	for(i = 0; i <= atom_Count; i++,theAtomPtr++){		while( theAtomPtr->x > .999999999)theAtomPtr->x -= 1;		while( theAtomPtr->y > .999999999)theAtomPtr->y -= 1;		while( theAtomPtr->z > .999999999)theAtomPtr->z -= 1;		while( theAtomPtr->x < 0)theAtomPtr->x += 1;		while( theAtomPtr->y < 0)theAtomPtr->y += 1;		while( theAtomPtr->z < 0)theAtomPtr->z += 1;	}	theAtomKPtr = theAtomPtr = *theAtoms;	for(i = 0; i <= atom_Count; i++,theAtomPtr++){		theAtomKPtr = *theAtoms;		for(k = 0; k <= atom_Count; k++,theAtomKPtr++){			if(i == k)				continue;			if(fabs(theAtomPtr->x - theAtomKPtr->x) <= .00001 &&				fabs(theAtomPtr->y - theAtomKPtr->y) <= .00001 &&				fabs(theAtomPtr->z - theAtomKPtr->z) <= .00001)			{				atom_Count--;				theAtomJPtr = theAtomKPtr;				for(j = k;j <= atom_Count;j++,theAtomJPtr++){					*theAtomJPtr = theAtomJPtr[1];				}				k--;				theAtomKPtr--;			}		}	}	D_HUnlock((Handle)theAtoms);}double Crystal::CrystalDensity(double *avgAtWt,double *avgZ){	short i;	short atNum;	float		**atomicMassHndl;	float		atomicMass,atomicNumAvg = 0;	double		density;	AtomPtr theAtomsPtr;	if(atom_Count < 0 || volume < .2){		return 0;	}	density = 0;	atomicMass = 0;	atomicMassHndl = (float**)GetResource('info',100);	D_HLock((Handle)theAtoms);	theAtomsPtr = *theAtoms;		for(i = 0; i <= atom_Count;i++){		if(theAtomsPtr[i].atomicNum >= 105 && theAtomsPtr[i].atomicNum < 200){			UserDefAtom*	thisUDAtom;			double	percent;			short m,theAtom,atNum;			m = theAtomsPtr[i].atomicNum - 105;			thisUDAtom = theUserAtoms[m];			for(theAtom = 0 ; theAtom <= thisUDAtom->lastAtom ; theAtom++){				percent = thisUDAtom->theElements[theAtom].percent / 100.;				atNum	= thisUDAtom->theElements[theAtom].atomicNum;				ReturnValance(&atNum);				atomicMass += (*atomicMassHndl)[atNum - 1] * percent;				atomicNumAvg += atNum * percent;			}		}else{			atNum = theAtomsPtr[i].atomicNum;			ReturnValance(&atNum);			atomicMass += (*atomicMassHndl)[atNum - 1];			atomicNumAvg += atNum;		}			}	D_HUnlock((Handle)theAtoms);	ReleaseResource((Handle)atomicMassHndl);	*avgAtWt = atomicMass/(double)(atom_Count + 1);	*avgZ    = atomicNumAvg/(double)(atom_Count + 1);	return atomicMass * 1.66112 / volume;}typedef struct AtomicPos0{						float			x;						float			y;						float			z;						short		atomicNumber;					} AtomicPos0;typedef struct AtomicPos1{						short		x;						short		y;						short		z;						short		occupancy;						short		atomicNumber;					} AtomicPos1;typedef struct  Crystal0 {								/*		TYPE		*/						short				type;						/* 	Cubic 				1	*/						short double		axisA;						/* 	Orthorhombic  	7	*/						short double		axisB;						/* 	Rhombohedral  	9	*/						short double		axisC;						/* 	Hexagonal			5	*/						short double		angleA;						/* 	Monoclinic 		39	*/						short double		angleB;						/* 	triclinic			63	*/						short double		angleC;							short double		percent;						short				lattice;						/* dialog crystal type */						AtomicPos0			theAtom[100];									short				lastUnitCellAtom;						short double		minDSpace;				/* minimum value for d spacing calc */						short double		maxDSpace;				/* maximum value for d spacing calc */				 		short double		volume;					/* volume of unit cell	*/						short				flags;						/* various flags...0 = dspace */					} Crystal0;									typedef struct  Crystal1 {								/*		TYPE		*/						short				type;						/* 	Cubic 				1	*/						short double		axisA;						/* 	Orthorhombic  	7	*/						short double		axisB;						/* 	Rhombohedral  	9	*/						short double		axisC;						/* 	Hexagonal			5	*/						short double		angleA;						/* 	Monoclinic 		39	*/						short double		angleB;						/* 	triclinic			63	*/						short double		angleC;							short double		percent;						short				lattice;						/* dialog crystal type */						AtomicPos1			theAtom[250];									short				lastUnitCellAtom;						short double		minDSpace;				/* minimum value for d spacing calc */						short double		maxDSpace;				/* maximum value for d spacing calc */				 		short double		volume;					/* volume of unit cell	*/						short				flags;						/* various flags...0 = dspace */					} Crystal1;			void	Crystal::SaveAsOldFormat(void){	Crystal1		oldCrystal;	short i;	AtomPtr theAtomsPtr,theAtomPtr;			oldCrystal.axisA = theUnitCell.a;	oldCrystal.axisB = theUnitCell.b;	oldCrystal.axisC = theUnitCell.c;	oldCrystal.angleA = theUnitCell.alpha;	oldCrystal.angleB = theUnitCell.beta;	oldCrystal.angleC = theUnitCell.gamma;	oldCrystal.volume = volume;	oldCrystal.lastUnitCellAtom = atom_Count;		switch(lattice_Type){		case CUBIC:			oldCrystal.type = 1;			oldCrystal.lattice = 7;			break;		case ORTHORHOMBIC:		case TETRAGONAL:			oldCrystal.type = 7;			oldCrystal.lattice = 8;			break;		case TRIGHEX:			oldCrystal.type = 9;			oldCrystal.lattice = 9;			break;		case HEXAGONAL:		case TRIGONAL:			oldCrystal.type = 5;			oldCrystal.lattice = 10;			break;		case MONOCLINIC:			oldCrystal.type = 23;			oldCrystal.lattice = 11;			break;		case TRICLINIC:			oldCrystal.type = 63;			oldCrystal.lattice = 12;			break;	}	D_HLock((Handle)theAtoms);	theAtomsPtr = *theAtoms;	for(i = 0; i <= atom_Count; i++){		theAtomPtr = &(theAtomsPtr[i]);		oldCrystal.theAtom[i].x = (double)10000 * (double)theAtomPtr->x;		oldCrystal.theAtom[i].y = (double)10000 * (double)theAtomPtr->y;		oldCrystal.theAtom[i].z = (double)10000 * (double)theAtomPtr->z;		oldCrystal.theAtom[i].atomicNumber = theAtomPtr->atomicNum;		oldCrystal.theAtom[i].occupancy = 100;	}	D_HUnlock((Handle)theAtoms);	oldCrystal.percent = 1.;	oldCrystal.flags = 0;	oldCrystal.minDSpace = 1;	oldCrystal.maxDSpace = 2.;	gTheFile->WriteStructureBlock((Ptr)&oldCrystal,(sizeof(Crystal1)));	return;}void	Crystal::SaveAsText(void){	char**  		charHandle;	short			i;	AtomPtr 		theAPtr;	CrystalFacePtr 	theFPtr;	charHandle 	= 	D_NewHandle(1000);	**charHandle = 0;	charHandle =  WriteStrgHnd(charHandle,"Secondary Source",(double)referenceInfoSet,1);		charHandle =  WriteStrgHnd(charHandle,"Lattice Type",(double)lattice_Type,1);	charHandle =  WriteStrgHnd(charHandle,"Space Group",(double)spaceGrpNm,1);		charHandle =  WriteStrgHnd(charHandle,"a",	theUnitCell.a,		0);	charHandle =  WriteStrgHnd(charHandle,"b",	theUnitCell.b,		0);	charHandle =  WriteStrgHnd(charHandle,"c",	theUnitCell.c,		0);	charHandle =  WriteStrgHnd(charHandle,"alpha",theUnitCell.alpha,	0);	charHandle =  WriteStrgHnd(charHandle,"beta",	theUnitCell.beta,	0);	charHandle =  WriteStrgHnd(charHandle,"gamma",theUnitCell.gamma,	0);	charHandle =  WriteStrgHnd(charHandle,"Volume",volume,		0);		charHandle =  WriteStrgHnd(charHandle,"Reduced a",	theReducedCell.a,		0);	charHandle =  WriteStrgHnd(charHandle,"Reduced b",	theReducedCell.b,		0);	charHandle =  WriteStrgHnd(charHandle,"Reduced c",	theReducedCell.c,		0);	charHandle =  WriteStrgHnd(charHandle,"Reduced alpha",theReducedCell.alpha,	0);	charHandle =  WriteStrgHnd(charHandle,"Reduced beta",theReducedCell.beta,	0);	charHandle =  WriteStrgHnd(charHandle,"Reduced gamma",theReducedCell.gamma,	0);	charHandle =  WriteStrgHnd(charHandle,"Reduced Volume",volumeReduced,	0);					charHandle =  WriteStrgHnd(charHandle,"JCPDF File#",	(double)fileNo,1);	charHandle =  WriteStrgHnd(charHandle,"JCPDF Card#",	(double)cardNo,1);	charHandle =  WriteStrgHnd(charHandle,formulaText,	(double)0,-1);	charHandle =  WriteStrgHnd(charHandle,crystalName,	(double)0,-1);	charHandle =  WriteStrgHnd(charHandle,cODEN,		(double)0,-1);	charHandle =  WriteStrgHnd(charHandle,author,		(double)0,-1);	charHandle =  WriteStrgHnd(charHandle,reference,	(double)0,-1);	charHandle =  WriteStrgHnd(charHandle,"Year Discovered",	(double)year,1);	charHandle =  WriteStrgHnd(charHandle,"Element List, (#)",	(double)noDifrntElem,1);	for(i = 0; i <= noDifrntElem - 1;i++)	{		charHandle =  WriteStrgHnd(charHandle," ",	(double)elementList[i],1);	}	charHandle =  WriteStrgHnd(charHandle,"Atom Positions (#)",		(double)atom_Count + 1,1);	theAPtr = *theAtoms;	HLock((Handle)theAtoms);	for(i = 0; i <= atom_Count;i++)	{		sprintf(gTheText,"%d\t%d\t%6.4f\t%6.4f\t%6.4f",theAPtr[i].atomicNum,theAPtr[i].wyckOffNum,theAPtr[i].x,theAPtr[i].y,theAPtr[i].z);		charHandle =  WriteStrgHnd(charHandle,gTheText,0.0,-1);	}	HUnlock((Handle)theAtoms);	charHandle =  WriteStrgHnd(charHandle,"Wyckoff Positions (#)",(double)wy_Atom_Count + 1,1);	for(i = 0; i <= wy_Atom_Count;i++)	{		char theText[255];		gTheText[0] = 0;		strcat(gTheText,theWyckAtoms[i].wckoffPosName);		sprintf(theText,"\t%d\t%d\t%6.4f\t%6.4f\t%6.4f",theWyckAtoms[i].wckoffPosNo,theWyckAtoms[i].atomicNum,theWyckAtoms[i].x,theWyckAtoms[i].y,theWyckAtoms[i].z);		strcat(gTheText,theText);		charHandle =  WriteStrgHnd(charHandle,gTheText,0.0,-1);	}			charHandle =  WriteStrgHnd(charHandle,"#User Defined Atoms (#)",(double)lastUserDef + 1,1);	for(i = 0; i <= lastUserDef;i++)	{		short j;		charHandle =  WriteStrgHnd(charHandle," ",(double)theUserAtoms[i]->lastAtom,1);		for(j = 0; j <= theUserAtoms[i]->lastAtom;j++)		{			sprintf(gTheText,"%d%6.4f",theUserAtoms[i]->theElements[j].atomicNum,theUserAtoms[i]->theElements[j].percent);			charHandle =  WriteStrgHnd(charHandle,gTheText,0.0,-1);		}	}	charHandle =  WriteStrgHnd(charHandle,"Listing of Dspacings + Intensities",0.0,-1);	for(i = 0; i <= 29;i++)	{		sprintf(gTheText,"%d\t%d\t%d\t%6.4f\t%6.4f",dspacings[i].h,dspacings[i].k,dspacings[i].l,dspacings[i].x,dspacings[i].intensity);		charHandle =  WriteStrgHnd(charHandle,gTheText,0.0,-1);	}		charHandle =  WriteStrgHnd(charHandle,"Elastic Constants",0.0,-1);		sprintf(gTheText,"%6.4f\t%6.4f\t%6.4f\t%6.4f\t%6.4f\t%6.4f",elasticConstants[0],elasticConstants[1],elasticConstants[2],elasticConstants[3],elasticConstants[4],elasticConstants[5]);	charHandle =  WriteStrgHnd(charHandle,gTheText,0.0,-1);		sprintf(gTheText,"%6.4f\t%6.4f\t%6.4f\t%6.4f\t%6.4f",elasticConstants[6],elasticConstants[7],elasticConstants[8],elasticConstants[9],elasticConstants[10]);	charHandle =  WriteStrgHnd(charHandle,gTheText,0.0,-1);		sprintf(gTheText,"%6.4f\t%6.4f\t%6.4f\t%6.4f",elasticConstants[11],elasticConstants[12],elasticConstants[13],elasticConstants[14]);	charHandle =  WriteStrgHnd(charHandle,gTheText,0.0,-1);		sprintf(gTheText,"%6.4f\t%6.4f\t%6.4f",elasticConstants[151],elasticConstants[16],elasticConstants[17]);	charHandle =  WriteStrgHnd(charHandle,gTheText,0.0,-1);		sprintf(gTheText,"%6.4f\t%6.4f",elasticConstants[18],elasticConstants[19]);	charHandle =  WriteStrgHnd(charHandle,gTheText,0.0,-1);		sprintf(gTheText,"%6.4f",elasticConstants[20]);	charHandle =  WriteStrgHnd(charHandle,gTheText,0.0,-1);		charHandle =  WriteStrgHnd(charHandle,"Physical Parameters (#)",(double)lastPhysicalParam,1);	for(i = 1; i <= lastPhysicalParam;i)	{		char theText[255];		double theValue = 0.0;		switch(i){			case 1:			case 2:				break;			default:				break;		}				charHandle =  WriteStrgHnd(charHandle,theText,(double)theValue,0);	}		charHandle =  WriteStrgHnd(charHandle,"Thermodynamic Parameters (#)",(double)lastThermoParam,1);	for(i = 1; i <= lastThermoParam;i)	{		char theText[255];		double theValue = 0.0;		switch(i){			case 1:			case 2:				break;			default:				break;		}		charHandle =  WriteStrgHnd(charHandle,theText,(double)theValue,0);	}		charHandle =  (char**)WriteStrgHnd(charHandle,"Crystal Faces (#)",		(double)face_Count + 1,1);	theFPtr = *theFaces;	HLock((Handle)theFaces);	for(i = 0; i <= face_Count;i++)	{		sprintf(gTheText,"%d\t%d\t%d\t%6.4f",theFPtr[i].h,theFPtr[i].k,theFPtr[i].l,theFPtr[i].length);		charHandle =  WriteStrgHnd(charHandle,gTheText,0.0,-1);	}	HUnlock((Handle)theFaces);		gTheFile->WriteHandle((Handle)charHandle);		KillHandle(&charHandle);}Handle WriteStrgHnd(char **charHandle,char *theText,double theValue,short floatInt){	short 	intValue;	long	stringLength;	char  	*theTextPtr;		switch(floatInt){		case -1:			break;		case 0:			sprintf			(gTheText," = \t%6.4f\r",theValue);		break;		case 1:			intValue = (short)theValue;			sprintf			(gTheText," = \t%d\r",intValue);		break;		default:			break;	}	stringLength	= 	(long)strlen(*charHandle);	if(floatInt >= 0)stringLength 	+= 	strlen(gTheText);		stringLength	+= 	strlen(theText);	if(stringLength + 1 > GetHandleSize((Handle)charHandle))		D_SetHandleSize		((Handle*)&charHandle,stringLength + 1);			theTextPtr 		= 	*charHandle;	strcat				(theTextPtr,theText);	if(floatInt >= 0)	strcat	(theTextPtr,gTheText);	else strcat(theTextPtr,"\r");	return charHandle;}		void	Crystal::OpenText(void){}void	Crystal::OpenOldFormat(void){	Crystal1		oldCrystal;	Crystal0		oldestCrystal;	AtomPtr theAtomsPtr;	short i;			if(gTheFile->theFileInfo.sfType == CRYST_OBJ_OLD){				gTheFile->ReadStructureBlock((Ptr)&oldCrystal,(long)sizeof(Crystal1));		switch(oldCrystal.lattice){			case 7:				lattice_Type = CUBIC;				break;			case 8:				lattice_Type = ORTHORHOMBIC;				break;			case 9:				lattice_Type = TRIGHEX;				break;			case 10:				lattice_Type = HEXAGONAL;				break;			case 11:				lattice_Type = MONOCLINIC;				break;			case 12:				lattice_Type = TRICLINIC;				break;		}		theUnitCell.a =		oldCrystal.axisA;		theUnitCell.b =		oldCrystal.axisB;		theUnitCell.c =		oldCrystal.axisC;		theUnitCell.alpha =	oldCrystal.angleA;		theUnitCell.beta =	oldCrystal.angleB;		theUnitCell.gamma =	oldCrystal.angleC;		volume = oldCrystal.volume;				atom_Count		= oldCrystal.lastUnitCellAtom;		KillHandle((Handle*)&theAtoms);		theAtoms = (AtomHnd)D_NewHandle((atom_Count + 1) * sizeof(Atom));		D_HLock((Handle)theAtoms);		theAtomsPtr = *theAtoms;		for(i = 0; i <= atom_Count;i++)		{			theAtomsPtr[i].atomicNum = oldCrystal.theAtom[i].atomicNumber;			theAtomsPtr[i].x = (double)oldCrystal.theAtom[i].x / 10000;			theAtomsPtr[i].y =(double)oldCrystal.theAtom[i].y / 10000;			theAtomsPtr[i].z = (double)oldCrystal.theAtom[i].z / 10000;			theAtomsPtr[i].wyckOffNum = 0;			theAtomsPtr[i].bi = 0;		}		D_HUnlock((Handle)theAtoms);	}	if(gTheFile->theFileInfo.sfType == CRYST_OBJ_OLDEST){		gTheFile->ReadStructureBlock((Ptr)&oldestCrystal,(long)sizeof(Crystal0));		switch(oldestCrystal.lattice){			case 7:				lattice_Type = CUBIC;				break;			case 8:				lattice_Type = ORTHORHOMBIC;				break;			case 9:				lattice_Type = TRIGHEX;				break;			case 10:				lattice_Type = HEXAGONAL;				break;			case 11:				lattice_Type = MONOCLINIC;				break;			case 12:				lattice_Type = TRICLINIC;				break;		}		theUnitCell.a 		=	oldestCrystal.axisA;		theUnitCell.b 		=	oldestCrystal.axisB;		theUnitCell.c 		=	oldestCrystal.axisC;		theUnitCell.alpha =	oldestCrystal.angleA;		theUnitCell.beta 	=	oldestCrystal.angleB;		theUnitCell.gamma =	oldestCrystal.angleC;		volume 				= 	oldestCrystal.volume;		referenceInfoSet 	= 	false;		atom_Count			= 	oldestCrystal.lastUnitCellAtom;		KillHandle((Handle*)&theAtoms);		theAtoms	= (AtomHnd)D_NewHandle((long)(atom_Count + 1) * sizeof(Atom)); 		D_HLock((Handle)theAtoms);		theAtomsPtr = *theAtoms;		for(i = 0; i <= atom_Count;i++)		{			theAtomsPtr[i].atomicNum = oldestCrystal.theAtom[i].atomicNumber;			theAtomsPtr[i].x = (double)oldestCrystal.theAtom[i].x;			theAtomsPtr[i].y =(double)oldestCrystal.theAtom[i].y;			theAtomsPtr[i].z = (double)oldestCrystal.theAtom[i].z;			theAtomsPtr[i].wyckOffNum = 0;			theAtomsPtr[i].bi = 0;		}		D_HUnlock((Handle)theAtoms);	}	spaceGrpNm		= 1;	GetSvals();	CellVolume();	DetermineCrystalFaces();	DetermineVertices();	DetermineEdges();		return;}void		Crystal::DoPrint(void){	TPPrPort 	thePrintPort;	GrafPtr 	oldPort;	short 		theTop,theLeft,i,j,oldLeft,oldTop;	TPrStatus 	theStatus;	Rect 		theRect,pictRect;	char 		theText[255];	PicHandle 	thePict;	short		secnColLeft;	short 		firstTop;		short pageLeft = 20;	short pageTop = 20;	short charWidth12 = 10;	short charHeight12 = 14;	short pageNo = 1;	FontInfo theFont;	GetPort(&oldPort);	PrOpen();	theLeft = pageLeft;		GetFontInfo(&theFont);	charHeight12 = theFont.ascent + theFont.descent + theFont.leading;	charWidth12 = theFont.widMax;		theTop = pageTop + (2 * charHeight12) + 10;		if(!gPrintRecHandle) gPrintRecHandle = (THPrint)GetResource('PREC',(short)1000);		if(GetHandleSize((Handle)gPrintRecHandle) != sizeof(TPrint)){		SetHandleSize((Handle)gPrintRecHandle,sizeof(TPrint));		ChangedResource((Handle)gPrintRecHandle);		WriteResource((Handle)gPrintRecHandle);	}						if(!PrJobDialog(gPrintRecHandle)){		//ReleaseResource((Handle)gPrintRecHandle);		PrClose(); 		SetPort(oldPort);		return;	}	thePict = DisplayCrystal(&pictRect,theLeft,theTop);	thePrintPort = PrOpenDoc(gPrintRecHandle,0L,0L);	theRect = (*gPrintRecHandle)->prInfo.rPage;	PrOpenPage(thePrintPort,0L);	SetPort((GrafPtr)thePrintPort);	theTop -= 2 * charHeight12 + 10;	theLeft = theLeft;		MoveTo(theLeft,theTop);	sprintf(gTheText,"Crystal Name:  ");	strcat(gTheText,crystalName); 	DrawDiffractString(c2pstr(gTheText));	theTop += charHeight12;		MoveTo(theLeft,theTop);	sprintf(gTheText,"Chemical Formula:  ");	strcat(gTheText,formulaText); 	DrawDiffractString(c2pstr(gTheText));	DrawPicture(thePict,&pictRect);		theLeft = pictRect.right + charWidth12;	MoveTo(theLeft,theTop);	oldLeft = theLeft;	oldTop = theTop;		secnColLeft = theLeft = pictRect.right + 10;	theTop = pictRect.top + 15;	sprintf(gTheText,"The Wyckoff Positions");	MoveTo(theLeft,theTop);	DrawDiffractString(c2pstr(gTheText));		theTop += .5 * charHeight12;	for(i = 0; i <= wy_Atom_Count;i++){		theTop += charHeight12;		MoveTo(theLeft,theTop);		strcpy(gTheText,theWyckAtoms[i].wckoffPosName);		sprintf(theText,"   %6.4f   %6.4f   %6.4f   ",theWyckAtoms[i].x,theWyckAtoms[i].y,theWyckAtoms[i].z);		strcat(gTheText,theText);		GetAtomicSymbol(theWyckAtoms[i].atomicNum,theText);		strcat(gTheText,theText);		DrawDiffractString(c2pstr(gTheText));		TestPosition( &thePrintPort, theRect, &theTop,&theLeft, pageTop, pageLeft, secnColLeft,&pageNo);	}		if(theTop < pictRect.bottom + 20){		theTop = pictRect.bottom + 20;	}		theLeft = pageLeft;		sprintf		(gTheText,"Reference:  ");	strcat		(gTheText,cODEN);	sprintf		(theText,"   Author:  ");	strcat		(gTheText,theText);	strcat		(gTheText,author);	MoveTo		(theLeft,theTop);	DrawDiffractString	(c2pstr(gTheText));	theTop 	+= 	charHeight12;		MoveTo		(theLeft,theTop);	sprintf		(gTheText,"Vol/Page:  ");	strcat		(gTheText,reference);	sprintf		(theText,"   year:  %d",year);	strcat		(gTheText,theText);	DrawDiffractString	(c2pstr(gTheText));	theTop += charHeight12;		MoveTo(theLeft,theTop);	sprintf(gTheText,"JCPDF file no:  %d  card no:  %d",fileNo,cardNo);	DrawDiffractString(c2pstr(gTheText));		j = 0;	theTop += charHeight12 + 5;	if(lastUserDef >= 0){		for(i = 0; i <= lastUserDef / 2;i++){			short oldTop,maxTop;			oldTop = theTop;			theUserAtoms[j]->TextUDAtom(105 + j,&theLeft,&theTop);			maxTop = theTop;			j++;			if(j <=  lastUserDef){				theLeft = secnColLeft; 				theTop = oldTop;				theUserAtoms[j]->TextUDAtom(105 + j,&theLeft,&theTop);				if(maxTop > theTop)					theTop = maxTop;							}			j++;			theLeft = pageLeft;		}		}	firstTop = theTop;	sprintf(gTheText,"Individual Atomic Positions");	MoveTo(theLeft,theTop);	DrawDiffractString(c2pstr(gTheText));	theTop += 5;		for(i = 0; i <= atom_Count;i++){		theTop += charHeight12;		MoveTo(theLeft,theTop);		sprintf(gTheText," %6.4f %6.4f %6.4f   ",(*theAtoms)[i].x,(*theAtoms)[i].y,(*theAtoms)[i].z);		GetAtomicSymbol((*theAtoms)[i].atomicNum,theText);		strcat(gTheText,theText);		DrawDiffractString(c2pstr(gTheText));		oldLeft = theLeft;		oldTop = theTop;		if(pageNo == 1){			TestPosition( &thePrintPort, theRect, &theTop,&theLeft, firstTop, pageLeft,secnColLeft,&pageNo);			if(pageNo > 1){				theTop = pageTop;			}		}else			TestPosition( &thePrintPort, theRect, &theTop,&theLeft, pageTop, pageLeft,secnColLeft,&pageNo);		if(oldLeft != theLeft || oldTop != theTop){			sprintf(gTheText,"Individual Atomic Positions");			MoveTo(theLeft,theTop);			DrawDiffractString(c2pstr(gTheText));			theTop += charHeight12;		}	}			PrClosePage(thePrintPort);	PrCloseDoc(thePrintPort);	if((*gPrintRecHandle)->prJob.bJDocLoop == bSpoolLoop){		PrPicFile(gPrintRecHandle,0L,0L,0L,&theStatus);	}	KillPicture(thePict); 	//ReleaseResource((Handle)gPrintRecHandle);	PrClose();	SetPort(oldPort);	ClipRect(&oldPort->portRect);	gCurrentObj->DMForeColor(BLACK);	gCurrentObj->DMBackColor(WHITE);}void Crystal::ChemicalFormula(void){	char 	theText[256],theText1[40];	short 	i,j,numberOfElement,elementNo ;	short	theTotalElements[20];	AtomPtr theAtomsPtr;	if(referenceInfoSet) 		return;	gTheText[0] = NUL;	D_HLock((Handle)theAtoms);	theAtomsPtr = *theAtoms;	for(i = 0; i <= noDifrntElem - 1;i++)	{		short atNum;		short valance;		elementNo = elementList[i] + 1;		numberOfElement = 0;		for(j = 0; j <= atom_Count;j++){			atNum 	= 	theAtomsPtr[j].atomicNum;			valance = 	ReturnValance(&atNum);			if(elementNo == atNum)					numberOfElement++;		}		theTotalElements[i] = numberOfElement;	}	for (i = 17.0 ; i >= 2.0; i--){		for(j = 0; j <= noDifrntElem - 1;j++){			if(theTotalElements[j] % i)				goto START;		}		for(j = 0; j <= noDifrntElem - 1;j++){			theTotalElements[j] /= i;		}		i++;		START:;	}	for(i = 0; i <= noDifrntElem - 1;i++)	{		elementNo = elementList[i] + 1;		GetAtomicSymbol(elementNo,theText);		if(theTotalElements[i] > 1){			sprintf(theText1,"%d ",theTotalElements[i]);			strcat(theText,theText1);		}		strcat(gTheText,theText);	}	D_HUnlock((Handle)theAtoms);	KillPtr((Ptr)formulaText);	formulaText = D_NewPtr(sizeof(char) * (strlen(gTheText) + 1));	strcpy(formulaText,gTheText);	return;}#define	Z_TAB0	(theLeft + 20)#define	Z_TAB1	(theLeft + 200)#define	Z_TAB2	(theLeft + 110)#define	Z_TAB3	(theLeft + 240)void Crystal::TableDisplayCrystal(short *orgLeft,short *orgTop){	short 		length,i,width,j;	Rect			frameRect;	double		density;	short 		theTop,theLeft,oldTop,charHeight = 12,charWidth;	FontInfo theFont;	Handle theHandle;	short theID;	ResType theType;	char	theText[255];	double  atWt,targetZ;		GetFontInfo(&theFont);	charHeight = theFont.ascent + theFont.descent + theFont.leading;	charWidth = theFont.widMax;	theLeft = *orgLeft;	theTop = *orgTop;	SetRect(&frameRect,theLeft,theTop - charHeight + 1,theLeft + charWidth * 29,theTop + 6 * charHeight + 2);		dm_EraseRect(&frameRect);		if(!gCurrentObj->printing)/*Jim August 1993*/		InvalRect(&frameRect);					/******Eric added this to fix search dialog Aug 1993*/			sprintf(gTheText,"Chemical Formula:  ");	strcat(gTheText,formulaText); 	MoveTo(Z_TAB0,theTop);	DrawDiffractString(c2pstr(gTheText));		length = StringWidth(pTheText);	sprintf(gTheText,"Year: %d ",year);	MoveTo(Z_TAB1,theTop);	DrawDiffractString(c2pstr(gTheText));		sprintf(gTheText,"Crystal Type:  Orthorhombic");	c2pstr(gTheText);	width = StringWidth(pTheText);	p2cstr(pTheText);		switch(lattice_Type){		case	CUBIC:			theHandle = GetResource('Cubc',spaceGrpNm);			sprintf(&(gTheText[14])," Cubic");			break;		case	TETRAGONAL:			theHandle = GetResource('Tetr',spaceGrpNm);			sprintf(&(gTheText[14])," Tetragonal");			break;		case	ORTHORHOMBIC:			theHandle = GetResource('Orth',spaceGrpNm);			sprintf(&(gTheText[14])," Orthorhombic");			break;		case	TRIGONAL:			theHandle = GetResource('Trig',spaceGrpNm);			sprintf(&(gTheText[14])," Trigonal");			break;		case	TRIGHEX:			theHandle = GetResource('Trhx',spaceGrpNm);			sprintf(&(gTheText[14])," Rhombohedral");			break;		case	HEXAGONAL:			theHandle = GetResource('Hexa',spaceGrpNm);			sprintf(&(gTheText[14])," Hexagonal");			break;		case	MONOCLINIC:			theHandle = GetResource('Mono',spaceGrpNm);			sprintf(&(gTheText[14])," Monoclinic");			break;		case	TRICLINIC:			if(spaceGrpNm) theHandle = GetResource('Tric',spaceGrpNm);						sprintf(&(gTheText[14])," Triclinic");			break;		default:			sprintf(&(gTheText[14])," ????");			break;	}	c2pstr(gTheText);		length = StringWidth((unsigned char*)gTheText);	theTop += charHeight + 4;	MoveTo(Z_TAB0,theTop);	DrawDiffractString((unsigned char*)gTheText);				density = CrystalDensity(&atWt,&targetZ);	oldTop = theTop + 14;	if(spaceGrpNm){		GetResInfo(theHandle,&theID,&theType,(unsigned char*)theText);		p2cstr((unsigned char*)theText);		sprintf(gTheText,"Space Group No = ");		strcat(gTheText,theText);			}else{		sprintf(gTheText,"Space Group No = Not Given");	}	if(theHandle)ReleaseResource(theHandle);	MoveTo(Z_TAB1,theTop);	DrawDiffractString(c2pstr(gTheText));		/* theTop += 14; */				for(i = 2 ; i <= 10 ; i++){		switch(i){			case 2:				sprintf(gTheText,"a = %5.2f Å",theUnitCell.a);				break;			case 5:				sprintf(gTheText,"b = %5.2f Å",theUnitCell.b);				break;			case 8:				sprintf(gTheText,"c = %5.2f Å",theUnitCell.c);				break;			case 3:				sprintf(gTheText,"alpha = %5.2f °",theUnitCell.alpha);				break;			case 6:				sprintf(gTheText,"beta  = %5.2f °",theUnitCell.beta);				break;			case 9:				sprintf(gTheText,"gamma = %5.2f °",theUnitCell.gamma);				break;			case 4:				if(volume < 5 || volume > 10e100){					sprintf(gTheText,"volume not given");				}else				sprintf(gTheText,"volume = %8.3f Å3",volume);				break;			case 7:				sprintf(gTheText,"Red. Vol. = %8.3f Å3",volumeReduced);				break;			case 10:				if(density < .5 || density > 50){					sprintf(gTheText,"density not given");				}else 				sprintf(gTheText,"density = %8.3f gm/cm3",density);				break;		}		c2pstr(gTheText);		length = StringWidth((unsigned char*)gTheText);		j = (i + 1) % 3;		switch(j){			case 0:				theTop += 14;				MoveTo(Z_TAB0,theTop);				break;			case 1:				MoveTo(Z_TAB2,theTop);				break;			case 2:				MoveTo(Z_TAB3,theTop);				break;			default:				break;		}		DrawDiffractString((unsigned char*)gTheText);			}		PenNormal();	*orgTop = theTop + 40;	*orgLeft = theLeft + length;	return;}void Crystal::DetermineVertices(void){	long i,j,k;	CrystalFace *facePtr1,*facePtr2,*facePtr3,*theFacesPtr;		last_Vertice				= -1;		D_HLock((Handle)theFaces);	theFacesPtr = *theFaces;		for(i = 0 ; i <= face_Count; i++){		facePtr1 = &(theFacesPtr[i]);		for(j = 0; j <= face_Count; j++){			if(j == i)				continue;			facePtr2 = &(theFacesPtr[j]);			if(FacesParallel(facePtr1,facePtr2)) continue; 							for(k = 0 ; k <= face_Count; k++){				if(k == i || k == j) continue;									facePtr3 = &(theFacesPtr[k]);								if(FacesParallel(facePtr1,facePtr3)) continue;				if(FacesParallel(facePtr2,facePtr3)) continue;									DetermineInterceptionPoint(i,j,k);			}		}	}	D_HUnlock((Handle)theFaces);}void Crystal::DetermineInterceptionPoint(short face1,short face2,short face3){	double matrix[9],x[3],x1,x2,x3,L;	long n,i;	long sizeOf;	long maxAllowedItems;	CrystalVertice *theVPtr1,*theVertsPtr;	CrystalFace *facePtr1;	CrystalFace *facePtr2;	CrystalFace *facePtr3;	CrystalFace *theFacesPtr;		theFacesPtr = *theFaces;		facePtr1 = &(theFacesPtr[face1]);	facePtr2 = &(theFacesPtr[face2]);	facePtr3 = &(theFacesPtr[face3]);		n = 0;	matrix[0] = (double)facePtr1->x;	matrix[1] = (double)facePtr1->y;	matrix[2] = (double)facePtr1->z;	matrix[3] = (double)facePtr2->x;	matrix[4] = (double)facePtr2->y;	matrix[5] = (double)facePtr2->z;	matrix[6] = (double)facePtr3->x;	matrix[7] = (double)facePtr3->y;	matrix[8] = (double)facePtr3->z;	{		double L1;		L = Determinate3x3Matrix(matrix);		L1 = L;			if(fabs(L1) < .0001)			return;	}	matrix[0] = (double)facePtr1->y;	matrix[1] = (double)facePtr1->z;	matrix[2] = (double)facePtr1->length;	matrix[3] = (double)facePtr2->y;	matrix[4] = (double)facePtr2->z;	matrix[5] = (double)facePtr2->length;	matrix[6] = (double)facePtr3->y;	matrix[7] = (double)facePtr3->z;	matrix[8] = (double)facePtr3->length;		x[0] = (Determinate3x3Matrix(matrix)) / L;		matrix[0] = (double)facePtr1->z;	matrix[1] = (double)facePtr1->x;	matrix[2] = (double)facePtr1->length;	matrix[3] = (double)facePtr2->z;	matrix[4] = (double)facePtr2->x;	matrix[5] = (double)facePtr2->length;	matrix[6] = (double)facePtr3->z;	matrix[7] = (double)facePtr3->x;	matrix[8] = (double)facePtr3->length;	x[1] = (Determinate3x3Matrix(matrix)) / L;		matrix[0] = (double)facePtr1->x;	matrix[1] = (double)facePtr1->y;	matrix[2] = (double)facePtr1->length;	matrix[3] = (double)facePtr2->x;	matrix[4] = (double)facePtr2->y;	matrix[5] = (double)facePtr2->length;	matrix[6] = (double)facePtr3->x;	matrix[7] = (double)facePtr3->y;	matrix[8] = (double)facePtr3->length;	x[2] = (Determinate3x3Matrix(matrix)) / L;		D_HUnlock((Handle)theFaces);	n = CornerInsideVolume(x);	D_HLock((Handle)theFaces);		if(n > 0){				x1 = x[0];		x2 = x[1];		x3 = x[2];		sizeOf	=	sizeof(CrystalVertice);		maxAllowedItems = GetHandleSize((Handle)theVertices) / sizeOf;		D_HLock((Handle)theVertices);		theVertsPtr = *theVertices;		if(last_Vertice > 1){			for(i = 0; i <= last_Vertice; i++){				theVPtr1 = &(theVertsPtr[i]);				if(fabs((double)theVPtr1->x - x1) <= .01					&& fabs((double)theVPtr1->y - x2) <= .01					&& fabs((double)theVPtr1->z - x3) <= .01)					n = 0;			}					}		if(n > 0){			++last_Vertice;			if(!CheckHandleSize((Handle)theVertices,&maxAllowedItems,(long)(last_Vertice + 1),sizeOf)){				 D_HUnlock((Handle)theVertices);				 return;			}									theVertsPtr = *theVertices;			theVPtr1 = &(theVertsPtr[last_Vertice]);			theVPtr1->x = (short double)x1;			theVPtr1->y = (short double)x2;			theVPtr1->z = (short double)x3;			theVPtr1->face1 = face1;			theVPtr1->face2 = face2;			theVPtr1->face3 = face3;		}		D_HUnlock((Handle)theVertices);	}	}long Crystal::CornerInsideVolume(double  theAtom[3]){	CrystalFace *facePtr;	long n,i;	Boolean p;	double lengthTest;	n = 1;		p = false;	D_HLock((Handle)theFaces);	facePtr = *theFaces;	for(i = 0; i <= face_Count;i++,facePtr++){		lengthTest = (double)(facePtr->x * theAtom[0] + (double)facePtr->y * theAtom[1] + (double)facePtr->z * theAtom[2]);		if(lengthTest >= facePtr->length + .001){			D_HUnlock((Handle)theFaces);			return 0;		}		if(lengthTest >= -.02)				p = true;		if(lengthTest <= (double)(facePtr->length + .001) && lengthTest >= (double)(facePtr->length - .02))			n = 2;	}	D_HUnlock((Handle)theFaces);	if(p == false)		return 0;	return n ;}Boolean FacesParallel(CrystalFace *facePtr1,CrystalFace *facePtr2){	if(facePtr1->x * facePtr2->y != facePtr1->y * facePtr2->x)		return false;	if(facePtr1->x * facePtr2->z != facePtr1->z * facePtr2->x)		return false;	if(facePtr1->y * facePtr2->z != facePtr1->z * facePtr2->y)		return false;	return true;}void Crystal::DetermineCrystalFaces(void){	long 		i;	double 		dspacing,x,y,z;	CrystalFace *facePtr;	double		theXform[3][3];		D_HLock((Handle)theFaces);	facePtr = *theFaces;	for(i = 0 ; i <= face_Count; i++,facePtr++)	{		double h,k,l,L;		double u,v,w;				facePtr->theCrystal = (Handle)this;		u = h = (double)facePtr->h;		v = k = (double)facePtr->k;		w = l = (double)facePtr->l; 		u = h * sVals[0] + k * sVals[3] + l * sVals[5];		v = h * sVals[3] + k * sVals[1] + l * sVals[4];		w = h * sVals[5] + k * sVals[4] + l * sVals[2];				Get001XForm(theXform);		x = u * theXform[0][0] + v * theXform[0][1] + w * theXform[0][2];		y = u * theXform[1][0] + v * theXform[1][1] + w * theXform[1][2];		z = u * theXform[2][0] + v * theXform[2][1] + w * theXform[2][2];		L = sqrt(x * x + y * y + z * z);		x /= L;		y /= L;		z /= L;		dspacing = DSpacing((short)h,(short)k,(short)l);		facePtr->x = x;		facePtr->y = y;		facePtr->z = z;		facePtr->length =  dspacing * facePtr->area;		facePtr->flags = 0;			}	D_HUnlock((Handle)theFaces);}void Crystal::DetermineEdges(void){	long i,j,k;	long sizeOf;	long maxAllowedItems;	CrystalVertice *cornerPtr,*cornerPtr1,*theVertice;	CrystalEdge *theEdgePtr,*theEdge;	short n,vert1,vert2,face1,face2;	double x[3];	n = 0;	sizeOf 	=	sizeof(CrystalEdge);	maxAllowedItems = GetHandleSize((Handle)(theEdges)) / sizeOf;	last_Edge					= -1;	D_HLock((Handle)theVertices);	D_HLock((Handle)theEdges);	theVertice = *theVertices;	theEdgePtr = *theEdges;	theEdge = *theEdges;	for(i = 0; i <= last_Vertice; i++){		for(k = 0; k <= last_Vertice; k++){			if(k == i)				continue;			cornerPtr  = &(theVertice[k]);			cornerPtr1 = &(theVertice[i]);			if(!CommonFaces(*cornerPtr,*cornerPtr1,&face1,&face2)) continue;						x[0] = (cornerPtr->x + cornerPtr1->x) / 2;			x[1] = (cornerPtr->y + cornerPtr1->y) / 2;			x[2] = (cornerPtr->z + cornerPtr1->z) / 2;			n = AtomAtFace(x);			if(n < 2) continue;			if(last_Edge > 1){				for(j = 0; j <= last_Edge; j++){					vert1 =  theEdge[j].vert1;					vert2 =  theEdge[j].vert2;					if(vert1 == k &&  vert2 == i/* || vert2 == k &&  vert1 == i*/)						n = 0;				}			}			if(n == 0) continue;			last_Edge++;			if(!CheckHandleSize((Handle)theEdges,&maxAllowedItems,(long)(last_Edge + 1),sizeOf)){				 D_HUnlock((Handle)theVertices);				 D_HUnlock((Handle)theEdges);				 return;			}			theEdge = 		*theEdges;			theEdgePtr =   &(theEdge[last_Edge]);			theEdgePtr->vert1 = i;			theEdgePtr->vert2 = k;			theEdgePtr->face1 = face1;			theEdgePtr->face2 = face2;			theEdgePtr->x = cornerPtr->x - cornerPtr1->x;			theEdgePtr->y = cornerPtr->y - cornerPtr1->y;			theEdgePtr->z = cornerPtr->z - cornerPtr1->z;		}	}	D_HUnlock((Handle)theVertices);	D_HUnlock((Handle)theEdges);}Boolean CommonFaces(CrystalVertice theVertice1,CrystalVertice theVertice2,short *face1,short *face2){	short num1[3],num2[3],theFace[9];	short i,k,n;	num1[0] = theVertice1.face1;	num1[1] = theVertice1.face2;	num1[2] = theVertice1.face3;	num2[0] = theVertice2.face1;	num2[1] = theVertice2.face2;	num2[2] = theVertice2.face3;	n = -1;	for(i = 0; i <= 2; i++){		for(k = 0; k <= 2; k++){			if(num1[i] == num2[k])			{				n++;				theFace[n] = num1[i];			}		}	}	if(n == 1){		*face1 = theFace[0];		*face2 = theFace[1];		return true;	}	*face1 = 0;	*face2 = 0;	return true;}long Crystal::AtomAtFace(double  theAtom[3]){	CrystalFace *facePtr,*theFacesPtr;	long i,n;	double lengthTest;	n = 0;	D_HLock((Handle)theFaces);	theFacesPtr = *theFaces;	for(i = 0; i <= face_Count;i++){		facePtr = &(theFacesPtr[i]);		lengthTest = (double)facePtr->x * theAtom[0] + 			(double)facePtr->y * theAtom[1] + 			(double)facePtr->z * theAtom[2];					if(lengthTest <= (double)(facePtr->length + .02) && 			lengthTest >= (double)(facePtr->length - .02))			n++;	}	D_HUnlock((Handle)theFaces);	return n;}void Crystal::CrystalShapeParameters(double crystalVector[][3],Vector *unitFace,Vector *edgeDir,Vector *midPoint,	double *faceDist,double *faceArea,double *length,short *edge_Count){	CrystalEdge 	*theEdgesPtr;	CrystalFace 	*theFacePtr;	CrystalVertice 	theVertice1,theVertice2,*theVerticesPtr;	short 			i,k,j,num,edgeNum;	Vector 			v;	double			linto;	D_HLock((Handle)theFaces);	D_HLock((Handle)theEdges);	D_HLock((Handle)theVertices);	theFacePtr = *theFaces;	theVerticesPtr = *theVertices;	for( i = 0; i <= face_Count;i++,theFacePtr++){		v.x = theFacePtr->x;		v.y = theFacePtr->y;		v.z = theFacePtr->z;		TransFormVector(&v.x,&v.y,&v.z,crystalVector);		if(fabs(v.x) > fabs(v.y))linto = fabs(v.x);else linto = fabs(v.y);		if(fabs(v.z) > linto)linto = fabs(v.z);		v.x /= linto;		v.y /= linto;		v.z /= linto;		unitFace[i] = v;		faceDist[i] = theFacePtr->length;		j = -1;		faceArea[i] = 0;		theEdgesPtr = *theEdges;		for(k = 0; k <= last_Edge;k++,theEdgesPtr++){						if(theEdgesPtr->face1 == i || theEdgesPtr->face2 == i){				v.x = theEdgesPtr->x;				v.y = theEdgesPtr->y;				v.z = theEdgesPtr->z;				TransFormVector(&v.x,&v.y,&v.z,crystalVector);				++j;				edgeNum 				= (i * 12) + j;				edgeDir[edgeNum] 	= v;				length[edgeNum] 	= VectorMag(v);				num 					= theEdgesPtr->vert1;				theVertice1 		= theVerticesPtr[num];								num 					= theEdgesPtr->vert2;				theVertice2 		= theVerticesPtr[num];								v.x = (theVertice1.x +  theVertice2.x)/2;				v.y = (theVertice1.y +  theVertice2.y)/2;				v.z = (theVertice1.z +  theVertice2.z)/2;								TransFormVector(&v.x,&v.y,&v.z,crystalVector);				midPoint[edgeNum] = v;				faceArea[i] += .5 * (length[edgeNum] *  VectorMag(v));			}		}		edge_Count[i] = j;	}	D_HUnlock((Handle)theFaces);	D_HUnlock((Handle)theEdges);	D_HUnlock((Handle)theVertices);}Boolean Crystal::DoUpDate(Crystal *compareCrystal){	if(!compareCrystal->SameCrystal(this)){		GetSvals();		CellVolume();		//SetDSpace();		DetermineCrystalFaces();		DetermineVertices();		DetermineEdges();		/* ChemicalFormula(&retValue); */		return true;	}	return false;}void Crystal::AtomsFromFormula(short total_Atoms){	short i,k,l,m;	long sizeOfTheAtoms;	short theElement;	long	atom_Max;	short theNumber; 	char theChar;	char theText[6];	AtomPtr theAtomsPtr,theAtomPtr,theAtomPtr2;	Boolean flag,flag1,flag2;	char	theNumbers[10] = {'0','1','2','3','4','5','6','7','8','9,'};	char	theCaps[26] = {'A','B','C','D','E','F','G','H','I','J','K',     					'L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};    char    theLower[26] = {'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p',    'q','r','s','t','u','v','w','x','y','z'};    atom_Count = 0;    return;   	atom_Count = total_Atoms;	if(atom_Count <= 0){		 atom_Count = 0;		 return;	}		atom_Max = atom_Count;	sizeOfTheAtoms =  ((long)atom_Count + 2L) * (long)sizeof(Atom);	KillHandle((Handle*)&theAtoms);	theAtoms = (AtomHnd)D_NewHandle(sizeOfTheAtoms);	sizeOfTheAtoms = (long)sizeof(Atom);	if(MemError() != 0 || (Handle)theAtoms == (Handle)NUL){		StopAlert(OUT_OF_MEM,NUL);		{			KeyMap		keyArray;			GetKeys(keyArray);			if(keyArray[1] == 5){				SysBreak();			}		}		return;	}		i = 0;	m = -1;	D_HLock((Handle)theAtoms);	theAtomsPtr = *theAtoms;	while(formulaText[i] != NUL)	{			theChar = formulaText[i];				flag = false;		flag1 = false;		l = 0;		k = 0;		while(!flag && k <= 25 ){			if(theChar == theCaps[k]){ flag = true;i++;theText[l++] = theChar;}			else k++;		}		theChar = formulaText[i];		theText[l] = NUL;		k = 0;		if(flag){			while(!flag1 && k <= 25 ){				if(theChar == theLower[k]) { 					flag1 = true;					i++;					theText[l++] = theChar;					theText[l] = NUL;				}else k++;			}			theElement = this->TheAtomicNum(theText);		}		k = 0;		theChar = formulaText[i];		theNumber = 0;		flag2 = false;		if(flag){RECURSE:	while(k <= 9 ){				if(theChar == theNumbers[k]) { 					i++;					flag2 = true;					theNumber *= 10;					theNumber += k;					theChar = formulaText[i];					k = 0;					goto RECURSE;				}else k++;			}			if(!flag2)theNumber = 1;		}		if(!flag) i++;		else{			if(theElement != 104){				for(k = 1; k <= theNumber;k++){					if(!CheckHandleSize((Handle)theAtoms,&atom_Max,(long)(m + 2),sizeOfTheAtoms)){						D_HUnlock((Handle)theAtoms);						return;					}					theAtomsPtr = *theAtoms;					theAtomPtr = &(theAtomsPtr[++m]);					theAtomPtr->atomicNum = theElement;					theAtomPtr->x = 0;					theAtomPtr->y = 0;					theAtomPtr->z = 0;				 }			}		}	}		if(m <= 0){		theAtomPtr = &(theAtomsPtr[0]);		theAtomPtr->atomicNum = 29;		theAtomPtr->x = 0;		theAtomPtr->y = 0;		theAtomPtr->z = 0;	}	theAtomsPtr = *theAtoms;	i = 0;	while( m <= atom_Count){		theAtomPtr = &(theAtomsPtr[i++]);		theAtomPtr2 = &(theAtomsPtr[++m]);		theAtomPtr2->atomicNum = theAtomPtr->atomicNum;		theAtomPtr2->x = 0;		theAtomPtr2->y = 0;		theAtomPtr2->z = 0;	}	D_HUnlock((Handle)theAtoms);}void Crystal::ReferenceDITL(void){	Boolean		quit=false;	short 		i,type,k;	DialogPtr 		theDialog;	Rect theRect;	theDialog = GetNewDialog(1009,NUL,IN_FRONT);	for(i = 2; i <= 10;i++){		GetDItem(theDialog,i,&type,&gTheHandle,&theRect);		switch(i){			case 2:				strcpy(gTheText,crystalName);				break;			case 3:				sprintf(gTheText,"%d",year);				break;			case 4:				sprintf(gTheText,"%d",atom_Count + 1);				break;			case 5:				strcpy(gTheText,formulaText);				break;			case 6:				ConvertCODENToJournal();				strcpy(gTheText,cODEN);				break;			case 7:				strcpy(gTheText,reference);				break;			case 8:				strcpy(gTheText,author);				break;			case 9:				sprintf(gTheText,"%d",fileNo);				break;			case 10:				sprintf(gTheText,"%d",cardNo);				break;						}					c2pstr(gTheText);		SetIText(gTheHandle,pTheText);	}		while(1 != 2){		SystemTask();		ModalDialog(SmallFilterUPP/*TheFilterUPP*/,&i);		switch(i){						case  DLOG_OK:			case  CANCELCLICK:				DisposDialog(theDialog);				return;						case  13:			/* case  ENTERCLICK: */					for(i = 2; i <= 10;i++){						if(i == 4) continue;						GetDItem(theDialog,i,&type,&gTheHandle,&theRect);						GetIText(gTheHandle,pTheText);						p2cstr(pTheText);						referenceInfoSet = true;						switch(i){							case 2:								k = strlen(gTheText);								if(k  > GetPtrSize((Ptr)crystalName)){									KillPtr((Ptr)crystalName);									crystalName = D_NewPtr((long)(k + 1) * sizeof(char));								}								strcpy(crystalName,gTheText);								break;							case 3:								year = atof(gTheText);								break;							case 5:								k = strlen(gTheText);								if( k > GetPtrSize((Ptr)formulaText)){									KillPtr((Ptr)formulaText);									formulaText = D_NewPtr((long)(k + 1) * sizeof(char));								}								strcpy(formulaText,gTheText);								break;							case 6:								k = strlen(gTheText);								if( k > GetPtrSize((Ptr)cODEN)){									KillPtr((Ptr)cODEN);									cODEN = D_NewPtr((long)(k + 1) * sizeof(char));								}								strcpy(cODEN,gTheText);								break;							case 7:								k = strlen(gTheText);								if( k > GetPtrSize((Ptr)reference)){									KillPtr((Ptr)reference);									reference = D_NewPtr((long)(k + 1) * sizeof(char));								}								strcpy(reference,gTheText);								break;							case 8:								k = strlen(gTheText);								if( k > GetPtrSize((Ptr)author)){									KillPtr((Ptr)author);									author = D_NewPtr((long)(k + 1) * sizeof(char));								}								strcpy(author,gTheText);								break;							case 9:								fileNo = atof(gTheText);								break;							case 10:								cardNo = atof(gTheText);								break;														}				}				DisposDialog(theDialog);				return;				break;				case UPDATE_EVT:				DrawDialog(theDialog);				break;				default:					break;						}	}	}PicHandle Crystal::DrawMorphology(double xForm[3][3],Rect thePicRect)				{	CrystalVertice 	theVert;	double 		scaleFactor;	short 			centerX, centerY;	double 		x1,y1,z1,z2;	PicHandle 		thePict;	CrystalEdge 	*theEdgesPtr;	CrystalVertice 	*theVerticesPtr;	CrystalFace 	*theFacesPtr;	short 			theHor1,theVer1,theHor2,theVer2,i,theDif;	double 		maxLength = 1;	Rect 			theRect;	short			color;	double			length,xMin,yMin,zMin;	RgnHandle		theRgn,oldRgn;	D_HLock			((Handle)theFaces);	D_HLock			((Handle)theEdges);	D_HLock			((Handle)theVertices);	PenMode(0);	theFacesPtr = *theFaces;	oldRgn = D_NewRgn();	GetClip(oldRgn);	theRgn = D_NewRgn();	RectRgn(theRgn,&thePicRect);	D_SetClip(theRgn);	for(i = 0; i <= face_Count;i++) {		if(maxLength < theFacesPtr[i].length) maxLength = theFacesPtr[i].length;	}	theDif 		= 	thePicRect.right - thePicRect.left;	scaleFactor = 	(double)(theDif * .40) / (2 * maxLength);	centerX 	= 	(thePicRect.right + thePicRect.left) / 2;	centerY 	= 	(thePicRect.top + thePicRect.bottom) / 2;	theEdgesPtr = 	*theEdges;	theVerticesPtr = *theVertices;		thePict = OpenPicture(&thePicRect);	SetRect(&theRect,-2,-2,2,2);	xMin = 500;	yMin = 500;	zMin = 500;	for(i = 0; i <= last_Edge;i++){		theVert = theVerticesPtr[theEdgesPtr[i].vert1];		x1 = theVert.x;		y1 = theVert.y;		z1 = theVert.z;		if(xMin > x1)		{			xMin = x1;			yMin = y1;			zMin = z1;		}				TransFormVector(&x1,&y1,&z1,xForm);				color = 4;		if(z1 < 0) color--;		if(z1 > 0) color++;		//theHor1 = x1 * scaleFactor + centerX;		//theVer1 = (-y1 * scaleFactor) + centerY;		theVer1 = x1 * scaleFactor + centerY;		theHor1 = (y1 * scaleFactor) + centerX;		MoveTo(theHor1,theVer1);				theVert = theVerticesPtr[theEdgesPtr[i].vert2];		x1 = theVert.x;		y1 = theVert.y;		z2 = theVert.z;				if(xMin > x1)		{			xMin = x1;			yMin = y1;			zMin = z2;		}		TransFormVector(&x1,&y1,&z2,xForm);		if(z2 < 0) color--;		if(z2 > 0) color++;		//theHor2 = x1 * scaleFactor + centerX;		//theVer2 = (-y1 * scaleFactor) + centerY;		theVer2 = x1 * scaleFactor + centerY;		theHor2 = (y1 * scaleFactor) + centerX;		if(g_Monitor){			gCurrentObj->DMForeColor/*PMForeColor*/(color);		}else{			PenNormal();			PenPat(&qd.black);			gCurrentObj->DMForeColor/*PMForeColor*/(BLACK);		}		LineTo(theHor2,theVer2);					}	TransFormVector(&xMin,&yMin,&zMin,xForm);	length = sqrt(xMin * xMin + yMin * yMin + zMin * zMin);	color = 4;	if(zMin / length < -.4) color = 2;	if(zMin / length > +.4) color = 6;	//theHor2 = xMin * scaleFactor + centerX;	//theVer2 = (-yMin * scaleFactor) + centerY;	theVer2 = xMin * scaleFactor + centerY;	theHor2 = (yMin * scaleFactor) + centerX;	OffsetRect(&theRect,theHor2,theVer2);	if(g_Monitor){		gCurrentObj->DMForeColor/*PMForeColor*/(color);	}else{		PenNormal();		PenPat(&qd.black);		gCurrentObj->DMForeColor/*PMForeColor*/(BLACK);	}	dm_PaintOval	(&theRect);	ForeColor/*PMForeColor*/(BLACK);	ClosePicture();	D_HUnlock	((Handle)theFaces);	D_HUnlock	((Handle)theEdges);	D_HUnlock	((Handle)theVertices);	D_SetClip(oldRgn);	D_DisposeRgn(&theRgn);	D_DisposeRgn(&oldRgn);	return thePict;}short Crystal::GetPointGrp(void){	short pointGrpSet[] = 	{1,2,5,9,15,24,46,74,80,82,88,98,110,122,142,146,	148,155,161,167,173,174,176,182,186,190,194,199,206,214,220,230};	short i = 0;	short spaceGroup;	short pointGrp = 0;		if(spaceGrpNm > 1000)		spaceGroup = spaceGrpNm - 1000;	else		spaceGroup = spaceGrpNm;			while(i <= 31 && pointGrp <= 0){		if(spaceGroup <= pointGrpSet[i])		{			pointGrp = i + 1;		}		i++;	}	return pointGrp;}char* Crystal::PointGrpName(char *theText){	char thePointGroups[32][6] = {"1","¡","2","m","2/m","222","mm2","mmm","4","¢","4/m","422"	,"4mm","¢2m","4/mmm","3","£","32","3m","£m","6","§","6/m","622","6mm","§m2","6/mmm"	,"23","m£","432","¢3m","m3m"};	short i;	short	pointGrp;		pointGrp = GetPointGrp();	for(i = 0; i <= 5;i++)		theText[i] = thePointGroups[pointGrp - 1][i];	return theText;}void Crystal::ElasticConstantSymmetry(void) /* Justin added this july 3 1991 */{	short pointGrp;	pointGrp = GetPointGrp();	switch(pointGrp){			case 1:		case 2:			break;		case 3:		case 4:		case 5:			elasticConstants[3] = elasticConstants[5] = elasticConstants[8] = 			elasticConstants[10] = elasticConstants[12] = elasticConstants[14] = 			elasticConstants[16] = elasticConstants[19] = 0;			break;		case 6:		case 7:		case 8:			elasticConstants[3] = elasticConstants[4] = elasticConstants[5] 			= elasticConstants[8] = 			elasticConstants[9] = elasticConstants[10] = elasticConstants[12] = 			elasticConstants[13] = 			elasticConstants[14] = elasticConstants[16] = elasticConstants[17] = 			elasticConstants[19] = 0;			break;									case 9:		case 10:		case 11:			elasticConstants[6] = elasticConstants[0];			elasticConstants[7] = elasticConstants[2];			elasticConstants[10] = -elasticConstants[5];			elasticConstants[18] = elasticConstants[15];						elasticConstants[3] = elasticConstants[4] =  elasticConstants[8] = 			elasticConstants[9] = elasticConstants[12] = elasticConstants[13] = 			elasticConstants[14] = elasticConstants[16] = elasticConstants[17] =			elasticConstants[19] = 0;			break;		case 12:		case 13:		case 14:		case 15:			elasticConstants[6] = elasticConstants[0];			elasticConstants[7] = elasticConstants[2];						elasticConstants[18] = elasticConstants[15];						elasticConstants[3] = elasticConstants[4] = elasticConstants[5] 			= elasticConstants[8] = elasticConstants[9] = elasticConstants[10] =			 			 elasticConstants[12] = elasticConstants[13] = elasticConstants[14] = 						elasticConstants[16] = elasticConstants[17] = elasticConstants[19] = 0;			break;				case 16:		case 17:					elasticConstants[6] = elasticConstants[0];			elasticConstants[7] = elasticConstants[2];			elasticConstants[8] = -elasticConstants[3];			elasticConstants[4] = -elasticConstants[9];			elasticConstants[17] = elasticConstants[9];			elasticConstants[18] = elasticConstants[15];			elasticConstants[19] = -elasticConstants[3];			elasticConstants[20] = (elasticConstants[0] - elasticConstants[1]) * .5;									elasticConstants[5] = elasticConstants[10] =  elasticConstants[12] = 			elasticConstants[13] = elasticConstants[14] = elasticConstants[16] = 0;				break;				case 18:		case 19:		case 20:					elasticConstants[6] = elasticConstants[0];			elasticConstants[7] = elasticConstants[2];			elasticConstants[8] = -elasticConstants[3];						elasticConstants[18] = elasticConstants[15];			elasticConstants[19] = -elasticConstants[3];			elasticConstants[20] = (elasticConstants[0] - elasticConstants[1]) * .5;						elasticConstants[4] = elasticConstants[9] = elasticConstants[17] =			elasticConstants[5] = elasticConstants[10] =  elasticConstants[12] = 			elasticConstants[13] = elasticConstants[14] = elasticConstants[16] = 0;			break;					case 21:		case 22:		case 23:		case 24:		case 25:		case 26:		case 27:						elasticConstants[6] = elasticConstants[0];			elasticConstants[7] = elasticConstants[2];			elasticConstants[18] = elasticConstants[15];			elasticConstants[20] = (elasticConstants[0] - elasticConstants[1]) * .5;						elasticConstants[3] = elasticConstants[4] =  elasticConstants[5] = 			elasticConstants[8] = elasticConstants[9] = elasticConstants[10] = 			elasticConstants[12] = elasticConstants[13] = elasticConstants[14] =			elasticConstants[16] = elasticConstants[17] = elasticConstants[19] = 0;			break;		case 28:		case 29:		case 30:		case 31:		case 32:			elasticConstants[11] = elasticConstants[6] = elasticConstants[0];			elasticConstants[7] = elasticConstants[2] = elasticConstants[1];			elasticConstants[20] = elasticConstants[18] = elasticConstants[15];						elasticConstants[3] = elasticConstants[4] =  elasticConstants[5] = 			elasticConstants[8] = elasticConstants[9] = elasticConstants[10] = 			elasticConstants[12] = elasticConstants[13] = elasticConstants[14] =			elasticConstants[16] = elasticConstants[17] = elasticConstants[19] = 0;			break;				default:					break;				}	return;}void	Crystal::DetermineBraviasLattice(void){	if(theUnitCell.a == theUnitCell.b &&		theUnitCell.b == theUnitCell.c		&& theUnitCell.alpha == theUnitCell.beta		&& theUnitCell.beta == theUnitCell.gamma		&& theUnitCell.alpha == 90 ){				lattice_Type = CUBIC;				spaceGrpNm = 195;				return;	}	if(theUnitCell.a != theUnitCell.b &&		theUnitCell.b != theUnitCell.c		&& theUnitCell.alpha == theUnitCell.beta		&& theUnitCell.beta == theUnitCell.gamma		&& theUnitCell.alpha == 90 ){				lattice_Type = ORTHORHOMBIC;				spaceGrpNm = 16;				return;	}	if(theUnitCell.a == theUnitCell.b &&		theUnitCell.b != theUnitCell.c		&& theUnitCell.alpha == theUnitCell.beta		&& theUnitCell.beta == theUnitCell.gamma		&& theUnitCell.alpha == 90 ){				lattice_Type = TETRAGONAL;				spaceGrpNm = 16;				return;	}	if(theUnitCell.a == theUnitCell.b &&		theUnitCell.b == theUnitCell.c		&& theUnitCell.alpha == theUnitCell.beta		&& theUnitCell.beta == theUnitCell.gamma		&& theUnitCell.alpha != 90 ){				lattice_Type = TRIGHEX;				spaceGrpNm = 1146;				return;	}	if(theUnitCell.a == theUnitCell.b &&		theUnitCell.b != theUnitCell.c		&& theUnitCell.alpha == theUnitCell.beta		&& theUnitCell.alpha == 90		&& theUnitCell.gamma == 120)		{				lattice_Type = HEXAGONAL;				spaceGrpNm = 168;				return;	}		if(theUnitCell.a != theUnitCell.b &&		theUnitCell.b != theUnitCell.c		&& theUnitCell.alpha != theUnitCell.beta		&& theUnitCell.beta != theUnitCell.gamma		&& theUnitCell.gamma == 90 ){				lattice_Type = MONOCLINIC;				spaceGrpNm = 3;				return;	}			if(theUnitCell.a != theUnitCell.b &&		theUnitCell.b != theUnitCell.c		&& theUnitCell.alpha != theUnitCell.beta		&& theUnitCell.beta != theUnitCell.gamma		 ){				lattice_Type = TRICLINIC;				spaceGrpNm = 1;				return;	}		lattice_Type = TRICLINIC;/*dec 1992 */		spaceGrpNm = 1;		return;	}void	Crystal::AtomicScatteringByD(short theBeamFlag,double theD,double electronMassRation,double *theZs){	short			element = -21131;	double		atomicScatterNum;	short			i;	Atom			*dummyAtom;	dummyAtom = *theAtoms;	for(i = 0; i <= atom_Count; i++,dummyAtom++,theZs++)	{		if(element != (short)dummyAtom->atomicNum){			element 					= (short)dummyAtom->atomicNum;			atomicScatterNum 	= 0.0;			if(element >= 105 && element < 199){				UserDefAtom*	thisUDAtom;				double				percent;				short 				m,theAtom,atNum;								m 						= element - 105;				thisUDAtom 		= theUserAtoms[m];				for(theAtom 	= 0 ; theAtom <= thisUDAtom->lastAtom ; theAtom++){					percent 		= thisUDAtom->theElements[theAtom].percent / 100.;					atNum				= thisUDAtom->theElements[theAtom].atomicNum;					switch(theBeamFlag){						case 1:							atomicScatterNum += (AtomicScatterEl(theD,(double)atNum) * percent);							break;						case 2:							atomicScatterNum += (AtomicScatterXRay(theD,(double)atNum) * percent);							break;						case 3:							atomicScatterNum += (AtomicScatterIon(theD,(double)atNum) * percent);							break;						default:							atomicScatterNum += (AtomicScatterEl(theD,(double)atNum) * percent);							break;					}				}			}else{				switch(theBeamFlag){					case 1:						atomicScatterNum = AtomicScatterEl(theD,(double)element);						break;					case 2:						atomicScatterNum = AtomicScatterXRay(theD,(double)element);						break;					case 3:						atomicScatterNum = AtomicScatterIon(theD,(double)element);						break;					default:						atomicScatterNum = AtomicScatterEl(theD,(double)element);						break;				}			}		}		*theZs = atomicScatterNum   *  electronMassRation;	}}void Crystal::ConvertCODENToJournal(void){	Boolean 	flagFound;	char 		theCheckCoden[255];		short 		vRefNum,refNum,theErr;	short 		i,k,lower,upper,middle;	short 		value;	long 		posOff,formSize,curEOF;		unsigned short theRecord[40],theValues[3]; 		OSErr 		fileError;	unsigned short lowByte = 0x00FF;	char		aText[255];			if(strlen(cODEN) > 7)		return;	sprintf(aText,"CODENS.DAT;1");	fileError = OpenNamedFile(SEARCH_EDD_CODENS,aText,&vRefNum,&refNum);	if(fileError){		sprintf(aText,"CODENS.DAT");		fileError = OpenNamedFile(SEARCH_EDD_CODENS,aText,&vRefNum,&refNum);		if(fileError){			FileErrorMessages_DirPath( fileError);			return ;		}	}	theErr 			= 	GetEOF(refNum,&curEOF);			formSize = 80;	lower = 1;	upper = curEOF/formSize; 	flagFound = false;		posOff = 0;	while(lower <= upper && !flagFound){		 middle = (lower + upper)/2;		posOff = middle * formSize; 				SetFPos(refNum,fsFromStart,posOff);				fileError = FSRead(refNum,&formSize,(Ptr)theRecord);		if(fileError){			FSClose(refNum);			return;		}		for(i = 0; i <= 2;i++) theValues[i] =  ConvertToMacBits(theRecord[i]);		k = 0;		for(i = 0; i <= 2;i++){			theCheckCoden[k] = (char)(theValues[i] & lowByte);			k++;			theCheckCoden[k] = (char)(theValues[i] / 256);			k++;		}		theCheckCoden[k] = NUL;		value = strncmp(theCheckCoden,cODEN,6);		 if(value < 0){			 lower = middle + 1;			continue;		}		if(value > 0){			upper = middle - 1;			continue;		} 		flagFound = true;			}	FSClose(refNum);	if(flagFound){		i = 3;		k = 0;		while(theRecord[i] && i <= 36 ){			*theValues =  ConvertToMacBits(theRecord[i]);			i++;			theCheckCoden[k] = (char)(*theValues & lowByte);			k++;			theCheckCoden[k] = (char)(*theValues / 256);			if(theCheckCoden[k] == 32 && theCheckCoden[k - 1] == 32)				 goto THEEND;			k++;		}		THEEND:		theCheckCoden[k] = NUL;		if(GetPtrSize((Ptr)cODEN) <= k + 1){			KillPtr(cODEN);			cODEN = D_NewPtr((long) (k + 1) * sizeof(char));		}		strcpy(cODEN,theCheckCoden);		}	}void Crystal::Wigner_Seitz(void){	short cellType = 'P';	double xForm[3][3];	Index	*theIndex;	ResType	theType;	short	theID;	Handle 	theHandle;	short		i;	CrystalFace *theFacesPtr,theFace;	if(spaceGrpNm){	switch(lattice_Type){		case	CUBIC:			theHandle = GetResource('Cubc',spaceGrpNm);			break;		case	TETRAGONAL:			theHandle = GetResource('Tetr',spaceGrpNm);			break;		case	ORTHORHOMBIC:			theHandle = GetResource('Orth',spaceGrpNm);			break;		case	TRIGONAL:			theHandle = GetResource('Trig',spaceGrpNm);			break;		case	TRIGHEX:			theHandle = GetResource('Trhx',spaceGrpNm);			break;		case	HEXAGONAL:			theHandle = GetResource('Hexa',spaceGrpNm);			break;		case	MONOCLINIC:			theHandle = GetResource('Mono',spaceGrpNm);			break;		case	TRICLINIC:			if(spaceGrpNm) theHandle = GetResource('Tric',spaceGrpNm);			break;		default:			break;	}	}	if(spaceGrpNm){		GetResInfo(theHandle,&theID,&theType,pTheText);		p2cstr(pTheText);		i = 0;		while(gTheText[i] != ' ')i++;		while(gTheText[i] == ' ')i++;		cellType = gTheText[i];			}	if(theHandle)ReleaseResource(theHandle);	KillHandle((Handle*)&theFaces);	theFaces = (CrystalFaceHnd)D_NewHandle(68 * sizeof(CrystalFace));	KillHandle((Handle*)&theEdges);	theEdges 		= 	(CrystalEdgeHnd)D_NewHandle(75 * sizeof(CrystalEdge));	KillHandle((Handle*)&theVertices);					theVertices 	= (CrystalVerticeHnd)D_NewHandle(75 * sizeof(CrystalVertice));		theFacesPtr = *theFaces;	face_Count = -1;	theFace.area = .5;		theFace.h = 0; theFace.k = 0;theFace.l = 1;	theFace.theCrystal = (Handle)this;	theFace.direction = false;	theFace.x = 0;	theFace.y = 0;	theFace.z = 0;	theFace.length = 0.0;	theFace.flags = 0;	if(spaceGrpNm < 1000){		CubicPermutate(&face_Count,theFace,theFacesPtr,true,CUBIC);		theFace.h = 1; theFace.k = 1;theFace.l = 0;		CubicPermutate(&face_Count,theFace,theFacesPtr,true,CUBIC);		theFace.h = 1; theFace.k = 1;theFace.l = 1;		CubicPermutate(&face_Count,theFace,theFacesPtr,true,CUBIC);	}else{				i = 0;		theFacesPtr[i].h = -1; theFacesPtr[i].k = 1;theFacesPtr[i].l = 1;				i++;		theFacesPtr[i].h = 2; theFacesPtr[i].k = 1;theFacesPtr[i].l = 1;		i++;		theFacesPtr[i].h = 1; theFacesPtr[i].k = -1;theFacesPtr[i].l = 2;		i++;		theFacesPtr[i].h = -1; theFacesPtr[i].k = -2;theFacesPtr[i].l = 1;					i++;		theFacesPtr[i].h = -1; theFacesPtr[i].k = 1;theFacesPtr[i].l = -1;		i++;		theFacesPtr[i].h = 2; theFacesPtr[i].k = 1;theFacesPtr[i].l = -1;		i++;		theFacesPtr[i].h = 1; theFacesPtr[i].k = -1;theFacesPtr[i].l = -2;		i++;		theFacesPtr[i].h = -1; theFacesPtr[i].k = -2;theFacesPtr[i].l = -1;		/*i++;		theFacesPtr[i].h = 1; theFacesPtr[i].k = 2;theFacesPtr[i].l = -2;		i++;		theFacesPtr[i].h = -2; theFacesPtr[i].k = -1;theFacesPtr[i].l = -2;		*/						i++;		theFacesPtr[i].h = 0; theFacesPtr[i].k = 1;theFacesPtr[i].l = 0;		i++;		theFacesPtr[i].h = 0; theFacesPtr[i].k = -1;theFacesPtr[i].l = 0;		i++;		theFacesPtr[i].h = 1; theFacesPtr[i].k = 0;theFacesPtr[i].l = 0;		i++;		theFacesPtr[i].h = -1; theFacesPtr[i].k = 0;theFacesPtr[i].l = 0;		i++;		theFacesPtr[i].h = 1; theFacesPtr[i].k = 1;theFacesPtr[i].l = 0;		i++;		theFacesPtr[i].h = -1; theFacesPtr[i].k = -1;theFacesPtr[i].l = 0;				face_Count = i;	}	theIndex = (Index*)D_new(Index);	theIndex->DoInit(true,this);	theIndex->reduceFlag = true;	Get001XForm( xForm);			for(i = 0; i <= face_Count; i++){		double theLength,u,v,w,dspacing;		theIndex->h = theFacesPtr[i].h;		theIndex->k = theFacesPtr[i].k;		theIndex->l = theFacesPtr[i].l;		theIndex->GetXYZ(xForm);		theLength = theIndex->GetLength();		theIndex->PlaneNormalOfDir(&u,&v,&w);		theIndex->x = u;		theIndex->y = v;		theIndex->z = w;		theIndex->ConvertXYZToHKLReduce();				theIndex->direction = false;		dspacing = theIndex->TheDSpacing();		theIndex->direction = true;		theFacesPtr[i].area = theLength * theFace.area / dspacing;		theFacesPtr[i].h = theIndex->h;		theFacesPtr[i].k = theIndex->k;		theFacesPtr[i].l = theIndex->l;	}	theIndex->DoClose();		switch(cellType){		case 'F':			for(i = 6; i <= 17;i++)theFacesPtr[i].area /= 2.0;			break;		case 'I':			for(i = 18; i <= 25;i++)theFacesPtr[i].area /= 2.0;			break;		case 'C':			for(i = 6; i <= 9;i++)theFacesPtr[i].area /= 2.0;			break;		case 'B':			for(i = 10; i <= 13;i++)theFacesPtr[i].area /= 2.0;			break;		case 'A':			for(i = 14; i <= 17;i++)theFacesPtr[i].area /= 2.0;			break;		case 'R':			if(spaceGrpNm > 1000){				for(i = 0; i <= 7;i++)theFacesPtr[i].area /= 3.0;			}						break;		return;	}}void	Crystal::CleanBadPlanes(void){	short 			test[200];	CrystalFace 	*theFacePtr;	CrystalEdge 	*theEdgePtr;	short 			i,j;		D_HLock((Handle)theFaces);	D_HLock((Handle)theEdges);	theFacePtr = *theFaces;	theEdgePtr = *theEdges;	for(i = 0; i <= face_Count;i++) test[i] = 0;	for(i = 0; i <= last_Edge; i++){		test[theEdgePtr[i].face1] = true;		test[theEdgePtr[i].face2] = true;	}	theFacePtr = *theFaces;		for(i = 0; i <= face_Count;i++){		if(!test[i]){			for(j = i ; j <= face_Count - 1;j++){				theFacePtr[j] = theFacePtr[j  + 1];				test[j] = test[j + 1];			}			face_Count--;			i--;		}	}	D_HUnlock((Handle)theFaces);	D_HUnlock((Handle)theEdges);}void	Crystal::GetPlaneOf3Points(double x3[3],double y3[3],double z3[3],short *h,short *k,short *l){	double u,v,w,			angleA,angleB,angleC,			radConvert,			xForm[3][3],			x1,y1,z1;	Index	*theIndex;	radConvert = PI / 180.0;		theIndex = (Index*)D_new(Index);	theIndex->DoInit(true,this);	theIndex->h  = 0;	theIndex->k  = 0;	theIndex->l  = 1;				x1 = y3[0] * (z3[1] - z3[2]) + y3[1] * (z3[2] - z3[0]) + y3[2] * (z3[0] - z3[1]);	y1 = z3[0] * (x3[1] - x3[2]) + z3[1] * (x3[2] - x3[0]) + z3[2] * (x3[0] - x3[1]);	z1 = x3[0] * (y3[1] - y3[2]) + x3[1] * (y3[2] - y3[0]) + x3[2] * (y3[0] - y3[1]);		Get001XForm(xForm);			TransFormVector(&x1,&y1,&z1,xForm);		angleA = theUnitCell.alpha * radConvert;	angleB = theUnitCell.beta * radConvert;	angleC = theUnitCell.gamma * radConvert;	u = x1 / (theUnitCell.a * sin(angleB) * sin(angleC));		v = (y1 - u * theUnitCell.a *sin(angleB) * cos(angleC)) /											(theUnitCell.b * sin(angleA));												w = (z1 - v * theUnitCell.b * cos(angleA) -					u * theUnitCell.a * cos(angleB) ) / theUnitCell.c;	theIndex->h = Round(100 * u);	theIndex->k = Round(100 * v);	theIndex->l = Round(100 * w);	theIndex->direction = true;	theIndex->PlaneNormalOfDir(&u,&v,&w);	theIndex->h = u;	theIndex->k = v;	theIndex->l = w;	theIndex->reduceFlag = true;	theIndex->ReduceIndex();	*h = theIndex->h;	*k = theIndex->k;	*l = theIndex->l;	theIndex->DoClose();	return;}