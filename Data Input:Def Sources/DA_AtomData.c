#include	"Diffract_INCs.h"//Macintosh HD:CodeWarriorª DR/3 Gold Ä:Metrowerks  C/C++ Ä:Projects:D.M. v2.0:Sources.Jim:Data Input/Def Sources:DA_AtomData.c#include 	"AtomicScatter.h"#include 	"AtomData.h"void AtomData::DoInit(short theNumber){	atomNumber = theNumber + 1;}void AtomData::DoClose(void){	D_delete(this);}Boolean AtomData::GetTheText(short segment,short subsegment,char *theText){	Handle theResHnd;	short i,k,j,l;	char theChar;	char *theString;	//Name,symbol,atomic#,atomic Mass,valance state(e-config),e-affinity,e-negativity,work function	//orbitals,denisty,tempmelting,(#12)tempboiling,valences,radii,ionization,electrochemical series,	//isotopes,%,mu¬µ,thermal barns,spin,isotope,b,coherent,total,crystals,transition temp	theText[0] = NUL;	theResHnd = GetResource('AtIn',atomNumber);	if(theResHnd == 0L) return false;	HLock((Handle)theResHnd);	theString = (char*)*theResHnd;	j = 0;	i = 0;	while(i != segment ){		theChar = theString[j];		if(theChar == 9) i++;		j++;		if(theString[j] == 0) return false;	}	k = 0;		while(k != subsegment){		theChar = theString[j];		if(theChar == ',') k++;		if(theChar == 9) return false;		j++;		if(theString[j] == 0) return false;	}		l = 0;	theChar = theString[j];	while(theChar != ',' && theChar != 9 && theChar != NUL){		theText[l] = theChar;		l++;		j++;		theChar = theString[j];	}	if(l == 0 && theText[l] == NUL) return false; 	while(l <= 9){		theText[l] = ' ';		l++;	}	theText[l] = NUL; 	HUnlock((Handle)theResHnd);	ReleaseResource((Handle)theResHnd);	return true;}float	AtomData::GetRadius(short radiusType,Crystal *aCrystal)	{	short	radType;	float  sumRadius;	AtomData *theAtomData;	if(atomNumber > 0 && atomNumber <= 105){		switch(radiusType){			case 1:				radType = 'c';				break;			case 2:				radType = 'm';				break;			case 3:				radType = 'v';				break;		}		return ReturnRadius(radType);	}else{		 if(atomNumber < 0 || atomNumber > 199){			radType = aCrystal->ReturnValance(&atomNumber);			return ReturnRadius(radType);		}else{			UserDefAtom*	thisUDAtom;			double	percent;			short m,theAtom,atNum;			m =  atomNumber  - 106;			theAtomData = (AtomData*)D_new(AtomData);			thisUDAtom = aCrystal->theUserAtoms[m];			sumRadius = 0.0;			for(theAtom = 0 ; theAtom <= thisUDAtom->lastAtom ; theAtom++){				percent = thisUDAtom->theElements[theAtom].percent / 100.;				atNum	= thisUDAtom->theElements[theAtom].atomicNum;				theAtomData->DoInit(atNum);				sumRadius += theAtomData->GetRadius(radiusType,aCrystal) * percent;			}			theAtomData->DoClose();			return sumRadius;		}	}		}	float			AtomData::ReturnRadius(short radType){	short i,k,j;	char theText[256],aText[256];	Boolean done;			j = k = 0;	done = false;	i = 0;	while(GetTheText(13,i,theText)){		i++;		j = 0;		while(theText[j] != ',' && theText[j] != 9 && theText[j] != NUL && !done){			if(theText[j] == '='){				if(radType < 0){					aText[0] = theText[j-2];					aText[1] = theText[j-1];					aText[2] = 0;					if(atof(aText) == radType) return atof(&theText[j+1]);				}else{					if(radType < 15){						if((atof(&theText[j-1])) == radType) return atof(&theText[j+1]);					}else{						if((short)(theText[j-1]) == radType) return atof(&theText[j+1]);					}				}			}			j++;		}	}	 switch(radType){	 	case 'v':			radType = 'c';			break;		case 'c':			radType = 'm';			break;		case 'm':			radType = 'c';			break;		default:			radType = 'c';	 } 	i = 0;	while(GetTheText(13,i,theText)){		i++;		j = 0;		while(theText[j] != ',' && theText[j] != ' ' && theText[j] != NUL && !done){			if(theText[j] == '='){				if(radType < 0){					aText[0] = theText[j-2];					aText[1] = theText[j-1];					aText[2] = 0;					if(atof(aText) == radType) return atof(&theText[j+1]);				}else{					if(radType < 15){						if((atof(&theText[j-1])) == radType) return atof(&theText[j+1]);					}else{						if((short)(theText[j-1]) == radType) return atof(&theText[j+1]);					}				}			}			j++;		}	}	return 1.5;}