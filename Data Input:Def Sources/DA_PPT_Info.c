#include	"Diffract_INCs.h"#include 	"crystalFaceObj.h"#include	"DA_PPT_Info.h"#include 	"ML_PPT_Info.h"//Macintosh HD:CodeWarriorª DR/3 Gold Ä:Metrowerks  C/C++ Ä:Projects:D.M. v2.0:Sources.Jim:Data Input/Def Sources:DA_PPT_Info.cvoid	DrawLines(DialogPtr theDialog);void	PPT_Info::DoInit(Crystal*	thatCrystal)		/*  ORel obj w/ Index obj	*/{	short	i;	ORel*	theO_Rel;		theCrystal = thatCrystal;	theO_Rel	= (ORel*)D_new(ORel);	if(HandleIsOK((Handle)theO_Rel)){		if(!(theO_Rel->DoInit(theCrystal))){			D_delete(theO_Rel);			lastOR	= -1;			return;		}		theORs[0] = theO_Rel;		lastOR	= 0;	}	for(i = 1 ; i<= MAX_NUM_OR - 1 ; i++){		theORs[i] = (ORel*)NUL;	}	intensity = 1.0;}			void	PPT_Info::DoClose(void){	short i;			for(i = 0 ; i <= lastOR ; i++){		theORs[i]->DoClose();	}	lastOR = -1;	D_delete(this);	return;}void	PPT_Info::DoEdit(void){	PPT_Info*			theNewPPT_Info;	ML_PPTParamsPtr		theMLParms;	DialogPtr		 	theDialog;	Boolean				quitFlag;	short				theSelect;	theNewPPT_Info = (PPT_Info*)D_new(PPT_Info);	if(HandleIsOK((Handle)theNewPPT_Info)){		theNewPPT_Info->DoInit(theCrystal);		DoCopy(theNewPPT_Info);				//SetDialogMenuBar();				//		This is the Pre Multilog Code//		if(theNewPPT_Info->DoDefine()){//			theNewPPT_Info->DoCopy(this);//			gCurrentObj->changedFlag = true;//		}//		quitFlag		= false;		theDialog 		= DM_GetNewDialog(OR_DEF_DLOG,NUL,IN_FRONT);		ML_DoPPTSetup((Ptr)theNewPPT_Info,theDialog,(Ptr*) &theMLParms);				while(!quitFlag){			ModalDialog(TheFilterUPP,&theSelect);			switch(theSelect){				case DLOG_OK:					ML_DoPPTRead((Ptr)theNewPPT_Info,theDialog,(Ptr)theMLParms,theMLParms->changed);					theNewPPT_Info->DoCopy(this);					gCurrentObj->changedFlag = theMLParms->changed;					quitFlag		= true;					break;									case DLOG_GO_AWAY:				case DLOG_CANCEL:					ML_DoPPTRead((Ptr)theNewPPT_Info,theDialog,(Ptr)theMLParms,false);					quitFlag		= true;					break;				case ML_UPDATE_EVT:							BeginUpdate(theDialog);					UpdtDialog(theDialog,theDialog->visRgn);					if(!gAppleEvtsOK){						HiliteOK(theDialog);					}					ML_DoPPTHit((Ptr)theNewPPT_Info,theDialog,theSelect,(Ptr)theMLParms);					EndUpdate(theDialog);					break;							default:					ML_DoPPTHit((Ptr)theNewPPT_Info,theDialog,theSelect,(Ptr)theMLParms);					break;			}		}		DM_DisposDialog(&theDialog);		theNewPPT_Info->DoClose();		//KillDialogMenuBar();	}	return;}void	PPT_Info::DoCopy(PPT_Info*	thePPT_Info)		/* Ok for ORel & index objs	*/{	short i,theEnd;	ORel*	thisOR;	Crystal *oldMatrix,*oldPPt;		oldMatrix 	= thePPT_Info->theORs[0]->theMatrix2->theCrystal;	oldPPt		= thePPT_Info->theORs[0]->thePPT2->theCrystal;	for(i = 0 ; i <= thePPT_Info->lastOR ; i++){		thePPT_Info->theORs[i]->DoClose();	}	theEnd = lastOR;	thePPT_Info->lastOR = -1;			for(i = 0 ; i <= theEnd ; i++){		thisOR = (ORel*)D_new(ORel);		if(HandleIsOK((Handle)thisOR)){			if(thisOR->DoInit(oldPPt)){				theORs[i]->DoCopy(thisOR);				thisOR->theMatrix1->theCrystal 	= oldMatrix;				thisOR->thePPT1->theCrystal 	= oldPPt;				thisOR->theMatrix2->theCrystal 	= oldMatrix;				thisOR->thePPT2->theCrystal		= oldPPt;				thePPT_Info->theORs[i] 			= thisOR;				thePPT_Info->lastOR++;			} else {				theEnd = 0;			}		} else {			theEnd = 0;		}	}	thePPT_Info->intensity = intensity;	return;}	void	DrawLines(DialogPtr theDialog){	short type;		GetDItem(theDialog,THE_LIST_RECT,&type,&gTheHandle,&gTheRect);}		Boolean	PPT_Info::DoDefine(void){	DialogPtr		theDialog;	short			type,theSelect,last = 0,num,i,length,ii;	Rect			theRect;	Boolean			quitFlag,changed,retValue,update,dblClick;	Index			*theIndex,*thisIndex,*thatIndex;	ListHandle		theList;	Cell			theCell;	unsigned long			theResult;		quitFlag = changed = retValue = update = false;	theDialog = DM_GetNewDialog(OR_DEF_DLOG,NUL,IN_FRONT);	theIndex = (Index*)D_new(Index);		//TextFont(50);	DrawLines(theDialog);	GetDItem(theDialog,INTENSITY,&type,&gTheHandle,&gTheRect);	sprintf(gTheText,"%d",(short)(intensity * 100));	SetIText(gTheHandle,c2pstr(gTheText));	p2cstr(pTheText);		theList = InitORList(theDialog);	ListORs(theList);	theSelect = 0;	while(!quitFlag){		ModalDialog(TheFilterUPP,&theSelect);		if(update && last != theSelect){			theIndex->GetIndex(theDialog,last);			theIndex->SetIndex(theDialog,last);			update = false;		}					switch(theSelect){			case DLOG_GO_AWAY:			case DLOG_CANCEL:				if(!changed || CANCEL_YOUR_MODS){					retValue	= false;					quitFlag 	= true;				} else {					DrawLines(theDialog);				}				break;			case DLOG_OK:				if(changed)					ReadData(theDialog);				retValue	= true;				quitFlag 	= true;				break;			case DLOG_ENTER_KEY:				GetDItem(theDialog,THE_CHECK_BOX,&type,&gTheHandle,&theRect);				HiliteControl((ControlHandle)gTheHandle,1);				Delay(8L,&theResult);				HiliteControl((ControlHandle)gTheHandle,0);  /*  !!!!  NO BREAK  !!!  */			case	THE_CHECK_BOX:				theCell.h	= theCell.v	= 0;				if(LGetSelect(true,&theCell,theList))					CellUpdate(theDialog,theList,theCell);				changed = true;				break;			case LOAD_PPT:				i = Alert(SELECT_XTAL,NUL);				switch(i){					case 1:						break;					case 2:						Message(NOT_VALID_FOR_MATRIX);						break;					case 3:					case 4:					case 5:						i -= 3;						(gDefault->the_PPT_Info[i])->DoCopy(this);						changed = true;						break;					case 6:						Message(NOT_VALID_FOR_MATRIX);						break;					case 7:					case 8:					case 9:						i -= 7;						(gCurrentObj->the_PPT_Info[i])->DoCopy(this);						changed = true;						break;					default:						break;				}				KillORList(theList);				theList = InitORList(theDialog);				ListORs(theList);				break;			case DUMP_PPT:				i = Alert(SELECT_XTAL,NUL);				switch(i){					case 1:						break;					case 2:						Message(NOT_VALID_FOR_MATRIX);						break;					case 3:					case 4:					case 5:						i -= 3;						ReadData(theDialog);						DoCopy((gDefault->the_PPT_Info[i]));						break;					case 6:						Message(NOT_VALID_FOR_MATRIX);						break;					case 7:					case 8:					case 9:						i -= 7;						ReadData(theDialog);						DoCopy((gDefault->the_PPT_Info[i]));						break;					default:						break;				}				KillORList(theList);				theList = InitORList(theDialog);				ListORs(theList);				break;			case SET_NUM_ORS:				SeNumORs();				DrawLines(theDialog);				KillORList(theList);				theList = InitORList(theDialog);				ListORs(theList);				changed = true;				break;			case VARIANTS:				DoVariants();				KillORList(theList);				theList = InitORList(theDialog);				ListORs(theList);				changed = true;				break;						case INTENSITY:				changed = true;				break;			case DELETE:				if(DeletePPt(theCell)){					changed = true;					ii = theCell.v / 2;					LDelRow(2,ii * 2,theList);				}				ListORs(theList);				break;						case THE_LIST_RECT:				GlobalToLocal(&(gTheEvent.where));				dblClick = LClick(gTheEvent.where,gTheEvent.modifiers,theList);				theCell = LLastClick(theList);				num = 1 + lastOR * 2;				if(theCell.v > num)					break;				if(dblClick && theCell.h == PARALLEL){					i = theCell.v / 2;					if((theCell.v % 2) == 0){						thisIndex = theORs[i]->theMatrix1;						thatIndex = theORs[i]->thePPT1;					} else {						thisIndex = theORs[i]->theMatrix2;						thatIndex = theORs[i]->thePPT2;					}					thisIndex->direction = !(thisIndex->direction);					thatIndex->direction = thisIndex->direction;					thisIndex->SetListDir(theList,theCell);				} else {					GetDItem(theDialog,THE_LIST_DATA,&type,&gTheHandle,&theRect);					length = 10;					LGetCell(&(gTheText[1]),&length,theCell,theList);					gTheText[0] = (char)length;					if(theCell.h == PARALLEL){						type = statText;						if(gTheText[1] == 'D'){							length = sprintf(&(gTheText[1]),"Plane");						} else {							length = sprintf(&(gTheText[1]),"Direction");						}						gTheText[0] = (char)length;					} else if(theCell.h == NUMBER && (theCell.v % 2) != 0){						LSetSelect(false,theCell,theList);						theCell.v--;						LSetSelect(true,theCell,theList);						length = 10;						LGetCell(&(gTheText[1]),&length,theCell,theList);						gTheText[0] = (char)length;						type = editText;					} else {						type = editText;					} 					SetIText(gTheHandle,pTheText);					SelIText(theDialog,THE_LIST_DATA,0,length);					SetDItem(theDialog,THE_LIST_DATA,type,gTheHandle,&theRect);				}				break;			case THE_SCROLL_RECT:				GlobalToLocal(&(gTheEvent.where));				dblClick = LClick(gTheEvent.where,gTheEvent.modifiers,theList);				break;			case DO_MENU:				ReadData(theDialog);				switch(DoMenu(GetWRefCon(theDialog))){					case 1:						DrawLines(theDialog);						ListORs(theList);						break;					case 2:						quitFlag = true;						break;					default:						DrawLines(theDialog);						ListORs(theList);						break;				}				break;			case ML_UPDATE_EVT:							BeginUpdate(theDialog);					UpdtDialog(theDialog,theDialog->visRgn);					if(!gAppleEvtsOK){						HiliteOK(theDialog);					}					EndUpdate(theDialog);					break;			default:				break;		}	}	KillORList(theList);	DM_DisposDialog(&theDialog);	theIndex->DoClose();	return(retValue);}short	PPT_Info::DoMenu(long	theResult){	short theMenu,theItem,rval;		rval = 0;	theMenu = HiWord(theResult);	theItem = LoWord(theResult);	switch(theMenu){		case FILE_MENU:			switch(theItem){				case D_OPEN:					FileOpenPPTInfo();					if(gTheFile->theFileInfo.sfGood)						rval = 1;					break;				case D_SAVE_AS:					FileSavePPTInfo();					break;				case D_PAGE_SETUP:					SetupPage();					break;				case D_PRINT:					break;				case D_CLOSE:					rval = 2;					break;				default:					break;			}			break;		default:			break;	}	HiliteMenu(0);	return rval;}enum {	THE_TEXT_BOX = 3,		THE_PROMPT	};void	PPT_Info::SeNumORs(void){	DialogPtr 		theDialog;	Boolean			changed,quit;	short			count,i,type,theSelect;	Rect			theRect;	ORel			*theNewOR;		changed	= quit = false;	theDialog = DM_GetNewDialog(DLOG_SET_NUM_ATOMS,NUL,IN_FRONT);	GetDItem	(theDialog,THE_PROMPT,&type,&gTheHandle,&theRect);	sprintf		(gTheText,(char*)"\pPlease enter number of ORs. ->");	SetIText	(gTheHandle,pTheText);	GetDItem	(theDialog,THE_TEXT_BOX,&type,&gTheHandle,&theRect);	sprintf		(gTheText,"%3d",lastOR + 1);	c2pstr		(gTheText);	SetIText	(gTheHandle,pTheText);	SelIText	(theDialog,THE_TEXT_BOX,0,3);		while(!quit){		ModalDialog(NUL,&theSelect);		switch(theSelect){			case DLOG_CANCEL:				if(!changed || CANCEL_YOUR_MODS){					quit 		= true;				}				break;			case DLOG_ENTER_OR_CR:			case 1:				GetDItem(theDialog,THE_TEXT_BOX,&type,&gTheHandle,&theRect);				GetIText(gTheHandle,pTheText);				p2cstr(pTheText);				count = atoi(gTheText) - 1;				if(count < 0)					count = 0;				if(count > (MAX_NUM_OR - 1)){					count = MAX_NUM_OR - 1;					Message(TOO_MANY_ORS);				}				if(lastOR > count){					for(i = lastOR ; i > count ; i--){						theORs[i]->DoClose();					}					lastOR = count;				} else if(lastOR < count){					for(i = lastOR + 1 ; i <= count ; i++){						theNewOR = (ORel*)D_new(ORel);						if(HandleIsOK((Handle)theNewOR)){							if(theNewOR->DoInit(theCrystal)){								theORs[lastOR]->DoCopy(theNewOR);								theORs[i] = theNewOR;							} else {								theNewOR->DoClose();								count = i - 1;							}						} else {							count = i - 1;						}					}					lastOR = count;				}				quit = true;				break;			case THE_TEXT_BOX:				changed = true;				break;			case ML_UPDATE_EVT:						BeginUpdate(theDialog);				UpdtDialog(theDialog,theDialog->visRgn);				if(!gAppleEvtsOK){					HiliteOK(theDialog);				}				EndUpdate(theDialog);				break;			default:				break;		}	}	DM_DisposDialog(&theDialog);}void	PPT_Info::ReadData(DialogPtr    theDialog){			if(fabs(intensity - (GetItemValue(theDialog,INTENSITY)/100)) > .01)gCurrentObj->changedFlag = true;	intensity = GetItemValue(theDialog,INTENSITY)/100;	return;}ListHandle	PPT_Info::InitORList(DialogPtr    theDialog){	FontInfo 			theFont;	short					textHeight,type,num;	Point					cellSize;	Rect					theRect,rBounds;	ListHandle		theListHandle;		GetFontInfo(&theFont);		textHeight 	= theFont.ascent + theFont.descent + theFont.leading;		GetDItem(theDialog,THE_LIST_RECT,&type,&gTheHandle,&theRect);	dm_EraseRect(&theRect);	num = 2 * (lastOR + 1);	SetRect(&rBounds,0,0,6,num);	cellSize.h = (theRect.right - theRect.left) / 6;	cellSize.v = textHeight;	theListHandle = LNew(&theRect,&rBounds,cellSize,0,theDialog,true,false,false,true);	(*theListHandle)->selFlags = 0x80;	InsetRect(&theRect,-1,-1);	type = 0;	theRect.left -= type;	dm_FrameRect(&theRect);	return(theListHandle);}void	PPT_Info::KillORList(ListHandle	theList){		LDispose(theList);	return;}void	PPT_Info::ListOR(ListHandle	theList,short theVCell){	short j,i,length;	Cell theCell,nextCell;		i = theVCell / 2;	theCell.v = i;	nextCell.v = theCell.v + 1;		for(j = 0 ; j <= 4 ; j++){		nextCell.h =	theCell.h = j;		switch(j){			case NUMBER:				length = sprintf(gTheText,"%2d",i + 1);				LSetCell(gTheText,length,theCell,theList);				LSetCell(gTheText,0,nextCell,theList);				break;			case PARALLEL:				theORs[i]->theMatrix1->SetListDir(theList,theCell);				theORs[i]->theMatrix2->SetListDir(theList,nextCell);				break;			case MATRIX_INDEX:				theORs[i]->theMatrix1->SetListIndex(theList,theCell);				theORs[i]->theMatrix2->SetListIndex(theList,nextCell);				break;			case PPT_INDEX:				theORs[i]->thePPT1->SetListIndex(theList,theCell);				theORs[i]->thePPT2->SetListIndex(theList,nextCell);				break;			case ROTATION:				length = sprintf(gTheText,"%5.2f",theORs[i]->rot1);				LSetCell(gTheText,length,theCell,theList);								length = sprintf(gTheText,"%5.2f",theORs[i]->rot2);				LSetCell(gTheText,length,nextCell,theList);								break;			case OFF_ROTATION:								length = sprintf(gTheText,"%5.2f",theORs[i]->rot1b);				LSetCell(gTheText,length,theCell,theList);				length = sprintf(gTheText,"About P1");				LSetCell(gTheText,length,nextCell,theList);				break;			default:				break;		}	}	return;}void	PPT_Info::ListORs(ListHandle	theList){	short i,j,line,length;	Cell theCell,nextCell;		for(i = 0 ; i <= lastOR ; i++){		line = 2 * i;		theCell.v = line;		nextCell.v = line + 1;		for(j = 0 ; j <= 5 ; j++){			nextCell.h =	theCell.h = j;			switch(j){				case NUMBER:					length = sprintf(gTheText,"%2d",i + 1);					LSetCell(gTheText,length,theCell,theList);					LSetCell(gTheText,0,nextCell,theList);					break;				case PARALLEL:					theORs[i]->theMatrix1->SetListDir(theList,theCell);					theORs[i]->theMatrix2->SetListDir(theList,nextCell);					break;				case MATRIX_INDEX:					theORs[i]->theMatrix1->SetListIndex(theList,theCell);					theORs[i]->theMatrix2->SetListIndex(theList,nextCell);					break;				case PPT_INDEX:					theORs[i]->thePPT1->SetListIndex(theList,theCell);					theORs[i]->thePPT2->SetListIndex(theList,nextCell);					break;				case ROTATION:					length = sprintf(gTheText,"%5.2f",theORs[i]->rot1);					LSetCell(gTheText,length,theCell,theList);										length = sprintf(gTheText,"%5.2f",theORs[i]->rot2);					LSetCell(gTheText,length,nextCell,theList);										break;				case OFF_ROTATION:										length = sprintf(gTheText,"%5.2f",theORs[i]->rot1b);					LSetCell(gTheText,length,theCell,theList);					length = sprintf(gTheText,"About P1");					LSetCell(gTheText,length,nextCell,theList);					break;				default:					break;			}		}	}	return;}	void	PPT_Info::CellUpdate(DialogPtr    theDialog,ListHandle	theList,Cell	theCell){	Index	*theIndex,*thatIndex;	short	theNum,i,j,oldNum,length,theORNum;	ORel	*thisOR;	float	value;	Rect	theRect;	char	theText[256];		if(theCell.v < 0)		return;	GetDItem(theDialog,THE_LIST_DATA,&i,&gTheHandle,&theRect);	GetIText(gTheHandle,pTheText);	length = (short)gTheText[0];	p2cstr(pTheText);	theORNum = theCell.v / 2;	if((theCell.v % 2) == 0){			theIndex = theORs[theORNum]->theMatrix1;		thatIndex = theORs[theORNum]->thePPT1;	} else {		theIndex = theORs[theORNum]->theMatrix2;		thatIndex = theORs[theORNum]->thePPT2;	}	switch(theCell.h){		case NUMBER:			theNum = atoi(gTheText) - 1;			if(theNum < 0 || theNum > lastOR){				SysBeep(30);				SelIText(theDialog,THE_LIST_DATA,0,3);				return;				break;			}			oldNum = theCell.v;			thisOR = theORs[oldNum];			if(theNum < oldNum){				for(i = lastOR , j = lastOR ; i >= 0 ; i--){					if(i == oldNum){						j--;						theORs[i] = theORs[j--];					} else if(i == theNum){						theORs[i] = thisOR;					} else {						theORs[i] = theORs[j--];					}				}			}						if(theNum > oldNum){				for(i = 0 , j = 0 ; i <= lastOR ; i++){					if(i == oldNum){						j++;						theORs[i] = theORs[j++];					} else if(i == theNum){						theORs[i] = thisOR;					} else {						theORs[i] = theORs[j++];					}				}			}						LSetSelect(false,theCell,theList);			ListORs(theList);			theCell.h = NUMBER;			theCell.v = theNum;			LSetSelect(true,theCell,theList);			LAutoScroll(theList);			SelIText(theDialog,THE_LIST_DATA,0,3);			return;			break;						case PARALLEL:							theIndex->direction = !(theIndex->direction);			thatIndex->direction = theIndex->direction;			if(theIndex->direction){				length = sprintf(&(gTheText[1]),"Direction");				sprintf(theText,"Plane");				c2pstr(theText);				i = 5;			} else {				length = sprintf(&(gTheText[1]),"Plane");				sprintf(theText,"Direction");				c2pstr(theText);				i = 9;			}			gTheText[0] = (char)length;			LSetCell(&(gTheText[1]),length,theCell,theList);			SetIText(gTheHandle,(unsigned char*)theText);			SelIText(theDialog,THE_LIST_DATA,0,i);			return;			break;		case MATRIX_INDEX:			theIndex->GetIndex(theDialog,THE_LIST_DATA);			theIndex->SetListIndex(theList,theCell);			LSetSelect(false,theCell,theList);			theCell.h += 1;			break;		case PPT_INDEX:			thatIndex->GetIndex(theDialog,THE_LIST_DATA);			thatIndex->SetListIndex(theList,theCell);			LSetSelect(false,theCell,theList);			theCell.h += 1;			break;		case ROTATION:			value = atof(gTheText);			length = sprintf(gTheText,"%5.2f",value);			if((theCell.v % 2) == 0){				theORs[theORNum]->rot1 = value;				LSetCell(gTheText,length,theCell,theList);				LSetSelect(false,theCell,theList);				theCell.h += 1;			} else {				theORs[theORNum]->rot2 = value;				LSetCell(gTheText,length,theCell,theList);				LSetSelect(false,theCell,theList);				theCell.h = 2;				theCell.v += 1;				if(theCell.v > (2 * lastOR + 1))					theCell.v = 0;			}			break;		case OFF_ROTATION:			value = atof(gTheText);			length = sprintf(gTheText,"%5.2f",value);			if((theCell.v % 2) == 0){				theORs[theORNum]->rot1b = value;				LSetCell(gTheText,length,theCell,theList);				LSetSelect(false,theCell,theList);				theCell.h = 2;				theCell.v += 1;				if(theCell.v > (2 * lastOR + 1))					theCell.v = 0;			} else {				LSetSelect(false,theCell,theList);				gTheText[0] = 0;				theCell.h = 2;				theCell.v += 1;				if(theCell.v > (2 * lastOR + 1))					theCell.v = 0;			}			break;	}	LSetSelect(true,theCell,theList);	LAutoScroll(theList);	length	=	10;	LGetCell(&(gTheText[1]),&length,theCell,theList);	gTheText[0] = (char)length;	GetDItem(theDialog,THE_LIST_DATA,&i,&gTheHandle,&theRect);	SetIText(gTheHandle,pTheText);	SelIText(theDialog,THE_LIST_DATA,0,length);}		void	PPT_Info::FileSavePPTInfo(void){	gTheFile->SaveFileOpen(PPT_OBJ);	if(!gTheFile->file_is_Open)		return;	FileWritePPTInfo();	gTheFile->DoFileClose();	return;}void	PPT_Info::FileOpenPPTInfo(void){	gTheFile->ReadFileOpen(PPT_OBJ);	if(!gTheFile->file_is_Open)		return;	FileReadPPTInfo();	gTheFile->DoFileClose();	return;}void	PPT_Info::FileWritePPTInfo(void){	short	i;				gTheFile->WriteShort(lastOR);		for(i = 0 ; i <= lastOR ; i++){		theORs[i]->WriteOR();	}		gTheFile->WriteFloat(intensity);}void	PPT_Info::FileReadPPTInfo(void){	short	i;			lastOR = gTheFile->ReadShort();	theORs[0]->ReadOR();		for(i = 1 ; i <= lastOR ; i++){		if(theORs[i] == (ORel*)NUL){			/* if no obj alloc new */			theORs[i] = (ORel*)(ORel*)D_new(ORel);			theORs[i]->DoInit(theCrystal);		}		theORs[i]->ReadOR();	}		for(i = lastOR + 1 ; i < MAX_NUM_OR ; i++){		/* kill unused Obj		*/		if(theORs[i] != (ORel*)NUL){			D_delete(theORs[i]);		}	}	intensity = gTheFile->ReadFloat();}Boolean		ORel::DoInit(Crystal* thatCrystal){	Index*	theIndex;			rot1b = rot1	= rot2	= 0.0;	theIndex = (Index*)D_new(Index);	if(!HandleIsOK((Handle)theIndex)){		return false;	}	theMatrix1	= theIndex;	theMatrix1->DoInit(PLANE,gCurrentObj->theCrystal[0]);		theIndex = (Index*)D_new(Index);	if(!HandleIsOK((Handle)theIndex)){		theMatrix1->DoClose();		return false;	}	thePPT1	= theIndex;	thePPT1->DoInit(PLANE,thatCrystal);	theIndex = (Index*)D_new(Index);	if(!HandleIsOK((Handle)theIndex)){		theMatrix1->DoClose();		thePPT1->DoClose();		return false;	}	theMatrix2	= theIndex;	theMatrix2->DoInit(DIRECTION,gCurrentObj->theCrystal[0]);	theMatrix2->h = 1;	theMatrix2->l = 0;	theIndex = (Index*)D_new(Index);	if(!HandleIsOK((Handle)theIndex)){		theMatrix1->DoClose();		thePPT1->DoClose();		theMatrix2->DoClose();		return false;	}	thePPT2	= theIndex;	thePPT2->DoInit(DIRECTION,thatCrystal);	thePPT2->h = 1;	thePPT2->l = 0;		return true;}void	ORel::DoClose(){	theMatrix1->DoClose();	thePPT1->DoClose();	theMatrix2->DoClose();	thePPT2->DoClose();	D_delete(this);}	void	ORel::DoCopy(ORel*	thisOR){	theMatrix1->DoCopy(thisOR->theMatrix1);	thePPT1->DoCopy(thisOR->thePPT1);	theMatrix2->DoCopy(thisOR->theMatrix2);	thePPT2->DoCopy(thisOR->thePPT2);		thisOR->rot1 = rot1;	thisOR->rot1b = rot1b;	thisOR->rot2 = rot2;}void	ORel::WriteOR(void){	theMatrix1->WriteIndex();	thePPT1->WriteIndex();	gTheFile->WriteFloat(rot1);	gTheFile->WriteFloat(rot1b);	theMatrix2->WriteIndex();	thePPT2->WriteIndex();	gTheFile->WriteFloat(rot2);	return;}void	ORel::ReadOR(void){	Crystal *setCrystal[4],*setCrystal1[4];	setCrystal[0] 	= theMatrix1->theCrystal;	setCrystal1[0] 	= thePPT1->theCrystal;	theMatrix1		->ReadIndex(setCrystal);	thePPT1			->ReadIndex(setCrystal1);	rot1 			= gTheFile->ReadFloat();	if(gCurrentObj->objectType	==	NUL || GetVersion(gCurrentObj->objectType)){		rot1b 		= gTheFile->ReadFloat();	}else{		rot1b 		= 0;	}	theMatrix2		->ReadIndex(setCrystal);	thePPT2			->ReadIndex(setCrystal1);	rot2 			= gTheFile->ReadFloat();	return;}void PPT_Info::DoVariants(void){	CrystalFace theORHKL,*theMORHKL1,*theMORHKL2,*thePORHKL1,	*thePORHKL2,thePtr[100];	Index	*theIndex;	short	i,j,k,l,startOR,total[4];	short	latticeType;	ORel	*theNewOR;	double theAngle, theAngle2,test;	Boolean flag;	short 	degenericies[4];		if(fabs(fabs(theORs[lastOR]->theMatrix1->GetTheAngle(theORs[lastOR]->theMatrix2))		- fabs(theORs[lastOR]->thePPT1->GetTheAngle(theORs[lastOR]->thePPT2))) > .3)			return ;	theAngle = fabs(theORs[lastOR]->theMatrix1->GetTheAngle(theORs[lastOR]->theMatrix2));	theAngle2 = fabs(theORs[lastOR]->thePPT1->GetTheAngle(theORs[lastOR]->thePPT2));				for(i = 0; i <= 3; i++){		total[i] = -1;		switch(i){			case 0:				theIndex = theORs[lastOR]->theMatrix1;				break;			case 1:				theIndex = theORs[lastOR]->thePPT1;				break;			case 2:				theIndex = theORs[lastOR]->theMatrix2;				break;			case 3:				theIndex = theORs[lastOR]->thePPT2;				break;			default:					break;		}		theORHKL.h = theIndex->h;		theORHKL.k = theIndex->k;		theORHKL.l = theIndex->l;		latticeType = theIndex->theCrystal->lattice_Type;		switch(latticeType)		{			case CUBIC:				degenericies[i] = 1;//3,2				break;			case TRIGONAL:			case TRIGHEX: 					degenericies[i] = 1;//3				break;			case TETRAGONAL:				degenericies[i] = 1;				break;			case TRICLINIC:			case MONOCLINIC:			case ORTHORHOMBIC:				degenericies[i] = 1;				break;			case HEXAGONAL:				if(theIndex->h == 0 && theIndex->k == 0)					degenericies[i] = 1;				else					degenericies[i] = 1;//3;				break;			default:				degenericies[i] = 1;				break;		}		//if(latticeType == HEXAGONAL)k = HEXAGONAL;		//else k = TRICLINIC;		switch(i){			case 0:				CubicPermutate(&total[i],theORHKL,thePtr,false,latticeType);				theMORHKL1 = (CrystalFace*)D_NewPtr((total[i] + 1) * sizeof(CrystalFace));				for(j = 0; j <= total[i]; j++) theMORHKL1[j] = thePtr[j];				break;			case 1:				/* thePORHKL1 = (CrystalFace*)D_NewPtr(1L * sizeof(CrystalFace));				thePORHKL1[0] = theORHKL; */				CubicPermutate(&total[i],theORHKL,thePtr,false,latticeType);				thePORHKL1 = (CrystalFace*)D_NewPtr((total[i] + 1) * sizeof(CrystalFace));				for(j = 0; j <= total[i]; j++) thePORHKL1[j] = thePtr[j];				break;			case 2:				CubicPermutate(&total[i],theORHKL,thePtr,false,latticeType);				theMORHKL2 = (CrystalFace*)D_NewPtr((total[i] + 1) * sizeof(CrystalFace));				for(j = 0; j <= total[i]; j++) theMORHKL2[j] = thePtr[j];				break;			case 3:				/*thePORHKL2 = (CrystalFace*)D_NewPtr(1L * sizeof(CrystalFace));				thePORHKL2[0] = theORHKL;*/				CubicPermutate(&total[i],theORHKL,thePtr,false,latticeType);				thePORHKL2 = (CrystalFace*)D_NewPtr((total[i] + 1) * sizeof(CrystalFace));				for(j = 0; j <= total[i]; j++) thePORHKL2[j] = thePtr[j];				break;			default:					break;		}	}		for(i = 0;i <= 3;i++)		++total[i];	total[0] /= degenericies[1];		total[2] /= degenericies[3];		total[1] /= degenericies[0];		total[3] /= degenericies[2];		for(i = 0;i <= 3;i++){		if(total[i] <= 0){			total[i] = 0;		}else		--total[i];	}	flag = false;	startOR = lastOR;	for(i = 0; i <= total[0] ; i++){		for(j = 0; j <= total[1] ; j++){			for(k = 0; k <= total[2] ; k++){				for(l = 0; l <= total[3] ; l++){					if(flag == false){						flag = true;						continue;					}					theNewOR = (ORel*)D_new(ORel);					if(HandleIsOK((Handle)theNewOR)){						if(theNewOR->DoInit(theCrystal)){							theORs[lastOR]->DoCopy(theNewOR);							if(MAX_NUM_OR <= lastOR + 1)								continue;							lastOR++;														theORs[lastOR] = theNewOR;														theORs[lastOR]->theMatrix1->h = theMORHKL1[i].h;							theORs[lastOR]->theMatrix1->k = theMORHKL1[i].k;							theORs[lastOR]->theMatrix1->l = theMORHKL1[i].l;														theORs[lastOR]->thePPT1->h = thePORHKL1[j].h;							theORs[lastOR]->thePPT1->k = thePORHKL1[j].k;							theORs[lastOR]->thePPT1->l = thePORHKL1[j].l;														theORs[lastOR]->theMatrix2->h = theMORHKL2[k].h;							theORs[lastOR]->theMatrix2->k = theMORHKL2[k].k;							theORs[lastOR]->theMatrix2->l = theMORHKL2[k].l;														theORs[lastOR]->thePPT2->h = thePORHKL2[l].h;							theORs[lastOR]->thePPT2->k = thePORHKL2[l].k;							theORs[lastOR]->thePPT2->l = thePORHKL2[l].l;							test = fabs(theORs[lastOR]->theMatrix1->GetTheAngle(theORs[lastOR]->theMatrix2));							test = fabs(fabs(theORs[lastOR]->theMatrix1->GetTheAngle(theORs[lastOR]->theMatrix2))							 - theAngle);							if(fabs(fabs(theORs[lastOR]->theMatrix1->GetTheAngle(theORs[lastOR]->theMatrix2))							 - theAngle) > 0.3){							 	theORs[lastOR]->DoClose();							 	lastOR--;							 	continue;							 }							 test = fabs(theORs[lastOR]->thePPT1->GetTheAngle(theORs[lastOR]->thePPT2));							if(fabs(fabs(theORs[lastOR]->thePPT1->GetTheAngle(theORs[lastOR]->thePPT2))							- theAngle2) > .3){								theORs[lastOR]->DoClose();								lastOR--;								continue;							}						} else {							theNewOR->DoClose();						}					}										} 			}		}	}	KillPtr((Ptr)theMORHKL1);	KillPtr((Ptr)theMORHKL2);	KillPtr((Ptr)thePORHKL1);	KillPtr((Ptr)thePORHKL2);	//Brute Method for eliminating redundancies...computers are great!!!	for(k = startOR; k <= lastOR;k++)	{			short p;		double xForm[3][3],xCForm[3][3];		gDefault->GetPPTXFormMatrixBase		(xForm,theCrystal,k);		for(i = startOR + 1; i <= lastOR;i++){			gDefault->GetPPTXFormMatrixBase		(xCForm,theCrystal,i);			for(j = 0; j < 3;j++){				for(l = 0; l < 3;l++){					if(fabs(xCForm[j][l] - xForm[j][l]) > .01)goto NEXT_MATRIX;				}			}			for(p = i; p <= lastOR - 1; p++)			{				theORs[p + 1]->DoCopy(theORs[p]);			}			theORs[lastOR]->DoClose();			--lastOR;			NEXT_MATRIX:;		}	}		}Boolean PPT_Info::DeletePPt(Cell theCell){	short i,j;	if(lastOR <= 0)		return false;	j = theCell.v / 2;		for(i = j; i <= lastOR - 1; i++)	{		theORs[i + 1]->DoCopy(theORs[i]);	}	theORs[lastOR]->DoClose();	--lastOR;	return true;}Boolean PPT_Info::SameOR(PPT_Info *theObj){	short i;	if(lastOR != theObj->lastOR)return false;	for(i = 0; i < lastOR;i++){		if(!theORs[i]->theMatrix1->SameIndex(theObj->theORs[i]->theMatrix1))return false;		if(!theORs[i]->thePPT1->SameIndex(theObj->theORs[i]->theMatrix1))return false;		if(!theORs[i]->theMatrix2->SameIndex(theObj->theORs[i]->theMatrix1))return false;		if(!theORs[i]->thePPT2->SameIndex(theObj->theORs[i]->theMatrix1))return false;		if(theORs[i]->rot1 != theObj->theORs[i]->rot1)return false;		if(theORs[i]->rot2 != theObj->theORs[i]->rot2)return false;	}	return true;}