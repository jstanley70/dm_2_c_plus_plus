class Polyhedral;class Polygons;template <class Type>class BTree{	private:		Type*  me;	Type*  left;	Type*  right;	Boolean Criterion(Type* n);	BTree<Type> RightMost(){if(right)return right->RightMost();else return this;};	public:	BTree(Type* n): me(n){				left = 0L;		right = 0L;	}	operator+=(Type* n)	{		if(Criterion(Type* n)){			if(left == 0){				left = BTree<Type>(n);			}else{				left +=(n);			}			return left;		}else{			if(right == 0){				right = BTree<Type>(n);			}else{				right +=(n);			}		}	}	Boolean operator-=(Type* n)	{		if(n == me){			Type* rightMost;						rightMost = left->right->RightMost();			rightMost->right = right;			delete me;			me = left;			return true;		}else{			if(left-=(n))return true;			if(right-=(n))return true;			return false;		}	}};template <class Type>Boolean BTree<Type>::Criterion(Type* n){	if(this->me->value >= n->value) return true;	return false;}//class vector;class Polygons{	//vector	*vertices;	public:	Polygons(){//vector* thePoints,short n){		//vertices = thePoints;		return;	}	~Polygons(){		//KillPtr(vertices);	}			virtual void Add(void);	virtual void Draw(void);};template <class Type>class vector{	enum{		X = 1,		Y,		Z,		L	}	public:	Type	x;	Type	y;	Type	z;	Type	value;	Type	l;	Type 	length(){		return sqrt(x * x + y * y + z * z);	}	vector(Type a,Type b,Type c)	{		x = a;		y = b;		z = c;		value = 0;	}	vector(Vector v)	{		x = v.x;		y = v.y;		z = v.z;	}	operator+=(Type v){		x += v.x;		y += v.y;		z += v.z;	}	operator++{		return v++;		if(v == vEnd)return 0L;	}	operator*=(Type v){		x *= v.x;		y *= v.y;		z *= v.z;	}	double* D operator= Type v{		d[0] = v.x;		d[1] = v.y;		d[2] = v.z;	}		operator*(Type v){		x *= v.x;		y *= v.y;		z *= v.z;		return this;	}	operator/ (double c){		x /= c;		y /= c;		z /= c;		return this;	}	double operator*(Type v){		return x * v.x + 		y * v.y +		z * v.z;	}		Type operator== double D{		if(fabs(D - l) < .002) 		return true;		return false;	}	Type operator== Type v{		if(fabs((double)v.x - x) <= .01					&& fabs((double)v.y - y) <= .01					&& fabs((double)v.z - z) <= .01))return true;			else				return false;	}	Type operator<= double D{		if(l < D + .002) 		return true;		return false;	}		operator||(vector v){//parallel		if(x * v.y != y * v.x)			return false;		if(x * v.z != z * v.x)			return false;		if(y * v.z != z * v.y)			return false;		return true;	}	void	Insert(double *matrix,short a,short b,short c);		~vector(){delete this;}	};class Polyhedral{public:		Polygons* DeterminePolygons(vector<double> *pointSet);	double	 length();		Polygons *polygonset;	Polyhedral(vector<double> *pointSet){		polygonset = DeterminePolygons(pointSet);			}	~Polyhedral(){		delete polygonset;		delete this;	}	Draw();	long PointInside(vector theAtom);		};