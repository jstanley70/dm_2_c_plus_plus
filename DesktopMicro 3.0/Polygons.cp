#include "Polygons.h"void Test(void);void Test(void){	Polyhedral a(0);	double	t;	vector<double> v(1,2,3);	vector<double> v1(v);	t = a.length();	if( v1 || v){return;}}void Polyhedral::DetermineVertices(void){	BTree<vector> face1,face2,face3;	face1 = faces;	face2 = faces;	face3 = faces;	while(face1){		while(face2){			if(face1 == face2 || face1 || face2) continue; //if faces are equal or parallel (== is redundant)			while(face3){				if(face1 || face3)) continue;//faces parallel				if(face2 || face3) continue;//faces parallel				face->DetermineCorner(face1->me,face2->me);				face3++;			}			face2++;		}		face1++;	}}void Polyhedral::DetermineCorner(vector *face2,vector *face3){	double matrix[9],x[3],x1,x2,x3,L;	long n,i;	long sizeOf;	long maxAllowedItems;	n = 0;	matrix = face1;	&matrix[3] = face2;	&matrix[6] = face3;		{		double L1;		L = Determinate3x3Matrix(matrix);		L1 = L;			if(fabs(L1) < .0001)			return;	}	face1->Insert(matrix,2,3,4);	face2->Insert(&matrix[3],2,3,4);	face3->Insert(&matrix[6],2,3,4);		vector.x = (Determinate3x3Matrix(matrix)) / L;		face1->Insert(matrix,3,1,4);	face2->Insert(&matrix[3],3,1,4);	face3->Insert(&matrix[6],3,1,4);		vector.y = (Determinate3x3Matrix(matrix)) / L;		face1->Insert(matrix,1,2,4);	face2->Insert(&matrix[3],1,2,4);	face3->Insert(&matrix[6],1,2,4);		vector.z = (Determinate3x3Matrix(matrix)) / L;			if(!(Boolean)PointInside(vector)){		corner = *corners;		if(corner[1]){			while(corner){				if(*corner == vector)					return;				corner++			}					}		if(n > 0){			corner = corners->Add();			*corner = vector;		}	}	}void vector::void	Insert(double *matrix,short a,short b,short c){	short n;	short i = 0;	while(i < 3){		switch(n){			case 0:				n = a;			break;			case 1:				n = b;			break;			case 2:				n = c;			break;		}		switch(n){			case X:				matrix[i] = x;			break;			case Y:				matrix[i] = y;			break;			case Z:				matrix[i] = z;			break;			case L:				matrix[i] = l;			break;		}		i++;	}}long Polyhedral::PointInside(vector theAtom)//determines in end of vector is inside polygon{	vector *facePtr;	long n,i;	Boolean p;	double lengthTest;	n = 1;		p = false;	facePtr = faces;	while(facePtr){		lengthTest = (double)(facePtr * theAtom);		if(facePtr <= lengthTest){			return 0;		}		if(lengthTest >= -.02)				p = true;		if(lengthTest <= (double)(facePtr->l + .001) && lengthTest >= (double)(facePtr->l - .02))			n = 2;		facePtr++	}	if(p == false)		return 0;	return n ;}void Polyhedral::DeterminePolygons(void){		double x[3];	n = 0;	theEdgePtr = *theEdges;	theEdge = *theEdges;	face = faces	corner = corners;	while(face){		polygon++;		while(corner){			vector = corner * face;			vector *= corner.l;			if(vector.length() - face.length) < RESOLUTION){				corner -= face; //eliminates displacement from origin				polygon.add(corner);			}			corner++;		}				polygon.orderCorners();		polygon.displaceCorners(face);		face++;	}	//find two of the corners that are on edge	}long Polyhedral::PointOnFace(vector v){	long i,n;	double lengthTest;	n = 0;	face = faces;	while(face){		lengthTest = face * v;					if(face == (double)lengthTest)			n++;		face++;	}	return n;}void Polygon::OrderCorners(void){		cornerN = corner1 = corners;	while(corner1){		double angle = 2_PI;		corner2 = corner1;		corner2++;		while(corner2){			if((ang = corner1->corner2.angle()) < angle){				angle = ang;				*match = *corner2;			}			corner2++;		}		corner1 = corner1 -> Neighbor(corner2);		corner1++;	//moves it to corner 2	}	}LTree<vector> Polygon::Neighbor(BTree corner){	old = next;	next = corner;	old->Order(corner);}LTree<vector>::Order(LTree<vector> comparator);{	while(next){		if(comparator == next){		next = old;		next	}}