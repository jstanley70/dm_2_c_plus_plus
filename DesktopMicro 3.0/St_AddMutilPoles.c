void StereoObject::SetUpForInputOfPoleOrMatrix(){	DialogPtr 		theDialog;	short 			k,i,theItem;	Rect 			rDataBnds,theRect;	Cell			cellSize;	TextBoxFree		*textBox;	PopUpMenu		*menu1,*menu2;	long			start1,start2,end1,end2;	long			old_Data;	Boolean			quit = false;	ParallelSpots 	**parallelHandle;	ORSet **orHandle;	ParallelSpots 	*parallels,*parallel,*par1,*par2;	long 			totalParallel,maxParallel;	SpotInfo 		*theSpots,*spot1,*spot2,*spot1a,*spot2a;	double 			angle,angleDif;	Index*			theIndex;	short			oldBase,oldPValue[4],oldDValue[4],maxHKL;	Boolean			oldFlag;	ORSet 			*ors,*orr;	long 			maxOR,totalOR;	short			id1,id2;	double			theYForm[3][3],theTForm[3][3];	double theta1,theta2,theta3;	theDialog = DM_GetNewDialog(367, 0L,(WindowPtr)-1L);		menu1	->	Init(theDialog,4,14,1);	menu1	->	SetPopUp();		menu2 	= (PopUpMenu*)D_new(PopUpMenu);	menu2	->	Init(theDialog,5,14,2);	menu2	->	SetPopUp();		SetItemValue(theDialog,6,001,2);	SetItemValue(theDialog,7,100,0);		while(!quit){		Point thePoint;		SystemTask();		ModalDialog(TheFilterUPP,&theItem);		switch(theItem){			case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;			case 1:				gTheFileObject->CloseTextFile();			break;						case 2:			case CANCELCLICK:				gTheFileObject->CloseTextFile();				quit = true;				break;			case 3:				gTheFileObject->OpenTextFile();				break;			case 4:			default:				break;		}	}		return;}void	StereoObject::AddPoleDialog(void){	DialogPtr 	theDialog;	double 		lambda,mu,x,y,z,angle,angle2;	short 			theSelect=0;	Point		thePoint,lastPoint;	PopUpMenu	*menu;	PolePosition thePole;	Index		*theI;		theDialog = DM_GetNewDialog(364,NUL,IN_FRONT);	theI	= (Index*)D_new(Index);	ShowWindow(theDialog);		menu 	= (PopUpMenu*)D_new(PopUpMenu);	menu	->	Init(theDialog,3,14,1);	menu	->	SetPopUp();		obj_Index->h = 0;obj_Index->k = 0;obj_Index->l = 1;	obj_Index->SetIndex(theDialog,4);	obj_Index->h = 1;obj_Index->k = 0;obj_Index->l = 0;	obj_Index->SetIndex(theDialog,5);	SetItemValue(theDialog,6,0,2);	SetItemValue(theDialog,7,0,2);	SetItemValue(theDialog,8,0,2);	SetItemValue(theDialog,9,90,2);			while(true){		GetMouse(&thePoint);		if(PtInRect(thePoint,&(theDialog->portRect))|| !Button()){			ModalDialog(TheFilterUPP,&theSelect);			switch(theSelect){				case ML_UPDATE_EVT:				BeginUpdate(theDialog);			UpdtDialog(theDialog,theDialog->visRgn);			if(!gAppleEvtsOK){				HiliteOK(theDialog);			}			EndUpdate(theDialog);			break;				case 2:					menu->DoClose();					theI->DoClose();					DM_DisposDialog(&theDialog);					FlushEvents(everyEvent,0);					return;					break;				case 1:					obj_Index->theCrystal = theCrystal[menu->lastResult - 1];					obj_Index->flags = menu->lastResult - 1;					obj_Index->direction = true;					obj_Index->reduceFlag = true;					obj_Index->GetIndex(theDialog,4);										lambda = PI * GetItemValue(theDialog,6) / 180;					mu = PI * GetItemValue(theDialog,7) / 180;					ConvertMuLambdaToXYZ(&x,&y,&z,mu,lambda);					obj_Index->CopyIndexToPtr((Ptr)&thePole.zoneAxis);					thePole.zoneAxis.x = x;					thePole.zoneAxis.y = y;					thePole.zoneAxis.z = z;					obj_Index->DoCopy(theI);										obj_Index->direction = false;					obj_Index->reduceFlag = false;										obj_Index->GetIndex(theDialog,5);					obj_Index->CopyIndexToPtr((Ptr)&thePole.gvector);										lambda = PI * GetItemValue(theDialog,8) / 180;					mu = PI * GetItemValue(theDialog,9) / 180;					ConvertMuLambdaToXYZ(&x,&y,&z,mu,lambda);					thePole.gvector.x = x;					thePole.gvector.y = y;					thePole.gvector.z = z;					angle = 180 * acos( x * thePole.zoneAxis.x + y * thePole.zoneAxis.y + z * thePole.zoneAxis.z) / PI;					angle2 = obj_Index->GetTheAngle(theI);					if(fabs(fabs(angle) - fabs(angle2)) > 1){						double theXForm2[3][3],theXForm1[3][3],theXForm3[3][3];						angle = PI * (angle2 - angle)/180;//angular difference between allowed and actual.						x = thePole.zoneAxis.x;						y = thePole.zoneAxis.y;						z = thePole.zoneAxis.z;						FIND_CENTER_XFORM(x,y,z,theXForm1);						x = thePole.gvector.x;						y = thePole.gvector.y;						z = thePole.gvector.z;						TransFormVector(&x,&y,&z,theXForm1);						FIND_VERT_XFORM(x,y,theXForm2);						TransFormVector(&x,&y,&z,theXForm2);						//FindXAxisXform(sin(angle), cos(angle),theXForm3);												RotatateMatrixAxis(theXForm3,angle,1);						TransFormVector(&x,&y,&z,theXForm3);												InvertMatrix(theXForm2);						InvertMatrix(theXForm1);						TransFormVector(&x,&y,&z,theXForm2);						TransFormVector(&x,&y,&z,theXForm1);																		GetMuLambdaFromXYZ(x,y,z,&mu,&lambda);						SetItemValue(theDialog,8,lambda,2);						SetItemValue(theDialog,9,mu,2);						thePole.gvector.x = x;						thePole.gvector.y = y;						thePole.gvector.z = z;					}					SetPort(theWindow);					D_SetClip(drawRgn);										AddPoleObject(thePole,true);					SetPort(theDialog);					newPictReq = true;					break;				case 3:					menu->DoPopUp();					break;			}		} else if(Button()){			while(Button()){				GetMouse(&thePoint);				if(!EqualPt(thePoint,lastPoint)){					lastPoint = thePoint;					LocalToGlobal(&thePoint);					SetPort(theWindow);					GlobalToLocal(&thePoint);					SetPort(theDialog);					onScreen = true;					LocalToObj(&thePoint);					GetMuLambda( thePoint,&mu,&lambda,false);					SetItemValue(theDialog,6,lambda,2);					SetItemValue(theDialog,7,mu,2);									}			}		}	}}