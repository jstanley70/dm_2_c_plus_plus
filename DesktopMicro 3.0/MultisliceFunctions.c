#include	"Diffract_INCs.h"//ects:D.M. v2.0:Sources.Jim:Table Sources:TA_Periodicity_Table.c#include 	"a_Crystal.h"#include 	"MultisliceFunctions.h"#include "f2c.h"#include "FortranProtos.h"void fourn(float data[], unsigned long nn[], int ndim, int isign);Handle  FastFourierTransform(Boolean replace, Handle *function,integer nX,integer nY,int iSign,short i){	float** newFunction;	float*  values;	unsigned long		nn[3];	newFunction = (float**)*function;	if(!replace){		D_HandToHand((Handle*)&newFunction);	}		D_HLock(newFunction);		values = *newFunction;	nn[1] = (unsigned long)nX;	nn[2] = (unsigned long)nY;		fourn(&(values[i]),nn,2,iSign);	D_HUnlock(newFunction);		return (Handle)newFunction;}Handle ConvolveInverseTransforms(Boolean replace,Handle* handle1,Handle handle2,short meshX,short meshY){	ccomplex 		*value1,*value2;	ccomplex 			**handleNew;	double			rmt;	double				mt;	short				i,j,k;	dcomplex		d1,d2;		mt = meshX * meshY;	rmt = 1/(double)mt;	k = -1;	value1 = (ccomplex*)*handle1;	handleNew = (ccomplex**)*handle1;	if(!replace){		D_HandToHand((Handle*)&handleNew);	}	D_HLock(handleNew);	D_HLock(handle2);	value1 = *handleNew;	value2 = (ccomplex*)*handle2;		value1++;//turn into fortran type array			value2++;	for(j = 0; j < meshY;j++){		for(i = 0; i < meshX;i++){			d1.i = value1->i;			d1.r = value1->r;			d2.i = value2->i;			d2.r = value2->r;			d1 = RCmul(rmt, Cmul(d1 ,d2));			value1->i = d1.i;			value1->r = d1.r;			value1++;			value2++;		}	}	D_HUnlock(handleNew);	D_HUnlock(handle2);	return (Handle)handleNew;}Handle ConvolveTransforms(Boolean replace,Handle* handle1,Handle handle2,short meshX,short meshY){	ccomplex *value1,*value2;	ccomplex** 	handleNew;	dcomplex d1,d2;	short mt;	double	rmt;	short	j,i,k = -1;		mt = meshX * meshY;	rmt = 1/(double)mt;	handleNew = (ccomplex**)*handle1;	if(!replace){		D_HandToHand((Handle*)&handleNew);	}	D_HLock(handleNew);	D_HLock(handle2);	value1 = *handleNew;	value2 = (ccomplex*)*handle2;	value1++;	value2++;	for(j = 0; j < meshY;j++){		for(i = 0; i < meshX;i++){						d1.i = value1->i;			d1.r = value1->r;			d2.i = value2->i;			d2.r = value2->r;			d1 = Cmul(d1,d2);			value1->i = d1.i;			value1->r = d1.r;			value1++;			value2++;		}	}	D_HUnlock(handleNew);	D_HUnlock(handle2);	return (Handle)handleNew;}Handle  PropogationValues(short meshX,short meshY, float tilt[2],float lambda,float deltaZ,float xShift,float yShift,double cell2R[3]){	Handle 		theNewHandle;	ccomplex 	*vector,*vectors;	short  		mx,my,totalMesh;	double 		a2,b2,t0,t1,a,b,K_Wave2;	double		aDotB,h,k,sg,temp;	short  		i,j,j1,i1;	double testC,testS;		totalMesh = (meshX + 1) * (meshY + 1);	theNewHandle = D_NewHandle(sizeof(ccomplex) * totalMesh);			D_HLock(theNewHandle);	vectors = (ccomplex*)*theNewHandle;	for(i = 0; i < totalMesh;i++,vectors++){vectors->r = 0; vectors->i = 0;}	vectors = (ccomplex*)*theNewHandle;	//PI_2 = 6.2831853;	K_Wave2 = lambda/2;	mx = meshX/2;	my = meshY/2;	a2 = cell2R[0] * cell2R[0];	b2 = cell2R[1] * cell2R[1];	aDotB = cell2R[0] * cell2R[1] * cell2R[2];	t0 = 2 * tilt[0];	t1 = 2 * tilt[1];	for(j = 2; j <= meshY;j++){				k = j - my - 1;		j1 = (j - 1 ) * meshX;			testC = 1;		testS = 2;		for( i = 2;i <= meshX;i++){						h = i - mx - 1;			a = t0 + h;			b = t1 + k;			sg = K_Wave2 * ( (a * h * a2) + (b * k * b2) + ((a * k + b * h) * aDotB));			temp = -PI_2 * ((sg * deltaZ) + (h * xShift) + (k * yShift));			i1 = j1 + i;//keep it to Fortran type array			vector = &(vectors[i1]);			testC = cos(temp);			testS = sin(temp);			vector->r = (float)testC;			vector->i = (float)testS;					}	}	D_HUnlock(theNewHandle);	PAD0((ccomplex**)theNewHandle,meshX,meshY);	OShift( theNewHandle,meshX, meshY);	return theNewHandle;}void PAD0(ccomplex **pMap,short meshX, short meshY){	ccomplex* pMapPtr;	short i,j,j1;	D_HLock(pMap);	pMapPtr = *pMap;	for(i = 1; i <= meshX;i++){		pMapPtr[i].r = 0;		pMapPtr[i].i = 0;	}	for(j = 2; j <= meshY;j++){		j1 = (j-1) * meshX + 1;//may need to check symantics		pMapPtr[j1].r = 0;		pMapPtr[j1].i = 0;	}	D_HUnlock(pMap);}Handle  PhaseGratingMap(Boolean replace,short meshX,short meshY, double sigma,Handle* pMap){	Handle 		theNewHandle;	ccomplex 	*vectors,*pMapPtr,**pMapHdn;	double 		pr, temp,piI;	short			MT,i;		pMapHdn 			= (ccomplex**)*pMap;	D_HLock((Handle)pMapHdn);	pMapPtr 			= *pMapHdn;	if(!replace){		theNewHandle = (Handle)pMapHdn;		D_HandToHand((Handle*)&theNewHandle);		D_HLock((Handle)theNewHandle);		vectors = (ccomplex*)*theNewHandle;	}else{		vectors = pMapPtr;	}	MT = meshX * meshY;		pMapPtr++;//turn into fortran type array	vectors++;		for(i = 0 ; i < MT; i++,pMapPtr++,vectors++){		pr  		= (double)pMapPtr->r;		piI 		= ((double)pMapPtr->i);//this may be incorrect		temp 		= - sigma * pr;		piI 		= exp(sigma * piI);		vectors->r = cos(temp) * piI;		vectors->i = sin(temp) * piI;	}	D_HUnlock(pMapHdn);	if(!replace){		D_HUnlock(theNewHandle);		return theNewHandle;	}		return (Handle)pMapHdn;}Handle  StructureFactorMap(short sliceNumber,double deltaZ,short meshX,short meshY,double cell2D[3],double cell2R[3],AtomHnd theAtoms,double dspaceMax){		ccomplex *vector;		dcomplex	theScat;		short 		j,k,i, MX, MY,ix,jp,jy,h,ip;		double 	vol;		double		pi_2, temp,s2;		Handle		theNewHandle;		Crystal		*thisCrystal;		double		*theUs,*theVs,*theWs,*theZs,*theBs;		Ptr*			theHandle;		double		electronMassRation;		short			atom_Count,totalMesh;		totalMesh = (meshX + 1) * (meshY + 1);		theNewHandle = D_NewHandle(sizeof(ccomplex) * (meshX + 1) * (meshY + 1));				thisCrystal  = gCurrentObj->theCrystal[gCurrentObj->baseCrystal];		D_HLock(theNewHandle);		vector 		= (ccomplex*)*theNewHandle;		for(i = 0; i < totalMesh;i++,vector++){vector->r = 0; vector->i = 0;}				vector 		= (ccomplex*)*theNewHandle;				pi_2 			= 6.283185307;		temp 			= cell2D[2] * cell2D[2];		temp 			= sqrt(1 - temp);		vol 			= cell2D[0] * cell2D[1] * temp;		//vol 			= 47.878009/vol;		MX 				= meshX/2;		MY 				= meshY/2;		dspaceMax *= dspaceMax;				electronMassRation = 1. + ( (double)gCurrentObj->energy / 511.);				theHandle 	= thisCrystal->AtomicScatteringSet(electronMassRation,0);		if(!SetScatteringPosAIntensity(thisCrystal,&theUs,&theVs,&theWs,&theZs,&theBs,&atom_Count))return 0L;//Timebomb!!//*atom_Count cannot be the same address as *crystal->Atom_Couynt  or you will continually increase the number				for(j = 2;j <= MY + 1;j++){			k = j - MY - 1;			jy = (j - 1) * meshX;			jp = -k + MY + 1;			jp = (jp - 1) * meshX;			for(i = 2; i <= meshX;i++){				h = i - MX - 1;				s2 = sqrt(h * h * cell2R[0] * cell2R[0] + k * k * cell2R[1] * cell2R[1] + 2 * h * k * cell2R[0] * cell2R[1] * cell2R[2]);				if(s2 > dspaceMax){					ix = jy + i;					vector[ix].r = 0;vector[ix].i = 0;//keep a fortran array					ip = -h + MX + 1;					ip = jp + ip;					vector[ip].r = 0;vector[ip].i = 0;//keep a fortran array					continue;				}				//s2 = .25 * s2;				//make sure theZs are multiplied by .023933754				AtomicScatterForDFromSet(s2,theHandle,theZs,atom_Count);				//theScat = 	StructureFactorDW_2D( h, k,theUs,theVs, atom_Count,theZs,theBs, vol, s2/*should be actual 1/dspace*/);									theScat =   TotalStructureFactor2D(h,k,theUs,theVs, atom_Count,theZs,theBs,vol,1/s2,thisCrystal,0L);					ix = jy + i;					vector[ix].r = theScat.r;					vector[ix].i = theScat.i;					ip = -h + MX + 1;					ip += jp;					vector[ip].r = theScat.r;					vector[ip].i = -theScat.i;					continue;			}		}		D_HUnlock(theNewHandle);				thisCrystal->ClearAtomicScatSet(theHandle);		KillPtr((Ptr)theUs);		PAD0((ccomplex**)theNewHandle,meshX,meshY);		return theNewHandle;}void OShift(Handle pmapH,short xCount,short yCount){	long 	mX,mY,j1,i1,i2,j2,j,i;	ccomplex 	temp;	ccomplex	*pmap;		mX = xCount / 2;	mY = yCount / 2;		D_HLock((Handle)pmapH);	pmap = (ccomplex*)*pmapH;	for(j = 1; j <= mY;j++){		j1 = (j - 1) * xCount;		j2 = (j + mY - 1) * xCount;		for(i = 1;i <= mX;i++){			i1 = j1 + i;			i2 = j2 + i + mX;			temp = pmap[i1];			pmap[i1] = pmap[i2];			pmap[i2] = temp;		}	}	for(j = mY + 1; j <= yCount;j++){		j1 = (j - 1) * xCount;		j2 = (j - mY -1) * xCount;		for(i = 1; i <= mX; i++){			i1 = j1 + i;			i2 = j2 + i + mX;			temp = pmap[i1];			pmap[i1] = pmap[i2];			pmap[i2] = temp;		}	}		D_HUnlock((Handle)pmapH);}