#include	"Diffract_INCs.h"#include	"ST_StereoMacros.c"#include	"UT_VectorMacros.c"#include	"PCVNumerical.h"#include	"RulerButton.h"#include	"AtomicScatter.h"#include	"SF_MathLib.h"#include	"Diffract_INCs.h"#include	"MicrographObj.h"#include 	"mathRecipies.h"#include 	"nrutil.h"#include 	"PictUtils.h"#include	"SADObj.h"#include	"CBEDObj.h"//s.Jim:Desktop.2.0:E_Diffract 2:EL2_Micrograph.c#include "PoleBox.h"#include 	"PointObj.h"#include 	"GraphObject.h"      #include 	"TextTableObj.h"  //#include	"UBitMapObj.h"  #include 	"AtomData.h"#include 	"MultisliceFunctions.h"#include "f2c.h"#include "FortranProtos.h"#include "UextBoxFree.h"#define SADDEFINE_OBJ 300#pragma segment Mainenum{	SET_UP_MS	=	1,	THRU_THICK_MS = 3,	THRU_TILT_MS,	PLOT_CRITICAL_VOLTAGE_MS,	FULL_TILT_MS = 7,	FULL_TILT_All_MS,	INCREASE_RES_MS = 10,	DECREASE_RES_MS,	SHOW_PHASEGRATING = 13,	SHOW_PENDULSONG};enum{	X_VECTOR	=	3,	Y_VECTOR,	XSHIFT,	YSHIFT,	MESHX,	MESHY,	DELTAZ,	NOOFSLICES};#define	MS_DEF_DLOG  11101long		numPoints_MS = 101;void DiffractObject::MultiSliceMenu(short item){		switch(item)	{		case SET_UP_MS:		DoMS_Define();		break;		case THRU_THICK_MS://Bloch			functionID = THRU_THICKNESS_MS;			theRuler->SetPrompt("Calculate Thru Thickness Dynamic Plots for selected spot");			theRuler->SetHelp("Labels toggle on/off with succesive clicks. Plot Generated when spot selected.");/*dec 1992*/			SetTheCursor(TARGET_CURSOR);			break;		case THRU_TILT_MS://Bloch			functionID = THRU_TILT_F_MS;			theRuler->SetPrompt("Calculate Thru Tilt Dynamic Plots for selected spot. Line thru center of spot,along line  from spot to center.");			theRuler->SetHelp("Labels toggle on/off with succesive clicks. Plot generated when spot selected.");/*dec 1992*/			SetTheCursor(TARGET_CURSOR);			 break;		case FULL_TILT_MS://Bloch			functionID = FULL_TILT_F_MS;			nOut = 1;			theRuler->SetPrompt("Calculate Full Tilt Dynamic Plots for selected spot. This plot will be for both x and y direction.");			theRuler->SetHelp("Labels toggle on/off with succesive clicks. Plot generated when spot selected.");/*dec 1992*/			SetTheCursor(TARGET_CURSOR);			break;		case FULL_TILT_All_MS://Bloch			nOut = startCount[baseCrystal + 1] - startCount[baseCrystal];			theRuler->SetPrompt("Calculate Full Tilt Dynamic Plots for the full pattern.");			//g_ThreadObj->CreateCoopThread((ThreadEntryProcPtr)FullTiltThreadEntry,(void*)this);//MyCalculate();			MultiSlice_Full(&nOut,(SpotInfoPtr)*theDataHandle);			break;				case PLOT_CRITICAL_VOLTAGE_MS:			functionID = CRITICAL_VOLTAGE_MS;			theRuler->SetPrompt("Calculate Intensity vs Voltage for selected spot.");			theRuler->SetHelp("Labels toggle on/off with succesive clicks. Plot generated when spot selected.");/*dec 1992*/			SetTheCursor(TARGET_CURSOR);			break;		case INCREASE_RES_MS:			numPoints_MS += numPoints_MS * .33;			sprintf(gTheText,"Multislice Plots will now have a total of %d calculated points",numPoints_MS);			theRuler->SetPrompt(gTheText);			break;		case DECREASE_RES_MS:			numPoints_MS -= numPoints_MS * .33;			sprintf(gTheText,"Multislice Plots will now have a total of %d calculated points",numPoints_MS);			theRuler->SetPrompt(gTheText);			break;				}}void DiffractObject::MS_ThruTilt(SpotInfoPtr theSpotsSt)//MultiSlice{	SpotInfoPtr theSpots,theSpot;	double		matrixX[3][3],matrixY[3][3];	double		rotX,rotY,ratio,x,y;	double		delT,thetaTotal;	double		*val,**value,bigK;	double		*intensities;	double		normal;	long		k,i;	Rect		theRect;	char		theText[125];	short		num;	long		start,totalBeams;		if(theSpotsSt[spotLoc].flags & BETH_PERTURB)return;	if(!GetStartStop(theSpotsSt,&start,&totalBeams))return;	if(totalBeams > 10000){		if(TooManyBeams(totalBeams)){			return;		}	}	StartWatch();	theSpots = theSpotsSt;	for(i = 0; i < numSpots;i++,theSpots++){		if(theSpots->flags &= PRIME_MASK)		theSpots->flags ^= PRIME_MASK;	}	if(calcIntensities)KillHandle((Handle*)&calcIntensities);	calcIntensities = 0L;	k = 0;	if(spotLoc > 0)k = spotLoc - start;	ratio = (.006648352)*(1 + (1.9569341e-3 * energy));// this converts Vg to Ug, Vg is the fourier components of the 	//crystal potential given in eV, Ug is the Dynamical Structure factor	theSpots = theSpotsSt;	theSpot = &theSpots[k];	bigK  = sqrt((1/ (wavelength * wavelength)) + (ratio * theSpots->sF.r));	if(k == 0){		if(this->objectType == CBED_OBJ){		if(((CBEDObj*)this)->acrossCenter == 0){x = 1;y = 0;((CBEDObj*)this)->acrossCenter = 1;}		else {x = 0;y = 1;((CBEDObj*)this)->acrossCenter = 0;}		}	}else{		y = theSpot->x / sqrt(theSpot->x * theSpot->x + theSpot->y * theSpot->y);		x = theSpot->y / sqrt(theSpot->x * theSpot->x + theSpot->y * theSpot->y);	}	thetaTotal = -(double)theEBeam->convergenceAngle / bigK;// the standard sinz theta == theta at small angles assumption	num = (numPoints_MS - 1) * .5;	delT = -thetaTotal / num;	delugeFlag = false;	value = (double**)D_NewHandle(numPoints_MS * sizeof(double));	D_HLock(value);	val = *value;	for(i = 0; i < numPoints_MS;i++,val++)*val = 0;	val = *value;		intensities = 0L;		normal = 1 / (double)(2 * num);	for(i = -num; i <= num;i++,thetaTotal += delT,val++){					rotX = thetaTotal * x;		rotY = thetaTotal * y;		RotatateMatrixAxis( matrixX,rotX,0);		RotatateMatrixAxis( matrixY,rotY,1);		MatrixMultiply(matrixX,matrixY,matrixX);		theMSVariables.tilt[0] = rotX;		theMSVariables.tilt[1] = rotY;		intensities = MultiSlice(matrixX);				if(intensities == 0L || Quit()){// this is a potential crash site.			if(intensities != 0L)KillPtr(intensities);		 goto THE_END;		}		*val = *intensities;		if(fabs(*val) > 3){			*val = 0;		}		KillPtr(intensities);				sprintf(gTheText,"Percentage Complete %5.1f.",(double)(i + num) * normal * 100 );		theRuler->SetInfo(gTheText);		AllowBackground();	}THE_END2:		SetRect(&theRect,thePictRect.right - 250,thePictRect.bottom - 250,		thePictRect.right - 40,thePictRect.bottom - 100);	if(graph == 0L){		graph	= (GraphFunction*)D_new(GraphFunction);		graph	->	DoInit(theRect,theCrystal[(theSpotsSt->flags & CRYSTAL_MASK)]->crystalColor,true,true);	}		graph	->	SetValues			(0L,(Handle)value);		theSpots = theSpotsSt;	theSpots[spotLoc].flags |= PRIME_MASK;	obj_Index->CopyPtrToIndex((Ptr)&(theSpots[spotLoc]));	sprintf			(gTheText,"g-vector ");	obj_Index->IndexToText	(theText);	p2cstr			((unsigned char*)theText);	strcat			(gTheText,theText);	graph	->SetTitleY(gTheText);	sprintf			(gTheText,"Tilt in Recp.Angstroms");	graph	->SetTitleX(gTheText);	sprintf			(gTheText,"Beam Intensity vs Tilt");	graph	->SetTitleGraph(gTheText);	graph	->	minX 	= -theEBeam->convergenceAngle;	graph	->	maxX 	= theEBeam->convergenceAngle;	graph	->ResetPlotMinMax	();	//graph	->PlotGraph();	sprintf			(gTheText,"Thru Tilt");	c2pstr(gTheText);	graph->titleMenu->P_DelMenuItem		(2);	graph->titleMenu->P_AppendMenu	(gTheText);	graph->titleMenu->P_CheckItem		(2,true);	THE_END:	D_HUnlock(value);	KillHandle((Handle*)&value);		newPictReq = true;	StopWatch();		return;	}void DiffractObject::MS_SingleTilt(short *nout,dcomplex *sF,SpotInfoPtr theSpotsSt){	double		matrixX[3][3];	double		*intensities;	static short j = 0;	long		totalBeams;	totalBeams = *nout;		if(totalBeams > 1000){		if(TooManyBeams(totalBeams)){			*nout = 0;			return;		}	}	StartWatch();	delugeFlag 		= false;	if(calcIntensities)KillHandle((Handle*)&calcIntensities);	calcIntensities = 0L;	Identity_Matrix(matrixX);	intensities = MultiSlice(matrixX);	if(intensities != 0L){		KillPtr(intensities);	}else{		*nout = 0;	}		newPictReq = true;	StopWatch();	return;}void DiffractObject::MultiSlice_Full(short *nout,SpotInfoPtr theSpotsSt){		SpotInfoPtr theSpots;	double		matrixPrime[3][3];	double		ratio;	double		delT,thetaY,thetaX,baseThetaY,baseThetaX;	double		*val,bigK,maxInten;	double		*intensities,*inten,startTheta;	static short j = 0;	long			k,i,theSize;	long			totalPoints;	double		value;		StartWatch();	ratio = (.006648352)*(1 + (1.9569341e-3 * energy));// this converts Vg to Ug, Vg is the fourier components of the 	//crystal potential given in eV, Ug is the Dynamical Structure factor	theSpots		=	theSpotsSt;	bigK  			= 	sqrt((1/ (wavelength * wavelength)) + (ratio * theSpots->sF.r));		//crystal potential given in eV, Ug is the Dynamical Structure factor	theSize 		= 	(double)scaleFactor * (double)theEBeam->convergenceAngle;	*nout 		=		(theMSVariables.meshX) * (theMSVariables.meshY);	value = (double)(theSize * theSize);	value /=  101;	sprintf(gTheText,"Calculation  will take ~ %5.1f longer than a thru tilt.",value);	theRuler->SetInfo(gTheText);		totalPoints		=	((theSize * 2) + 1) *  ((theSize * 2) + 1) * *nout;	startTheta 		= thetaX = -(double)theEBeam->convergenceAngle / bigK;// the standard sin theta == theta at small angles assumption	delT 					= -thetaX / theSize;	if(calcIntensities != 0){KillHandle((Handle*)&calcIntensities);calcIntensities = 0L;}		calcIntensities = (double**)D_NewHandle((totalPoints + 2) * sizeof(double));	if(calcIntensities == 0L){StopWatch(); return;}	val = *calcIntensities;	for(i = 0; i <= totalPoints;i++,val++)*val = 0.0;	D_HLock(calcIntensities);	val = *calcIntensities;	*val = theSize ;	val++;	*val = *nout;	val++;	maxInten = 0.0000001;	intensities = 0L;	GetOrientation(matrixPrime);	if(calcIrrational != 7){		//if rotation method does not use laue circle we need to find it in method 5 and convert to laue		ConvertToORType(calcIrrational, 7,theZoneAxis,g_Vector,&offLaueDistance,&rotationAngle);		calcIrrational = 7;	}	baseThetaX = offLaueDistance / cameraLength;	baseThetaY = rotationAngle / cameraLength;	for(i = -theSize; i <= theSize;i++,thetaX += delT){		thetaY = startTheta;		for(j = -theSize; j <= theSize;j++,thetaY += delT){			double jx,ix;						ix = i; jx = j;			if(Round(sqrt(ix * ix + jx * jx)) > theSize)continue;			theMSVariables.tilt[0] = thetaX + baseThetaX;			theMSVariables.tilt[1] = thetaY + baseThetaY;			intensities = inten = MultiSlice(matrixPrime);						if(intensities == 0L || Quit()){// this is a potential crash site.				if(intensities != 0L)KillPtr(intensities);			 goto THE_END;			}			for(k = 0; k < *nout;k++,val++,inten++){				*val = *inten;				if(*val > 3){					*val = 0;				}				if(*val > maxInten)maxInten = *val;			}			KillPtr(intensities);			AllowBackground();		}		sprintf(gTheText,"Percentage Complete %5.1f .",-50 * (thetaX - startTheta) / startTheta);		theRuler->SetInfo(gTheText);	}THE_END:		val = *calcIntensities;	val += 2;	for(i = 0; i < totalPoints;i++,val++){		*val /= maxInten;	}	D_HUnlock(calcIntensities);	newPictReq = true;	plotType = MULTI_CBED;	StopWatch();	return;}void DiffractObject::FullPlot_MS(short nout,SpotInfoPtr theSpot){	SpotInfoPtr theSpots;	double		*val;	static short j = 0;	short		h,k,i,theSize;	Rect		oldOval,theOval;	double		grayGain;	short		theIdent,n;	double		intensityRange;	double		xChangeH,yChangeH,zChangeH;	double		xChangeK,yChangeK,zChangeK;	short		hMin,kMin;	double		xH,yH,zH,x,y,z;	double		xK,yK,zK;	if(calcIntensities == 0 || nout < 1 || plotType != MULTI_CBED)return;		SetDrawEnviron();	if(g_Monitor){		grayGain = 220. ;	}else{		grayGain = 10;	}		greyFlag = true;			SetRect(&oldOval,0,0,0,0);		D_HLock(calcIntensities);	val 	= *calcIntensities;	theSize = Round(*val);	val++;	nout = Round(*val);	val++;	intensityRange = 1. / (double)dyRange;	theSpots = theSpot;	theIdent = theSpots->flags & CRYSTAL_MASK;	//All this below is doing is setting up the g_vectors that were used to calculate// the 2-D lattice used in the Multi-Slice calculation			theMSVariables.x_Vector->GetXYZFrHKL_Full((DiffractObject*) this,0);	hMin = - theMSVariables.meshX/2;		xH = hMin * theMSVariables.x_Vector->x;	yH = hMin * theMSVariables.x_Vector->y;	zH = hMin * theMSVariables.x_Vector->z;		xChangeH = theMSVariables.x_Vector->x;	yChangeH = theMSVariables.x_Vector->y;	zChangeH = theMSVariables.x_Vector->z;		theMSVariables.y_Vector->GetXYZFrHKL_Full((DiffractObject*) this,0);		kMin = - theMSVariables.meshY/2;				xChangeK = theMSVariables.y_Vector->x;	yChangeK = theMSVariables.y_Vector->y;	zChangeK = theMSVariables.y_Vector->z;		n = 0;		for(i = -theSize; i <= theSize;i++){		for(j = -theSize; j <= theSize;j++){			double ix,jx;			long	theX,theY;			short	theValue;			ix = i; jx = j;			if(Round(sqrt(ix * ix + jx * jx)) > theSize)continue;						xH = hMin * theMSVariables.x_Vector->x;			yH = hMin * theMSVariables.x_Vector->y;			zH = hMin * theMSVariables.x_Vector->z;			for(h = hMin; h < -hMin;h++,xH += xChangeH,yH += yChangeH,zH += zChangeH){				xK = kMin * theMSVariables.y_Vector->x;				yK = kMin * theMSVariables.y_Vector->y;				zK = kMin * theMSVariables.y_Vector->z;				for(k = kMin; k < -kMin;k++, val++, xK += xChangeK,yK += yChangeK,zK += zChangeK){					n++;					x = xH + xK;					y = yH + yK;					z = zH + zK;					CalcSpotLocAngsToPixels(x,y,z,&theX,&theY);					theX += i;					theY += j;					theOval = oldOval;					OffsetRect(&theOval,(short)theX,(short)theY);					theValue = Round(grayGain * (pow((double)*val,intensityRange)));					if(theValue > 219)					{					;						theValue = 219;					}					if(theValue <= 0){						theValue = 1;						continue;					}					DMForeColor(theValue + 15);					dm_PaintRect(&theOval);				}			}		}	}	D_HUnlock(calcIntensities);	theSpots			= 				((SpotInfoPtr)*theDataHandle);	PlotKLines(theSpots);	theSearchObj->PlotRings(scaleFactor,scaleFactor,centerX,centerY,0,500);	ClearDrawEnviron();} #pragma segment Mainvoid DiffractObject::ConvertToORType(short oldMethod,short newMethod,Index *theIndex,Index *aIndex,float *x,float *y){	float radConvert = PI / 180.0;	float  mu,lambda,angstroms,dspace;	short	j;	double U,V,W;	double newMatrix[3][3];		j = 1;	GetOrientation(newMatrix);	if(oldMethod < 5){		double x3,y3,z3;		aIndex->DirOfPlaneNormal(&x3,&y3,&z3);		TRANSFORM_VECTOR(x3,y3,z3,newMatrix);		if(y3 < 0){			j = -1;		}	}else{		j = -1;	}	if(aIndex->direction && theIndex->direction){		theIndex->G_Vector(aIndex,theRotationAxis); 		theRotationAxis->FindLowestDiffractingG();		dspace =   j * -theRotationAxis->TheDSpacing();	}else{		dspace =   j * -aIndex->TheDSpacing();	}	cameraLength = cameraConstant / wavelength;				switch(oldMethod){		double angstroms;		case SIM_ZONE_OR:			*x = 0;			*y = 0;		break;		case SIM_PLANE_OR:			//Need to convert plane to direction and return			theIndex->DirOfPlaneNormal( &U, &V, &W);			theIndex->h = U;			theIndex->k = V;			theIndex->l = W;			theIndex->reduceFlag 	= true;			theIndex->direction 	= true;			theIndex->ReduceIndex();			*x = 0;			*y = 0;		break;				//converts everything to mu and lambda		case TO_Z_LAUE_OR:  /*towards horizontal,from laue, in theta,mm*/			mu = radConvert *  -*x;			lambda = asin(( j * *y) / (cameraLength/* * 2.*/));			break;		case TO_Z_BRAG_OR: /*towards horizontal,from bragg,in theta,mm*/			mu = radConvert *  -*x;			angstroms = cameraConstant / dspace;			lambda = asin(( (j * *y) + angstroms) / (cameraLength /* * 2.*/));			break;		case HOR_LAUE: /*about horizontal, from laue, in theta,mm*/			mu = radConvert *  *x;			lambda = asin((j * *y) / (cameraLength /* * 2.*/));			break;		case HOR_BRAG_OR: /*about horizontal, from Bragg, in theta,mm*/			mu = radConvert *  *x;			//lambda = asin((dspace + ((double)*y * wavelength)) /((double)cameraConstant * 2.));			angstroms = cameraConstant / dspace;			lambda = asin(((j * *y) + angstroms) / (cameraLength /* * 2.*/));			break;		case LAUE_CIR_OR: /*towards horizontal,from laue,in mm,mm*/			lambda 	=  	asin( ((double)*x) / ((double)cameraLength));			mu 		= 	asin((double)*y / (j * cameraLength));			break;	}			/// since we now know mu and lambda we can convert each back to THEIR respective values		j = 1;	if(newMethod < HOR_LAUE){		double x3,y3,z3;		aIndex->DirOfPlaneNormal(&x3,&y3,&z3);		TRANSFORM_VECTOR(x3,y3,z3,newMatrix);		if(y3 < 0){			j = -1;		}	}else{		j = -1;	}	if(aIndex->direction && theIndex->direction){		theIndex->G_Vector(aIndex,theRotationAxis); 		theRotationAxis->FindLowestDiffractingG();		dspace =   j * -theRotationAxis->TheDSpacing();	}else{		dspace =   j * -aIndex->TheDSpacing();	}	cameraLength = cameraConstant / wavelength;					switch(newMethod){		case SIM_ZONE_OR:			*x = 0;			*y = 0;		return;		case SIM_PLANE_OR:			//Need to convert direction to plane and return			theIndex->PlaneNormalOfDir( &U, &V, &W);			theIndex->h = U;			theIndex->k = V;			theIndex->l = W;			theIndex->reduceFlag = true;			theIndex->ReduceIndex();			theIndex->direction = false;			*x = 0;			*y = 0;		break;			case TO_Z_LAUE_OR:			*x = - mu / radConvert;			*y  = j * /* * 2.*/ sin(lambda) * cameraLength;		break;			case TO_Z_BRAG_OR:			*x = - mu / radConvert;			angstroms = cameraConstant / dspace;			*y =  j * ((cameraLength * /* * 2.*/ sin(lambda)) - angstroms) ;		break;		case HOR_LAUE:			*x = mu / radConvert;			*y  = j * /* * 2.*/ sin(lambda) * cameraLength;			break;		case HOR_BRAG_OR:			*x = mu / radConvert;			angstroms = cameraConstant / dspace;			*y = j* ((cameraLength */* * 2.*/ sin(lambda)) - angstroms);		break;			case LAUE_CIR_OR:			*y =  j * cameraLength  * sin(mu);			*x =  cameraLength  * sin(lambda);		break;		}	}void DiffractObject::MS_ThruThicknessRockingCurve(SpotInfoPtr theSpotsSt)//MultiSlice{	double 		*intensities,*inten;	double		**value,*val;	char		theText[200];	Rect		theRect;	short		k,i;	SpotInfoPtr theSpots;	double		matrix[3][3];	long		start,totalBeams;			Identity_Matrix(matrix);	if(theSpotsSt[spotLoc].flags & BETH_PERTURB)return;	if(!GetStartStop(theSpotsSt,&start,&totalBeams))return;	if(totalBeams > 1000){		if(TooManyBeams(totalBeams)){			return;		}	}	StartWatch();	delugeFlag = true;	numberOfSteps = numPoints_MS;	intensities = MultiSlice( matrix);		if(intensities == 0L) goto END_THRU_THICK;	if(calcIntensities)KillHandle((Handle*)&calcIntensities);	calcIntensities = 0L;	value = (double**)D_NewHandle(numberOfSteps * sizeof(double));	D_HLock(value);	val = *value;	k = 0;	if(spotLoc > 0)k = spotLoc - start;	for(i = 0; i < numberOfSteps;i++,val++,inten++){		*val = *inten;	}		SetRect(&theRect,thePictRect.right - 250,thePictRect.bottom - 250,		thePictRect.right - 40,thePictRect.bottom - 100);	if(graph == 0L){		graph	= (GraphFunction*)D_new(GraphFunction);		graph	->	DoInit(theRect,theCrystal[(theSpotsSt->flags & CRYSTAL_MASK)]->crystalColor,true,true);	}	D_HUnlock(value);	graph	->	SetValues			(0L,(Handle)value);		theSpots = theSpotsSt;	obj_Index->CopyPtrToIndex((Ptr)&(theSpots[k]));	sprintf			(gTheText,"g-vector ");	obj_Index->IndexToText	(theText);	p2cstr			((unsigned char*)theText);	strcat			(gTheText,theText);	graph	->SetTitleY(gTheText);	sprintf			(gTheText,"Thickness in nm");	graph	->SetTitleX(gTheText);	sprintf			(gTheText,"Beam Intensity vs Thickness");	graph	->SetTitleGraph(gTheText);	graph	->	minX 	= trueThickness - (numberOfSteps * interval);	graph	->	maxX 	= trueThickness;	sprintf(gTheText,"Thickness Plot");	c2pstr(gTheText);	graph->titleMenu->P_DelMenuItem		(2);	graph->titleMenu->P_AppendMenu	(gTheText);	graph->titleMenu->P_CheckItem		(2,true);	graph	->ResetPlotMinMax	();	//graph	->PlotGraph();	newPictReq = true;	KillPtr(intensities);END_THRU_THICK:		KillHandle((Handle*)&value);		StopWatch();	}void DiffractObject::MS_CriticalVoltagePlot(SpotInfoPtr theSpotsSt)//Multislice{	double 		*intensities;	char		theText[200];	Rect		theRect;	short		i;	SpotInfoPtr theSpots;	double		matrix[3][3];	long		start;	double		delEnergy,oldEnergy;	double		**value,*val;			Identity_Matrix(matrix);			StartWatch();	delEnergy = energy / numPoints_MS;	value = (double**)D_NewHandle(numPoints_MS * sizeof(double));	D_HLock(value);	val = *value;	oldEnergy = energy;	energy = 0;	if(calcIntensities)KillHandle((Handle*)&calcIntensities);	calcIntensities = 0L;	for(i = 0; i < numPoints_MS;i++,val++){		energy += delEnergy;		switch(theBeamFlag)		{			case 1:				theEBeam->		SetWaveAndEnergy(energy);				wavelength	=	theEBeam->wavelength;				break;			case 2:				wavelength 	= 	12.4 / energy;				break;			case 3:				break;		}		intensities = MultiSlice(matrix);				if(intensities == 0L) goto END_CRITICAL;		*val = *intensities;		if(fabs(*val) > 1){			*val = 0;		}		KillPtr(intensities);		sprintf(gTheText,"Percentage Complete %5.1f.",(double)((double)100 * i / (double)numPoints_MS) );		theRuler->SetInfo(gTheText);		AllowBackground();	}	END_CRITICAL:	energy = oldEnergy;	switch(theBeamFlag)	{		case 1:			theEBeam->		SetWaveAndEnergy(energy);			wavelength	=	theEBeam->wavelength;			break;		case 2:			wavelength 	= 	12.4 / energy;			break;		case 3:			break;	}	SetRect(&theRect,thePictRect.right - 250,thePictRect.bottom - 250,		thePictRect.right - 40,thePictRect.bottom - 100);	if(graph == 0L){		graph	= (GraphFunction*)D_new(GraphFunction);		graph	->	DoInit(theRect,theCrystal[(theSpotsSt->flags & CRYSTAL_MASK)]->crystalColor,true,true);	}	D_HUnlock(value);	graph	->	SetValues			(0L,(Handle)value);	KillHandle((Handle*)&value);	theSpots = theSpotsSt;	obj_Index->CopyPtrToIndex((Ptr)&(theSpots[spotLoc - start]));	sprintf			(gTheText,"g-vector ");	obj_Index->IndexToText	(theText);	p2cstr			((unsigned char*)theText);	strcat			(gTheText,theText);	graph	->SetTitleY(gTheText);	sprintf			(gTheText,"Voltage in kV");	graph	->SetTitleX(gTheText);	sprintf			(gTheText,"Beam Intensity vs Energy");	graph	->SetTitleGraph(gTheText);	graph	->	minX 	= delEnergy;	graph	->	maxX 	= energy;	graph	->ResetPlotMinMax	();	//graph	->PlotGraph();	sprintf(gTheText,"Critical Voltage");	c2pstr(gTheText);	graph->titleMenu->P_DelMenuItem		(2);	graph->titleMenu->P_AppendMenu	(gTheText);	graph->titleMenu->P_CheckItem		(2,true);	newPictReq = true;		StopWatch();	}Boolean DiffractObject::MS_SetupSwitch(DialogPtr theDialog,short theSelect,Ptr  thePtr,Boolean *saveData){	MultiSliceVariablesPtr theParams;	theParams = (MultiSliceVariablesPtr)thePtr;	switch(theSelect){			case REPLACE:				*saveData = true;				return true;			case CANCEL:			case CANCELCLICK: 				*saveData = false;				return true;						default:				break;			case ML_UPDATE_EVT:			DrawDialog(theDialog);			break;		}		return false;}Boolean DiffractObject::DoMS_SetUp(void){	short 			theSelect;	DialogPtr		theDialog;	Boolean 		quit = false;	Boolean			saveData;	MultiSliceVariablesPtr		 theParams;		theDialog = DM_GetNewDialog(MS_DEF_DLOG,0L,(WindowPtr)-1L);	theParams = (MultiSliceVariablesPtr)D_NewPtr(sizeof(MultiSliceVariables));		*theParams = theMSVariables;		DoMS_SetUp_SetUp( theDialog,theParams);	while(!quit){		SystemTask();		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:							BeginUpdate(theDialog);					UpdtDialog(theDialog,theDialog->visRgn);					if(!gAppleEvtsOK){						HiliteOK(theDialog);					}					EndUpdate(theDialog);					break;			default:				quit = MS_SetupSwitch( theDialog, theSelect,(Ptr)theParams,&saveData);			break;		}	}	DoMS_SetUpRead( theDialog,(Ptr)theParams, saveData,true);	DM_DisposDialog(&theDialog);	return saveData;}Boolean DiffractObject::DoMS_Define(void){	short 			theSelect;	DialogPtr		theDialog;	Boolean 		quit = false;	Boolean			saveData;	MultiSliceVariablesPtr		 theParams;		theDialog = DM_GetNewDialog(MS_DEF_DLOG,0L,(WindowPtr)-1L);	theParams = (MultiSliceVariablesPtr)D_NewPtr(sizeof(MultiSliceVariables));	*theParams = theMSVariables;	DoMS_SetUp_SetUp( theDialog,theParams);	while(!quit){		SystemTask();		ModalDialog(TheFilterUPP,&theSelect);		switch(theSelect){			case ML_UPDATE_EVT:							BeginUpdate(theDialog);					UpdtDialog(theDialog,theDialog->visRgn);					if(!gAppleEvtsOK){						HiliteOK(theDialog);					}					EndUpdate(theDialog);					break;			default:				quit = MS_SetupSwitch( theDialog, theSelect,(Ptr)theParams,&saveData);			break;		}	}	DoMS_SetUpRead( theDialog,(Ptr)theParams, saveData,true);	theMSVariables = *theParams;	KillPtr((Ptr)theParams);//new	DM_DisposDialog(&theDialog);	return saveData;}void	DiffractObject::DoMS_SetUpRead(DialogPtr theDialog,Ptr thePtr,Boolean saveData,Boolean closeDialog){	MultiSliceVariablesPtr theParams;	theParams = (MultiSliceVariablesPtr)thePtr;			if(!saveData) return;		theParams->x_Vector->GetIndex(theDialog,X_VECTOR);	theParams->y_Vector->GetIndex(theDialog,Y_VECTOR);	theParams->xShift = (short)GetItemValue( theDialog,XSHIFT);	theParams->yShift = (short)GetItemValue( theDialog,YSHIFT);	theParams->meshX = (short)GetItemValue( theDialog,MESHX);	theParams->meshY = (short)GetItemValue( theDialog,MESHY);	theParams->deltaZ = (short)GetItemValue( theDialog,DELTAZ);	theParams->noOfSlices = (short)GetItemValue( theDialog,NOOFSLICES);				return ;}void	DiffractObject::DoMS_SetUp_SetUp(DialogPtr theDialog,MultiSliceVariablesPtr  theParams)/*change here, Mar 1995*/{	theParams->x_Vector->SetIndex(theDialog,X_VECTOR);	theParams->y_Vector->SetIndex(theDialog,Y_VECTOR);	SetItemValue( theDialog,XSHIFT,(double)theParams->xShift,0);	SetItemValue( theDialog,YSHIFT,(double)theParams->yShift,0);	SetItemValue( theDialog,MESHX,(double)theParams->meshX,0);	SetItemValue( theDialog,MESHY,(double)theParams->meshY,0);	SetItemValue( theDialog,DELTAZ,(double)theParams->deltaZ,2);	SetItemValue( theDialog,NOOFSLICES,(double)theParams->noOfSlices,0);			DrawDialog(theDialog);}#include "f2c.h"#pragma segment Maindouble* DiffractObject::MultiSlice(double matrix[3][3]){	double 			sigma,*int1;	ccomplex	 	**propagator,**finalMap;	Handle			phaseGratings[200];//this just gives us 200 slices	ccomplex		*cMap;	double  		*intensities;	double			x,cell2D[3],cell2RD[3];	double 			volume2D,maxDspace = 8;	short			i, totalMesh,l,k;	AtomHnd			theAtm2D;	ccomplex		**theHandle,*thePtr,*thePtrFinal;	static short	firstRun = 0,numberOfColums = 0;		if((long)theMSVariables.x_Vector == 0L || (long)theMSVariables.y_Vector == 0L || theMSVariables.deltaZ == 0)return 0L;	sigma = CalculateSigma();	finalMap			= (ccomplex**)D_NewHandle(sizeof(ccomplex) * (theMSVariables.meshX + 1) * (theMSVariables.meshY + 1));	theAtm2D = (AtomHnd)Make2DCell(theMSVariables.x_Vector,theMSVariables.y_Vector, cell2D, cell2RD,&volume2D,baseCrystal,matrix);	//Structure Factor and Propagation Map Calculations	for(i = 0 ; i < theMSVariables.noOfDifSlices;i++){			phaseGratings[i] = (Handle)StructureFactorMap(i,theMSVariables.deltaZ,theMSVariables.meshX,theMSVariables.meshY,cell2D,cell2RD,theAtm2D,maxDspace);//gets map			OShift((Handle)phaseGratings[i],theMSVariables.meshX,theMSVariables.meshY);			phaseGratings[i] 		= (Handle)FastFourierTransform(true,(Handle*)(&(phaseGratings[i])),(long)theMSVariables.meshX,(long)theMSVariables.meshY,-1,1);			phaseGratings[i] = (Handle)PhaseGratingMap(true,theMSVariables.meshX,theMSVariables.meshY,sigma,(Handle*)&phaseGratings[i]); 	}	/** Calculates Fresnel Propogator in reciprocal space**/	propagator = (ccomplex**)PropogationValues(theMSVariables.meshX,theMSVariables.meshY,theMSVariables.tilt,wavelength,theMSVariables.deltaZ,0/*theMSVariables.xShift*/,theMSVariables.yShift,cell2RD);//will need to create new pMap		totalMesh= theMSVariables.meshX * theMSVariables.meshY;	x = 1/sqrt((double)totalMesh);	l = 0;	theHandle = (ccomplex**)phaseGratings[0];	thePtr = *theHandle;	thePtrFinal = *finalMap;	thePtr++;	thePtrFinal++;	for(i = 1; i <= theMSVariables.meshY;i++){				for(k = 0; k < theMSVariables.meshX;k++){			dcomplex		d1;			d1.r = thePtr->r;			d1.i = thePtr->i;		 	d1 = RCmul(x, d1);		 	thePtrFinal->r = d1.r;		 	thePtrFinal->i = d1.i;		 	thePtr++;		 	thePtrFinal++;		}		 	}		//MultiSlice Loop	for(k = 0; k < theMSVariables.noOfDifSlices;k++){		for(i = 0; i < theMSVariables.noOfSlices;i++){			finalMap = (ccomplex**)FastFourierTransform(true,(Handle*)&finalMap,theMSVariables.meshX,theMSVariables.meshY,1,1);						finalMap = (ccomplex**)ConvolveInverseTransforms(true,(Handle*)&finalMap,(Handle)propagator,theMSVariables.meshX,theMSVariables.meshY);			finalMap = (ccomplex**)FastFourierTransform(true,(Handle*)&finalMap,theMSVariables.meshX,theMSVariables.meshY,-1,1);						if(i == theMSVariables.noOfSlices - 1 && k == theMSVariables.noOfDifSlices - 1) continue;			finalMap = (ccomplex**)ConvolveTransforms(true,(Handle*)&finalMap,(Handle)phaseGratings[k],theMSVariables.meshX,theMSVariables.meshY);		}		KillHandle((Handle*)&phaseGratings[k]);	}			int1 = intensities = (double*)D_NewPtr(sizeof(double) * theMSVariables.meshX * theMSVariables.meshY);	if(intensities == 0L){		KillHandle((Handle*)&finalMap);		KillHandle((Handle*)&propagator);		KillHandle((Handle*)&theAtm2D);		 return 0L;	}	cMap = *finalMap;	cMap++;	for(i = 0; i < totalMesh; i++,int1++,cMap++){		*int1 = cMap->r * cMap->r + cMap->i * cMap->i;	}	if(firstRun < 20)			{TEST_BOX((Ptr)intensities,(Handle)0L,3,"Intensities",numberOfColums);numberOfColums++;}	KillHandle((Handle*)&finalMap);	KillHandle((Handle*)&propagator);	KillHandle((Handle*)&theAtm2D);	firstRun++;	return intensities;}#pragma segment Maindouble DiffractObject::CalculateSigma(void){	return .020886416 * wavelength * (1.0 + (1.9569341e-3 * energy));}#pragma segment MainHandle DiffractObject::Make2DCell(Index* h,Index* k,double cell2D[3],double cell2R[3],double *volume,short theCrys,double theXForm[3][3]){	double dH,dK;	AtomPtr  theAtoms,theOAtoms;	Handle   theAtomsHdn;	short			i;	double		xForm00,xForm01,xForm02;	double		xForm10,xForm11,xForm12;	double		xForm20,xForm21,xForm22;	Crystal		*thisCrystal;	thisCrystal = theCrystal[theCrys];		cell2D[0] = dH = h->TheDSpacing();	cell2D[1] = dK = k->TheDSpacing();	cell2D[2]  = h->GetAngleBetweenProjections(k);//returns the cosine	*volume = cell2D[0] * cell2D[1] * sqrt(1 - cell2D[2] * cell2D[2]);	//calculate receiprocal space	cell2R[0] = cell2D[1]/ *volume;	cell2R[1] = cell2D[0]/ *volume;	cell2R[2] = - cell2D[2];			xForm00	=	theXForm[0][0];	xForm01	=	theXForm[0][1];	xForm02	=	theXForm[0][2];		xForm10	=	theXForm[1][0];	xForm11	=	theXForm[1][1];	xForm12	=	theXForm[1][2];		xForm20	=	theXForm[2][0];	xForm21	=	theXForm[2][1];	xForm22	=	theXForm[2][2];	theAtomsHdn =  D_NewHandle(sizeof(Atom) * (thisCrystal->atom_Count + 1));	theAtoms = (AtomPtr)*theAtomsHdn;	D_HLock(theAtomsHdn);	D_HLock(thisCrystal->theAtoms);	theOAtoms = *thisCrystal->theAtoms;	for(i = 0 ; i <= thisCrystal->atom_Count ; i++,theAtoms++,theOAtoms++){		theAtoms->x = theOAtoms->x * xForm00 + theOAtoms->y * xForm01 + theOAtoms->z * xForm02;		theAtoms->y = theOAtoms->x * xForm10 + theOAtoms->y * xForm11 + theOAtoms->z * xForm12;		theAtoms->z = theOAtoms->x * xForm20 + theOAtoms->y * xForm21 + theOAtoms->z * xForm22;		if(theAtoms->x > 1) theAtoms->x -= 1;		if(theAtoms->y > 1) theAtoms->x -= 1;		if(theAtoms->z > 1) theAtoms->x -= 1;		if(theAtoms->x < 0) theAtoms->x += 1;		if(theAtoms->y < 0) theAtoms->x += 1;		if(theAtoms->z < 0) theAtoms->x += 1;		theAtoms->atomicNum = theOAtoms->atomicNum;		theAtoms->bi = theOAtoms->bi;	}	D_HUnlock((Handle)theAtomsHdn);	D_HUnlock((Handle)thisCrystal->theAtoms);	return theAtomsHdn;}void  DiffractObject::TEST_BOX(Ptr thePtr,Handle theHandle,short theType,char *theTitle,short row)//Override{	ccomplex		*sF;	float			*theFValue;	Cell			theCell;	short			totalValues;	double			*theDValue;		if(textBox == 0L){		Rect 			rDataBnds,theRect;		Point 		cellSize;				short			hor,ver;		hor						= (thePictRect.right - thePictRect.left) * .25;		ver						= (thePictRect.bottom - thePictRect.top) * .25;			textBox				=	(TextBoxFree*)D_new(TextBoxFree);		SetRect(&rDataBnds,0,0,30,60);		SetRect(&theRect,thePictRect.left,thePictRect.top + 30,thePictRect.left + hor + 18,thePictRect.top + ver + 48);		cellSize.h = 80;		cellSize.v = 15;		textBox		-> DoInit(&theRect,&rDataBnds,cellSize,0,theWindow,false,true,true,true,true,true,geneva,9,0);		textBox		-> ResetCell();		textBox		->selected = true;		textBox		-> SetColumnWidth(0,80);		textBox		->selected = false;		 TMX_SetOptions(tmBorder,textBox		->theList);		 			}	textBox->SetColumnTitle(theTitle,row);	textBox		->DrawList();	gTheText[0] = 0;	if(theHandle){		switch(theType){			case 1:				totalValues = GetHandleSize(theHandle) /sizeof(ccomplex);				sF = (ccomplex*)*theHandle;			break;			case 2:				theFValue = (float*)*theHandle;				totalValues = GetHandleSize(theHandle) /sizeof(float);			break;			case 3:				theDValue = (double*)*theHandle;				totalValues = GetHandleSize(theHandle) /sizeof(double);			break;		}	}else if(thePtr){		switch(theType){			case 1:				totalValues = GetPtrSize(thePtr) /sizeof(ccomplex);				sF = (ccomplex*)thePtr;			break;			case 2:				theFValue = (float*)thePtr;				totalValues = GetPtrSize(thePtr) /sizeof(float);			break;			case 3:				theDValue = (double*)thePtr;				totalValues = GetPtrSize(thePtr) /sizeof(double);			break;		}	}	theCell.h = row;	for(theCell.v = 0 ; theCell.v < totalValues;theCell.v++)	{			switch(theType){				case 1:					sprintf(gTheText,"%9.7f,%9.7f",sF->r,sF->i);					sF++;				break;				case 2:					sprintf(gTheText,"%9.7f",*theFValue);					theFValue++;				break;				case 3:					sprintf(gTheText,"%9.7f",*theDValue);					theDValue++;				break;				default:					gTheText[0] = 0;				break;								}			textBox	->SetListText(gTheText,theCell);				}	textBox->SetDrawFlag(true);}#pragma segment Main