#include	"Diffract_INCs.h"#include	"MenuDefs.h"#include "AbsorptionLabels.h"//s.Jim:Event/Memory:EV_FileObject.c#include	"EveMacros.h"#include	"Dir_Paths.h"#include	"Navigation.h"#include	"NavServices.h"/*	Boolean NavServicesAvailable (void); UInt32 NavLibraryVersion (void);  OSErr NavGetDefaultDialogOptions (NavDialogOptions *dialogOptions); paramErr  	-50 	Your application passed an invalid parameter for dialog box options. userCancelledErr  	-128 	User cancelled the action. kNavInvalidSystemConfigErr  	-5696 	One or more Navigation Services-required system components is missing or out of date. kNavCustomControlMessageFailedErr  	-5697 	Navigation Services did not accept a control message sent by your application. kNavInvalidCustomControlMessageErr  	-5698 	Your application sent an invalid custom control message. kNavMissingKindStringErr  	-5699  	No kind strings were provided to describe your application's native file types. For more information, see Providing File Format Options. OSErr NavDisposeReply(NavReplyRecord *reply); #include	"NavServices.h"*/	pascal void myEventProc(NavEventCallbackMessage callBackSelector,NavCBRecPtr callBackParms,NavCallBackUserData callBackUD);void MyHandleUpdateEvent(WindowPtr window, EventRecord* theEvent);pascal void myEventProc(NavEventCallbackMessage callBackSelector, 								NavCBRecPtr callBackParms, 								NavCallBackUserData callBackUD){	WindowPtr window = (WindowPtr)(callBackParms->eventData.eventDataParms.event->message);	switch (callBackSelector)	{		case kNavCBEvent:				switch (callBackParms->eventData.eventDataParms.event->what)				{					case updateEvt:						MyHandleUpdateEvent(window,(EventRecord*)callBackParms->eventData.eventDataParms.event);						break;				}		break;	}}void MyHandleUpdateEvent(WindowPtr window, EventRecord* theEvent){}/*struct NavTypeList {    OSType  componentSignature;    short   reserved;    short   osTypeCount;    OSType  osType[1];}; */OSErr ReadNavOpen(const FSSpecPtr defaultLocationfssPtr,OSType  fileType){	NavDialogOptions	dialogOptions;	AEDesc				defaultLocation;	NavEventUPP			eventProc = NewNavEventProc(myEventProc);//myEventProc);	NavObjectFilterUPP	filterProc = NewNavObjectFilterProc(0L);//myFilterProc);	OSErr				anErr = noErr;		//Specify default options for dialog box	anErr = NavGetDefaultDialogOptions(&dialogOptions);	if (anErr == noErr)	{			//Adjust the options to fit our needs		//Set this option		dialogOptions.dialogOptionFlags |= kNavSelectDefaultLocation;		//Clear this one		dialogOptions.dialogOptionFlags ^= kNavAllowPreviews;				anErr = AECreateDesc(typeFSS,// defaultLocationfssPtr,							 //sizeof(*defaultLocationfssPtr),							 0L,0L,							 &defaultLocation );		if (anErr == noErr)		{			// Get 'open' resource. A nil handle being returned is OK,			// this simply means no automatic file filtering.			NavTypeListHandle typeList;			NavReplyRecord reply;			if(fileType == CRYST_OBJ){				typeList  = (NavTypeListHandle)GetResource('open', 129);			}else{				typeList  = (NavTypeListHandle)GetResource('open', 128);			}						anErr = NavGetFile (&defaultLocation, &reply, &dialogOptions,								eventProc, nil, filterProc,								typeList, nil);			if (anErr == noErr && reply.validRecord)			{				//Deal with multiple file selection				long	count;								anErr = AECountItems(&(reply.selection), &count);				if (anErr == noErr)				{					long	index;										for (index = 1; index <= count; index++)					{						AEKeyword	theKeyword;						DescType	actualType;						Size		actualSize;						FSSpec		documentFSSpec;												anErr = AEGetNthPtr(&(reply.selection), index,											typeFSS, &theKeyword,											&actualType,&documentFSSpec,											sizeof(documentFSSpec),											&actualSize);						if (anErr == noErr)						{							anErr = DoOpenFile(&documentFSSpec);						}					}				}				//Dispose of NavReplyRecord, resources, descriptors				anErr = NavDisposeReply(&reply);			}			if (typeList != NULL)			{				ReleaseResource( (Handle)typeList);			}					(void) AEDisposeDesc(&defaultLocation);		}	}	if(eventProc)	DisposeRoutineDescriptor(eventProc);	if(filterProc)	DisposeRoutineDescriptor(filterProc);	return anErr;}short	DoOpenFile(FSSpec		*theFss){	FInfo	theFndrInfo;	short 	theErr;		theErr	= FSpGetFInfo(theFss,&theFndrInfo);	gTheFile->theFileInfo.sfFile = *theFss;	gTheFile->theFileInfo.sfGood = true;	gTheFile->theFileInfo.sfType = theFndrInfo.fdType;	if(theFndrInfo.fdType == 'Phas'){		AlertUser(5);		return 1;	} else if(theFndrInfo.fdType == 'INIT'){		AlertUser(6);		return 1;	}	//gTheFile->fileError = FSOpen(gTheFile->theFileInfo.sfFile.name,gTheFile->theFileInfo.sfFile.vRefNum,&gTheFile->pathRefNum);	gCurrentObj->DoOpen(true);	if(gTheFile->fileError != 0){		gTheFile->DoFileError();		return gTheFile->fileError;	}	return 0;}OSErr SaveNavOpen(WindowPtr theDocument,OSType	fileTypeToSave){	OSErr					anErr = noErr;	NavReplyRecord		reply;	NavDialogOptions	dialogOptions;	OSType				creatorType = OWNER;	NavEventUPP			eventProc = NewNavEventProc(myEventProc);//myEventProc);	anErr = NavGetDefaultDialogOptions(&dialogOptions);	if (anErr == noErr)	{		//One way to get the name for the file to be saved.		GetWTitle(theDocument, dialogOptions.savedFileName);		gTheFile->theFileInfo.sfGood			= true;		gTheFile->theFileInfo.sfType			= fileTypeToSave;		gTheFile->theFileInfo.sfScript		= smSystemScript;		gTheFile->theFileInfo.sfIsFolder		= true;		anErr = SetSearchVol(fileTypeToSave,&gTheFile->theFileInfo.sfFile);		gTheFile->theFileInfo.sfFile.vRefNum 	= -LMGetSFSaveDisk();		gTheFile->theFileInfo.sfFile.parID 	= LMGetCurDirStore();				anErr = NavPutFile( (AEDesc*)nil, &reply, &dialogOptions, eventProc,									fileTypeToSave, creatorType,nil );		if (anErr == noErr && reply.validRecord)		{				AEKeyword	theKeyword;				DescType	actualType;				Size		actualSize;				FSSpec		documentFSSpec;								anErr = AEGetNthPtr(&(reply.selection), 1, typeFSS,										&theKeyword, &actualType,										&documentFSSpec, sizeof(documentFSSpec),										&actualSize );				if (anErr == noErr)				{					/*if (reply.replacing)					{						// Make sure you save a temporary file						// so you can check for problems before replacing						// an existing file. Once the save is confirmed,						// swap the files and delete the original.						//anErr = DoSafeSave(&documentFSSpec, creatorType,												//	fileTypeToSave, theDocument);					}					else*/					{						{							anErr = WriteNewFile(&documentFSSpec,fileTypeToSave, reply);						}											}										if ( anErr == noErr)					{						// Always call NavCompleteSave() to complete						anErr = NavCompleteSave(&reply,kNavTranslateInPlace);					}				}				(void) NavDisposeReply(&reply);		}		DisposeRoutineDescriptor(eventProc);	}	return anErr;}#define CRYST_OBJ_2   2OSErr WriteNewFile(FSSpec *theFss,OSType fileTypeToSave,NavReplyRecord reply){	Boolean oldFlag;	if(fileTypeToSave == CRYST_OBJ_2){			fileTypeToSave = CRYST_OBJ;			oldFlag = true;	}	gTheFile->theFileInfo.sfFile = *theFss;	gTheFile->theFileInfo.sfGood = reply.validRecord;	gTheFile->theFileInfo.sfType = fileTypeToSave;	if(!gTheFile->theFileInfo.sfGood)			return gTheFile->fileError;				if(reply.replacing){			gTheFile->fileError = FSpDelete(&gTheFile->theFileInfo.sfFile);			if(gTheFile->fileError != 0){				gTheFile->DoFileError();				return gTheFile->fileError;			}		}		oldFlag = false;		if(fileTypeToSave == CRYST_OBJ_2){			fileTypeToSave = CRYST_OBJ;			oldFlag = true;		}		if(fileTypeToSave == 'TEXT'){			gTheFile->fileError = FSpCreate(&gTheFile->theFileInfo.sfFile,'ttxt',fileTypeToSave,gTheFile->theFileInfo.sfScript);		}else{			gTheFile->fileError = FSpCreate(&(gTheFile->theFileInfo.sfFile),OWNER,fileTypeToSave,gTheFile->theFileInfo.sfScript);		}		if(gTheFile->fileError != 0){			gTheFile->DoFileError();			return gTheFile->fileError;		}		gTheFile->fileError = FSpOpenDF(&gTheFile->theFileInfo.sfFile,fsRdWrPerm,&(gTheFile->pathRefNum));		gTheFile->file_is_Open = true;		switch(fileTypeToSave){		case CRYST_OBJ:			if(!oldFlag){				gCurrentObj->currentCrystal->FileWriteCrystal();			}else{				gCurrentObj->currentCrystal->FileWriteOldDesktop();			}			break;		case CRYST_OBJ_OLD:			gCurrentObj->currentCrystal->SaveAsOldFormat();			break;		case 'TEXT':			gCurrentObj->currentCrystal->SaveAsText();			break;		case 'PICT':				gTheFile->WritePICT((Ptr)gCurrentObj);		break;		case DIF_OBJ:				gCurrentObj->TitleTheWindow();				gCurrentObj->DoFileWrite();						break;			}	gTheFile->DoFileClose();	return gTheFile->fileError;}/*struct NavReplyRecord {	 UInt16		version;	 Boolean	validRecord;	 Boolean	replacing;	 Boolean	isStationery;	 Boolean	translationNeeded;	 AEDescListselection;	 ScriptCodekeyScript;	 FileTranslationSpec **fileTranslation; }; */